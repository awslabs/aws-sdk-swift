// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MediaTailorClientTypes.AccessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessType = "AccessType"
        case secretsManagerAccessTokenConfiguration = "SecretsManagerAccessTokenConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessType = self.accessType {
            try encodeContainer.encode(accessType.rawValue, forKey: .accessType)
        }
        if let secretsManagerAccessTokenConfiguration = self.secretsManagerAccessTokenConfiguration {
            try encodeContainer.encode(secretsManagerAccessTokenConfiguration, forKey: .secretsManagerAccessTokenConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessType.self, forKey: .accessType)
        accessType = accessTypeDecoded
        let secretsManagerAccessTokenConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration.self, forKey: .secretsManagerAccessTokenConfiguration)
        secretsManagerAccessTokenConfiguration = secretsManagerAccessTokenConfigurationDecoded
    }
}

extension MediaTailorClientTypes {
    /// Access configuration parameters.
    public struct AccessConfiguration: Swift.Equatable {
        /// The type of authentication used to access content from HttpConfiguration::BaseUrl on your source location. Accepted value: S3_SIGV4. S3_SIGV4 - AWS Signature Version 4 authentication for Amazon S3 hosted virtual-style access. If your source location base URL is an Amazon S3 bucket, MediaTailor can use AWS Signature Version 4 (SigV4) authentication to access the bucket where your source content is stored. Your MediaTailor source location baseURL must follow the S3 virtual hosted-style request URL format. For example, https://bucket-name.s3.Region.amazonaws.com/key-name. Before you can use S3_SIGV4, you must meet these requirements: • You must allow MediaTailor to access your S3 bucket by granting mediatailor.amazonaws.com principal access in IAM. For information about configuring access in IAM, see Access management in the IAM User Guide. • The mediatailor.amazonaws.com service principal must have permissions to read all top level manifests referenced by the VodSource packaging configurations. • The caller of the API must have s3:GetObject IAM permissions to read all top level manifests referenced by your MediaTailor VodSource packaging configurations.
        public var accessType: MediaTailorClientTypes.AccessType?
        /// AWS Secrets Manager access token configuration parameters.
        public var secretsManagerAccessTokenConfiguration: MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration?

        public init (
            accessType: MediaTailorClientTypes.AccessType? = nil,
            secretsManagerAccessTokenConfiguration: MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration? = nil
        )
        {
            self.accessType = accessType
            self.secretsManagerAccessTokenConfiguration = secretsManagerAccessTokenConfiguration
        }
    }

}

extension MediaTailorClientTypes {
    public enum AccessType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3Sigv4
        case secretsManagerAccessToken
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessType] {
            return [
                .s3Sigv4,
                .secretsManagerAccessToken,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3Sigv4: return "S3_SIGV4"
            case .secretsManagerAccessToken: return "SECRETS_MANAGER_ACCESS_TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessType(rawValue: rawValue) ?? AccessType.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.AdBreak: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageType = "MessageType"
        case offsetMillis = "OffsetMillis"
        case slate = "Slate"
        case spliceInsertMessage = "SpliceInsertMessage"
        case timeSignalMessage = "TimeSignalMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageType = self.messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let offsetMillis = self.offsetMillis {
            try encodeContainer.encode(offsetMillis, forKey: .offsetMillis)
        }
        if let slate = self.slate {
            try encodeContainer.encode(slate, forKey: .slate)
        }
        if let spliceInsertMessage = self.spliceInsertMessage {
            try encodeContainer.encode(spliceInsertMessage, forKey: .spliceInsertMessage)
        }
        if let timeSignalMessage = self.timeSignalMessage {
            try encodeContainer.encode(timeSignalMessage, forKey: .timeSignalMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let offsetMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offsetMillis)
        offsetMillis = offsetMillisDecoded
        let slateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .slate)
        slate = slateDecoded
        let spliceInsertMessageDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SpliceInsertMessage.self, forKey: .spliceInsertMessage)
        spliceInsertMessage = spliceInsertMessageDecoded
        let timeSignalMessageDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.TimeSignalMessage.self, forKey: .timeSignalMessage)
        timeSignalMessage = timeSignalMessageDecoded
    }
}

extension MediaTailorClientTypes {
    /// Ad break configuration parameters.
    public struct AdBreak: Swift.Equatable {
        /// The SCTE-35 ad insertion type. Accepted value: SPLICE_INSERT, TIME_SIGNAL.
        public var messageType: MediaTailorClientTypes.MessageType?
        /// How long (in milliseconds) after the beginning of the program that an ad starts. This value must fall within 100ms of a segment boundary, otherwise the ad break will be skipped.
        public var offsetMillis: Swift.Int?
        /// Ad break slate configuration.
        public var slate: MediaTailorClientTypes.SlateSource?
        /// This defines the SCTE-35 splice_insert() message inserted around the ad. For information about using splice_insert(), see the SCTE-35 specficiaiton, section 9.7.3.1.
        public var spliceInsertMessage: MediaTailorClientTypes.SpliceInsertMessage?
        /// Defines the SCTE-35 time_signal message inserted around the ad. Programs on a channel's schedule can be configured with one or more ad breaks. You can attach a splice_insert SCTE-35 message to the ad break. This message provides basic metadata about the ad break. See section 9.7.4 of the 2022 SCTE-35 specification for more information.
        public var timeSignalMessage: MediaTailorClientTypes.TimeSignalMessage?

        public init (
            messageType: MediaTailorClientTypes.MessageType? = nil,
            offsetMillis: Swift.Int? = nil,
            slate: MediaTailorClientTypes.SlateSource? = nil,
            spliceInsertMessage: MediaTailorClientTypes.SpliceInsertMessage? = nil,
            timeSignalMessage: MediaTailorClientTypes.TimeSignalMessage? = nil
        )
        {
            self.messageType = messageType
            self.offsetMillis = offsetMillis
            self.slate = slate
            self.spliceInsertMessage = spliceInsertMessage
            self.timeSignalMessage = timeSignalMessage
        }
    }

}

extension MediaTailorClientTypes.AdMarkerPassthrough: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension MediaTailorClientTypes {
    /// For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
    public struct AdMarkerPassthrough: Swift.Equatable {
        /// Enables ad marker passthrough for your configuration.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension MediaTailorClientTypes.Alert: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertCode = "AlertCode"
        case alertMessage = "AlertMessage"
        case lastModifiedTime = "LastModifiedTime"
        case relatedResourceArns = "RelatedResourceArns"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alertCode = self.alertCode {
            try encodeContainer.encode(alertCode, forKey: .alertCode)
        }
        if let alertMessage = self.alertMessage {
            try encodeContainer.encode(alertMessage, forKey: .alertMessage)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let relatedResourceArns = relatedResourceArns {
            var relatedResourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedResourceArns)
            for __string0 in relatedResourceArns {
                try relatedResourceArnsContainer.encode(__string0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertCode)
        alertCode = alertCodeDecoded
        let alertMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alertMessage)
        alertMessage = alertMessageDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let relatedResourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedResourceArns)
        var relatedResourceArnsDecoded0:[Swift.String]? = nil
        if let relatedResourceArnsContainer = relatedResourceArnsContainer {
            relatedResourceArnsDecoded0 = [Swift.String]()
            for string0 in relatedResourceArnsContainer {
                if let string0 = string0 {
                    relatedResourceArnsDecoded0?.append(string0)
                }
            }
        }
        relatedResourceArns = relatedResourceArnsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension MediaTailorClientTypes {
    /// Alert configuration parameters.
    public struct Alert: Swift.Equatable {
        /// The code for the alert. For example, NOT_PROCESSED.
        /// This member is required.
        public var alertCode: Swift.String?
        /// If an alert is generated for a resource, an explanation of the reason for the alert.
        /// This member is required.
        public var alertMessage: Swift.String?
        /// The timestamp when the alert was last modified.
        /// This member is required.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The Amazon Resource Names (ARNs) related to this alert.
        /// This member is required.
        public var relatedResourceArns: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init (
            alertCode: Swift.String? = nil,
            alertMessage: Swift.String? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            relatedResourceArns: [Swift.String]? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.alertCode = alertCode
            self.alertMessage = alertMessage
            self.lastModifiedTime = lastModifiedTime
            self.relatedResourceArns = relatedResourceArns
            self.resourceArn = resourceArn
        }
    }

}

extension MediaTailorClientTypes.AvailMatchingCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dynamicVariable = "DynamicVariable"
        case `operator` = "Operator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamicVariable = self.dynamicVariable {
            try encodeContainer.encode(dynamicVariable, forKey: .dynamicVariable)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dynamicVariableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dynamicVariable)
        dynamicVariable = dynamicVariableDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension MediaTailorClientTypes {
    /// MediaTailor only places (consumes) prefetched ads if the ad break meets the criteria defined by the dynamic variables. This gives you granular control over which ad break to place the prefetched ads into. As an example, let's say that you set DynamicVariable to scte.event_id and Operator to EQUALS, and your playback configuration has an ADS URL of https://my.ads.server.com/path?&podId=[scte.avail_num]&event=[scte.event_id]&duration=[session.avail_duration_secs]. And the prefetch request to the ADS contains these values https://my.ads.server.com/path?&podId=3&event=my-awesome-event&duration=30. MediaTailor will only insert the prefetched ads into the ad break if has a SCTE marker with an event id of my-awesome-event, since it must match the event id that MediaTailor uses to query the ADS. You can specify up to five AvailMatchingCriteria. If you specify multiple AvailMatchingCriteria, MediaTailor combines them to match using a logical AND. You can model logical OR combinations by creating multiple prefetch schedules.
    public struct AvailMatchingCriteria: Swift.Equatable {
        /// The dynamic variable(s) that MediaTailor should use as avail matching criteria. MediaTailor only places the prefetched ads into the avail if the avail matches the criteria defined by the dynamic variable. For information about dynamic variables, see [Using dynamic ad variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html) in the MediaTailor User Guide. You can include up to 100 dynamic variables.
        /// This member is required.
        public var dynamicVariable: Swift.String?
        /// For the DynamicVariable specified in AvailMatchingCriteria, the Operator that is used for the comparison.
        /// This member is required.
        public var `operator`: MediaTailorClientTypes.Operator?

        public init (
            dynamicVariable: Swift.String? = nil,
            `operator`: MediaTailorClientTypes.Operator? = nil
        )
        {
            self.dynamicVariable = dynamicVariable
            self.`operator` = `operator`
        }
    }

}

extension MediaTailorClientTypes.AvailSuppression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Mode.self, forKey: .mode)
        mode = modeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MediaTailorClientTypes {
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public struct AvailSuppression: Swift.Equatable {
        /// Sets the ad suppression mode. By default, ad suppression is off and all ad breaks are filled with ads or slate. When Mode is set to BEHIND_LIVE_EDGE, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window.
        public var mode: MediaTailorClientTypes.Mode?
        /// A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.
        public var value: Swift.String?

        public init (
            mode: MediaTailorClientTypes.Mode? = nil,
            value: Swift.String? = nil
        )
        {
            self.mode = mode
            self.value = value
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A request contains unexpected data.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaTailorClientTypes.Bumper: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endUrl = "EndUrl"
        case startUrl = "StartUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endUrl = self.endUrl {
            try encodeContainer.encode(endUrl, forKey: .endUrl)
        }
        if let startUrl = self.startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endUrl)
        endUrl = endUrlDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
    }
}

extension MediaTailorClientTypes {
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
    public struct Bumper: Swift.Equatable {
        /// The URL for the end bumper asset.
        public var endUrl: Swift.String?
        /// The URL for the start bumper asset.
        public var startUrl: Swift.String?

        public init (
            endUrl: Swift.String? = nil,
            startUrl: Swift.String? = nil
        )
        {
            self.endUrl = endUrl
            self.startUrl = startUrl
        }
    }

}

extension MediaTailorClientTypes.CdnConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adSegmentUrlPrefix = "AdSegmentUrlPrefix"
        case contentSegmentUrlPrefix = "ContentSegmentUrlPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adSegmentUrlPrefix = self.adSegmentUrlPrefix {
            try encodeContainer.encode(adSegmentUrlPrefix, forKey: .adSegmentUrlPrefix)
        }
        if let contentSegmentUrlPrefix = self.contentSegmentUrlPrefix {
            try encodeContainer.encode(contentSegmentUrlPrefix, forKey: .contentSegmentUrlPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adSegmentUrlPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adSegmentUrlPrefix)
        adSegmentUrlPrefix = adSegmentUrlPrefixDecoded
        let contentSegmentUrlPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentSegmentUrlPrefix)
        contentSegmentUrlPrefix = contentSegmentUrlPrefixDecoded
    }
}

extension MediaTailorClientTypes {
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public struct CdnConfiguration: Swift.Equatable {
        /// A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.<region>.amazonaws.com. Then specify the rule's name in this AdSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.
        public var adSegmentUrlPrefix: Swift.String?
        /// A content delivery network (CDN) to cache content segments, so that content requests don’t always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this ContentSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.
        public var contentSegmentUrlPrefix: Swift.String?

        public init (
            adSegmentUrlPrefix: Swift.String? = nil,
            contentSegmentUrlPrefix: Swift.String? = nil
        )
        {
            self.adSegmentUrlPrefix = adSegmentUrlPrefix
            self.contentSegmentUrlPrefix = contentSegmentUrlPrefix
        }
    }

}

extension MediaTailorClientTypes.Channel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case fillerSlate = "FillerSlate"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
        case tier = "Tier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelState = self.channelState {
            try encodeContainer.encode(channelState, forKey: .channelState)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let fillerSlate = self.fillerSlate {
            try encodeContainer.encode(fillerSlate, forKey: .fillerSlate)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for responseoutputitem0 in outputs {
                try outputsContainer.encode(responseoutputitem0)
            }
        }
        if let playbackMode = self.playbackMode {
            try encodeContainer.encode(playbackMode, forKey: .playbackMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier, forKey: .tier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension MediaTailorClientTypes {
    /// The configuration parameters for a channel. For information about MediaTailor channels, see [Working with channels](https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-channels.html) in the MediaTailor User Guide.
    public struct Channel: Swift.Equatable {
        /// The ARN of the channel.
        /// This member is required.
        public var arn: Swift.String?
        /// The name of the channel.
        /// This member is required.
        public var channelName: Swift.String?
        /// Returns the state whether the channel is running or not.
        /// This member is required.
        public var channelState: Swift.String?
        /// The timestamp of when the channel was created.
        public var creationTime: ClientRuntime.Date?
        /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEARPlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOPPlaybackMode.
        public var fillerSlate: MediaTailorClientTypes.SlateSource?
        /// The timestamp of when the channel was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The channel's output properties.
        /// This member is required.
        public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
        /// The type of playback mode for this channel. LINEAR - Programs play back-to-back only once. LOOP - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.
        /// This member is required.
        public var playbackMode: Swift.String?
        /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String:Swift.String]?
        /// The tier for this channel. STANDARD tier channels can contain live programs.
        /// This member is required.
        public var tier: Swift.String?

        public init (
            arn: Swift.String? = nil,
            channelName: Swift.String? = nil,
            channelState: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
            playbackMode: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            tier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.channelName = channelName
            self.channelState = channelState
            self.creationTime = creationTime
            self.fillerSlate = fillerSlate
            self.lastModifiedTime = lastModifiedTime
            self.outputs = outputs
            self.playbackMode = playbackMode
            self.tags = tags
            self.tier = tier
        }
    }

}

extension MediaTailorClientTypes {
    public enum ChannelState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelState] {
            return [
                .running,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelState(rawValue: rawValue) ?? ChannelState.sdkUnknown(rawValue)
        }
    }
}

extension ConfigureLogsForPlaybackConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentEnabled = "PercentEnabled"
        case playbackConfigurationName = "PlaybackConfigurationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentEnabled = self.percentEnabled {
            try encodeContainer.encode(percentEnabled, forKey: .percentEnabled)
        }
        if let playbackConfigurationName = self.playbackConfigurationName {
            try encodeContainer.encode(playbackConfigurationName, forKey: .playbackConfigurationName)
        }
    }
}

extension ConfigureLogsForPlaybackConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configureLogs/playbackConfiguration"
    }
}

/// Configures Amazon CloudWatch log settings for a playback configuration.
public struct ConfigureLogsForPlaybackConfigurationInput: Swift.Equatable {
    /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the [debug log mode](https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html). Valid values: 0 - 100
    /// This member is required.
    public var percentEnabled: Swift.Int?
    /// The name of the playback configuration.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?

    public init (
        percentEnabled: Swift.Int? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.percentEnabled = percentEnabled
        self.playbackConfigurationName = playbackConfigurationName
    }
}

struct ConfigureLogsForPlaybackConfigurationInputBody: Swift.Equatable {
    let percentEnabled: Swift.Int?
    let playbackConfigurationName: Swift.String?
}

extension ConfigureLogsForPlaybackConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentEnabled = "PercentEnabled"
        case playbackConfigurationName = "PlaybackConfigurationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentEnabledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentEnabled)
        percentEnabled = percentEnabledDecoded
        let playbackConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationName)
        playbackConfigurationName = playbackConfigurationNameDecoded
    }
}

extension ConfigureLogsForPlaybackConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfigureLogsForPlaybackConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ConfigureLogsForPlaybackConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureLogsForPlaybackConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConfigureLogsForPlaybackConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.percentEnabled = output.percentEnabled
            self.playbackConfigurationName = output.playbackConfigurationName
        } else {
            self.percentEnabled = nil
            self.playbackConfigurationName = nil
        }
    }
}

public struct ConfigureLogsForPlaybackConfigurationOutputResponse: Swift.Equatable {
    /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account.
    /// This member is required.
    public var percentEnabled: Swift.Int?
    /// The name of the playback configuration.
    public var playbackConfigurationName: Swift.String?

    public init (
        percentEnabled: Swift.Int? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.percentEnabled = percentEnabled
        self.playbackConfigurationName = playbackConfigurationName
    }
}

struct ConfigureLogsForPlaybackConfigurationOutputResponseBody: Swift.Equatable {
    let percentEnabled: Swift.Int?
    let playbackConfigurationName: Swift.String?
}

extension ConfigureLogsForPlaybackConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentEnabled = "PercentEnabled"
        case playbackConfigurationName = "PlaybackConfigurationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentEnabledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentEnabled)
        percentEnabled = percentEnabledDecoded
        let playbackConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationName)
        playbackConfigurationName = playbackConfigurationNameDecoded
    }
}

extension CreateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fillerSlate = "FillerSlate"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
        case tier = "Tier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fillerSlate = self.fillerSlate {
            try encodeContainer.encode(fillerSlate, forKey: .fillerSlate)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for requestoutputitem0 in outputs {
                try outputsContainer.encode(requestoutputitem0)
            }
        }
        if let playbackMode = self.playbackMode {
            try encodeContainer.encode(playbackMode.rawValue, forKey: .playbackMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct CreateChannelInput: Swift.Equatable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?
    /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEARPlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOPPlaybackMode.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The channel's output properties.
    /// This member is required.
    public var outputs: [MediaTailorClientTypes.RequestOutputItem]?
    /// The type of playback mode to use for this channel. LINEAR - The programs in the schedule play once back-to-back in the schedule. LOOP - The programs in the schedule play back-to-back in an endless loop. When the last program in the schedule stops playing, playback loops back to the first program in the schedule.
    /// This member is required.
    public var playbackMode: MediaTailorClientTypes.PlaybackMode?
    /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The tier of the channel.
    public var tier: MediaTailorClientTypes.Tier?

    public init (
        channelName: Swift.String? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        outputs: [MediaTailorClientTypes.RequestOutputItem]? = nil,
        playbackMode: MediaTailorClientTypes.PlaybackMode? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tier: MediaTailorClientTypes.Tier? = nil
    )
    {
        self.channelName = channelName
        self.fillerSlate = fillerSlate
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
        self.tier = tier
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let fillerSlate: MediaTailorClientTypes.SlateSource?
    let outputs: [MediaTailorClientTypes.RequestOutputItem]?
    let playbackMode: MediaTailorClientTypes.PlaybackMode?
    let tags: [Swift.String:Swift.String]?
    let tier: MediaTailorClientTypes.Tier?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fillerSlate = "FillerSlate"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
        case tier = "Tier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.RequestOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.RequestOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.RequestOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PlaybackMode.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Tier.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelName = output.channelName
            self.channelState = output.channelState
            self.creationTime = output.creationTime
            self.fillerSlate = output.fillerSlate
            self.lastModifiedTime = output.lastModifiedTime
            self.outputs = output.outputs
            self.playbackMode = output.playbackMode
            self.tags = output.tags
            self.tier = output.tier
        } else {
            self.arn = nil
            self.channelName = nil
            self.channelState = nil
            self.creationTime = nil
            self.fillerSlate = nil
            self.lastModifiedTime = nil
            self.outputs = nil
            self.playbackMode = nil
            self.tags = nil
            self.tier = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) to assign to the channel.
    public var arn: Swift.String?
    /// The name to assign to the channel.
    public var channelName: Swift.String?
    /// Indicates whether the channel is in a running state or not.
    public var channelState: MediaTailorClientTypes.ChannelState?
    /// The timestamp of when the channel was created.
    public var creationTime: ClientRuntime.Date?
    /// Contains information about the slate used to fill gaps between programs in the schedule.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The timestamp of when the channel was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The output properties to assign to the channel.
    public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    /// The playback mode to assign to the channel.
    public var playbackMode: Swift.String?
    /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The tier of the channel.
    public var tier: Swift.String?

    public init (
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelState: MediaTailorClientTypes.ChannelState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
        playbackMode: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tier: Swift.String? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.fillerSlate = fillerSlate
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
        self.tier = tier
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let channelName: Swift.String?
    let channelState: MediaTailorClientTypes.ChannelState?
    let creationTime: ClientRuntime.Date?
    let fillerSlate: MediaTailorClientTypes.SlateSource?
    let lastModifiedTime: ClientRuntime.Date?
    let outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    let playbackMode: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let tier: Swift.String?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case fillerSlate = "FillerSlate"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
        case tier = "Tier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ChannelState.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension CreateLiveSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfiguration0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfiguration0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLiveSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        guard let liveSourceName = liveSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSource/\(liveSourceName.urlPercentEncoding())"
    }
}

public struct CreateLiveSourceInput: Swift.Equatable {
    /// A list of HTTP package configuration parameters for this live source.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The name of the live source.
    /// This member is required.
    public var liveSourceName: Swift.String?
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct CreateLiveSourceInputBody: Swift.Equatable {
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLiveSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLiveSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLiveSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLiveSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLiveSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLiveSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.liveSourceName = output.liveSourceName
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.liveSourceName = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct CreateLiveSourceOutputResponse: Swift.Equatable {
    /// The ARN to assign to the live source.
    public var arn: Swift.String?
    /// The time the live source was created.
    public var creationTime: ClientRuntime.Date?
    /// A list of HTTP package configuration parameters for this live source.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The time the live source was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name to assign to the live source.
    public var liveSourceName: Swift.String?
    /// The name to assign to the source location of the live source.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct CreateLiveSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    let lastModifiedTime: ClientRuntime.Date?
    let liveSourceName: Swift.String?
    let sourceLocationName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLiveSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case liveSourceName = "LiveSourceName"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let liveSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .liveSourceName)
        liveSourceName = liveSourceNameDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePrefetchScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumption = "Consumption"
        case retrieval = "Retrieval"
        case streamId = "StreamId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumption = self.consumption {
            try encodeContainer.encode(consumption, forKey: .consumption)
        }
        if let retrieval = self.retrieval {
            try encodeContainer.encode(retrieval, forKey: .retrieval)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }
}

extension CreatePrefetchScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let playbackConfigurationName = playbackConfigurationName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/prefetchSchedule/\(playbackConfigurationName.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

public struct CreatePrefetchScheduleInput: Swift.Equatable {
    /// The configuration settings for MediaTailor's consumption of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the consumption window. Prefetch schedules automatically expire no earlier than seven days after the end time.
    /// This member is required.
    public var consumption: MediaTailorClientTypes.PrefetchConsumption?
    /// The name to assign to the schedule request.
    /// This member is required.
    public var name: Swift.String?
    /// The name to assign to the playback configuration.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?
    /// The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.
    /// This member is required.
    public var retrieval: MediaTailorClientTypes.PrefetchRetrieval?
    /// An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.
    public var streamId: Swift.String?

    public init (
        consumption: MediaTailorClientTypes.PrefetchConsumption? = nil,
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil,
        retrieval: MediaTailorClientTypes.PrefetchRetrieval? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.consumption = consumption
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
        self.retrieval = retrieval
        self.streamId = streamId
    }
}

struct CreatePrefetchScheduleInputBody: Swift.Equatable {
    let consumption: MediaTailorClientTypes.PrefetchConsumption?
    let retrieval: MediaTailorClientTypes.PrefetchRetrieval?
    let streamId: Swift.String?
}

extension CreatePrefetchScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumption = "Consumption"
        case retrieval = "Retrieval"
        case streamId = "StreamId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consumptionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PrefetchConsumption.self, forKey: .consumption)
        consumption = consumptionDecoded
        let retrievalDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PrefetchRetrieval.self, forKey: .retrieval)
        retrieval = retrievalDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension CreatePrefetchScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePrefetchScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePrefetchScheduleOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePrefetchScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePrefetchScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.consumption = output.consumption
            self.name = output.name
            self.playbackConfigurationName = output.playbackConfigurationName
            self.retrieval = output.retrieval
            self.streamId = output.streamId
        } else {
            self.arn = nil
            self.consumption = nil
            self.name = nil
            self.playbackConfigurationName = nil
            self.retrieval = nil
            self.streamId = nil
        }
    }
}

public struct CreatePrefetchScheduleOutputResponse: Swift.Equatable {
    /// The ARN to assign to the prefetch schedule.
    public var arn: Swift.String?
    /// The configuration settings for MediaTailor's consumption of the prefetched ads from the ad decision server. Each consumption configuration contains an end time and an optional start time that define the consumption window. Prefetch schedules automatically expire no earlier than seven days after the end time.
    public var consumption: MediaTailorClientTypes.PrefetchConsumption?
    /// The name to assign to the prefetch schedule.
    public var name: Swift.String?
    /// The name to assign to the playback configuration.
    public var playbackConfigurationName: Swift.String?
    /// The configuration settings for retrieval of prefetched ads from the ad decision server. Only one set of prefetched ads will be retrieved and subsequently consumed for each ad break.
    public var retrieval: MediaTailorClientTypes.PrefetchRetrieval?
    /// An optional stream identifier that MediaTailor uses to prefetch ads for multiple streams that use the same playback configuration. If StreamId is specified, MediaTailor returns all of the prefetch schedules with an exact match on StreamId. If not specified, MediaTailor returns all of the prefetch schedules for the playback configuration, regardless of StreamId.
    public var streamId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        consumption: MediaTailorClientTypes.PrefetchConsumption? = nil,
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil,
        retrieval: MediaTailorClientTypes.PrefetchRetrieval? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.consumption = consumption
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
        self.retrieval = retrieval
        self.streamId = streamId
    }
}

struct CreatePrefetchScheduleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let consumption: MediaTailorClientTypes.PrefetchConsumption?
    let name: Swift.String?
    let playbackConfigurationName: Swift.String?
    let retrieval: MediaTailorClientTypes.PrefetchRetrieval?
    let streamId: Swift.String?
}

extension CreatePrefetchScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case consumption = "Consumption"
        case name = "Name"
        case playbackConfigurationName = "PlaybackConfigurationName"
        case retrieval = "Retrieval"
        case streamId = "StreamId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let consumptionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PrefetchConsumption.self, forKey: .consumption)
        consumption = consumptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let playbackConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationName)
        playbackConfigurationName = playbackConfigurationNameDecoded
        let retrievalDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PrefetchRetrieval.self, forKey: .retrieval)
        retrieval = retrievalDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension CreateProgramInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adBreaks = "AdBreaks"
        case liveSourceName = "LiveSourceName"
        case scheduleConfiguration = "ScheduleConfiguration"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adBreaks = adBreaks {
            var adBreaksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adBreaks)
            for adbreak0 in adBreaks {
                try adBreaksContainer.encode(adbreak0)
            }
        }
        if let liveSourceName = self.liveSourceName {
            try encodeContainer.encode(liveSourceName, forKey: .liveSourceName)
        }
        if let scheduleConfiguration = self.scheduleConfiguration {
            try encodeContainer.encode(scheduleConfiguration, forKey: .scheduleConfiguration)
        }
        if let sourceLocationName = self.sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = self.vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }
}

extension CreateProgramInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        guard let programName = programName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
    }
}

public struct CreateProgramInput: Swift.Equatable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The name of the channel for this Program.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name of the LiveSource for this Program.
    public var liveSourceName: Swift.String?
    /// The name of the Program.
    /// This member is required.
    public var programName: Swift.String?
    /// The schedule configuration settings.
    /// This member is required.
    public var scheduleConfiguration: MediaTailorClientTypes.ScheduleConfiguration?
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    public var vodSourceName: Swift.String?

    public init (
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        channelName: Swift.String? = nil,
        liveSourceName: Swift.String? = nil,
        programName: Swift.String? = nil,
        scheduleConfiguration: MediaTailorClientTypes.ScheduleConfiguration? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.channelName = channelName
        self.liveSourceName = liveSourceName
        self.programName = programName
        self.scheduleConfiguration = scheduleConfiguration
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct CreateProgramInputBody: Swift.Equatable {
    let adBreaks: [MediaTailorClientTypes.AdBreak]?
    let liveSourceName: Swift.String?
    let scheduleConfiguration: MediaTailorClientTypes.ScheduleConfiguration?
    let sourceLocationName: Swift.String?
    let vodSourceName: Swift.String?
}

extension CreateProgramInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adBreaks = "AdBreaks"
        case liveSourceName = "LiveSourceName"
        case scheduleConfiguration = "ScheduleConfiguration"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adBreaksContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.AdBreak?].self, forKey: .adBreaks)
        var adBreaksDecoded0:[MediaTailorClientTypes.AdBreak]? = nil
        if let adBreaksContainer = adBreaksContainer {
            adBreaksDecoded0 = [MediaTailorClientTypes.AdBreak]()
            for structure0 in adBreaksContainer {
                if let structure0 = structure0 {
                    adBreaksDecoded0?.append(structure0)
                }
            }
        }
        adBreaks = adBreaksDecoded0
        let liveSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .liveSourceName)
        liveSourceName = liveSourceNameDecoded
        let scheduleConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ScheduleConfiguration.self, forKey: .scheduleConfiguration)
        scheduleConfiguration = scheduleConfigurationDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension CreateProgramOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProgramOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProgramOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProgramOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProgramOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adBreaks = output.adBreaks
            self.arn = output.arn
            self.channelName = output.channelName
            self.creationTime = output.creationTime
            self.liveSourceName = output.liveSourceName
            self.programName = output.programName
            self.scheduledStartTime = output.scheduledStartTime
            self.sourceLocationName = output.sourceLocationName
            self.vodSourceName = output.vodSourceName
        } else {
            self.adBreaks = nil
            self.arn = nil
            self.channelName = nil
            self.creationTime = nil
            self.liveSourceName = nil
            self.programName = nil
            self.scheduledStartTime = nil
            self.sourceLocationName = nil
            self.vodSourceName = nil
        }
    }
}

public struct CreateProgramOutputResponse: Swift.Equatable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The ARN to assign to the program.
    public var arn: Swift.String?
    /// The name to assign to the channel for this program.
    public var channelName: Swift.String?
    /// The time the program was created.
    public var creationTime: ClientRuntime.Date?
    /// The name of the LiveSource for this Program.
    public var liveSourceName: Swift.String?
    /// The name to assign to this program.
    public var programName: Swift.String?
    /// The scheduled start time for this Program.
    public var scheduledStartTime: ClientRuntime.Date?
    /// The name to assign to the source location for this program.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    public var vodSourceName: Swift.String?

    public init (
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        liveSourceName: Swift.String? = nil,
        programName: Swift.String? = nil,
        scheduledStartTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.arn = arn
        self.channelName = channelName
        self.creationTime = creationTime
        self.liveSourceName = liveSourceName
        self.programName = programName
        self.scheduledStartTime = scheduledStartTime
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct CreateProgramOutputResponseBody: Swift.Equatable {
    let adBreaks: [MediaTailorClientTypes.AdBreak]?
    let arn: Swift.String?
    let channelName: Swift.String?
    let creationTime: ClientRuntime.Date?
    let liveSourceName: Swift.String?
    let programName: Swift.String?
    let scheduledStartTime: ClientRuntime.Date?
    let sourceLocationName: Swift.String?
    let vodSourceName: Swift.String?
}

extension CreateProgramOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adBreaks = "AdBreaks"
        case arn = "Arn"
        case channelName = "ChannelName"
        case creationTime = "CreationTime"
        case liveSourceName = "LiveSourceName"
        case programName = "ProgramName"
        case scheduledStartTime = "ScheduledStartTime"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adBreaksContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.AdBreak?].self, forKey: .adBreaks)
        var adBreaksDecoded0:[MediaTailorClientTypes.AdBreak]? = nil
        if let adBreaksContainer = adBreaksContainer {
            adBreaksDecoded0 = [MediaTailorClientTypes.AdBreak]()
            for structure0 in adBreaksContainer {
                if let structure0 = structure0 {
                    adBreaksDecoded0?.append(structure0)
                }
            }
        }
        adBreaks = adBreaksDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let liveSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .liveSourceName)
        liveSourceName = liveSourceNameDecoded
        let programNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .programName)
        programName = programNameDecoded
        let scheduledStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduledStartTime)
        scheduledStartTime = scheduledStartTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension CreateSourceLocationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = self.accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let defaultSegmentDeliveryConfiguration = self.defaultSegmentDeliveryConfiguration {
            try encodeContainer.encode(defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
        }
        if let httpConfiguration = self.httpConfiguration {
            try encodeContainer.encode(httpConfiguration, forKey: .httpConfiguration)
        }
        if let segmentDeliveryConfigurations = segmentDeliveryConfigurations {
            var segmentDeliveryConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentDeliveryConfigurations)
            for segmentdeliveryconfiguration0 in segmentDeliveryConfigurations {
                try segmentDeliveryConfigurationsContainer.encode(segmentdeliveryconfiguration0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSourceLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
    }
}

public struct CreateSourceLocationInput: Swift.Equatable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The optional configuration for the server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The source's HTTP package configurations.
    /// This member is required.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// A list of the segment delivery configurations associated with this resource.
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name associated with the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct CreateSourceLocationInputBody: Swift.Equatable {
    let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    let segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSourceLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let segmentDeliveryConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.SegmentDeliveryConfiguration?].self, forKey: .segmentDeliveryConfigurations)
        var segmentDeliveryConfigurationsDecoded0:[MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil
        if let segmentDeliveryConfigurationsContainer = segmentDeliveryConfigurationsContainer {
            segmentDeliveryConfigurationsDecoded0 = [MediaTailorClientTypes.SegmentDeliveryConfiguration]()
            for structure0 in segmentDeliveryConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentDeliveryConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentDeliveryConfigurations = segmentDeliveryConfigurationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSourceLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSourceLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSourceLocationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSourceLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSourceLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessConfiguration = output.accessConfiguration
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.defaultSegmentDeliveryConfiguration = output.defaultSegmentDeliveryConfiguration
            self.httpConfiguration = output.httpConfiguration
            self.lastModifiedTime = output.lastModifiedTime
            self.segmentDeliveryConfigurations = output.segmentDeliveryConfigurations
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.accessConfiguration = nil
            self.arn = nil
            self.creationTime = nil
            self.defaultSegmentDeliveryConfiguration = nil
            self.httpConfiguration = nil
            self.lastModifiedTime = nil
            self.segmentDeliveryConfigurations = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct CreateSourceLocationOutputResponse: Swift.Equatable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The ARN to assign to the source location.
    public var arn: Swift.String?
    /// The time the source location was created.
    public var creationTime: ClientRuntime.Date?
    /// The optional configuration for the server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The source's HTTP package configurations.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The time the source location was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The segment delivery configurations for the source location. For information about MediaTailor configurations, see [Working with configurations in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html).
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name to assign to the source location.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct CreateSourceLocationOutputResponseBody: Swift.Equatable {
    let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    let lastModifiedTime: ClientRuntime.Date?
    let segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    let sourceLocationName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSourceLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let segmentDeliveryConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.SegmentDeliveryConfiguration?].self, forKey: .segmentDeliveryConfigurations)
        var segmentDeliveryConfigurationsDecoded0:[MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil
        if let segmentDeliveryConfigurationsContainer = segmentDeliveryConfigurationsContainer {
            segmentDeliveryConfigurationsDecoded0 = [MediaTailorClientTypes.SegmentDeliveryConfiguration]()
            for structure0 in segmentDeliveryConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentDeliveryConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentDeliveryConfigurations = segmentDeliveryConfigurationsDecoded0
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVodSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfiguration0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfiguration0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateVodSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        guard let vodSourceName = vodSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
    }
}

public struct CreateVodSourceInput: Swift.Equatable {
    /// A list of HTTP package configuration parameters for this VOD source.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The name of the source location for this VOD source.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The name associated with the VOD source.>
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init (
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct CreateVodSourceInputBody: Swift.Equatable {
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVodSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVodSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVodSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVodSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVodSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVodSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
            self.vodSourceName = output.vodSourceName
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
            self.vodSourceName = nil
        }
    }
}

public struct CreateVodSourceOutputResponse: Swift.Equatable {
    /// The ARN to assign to this VOD source.
    public var arn: Swift.String?
    /// The time the VOD source was created.
    public var creationTime: ClientRuntime.Date?
    /// A list of HTTP package configuration parameters for this VOD source.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The time the VOD source was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name to assign to the source location for this VOD source.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The name to assign to the VOD source.
    public var vodSourceName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct CreateVodSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    let lastModifiedTime: ClientRuntime.Date?
    let sourceLocationName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let vodSourceName: Swift.String?
}

extension CreateVodSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes.DashConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestEndpointPrefix = "ManifestEndpointPrefix"
        case mpdLocation = "MpdLocation"
        case originManifestType = "OriginManifestType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestEndpointPrefix = self.manifestEndpointPrefix {
            try encodeContainer.encode(manifestEndpointPrefix, forKey: .manifestEndpointPrefix)
        }
        if let mpdLocation = self.mpdLocation {
            try encodeContainer.encode(mpdLocation, forKey: .mpdLocation)
        }
        if let originManifestType = self.originManifestType {
            try encodeContainer.encode(originManifestType.rawValue, forKey: .originManifestType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestEndpointPrefix)
        manifestEndpointPrefix = manifestEndpointPrefixDecoded
        let mpdLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mpdLocation)
        mpdLocation = mpdLocationDecoded
        let originManifestTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.OriginManifestType.self, forKey: .originManifestType)
        originManifestType = originManifestTypeDecoded
    }
}

extension MediaTailorClientTypes {
    /// The configuration for DASH content.
    public struct DashConfiguration: Swift.Equatable {
        /// The URL generated by MediaTailor to initiate a playback session. The session uses server-side reporting. This setting is ignored in PUT operations.
        public var manifestEndpointPrefix: Swift.String?
        /// The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
        public var mpdLocation: Swift.String?
        /// The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
        public var originManifestType: MediaTailorClientTypes.OriginManifestType?

        public init (
            manifestEndpointPrefix: Swift.String? = nil,
            mpdLocation: Swift.String? = nil,
            originManifestType: MediaTailorClientTypes.OriginManifestType? = nil
        )
        {
            self.manifestEndpointPrefix = manifestEndpointPrefix
            self.mpdLocation = mpdLocation
            self.originManifestType = originManifestType
        }
    }

}

extension MediaTailorClientTypes.DashConfigurationForPut: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mpdLocation = "MpdLocation"
        case originManifestType = "OriginManifestType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mpdLocation = self.mpdLocation {
            try encodeContainer.encode(mpdLocation, forKey: .mpdLocation)
        }
        if let originManifestType = self.originManifestType {
            try encodeContainer.encode(originManifestType.rawValue, forKey: .originManifestType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mpdLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mpdLocation)
        mpdLocation = mpdLocationDecoded
        let originManifestTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.OriginManifestType.self, forKey: .originManifestType)
        originManifestType = originManifestTypeDecoded
    }
}

extension MediaTailorClientTypes {
    /// The configuration for DASH PUT operations.
    public struct DashConfigurationForPut: Swift.Equatable {
        /// The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
        public var mpdLocation: Swift.String?
        /// The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
        public var originManifestType: MediaTailorClientTypes.OriginManifestType?

        public init (
            mpdLocation: Swift.String? = nil,
            originManifestType: MediaTailorClientTypes.OriginManifestType? = nil
        )
        {
            self.mpdLocation = mpdLocation
            self.originManifestType = originManifestType
        }
    }

}

extension MediaTailorClientTypes.DashPlaylistSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestWindowSeconds = "ManifestWindowSeconds"
        case minBufferTimeSeconds = "MinBufferTimeSeconds"
        case minUpdatePeriodSeconds = "MinUpdatePeriodSeconds"
        case suggestedPresentationDelaySeconds = "SuggestedPresentationDelaySeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
        if let minBufferTimeSeconds = self.minBufferTimeSeconds {
            try encodeContainer.encode(minBufferTimeSeconds, forKey: .minBufferTimeSeconds)
        }
        if let minUpdatePeriodSeconds = self.minUpdatePeriodSeconds {
            try encodeContainer.encode(minUpdatePeriodSeconds, forKey: .minUpdatePeriodSeconds)
        }
        if let suggestedPresentationDelaySeconds = self.suggestedPresentationDelaySeconds {
            try encodeContainer.encode(suggestedPresentationDelaySeconds, forKey: .suggestedPresentationDelaySeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
        let minBufferTimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minBufferTimeSeconds)
        minBufferTimeSeconds = minBufferTimeSecondsDecoded
        let minUpdatePeriodSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minUpdatePeriodSeconds)
        minUpdatePeriodSeconds = minUpdatePeriodSecondsDecoded
        let suggestedPresentationDelaySecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .suggestedPresentationDelaySeconds)
        suggestedPresentationDelaySeconds = suggestedPresentationDelaySecondsDecoded
    }
}

extension MediaTailorClientTypes {
    /// Dash manifest configuration parameters.
    public struct DashPlaylistSettings: Swift.Equatable {
        /// The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.
        public var manifestWindowSeconds: Swift.Int?
        /// Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public var minBufferTimeSeconds: Swift.Int?
        /// Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public var minUpdatePeriodSeconds: Swift.Int?
        /// Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: 2 seconds. Maximum value: 60 seconds.
        public var suggestedPresentationDelaySeconds: Swift.Int?

        public init (
            manifestWindowSeconds: Swift.Int? = nil,
            minBufferTimeSeconds: Swift.Int? = nil,
            minUpdatePeriodSeconds: Swift.Int? = nil,
            suggestedPresentationDelaySeconds: Swift.Int? = nil
        )
        {
            self.manifestWindowSeconds = manifestWindowSeconds
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.minUpdatePeriodSeconds = minUpdatePeriodSeconds
            self.suggestedPresentationDelaySeconds = suggestedPresentationDelaySeconds
        }
    }

}

extension MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseUrl = "BaseUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseUrl = self.baseUrl {
            try encodeContainer.encode(baseUrl, forKey: .baseUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseUrl)
        baseUrl = baseUrlDecoded
    }
}

extension MediaTailorClientTypes {
    /// The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.
    public struct DefaultSegmentDeliveryConfiguration: Swift.Equatable {
        /// The hostname of the server that will be used to serve segments. This string must include the protocol, such as https://.
        public var baseUrl: Swift.String?

        public init (
            baseUrl: Swift.String? = nil
        )
        {
            self.baseUrl = baseUrl
        }
    }

}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteChannelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

public struct DeleteChannelPolicyInput: Swift.Equatable {
    /// The name of the channel associated with this channel policy.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DeleteChannelPolicyInputBody: Swift.Equatable {
}

extension DeleteChannelPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelPolicyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteLiveSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        guard let liveSourceName = liveSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSource/\(liveSourceName.urlPercentEncoding())"
    }
}

public struct DeleteLiveSourceInput: Swift.Equatable {
    /// The name of the live source.
    /// This member is required.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with this Live Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
    }
}

struct DeleteLiveSourceInputBody: Swift.Equatable {
}

extension DeleteLiveSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLiveSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLiveSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLiveSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLiveSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLiveSourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePlaybackConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/playbackConfiguration/\(name.urlPercentEncoding())"
    }
}

public struct DeletePlaybackConfigurationInput: Swift.Equatable {
    /// The name of the playback configuration.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeletePlaybackConfigurationInputBody: Swift.Equatable {
}

extension DeletePlaybackConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePlaybackConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlaybackConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePlaybackConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlaybackConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlaybackConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePrefetchScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let playbackConfigurationName = playbackConfigurationName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/prefetchSchedule/\(playbackConfigurationName.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

public struct DeletePrefetchScheduleInput: Swift.Equatable {
    /// The name of the prefetch schedule. If the action is successful, the service sends back an HTTP 204 response with an empty HTTP body.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the playback configuration for this prefetch schedule.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?

    public init (
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
    }
}

struct DeletePrefetchScheduleInputBody: Swift.Equatable {
}

extension DeletePrefetchScheduleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePrefetchScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePrefetchScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePrefetchScheduleOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePrefetchScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePrefetchScheduleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteProgramInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        guard let programName = programName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
    }
}

public struct DeleteProgramInput: Swift.Equatable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name of the program.
    /// This member is required.
    public var programName: Swift.String?

    public init (
        channelName: Swift.String? = nil,
        programName: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.programName = programName
    }
}

struct DeleteProgramInputBody: Swift.Equatable {
}

extension DeleteProgramInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProgramOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProgramOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProgramOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProgramOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProgramOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSourceLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
    }
}

public struct DeleteSourceLocationInput: Swift.Equatable {
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        sourceLocationName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
    }
}

struct DeleteSourceLocationInputBody: Swift.Equatable {
}

extension DeleteSourceLocationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSourceLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSourceLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSourceLocationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSourceLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSourceLocationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVodSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        guard let vodSourceName = vodSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
    }
}

public struct DeleteVodSourceInput: Swift.Equatable {
    /// The name of the source location associated with this VOD Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The name of the VOD source.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init (
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct DeleteVodSourceInputBody: Swift.Equatable {
}

extension DeleteVodSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVodSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVodSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVodSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVodSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVodSourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct DescribeChannelInput: Swift.Equatable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct DescribeChannelInputBody: Swift.Equatable {
}

extension DescribeChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelName = output.channelName
            self.channelState = output.channelState
            self.creationTime = output.creationTime
            self.fillerSlate = output.fillerSlate
            self.lastModifiedTime = output.lastModifiedTime
            self.outputs = output.outputs
            self.playbackMode = output.playbackMode
            self.tags = output.tags
            self.tier = output.tier
        } else {
            self.arn = nil
            self.channelName = nil
            self.channelState = nil
            self.creationTime = nil
            self.fillerSlate = nil
            self.lastModifiedTime = nil
            self.outputs = nil
            self.playbackMode = nil
            self.tags = nil
            self.tier = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var arn: Swift.String?
    /// The name of the channel.
    public var channelName: Swift.String?
    /// Indicates whether the channel is in a running state or not.
    public var channelState: MediaTailorClientTypes.ChannelState?
    /// The timestamp of when the channel was created.
    public var creationTime: ClientRuntime.Date?
    /// Contains information about the slate used to fill gaps between programs in the schedule.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The timestamp of when the channel was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The channel's output properties.
    public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    /// The channel's playback mode.
    public var playbackMode: Swift.String?
    /// The tags assigned to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The channel's tier.
    public var tier: Swift.String?

    public init (
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelState: MediaTailorClientTypes.ChannelState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
        playbackMode: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tier: Swift.String? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.fillerSlate = fillerSlate
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
        self.tier = tier
    }
}

struct DescribeChannelOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let channelName: Swift.String?
    let channelState: MediaTailorClientTypes.ChannelState?
    let creationTime: ClientRuntime.Date?
    let fillerSlate: MediaTailorClientTypes.SlateSource?
    let lastModifiedTime: ClientRuntime.Date?
    let outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    let playbackMode: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let tier: Swift.String?
}

extension DescribeChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case fillerSlate = "FillerSlate"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
        case tier = "Tier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ChannelState.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension DescribeLiveSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        guard let liveSourceName = liveSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSource/\(liveSourceName.urlPercentEncoding())"
    }
}

public struct DescribeLiveSourceInput: Swift.Equatable {
    /// The name of the live source.
    /// This member is required.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with this Live Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
    }
}

struct DescribeLiveSourceInputBody: Swift.Equatable {
}

extension DescribeLiveSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLiveSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLiveSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLiveSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLiveSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLiveSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.liveSourceName = output.liveSourceName
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.liveSourceName = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct DescribeLiveSourceOutputResponse: Swift.Equatable {
    /// The ARN of the live source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the live source was created.
    public var creationTime: ClientRuntime.Date?
    /// The HTTP package configurations.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The timestamp that indicates when the live source was modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the live source.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with the live source.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct DescribeLiveSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    let lastModifiedTime: ClientRuntime.Date?
    let liveSourceName: Swift.String?
    let sourceLocationName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeLiveSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case liveSourceName = "LiveSourceName"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let liveSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .liveSourceName)
        liveSourceName = liveSourceNameDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeProgramInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        guard let programName = programName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/program/\(programName.urlPercentEncoding())"
    }
}

public struct DescribeProgramInput: Swift.Equatable {
    /// The name of the channel associated with this Program.
    /// This member is required.
    public var channelName: Swift.String?
    /// The name of the program.
    /// This member is required.
    public var programName: Swift.String?

    public init (
        channelName: Swift.String? = nil,
        programName: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.programName = programName
    }
}

struct DescribeProgramInputBody: Swift.Equatable {
}

extension DescribeProgramInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProgramOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProgramOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProgramOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProgramOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProgramOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adBreaks = output.adBreaks
            self.arn = output.arn
            self.channelName = output.channelName
            self.creationTime = output.creationTime
            self.liveSourceName = output.liveSourceName
            self.programName = output.programName
            self.scheduledStartTime = output.scheduledStartTime
            self.sourceLocationName = output.sourceLocationName
            self.vodSourceName = output.vodSourceName
        } else {
            self.adBreaks = nil
            self.arn = nil
            self.channelName = nil
            self.creationTime = nil
            self.liveSourceName = nil
            self.programName = nil
            self.scheduledStartTime = nil
            self.sourceLocationName = nil
            self.vodSourceName = nil
        }
    }
}

public struct DescribeProgramOutputResponse: Swift.Equatable {
    /// The ad break configuration settings.
    public var adBreaks: [MediaTailorClientTypes.AdBreak]?
    /// The ARN of the program.
    public var arn: Swift.String?
    /// The name of the channel that the program belongs to.
    public var channelName: Swift.String?
    /// The timestamp of when the program was created.
    public var creationTime: ClientRuntime.Date?
    /// The name of the LiveSource for this Program.
    public var liveSourceName: Swift.String?
    /// The name of the program.
    public var programName: Swift.String?
    /// The date and time that the program is scheduled to start in ISO 8601 format and Coordinated Universal Time (UTC). For example, the value 2021-03-27T17:48:16.751Z represents March 27, 2021 at 17:48:16.751 UTC.
    public var scheduledStartTime: ClientRuntime.Date?
    /// The source location name.
    public var sourceLocationName: Swift.String?
    /// The name that's used to refer to a VOD source.
    public var vodSourceName: Swift.String?

    public init (
        adBreaks: [MediaTailorClientTypes.AdBreak]? = nil,
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        liveSourceName: Swift.String? = nil,
        programName: Swift.String? = nil,
        scheduledStartTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.adBreaks = adBreaks
        self.arn = arn
        self.channelName = channelName
        self.creationTime = creationTime
        self.liveSourceName = liveSourceName
        self.programName = programName
        self.scheduledStartTime = scheduledStartTime
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct DescribeProgramOutputResponseBody: Swift.Equatable {
    let adBreaks: [MediaTailorClientTypes.AdBreak]?
    let arn: Swift.String?
    let channelName: Swift.String?
    let creationTime: ClientRuntime.Date?
    let liveSourceName: Swift.String?
    let programName: Swift.String?
    let scheduledStartTime: ClientRuntime.Date?
    let sourceLocationName: Swift.String?
    let vodSourceName: Swift.String?
}

extension DescribeProgramOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adBreaks = "AdBreaks"
        case arn = "Arn"
        case channelName = "ChannelName"
        case creationTime = "CreationTime"
        case liveSourceName = "LiveSourceName"
        case programName = "ProgramName"
        case scheduledStartTime = "ScheduledStartTime"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adBreaksContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.AdBreak?].self, forKey: .adBreaks)
        var adBreaksDecoded0:[MediaTailorClientTypes.AdBreak]? = nil
        if let adBreaksContainer = adBreaksContainer {
            adBreaksDecoded0 = [MediaTailorClientTypes.AdBreak]()
            for structure0 in adBreaksContainer {
                if let structure0 = structure0 {
                    adBreaksDecoded0?.append(structure0)
                }
            }
        }
        adBreaks = adBreaksDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let liveSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .liveSourceName)
        liveSourceName = liveSourceNameDecoded
        let programNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .programName)
        programName = programNameDecoded
        let scheduledStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduledStartTime)
        scheduledStartTime = scheduledStartTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension DescribeSourceLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
    }
}

public struct DescribeSourceLocationInput: Swift.Equatable {
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        sourceLocationName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
    }
}

struct DescribeSourceLocationInputBody: Swift.Equatable {
}

extension DescribeSourceLocationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSourceLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSourceLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSourceLocationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSourceLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessConfiguration = output.accessConfiguration
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.defaultSegmentDeliveryConfiguration = output.defaultSegmentDeliveryConfiguration
            self.httpConfiguration = output.httpConfiguration
            self.lastModifiedTime = output.lastModifiedTime
            self.segmentDeliveryConfigurations = output.segmentDeliveryConfigurations
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.accessConfiguration = nil
            self.arn = nil
            self.creationTime = nil
            self.defaultSegmentDeliveryConfiguration = nil
            self.httpConfiguration = nil
            self.lastModifiedTime = nil
            self.segmentDeliveryConfigurations = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct DescribeSourceLocationOutputResponse: Swift.Equatable {
    /// The access configuration for the source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The ARN of the source location.
    public var arn: Swift.String?
    /// The timestamp that indicates when the source location was created.
    public var creationTime: ClientRuntime.Date?
    /// The default segment delivery configuration settings.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP package configuration settings for the source location.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The timestamp that indicates when the source location was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// A list of the segment delivery configurations associated with this resource.
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name of the source location.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct DescribeSourceLocationOutputResponseBody: Swift.Equatable {
    let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    let lastModifiedTime: ClientRuntime.Date?
    let segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    let sourceLocationName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeSourceLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let segmentDeliveryConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.SegmentDeliveryConfiguration?].self, forKey: .segmentDeliveryConfigurations)
        var segmentDeliveryConfigurationsDecoded0:[MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil
        if let segmentDeliveryConfigurationsContainer = segmentDeliveryConfigurationsContainer {
            segmentDeliveryConfigurationsDecoded0 = [MediaTailorClientTypes.SegmentDeliveryConfiguration]()
            for structure0 in segmentDeliveryConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentDeliveryConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentDeliveryConfigurations = segmentDeliveryConfigurationsDecoded0
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeVodSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        guard let vodSourceName = vodSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
    }
}

public struct DescribeVodSourceInput: Swift.Equatable {
    /// The name of the source location associated with this VOD Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The name of the VOD Source.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init (
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct DescribeVodSourceInputBody: Swift.Equatable {
}

extension DescribeVodSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVodSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVodSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVodSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVodSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeVodSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
            self.vodSourceName = output.vodSourceName
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
            self.vodSourceName = nil
        }
    }
}

public struct DescribeVodSourceOutputResponse: Swift.Equatable {
    /// The ARN of the VOD source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the VOD source was created.
    public var creationTime: ClientRuntime.Date?
    /// The HTTP package configurations.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The last modified time of the VOD source.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the source location associated with the VOD source.
    public var sourceLocationName: Swift.String?
    /// The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The name of the VOD source.
    public var vodSourceName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct DescribeVodSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    let lastModifiedTime: ClientRuntime.Date?
    let sourceLocationName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let vodSourceName: Swift.String?
}

extension DescribeVodSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension GetChannelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

public struct GetChannelPolicyInput: Swift.Equatable {
    /// The name of the channel associated with this Channel Policy.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct GetChannelPolicyInputBody: Swift.Equatable {
}

extension GetChannelPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelPolicyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetChannelPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetChannelPolicyOutputResponse: Swift.Equatable {
    /// The IAM policy for the channel. IAM policies are used to control access to your channel.
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetChannelPolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetChannelPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetChannelScheduleInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let durationMinutes = durationMinutes {
                let durationMinutesQueryItem = ClientRuntime.URLQueryItem(name: "durationMinutes".urlPercentEncoding(), value: Swift.String(durationMinutes).urlPercentEncoding())
                items.append(durationMinutesQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetChannelScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/schedule"
    }
}

public struct GetChannelScheduleInput: Swift.Equatable {
    /// The name of the channel associated with this Channel Schedule.
    /// This member is required.
    public var channelName: Swift.String?
    /// The duration in minutes of the channel schedule.
    public var durationMinutes: Swift.String?
    /// The maximum number of channel schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults channel schedules, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// (Optional) If the playback configuration has more than MaxResults channel schedules, use NextToken to get the second and subsequent pages of results. For the first GetChannelScheduleRequest request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request. If the previous response didn't include a NextToken element, there are no more channel schedules to get.
    public var nextToken: Swift.String?

    public init (
        channelName: Swift.String? = nil,
        durationMinutes: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.durationMinutes = durationMinutes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetChannelScheduleInputBody: Swift.Equatable {
}

extension GetChannelScheduleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelScheduleOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetChannelScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct GetChannelScheduleOutputResponse: Swift.Equatable {
    /// A list of schedule entries for the channel.
    public var items: [MediaTailorClientTypes.ScheduleEntry]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.ScheduleEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct GetChannelScheduleOutputResponseBody: Swift.Equatable {
    let items: [MediaTailorClientTypes.ScheduleEntry]?
    let nextToken: Swift.String?
}

extension GetChannelScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ScheduleEntry?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.ScheduleEntry]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.ScheduleEntry]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetPlaybackConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/playbackConfiguration/\(name.urlPercentEncoding())"
    }
}

public struct GetPlaybackConfigurationInput: Swift.Equatable {
    /// The identifier for the playback configuration.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetPlaybackConfigurationInputBody: Swift.Equatable {
}

extension GetPlaybackConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPlaybackConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPlaybackConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPlaybackConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlaybackConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPlaybackConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adDecisionServerUrl = output.adDecisionServerUrl
            self.availSuppression = output.availSuppression
            self.bumper = output.bumper
            self.cdnConfiguration = output.cdnConfiguration
            self.configurationAliases = output.configurationAliases
            self.dashConfiguration = output.dashConfiguration
            self.hlsConfiguration = output.hlsConfiguration
            self.livePreRollConfiguration = output.livePreRollConfiguration
            self.logConfiguration = output.logConfiguration
            self.manifestProcessingRules = output.manifestProcessingRules
            self.name = output.name
            self.personalizationThresholdSeconds = output.personalizationThresholdSeconds
            self.playbackConfigurationArn = output.playbackConfigurationArn
            self.playbackEndpointPrefix = output.playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = output.sessionInitializationEndpointPrefix
            self.slateAdUrl = output.slateAdUrl
            self.tags = output.tags
            self.transcodeProfileName = output.transcodeProfileName
            self.videoContentSourceUrl = output.videoContentSourceUrl
        } else {
            self.adDecisionServerUrl = nil
            self.availSuppression = nil
            self.bumper = nil
            self.cdnConfiguration = nil
            self.configurationAliases = nil
            self.dashConfiguration = nil
            self.hlsConfiguration = nil
            self.livePreRollConfiguration = nil
            self.logConfiguration = nil
            self.manifestProcessingRules = nil
            self.name = nil
            self.personalizationThresholdSeconds = nil
            self.playbackConfigurationArn = nil
            self.playbackEndpointPrefix = nil
            self.sessionInitializationEndpointPrefix = nil
            self.slateAdUrl = nil
            self.tags = nil
            self.transcodeProfileName = nil
            self.videoContentSourceUrl = nil
        }
    }
}

public struct GetPlaybackConfigurationOutputResponse: Swift.Equatable {
    /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
    public var adDecisionServerUrl: Swift.String?
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var availSuppression: MediaTailorClientTypes.AvailSuppression?
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
    public var bumper: MediaTailorClientTypes.Bumper?
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see [Domain Variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html).
    public var configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    /// The configuration for DASH content.
    public var dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    /// The configuration for HLS content.
    public var hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    /// The configuration for pre-roll ad insertion.
    public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    /// The Amazon CloudWatch log settings for a playback configuration.
    public var logConfiguration: MediaTailorClientTypes.LogConfiguration?
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    /// The identifier for the playback configuration.
    public var name: Swift.String?
    /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see [Ad Behavior in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var personalizationThresholdSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) for the playback configuration.
    public var playbackConfigurationArn: Swift.String?
    /// The URL that the player accesses to get a manifest from AWS Elemental MediaTailor. This session will use server-side reporting.
    public var playbackEndpointPrefix: Swift.String?
    /// The URL that the player uses to initialize a session that uses client-side reporting.
    public var sessionInitializationEndpointPrefix: Swift.String?
    /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    public var slateAdUrl: Swift.String?
    /// The tags assigned to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    public var transcodeProfileName: Swift.String?
    /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    public var videoContentSourceUrl: Swift.String?

    public init (
        adDecisionServerUrl: Swift.String? = nil,
        availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
        bumper: MediaTailorClientTypes.Bumper? = nil,
        cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
        configurationAliases: [Swift.String:[Swift.String:Swift.String]]? = nil,
        dashConfiguration: MediaTailorClientTypes.DashConfiguration? = nil,
        hlsConfiguration: MediaTailorClientTypes.HlsConfiguration? = nil,
        livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
        logConfiguration: MediaTailorClientTypes.LogConfiguration? = nil,
        manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
        name: Swift.String? = nil,
        personalizationThresholdSeconds: Swift.Int? = nil,
        playbackConfigurationArn: Swift.String? = nil,
        playbackEndpointPrefix: Swift.String? = nil,
        sessionInitializationEndpointPrefix: Swift.String? = nil,
        slateAdUrl: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        transcodeProfileName: Swift.String? = nil,
        videoContentSourceUrl: Swift.String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.hlsConfiguration = hlsConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.logConfiguration = logConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.playbackConfigurationArn = playbackConfigurationArn
        self.playbackEndpointPrefix = playbackEndpointPrefix
        self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

struct GetPlaybackConfigurationOutputResponseBody: Swift.Equatable {
    let adDecisionServerUrl: Swift.String?
    let availSuppression: MediaTailorClientTypes.AvailSuppression?
    let bumper: MediaTailorClientTypes.Bumper?
    let cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    let configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    let dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    let hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    let livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    let logConfiguration: MediaTailorClientTypes.LogConfiguration?
    let manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    let name: Swift.String?
    let personalizationThresholdSeconds: Swift.Int?
    let playbackConfigurationArn: Swift.String?
    let playbackEndpointPrefix: Swift.String?
    let sessionInitializationEndpointPrefix: Swift.String?
    let slateAdUrl: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let transcodeProfileName: Swift.String?
    let videoContentSourceUrl: Swift.String?
}

extension GetPlaybackConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case hlsConfiguration = "HlsConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case logConfiguration = "LogConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case playbackConfigurationArn = "PlaybackConfigurationArn"
        case playbackEndpointPrefix = "PlaybackEndpointPrefix"
        case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [Swift.String: Swift.String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashConfiguration.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let hlsConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsConfiguration.self, forKey: .hlsConfiguration)
        hlsConfiguration = hlsConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let playbackConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationArn)
        playbackConfigurationArn = playbackConfigurationArnDecoded
        let playbackEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackEndpointPrefix)
        playbackEndpointPrefix = playbackEndpointPrefixDecoded
        let sessionInitializationEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionInitializationEndpointPrefix)
        sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefixDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension GetPrefetchScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let playbackConfigurationName = playbackConfigurationName else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/prefetchSchedule/\(playbackConfigurationName.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

public struct GetPrefetchScheduleInput: Swift.Equatable {
    /// The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Returns information about the prefetch schedule for a specific playback configuration. If you call GetPrefetchSchedule on an expired prefetch schedule, MediaTailor returns an HTTP 404 status code.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?

    public init (
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil
    )
    {
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
    }
}

struct GetPrefetchScheduleInputBody: Swift.Equatable {
}

extension GetPrefetchScheduleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPrefetchScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPrefetchScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPrefetchScheduleOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPrefetchScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPrefetchScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.consumption = output.consumption
            self.name = output.name
            self.playbackConfigurationName = output.playbackConfigurationName
            self.retrieval = output.retrieval
            self.streamId = output.streamId
        } else {
            self.arn = nil
            self.consumption = nil
            self.name = nil
            self.playbackConfigurationName = nil
            self.retrieval = nil
            self.streamId = nil
        }
    }
}

public struct GetPrefetchScheduleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the prefetch schedule.
    public var arn: Swift.String?
    /// Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a consumption window. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.
    public var consumption: MediaTailorClientTypes.PrefetchConsumption?
    /// The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
    public var name: Swift.String?
    /// The name of the playback configuration to create the prefetch schedule for.
    public var playbackConfigurationName: Swift.String?
    /// A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).
    public var retrieval: MediaTailorClientTypes.PrefetchRetrieval?
    /// An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.
    public var streamId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        consumption: MediaTailorClientTypes.PrefetchConsumption? = nil,
        name: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil,
        retrieval: MediaTailorClientTypes.PrefetchRetrieval? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.consumption = consumption
        self.name = name
        self.playbackConfigurationName = playbackConfigurationName
        self.retrieval = retrieval
        self.streamId = streamId
    }
}

struct GetPrefetchScheduleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let consumption: MediaTailorClientTypes.PrefetchConsumption?
    let name: Swift.String?
    let playbackConfigurationName: Swift.String?
    let retrieval: MediaTailorClientTypes.PrefetchRetrieval?
    let streamId: Swift.String?
}

extension GetPrefetchScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case consumption = "Consumption"
        case name = "Name"
        case playbackConfigurationName = "PlaybackConfigurationName"
        case retrieval = "Retrieval"
        case streamId = "StreamId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let consumptionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PrefetchConsumption.self, forKey: .consumption)
        consumption = consumptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let playbackConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationName)
        playbackConfigurationName = playbackConfigurationNameDecoded
        let retrievalDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PrefetchRetrieval.self, forKey: .retrieval)
        retrieval = retrievalDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension MediaTailorClientTypes.HlsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestEndpointPrefix = "ManifestEndpointPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestEndpointPrefix = self.manifestEndpointPrefix {
            try encodeContainer.encode(manifestEndpointPrefix, forKey: .manifestEndpointPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestEndpointPrefix)
        manifestEndpointPrefix = manifestEndpointPrefixDecoded
    }
}

extension MediaTailorClientTypes {
    /// The configuration for HLS content.
    public struct HlsConfiguration: Swift.Equatable {
        /// The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.
        public var manifestEndpointPrefix: Swift.String?

        public init (
            manifestEndpointPrefix: Swift.String? = nil
        )
        {
            self.manifestEndpointPrefix = manifestEndpointPrefix
        }
    }

}

extension MediaTailorClientTypes.HlsPlaylistSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestWindowSeconds = "ManifestWindowSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestWindowSeconds = self.manifestWindowSeconds {
            try encodeContainer.encode(manifestWindowSeconds, forKey: .manifestWindowSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manifestWindowSeconds)
        manifestWindowSeconds = manifestWindowSecondsDecoded
    }
}

extension MediaTailorClientTypes {
    /// HLS playlist configuration parameters.
    public struct HlsPlaylistSettings: Swift.Equatable {
        /// The total duration (in seconds) of each manifest. Minimum value: 30 seconds. Maximum value: 3600 seconds.
        public var manifestWindowSeconds: Swift.Int?

        public init (
            manifestWindowSeconds: Swift.Int? = nil
        )
        {
            self.manifestWindowSeconds = manifestWindowSeconds
        }
    }

}

extension MediaTailorClientTypes.HttpConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseUrl = "BaseUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseUrl = self.baseUrl {
            try encodeContainer.encode(baseUrl, forKey: .baseUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseUrl)
        baseUrl = baseUrlDecoded
    }
}

extension MediaTailorClientTypes {
    /// The HTTP configuration for the source location.
    public struct HttpConfiguration: Swift.Equatable {
        /// The base URL for the source location host server. This string must include the protocol, such as https://.
        /// This member is required.
        public var baseUrl: Swift.String?

        public init (
            baseUrl: Swift.String? = nil
        )
        {
            self.baseUrl = baseUrl
        }
    }

}

extension MediaTailorClientTypes.HttpPackageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case sourceGroup = "SourceGroup"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let sourceGroup = self.sourceGroup {
            try encodeContainer.encode(sourceGroup, forKey: .sourceGroup)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let sourceGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGroup)
        sourceGroup = sourceGroupDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
    }
}

extension MediaTailorClientTypes {
    /// The HTTP package configuration properties for the requested VOD source.
    public struct HttpPackageConfiguration: Swift.Equatable {
        /// The relative path to the URL for this VOD source. This is combined with SourceLocation::HttpConfiguration::BaseUrl to form a valid URL.
        /// This member is required.
        public var path: Swift.String?
        /// The name of the source group. This has to match one of the Channel::Outputs::SourceGroup.
        /// This member is required.
        public var sourceGroup: Swift.String?
        /// The streaming protocol for this package configuration. Supported values are HLS and DASH.
        /// This member is required.
        public var type: MediaTailorClientTypes.ModelType?

        public init (
            path: Swift.String? = nil,
            sourceGroup: Swift.String? = nil,
            type: MediaTailorClientTypes.ModelType? = nil
        )
        {
            self.path = path
            self.sourceGroup = sourceGroup
            self.type = type
        }
    }

}

extension ListAlertsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAlertsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/alerts"
    }
}

public struct ListAlertsInput: Swift.Equatable {
    /// The maximum number of alerts that you want MediaTailor to return in response to the current request. If there are more than MaxResults alerts, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListAlertsInputBody: Swift.Equatable {
}

extension ListAlertsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAlertsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlertsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAlertsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlertsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAlertsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlertsOutputResponse: Swift.Equatable {
    /// A list of alerts that are associated with this resource.
    public var items: [MediaTailorClientTypes.Alert]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.Alert]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAlertsOutputResponseBody: Swift.Equatable {
    let items: [MediaTailorClientTypes.Alert]?
    let nextToken: Swift.String?
}

extension ListAlertsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.Alert?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.Alert]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.Alert]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// The maximum number of channels that you want MediaTailor to return in response to the current request. If there are more than MaxResults channels, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// A list of channels that are associated with this account.
    public var items: [MediaTailorClientTypes.Channel]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.Channel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    let items: [MediaTailorClientTypes.Channel]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.Channel?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.Channel]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.Channel]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLiveSourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLiveSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSources"
    }
}

public struct ListLiveSourcesInput: Swift.Equatable {
    /// The maximum number of live sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults live sources, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?
    /// The name of the source location associated with this Live Sources list.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceLocationName = sourceLocationName
    }
}

struct ListLiveSourcesInputBody: Swift.Equatable {
}

extension ListLiveSourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLiveSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLiveSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLiveSourcesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLiveSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLiveSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListLiveSourcesOutputResponse: Swift.Equatable {
    /// Lists the live sources.
    public var items: [MediaTailorClientTypes.LiveSource]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.LiveSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListLiveSourcesOutputResponseBody: Swift.Equatable {
    let items: [MediaTailorClientTypes.LiveSource]?
    let nextToken: Swift.String?
}

extension ListLiveSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.LiveSource?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.LiveSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.LiveSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPlaybackConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPlaybackConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/playbackConfigurations"
    }
}

public struct ListPlaybackConfigurationsInput: Swift.Equatable {
    /// The maximum number of playback configurations that you want MediaTailor to return in response to the current request. If there are more than MaxResults playback configurations, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaybackConfigurationsInputBody: Swift.Equatable {
}

extension ListPlaybackConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPlaybackConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlaybackConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPlaybackConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlaybackConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPlaybackConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaybackConfigurationsOutputResponse: Swift.Equatable {
    /// Array of playback configurations. This might be all the available configurations or a subset, depending on the settings that you provide and the total number of configurations stored.
    public var items: [MediaTailorClientTypes.PlaybackConfiguration]?
    /// Pagination token returned by the GET list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.PlaybackConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListPlaybackConfigurationsOutputResponseBody: Swift.Equatable {
    let items: [MediaTailorClientTypes.PlaybackConfiguration]?
    let nextToken: Swift.String?
}

extension ListPlaybackConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.PlaybackConfiguration?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.PlaybackConfiguration]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.PlaybackConfiguration]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPrefetchSchedulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamId = "StreamId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }
}

extension ListPrefetchSchedulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let playbackConfigurationName = playbackConfigurationName else {
            return nil
        }
        return "/prefetchSchedule/\(playbackConfigurationName.urlPercentEncoding())"
    }
}

public struct ListPrefetchSchedulesInput: Swift.Equatable {
    /// The maximum number of prefetch schedules that you want MediaTailor to return in response to the current request. If there are more than MaxResults prefetch schedules, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// (Optional) If the playback configuration has more than MaxResults prefetch schedules, use NextToken to get the second and subsequent pages of results. For the first ListPrefetchSchedulesRequest request, omit this value. For the second and subsequent requests, get the value of NextToken from the previous response and specify that value for NextToken in the request. If the previous response didn't include a NextToken element, there are no more prefetch schedules to get.
    public var nextToken: Swift.String?
    /// Retrieves the prefetch schedule(s) for a specific playback configuration.
    /// This member is required.
    public var playbackConfigurationName: Swift.String?
    /// An optional filtering parameter whereby MediaTailor filters the prefetch schedules to include only specific streams.
    public var streamId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        playbackConfigurationName: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.playbackConfigurationName = playbackConfigurationName
        self.streamId = streamId
    }
}

struct ListPrefetchSchedulesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let streamId: Swift.String?
}

extension ListPrefetchSchedulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamId = "StreamId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension ListPrefetchSchedulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPrefetchSchedulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPrefetchSchedulesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPrefetchSchedulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPrefetchSchedulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListPrefetchSchedulesOutputResponse: Swift.Equatable {
    /// Lists the prefetch schedules. An empty Items list doesn't mean there aren't more items to fetch, just that that page was empty.
    public var items: [MediaTailorClientTypes.PrefetchSchedule]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.PrefetchSchedule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListPrefetchSchedulesOutputResponseBody: Swift.Equatable {
    let items: [MediaTailorClientTypes.PrefetchSchedule]?
    let nextToken: Swift.String?
}

extension ListPrefetchSchedulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.PrefetchSchedule?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.PrefetchSchedule]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.PrefetchSchedule]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSourceLocationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSourceLocationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sourceLocations"
    }
}

public struct ListSourceLocationsInput: Swift.Equatable {
    /// The maximum number of source locations that you want MediaTailor to return in response to the current request. If there are more than MaxResults source locations, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSourceLocationsInputBody: Swift.Equatable {
}

extension ListSourceLocationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSourceLocationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSourceLocationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSourceLocationsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSourceLocationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSourceLocationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSourceLocationsOutputResponse: Swift.Equatable {
    /// A list of source locations.
    public var items: [MediaTailorClientTypes.SourceLocation]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.SourceLocation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSourceLocationsOutputResponseBody: Swift.Equatable {
    let items: [MediaTailorClientTypes.SourceLocation]?
    let nextToken: Swift.String?
}

extension ListSourceLocationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.SourceLocation?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.SourceLocation]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.SourceLocation]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with this resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with this resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVodSourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVodSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSources"
    }
}

public struct ListVodSourcesInput: Swift.Equatable {
    /// The maximum number of VOD sources that you want MediaTailor to return in response to the current request. If there are more than MaxResults VOD sources, use the value of NextToken in the response to get the next page of results.
    public var maxResults: Swift.Int?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?
    /// The name of the source location associated with this VOD Source list.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceLocationName = sourceLocationName
    }
}

struct ListVodSourcesInputBody: Swift.Equatable {
}

extension ListVodSourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVodSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVodSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVodSourcesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVodSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVodSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListVodSourcesOutputResponse: Swift.Equatable {
    /// Lists the VOD sources.
    public var items: [MediaTailorClientTypes.VodSource]?
    /// Pagination token returned by the list request when results exceed the maximum allowed. Use the token to fetch the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [MediaTailorClientTypes.VodSource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListVodSourcesOutputResponseBody: Swift.Equatable {
    let items: [MediaTailorClientTypes.VodSource]?
    let nextToken: Swift.String?
}

extension ListVodSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.VodSource?].self, forKey: .items)
        var itemsDecoded0:[MediaTailorClientTypes.VodSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MediaTailorClientTypes.VodSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MediaTailorClientTypes.LivePreRollConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case maxDurationSeconds = "MaxDurationSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adDecisionServerUrl = self.adDecisionServerUrl {
            try encodeContainer.encode(adDecisionServerUrl, forKey: .adDecisionServerUrl)
        }
        if let maxDurationSeconds = self.maxDurationSeconds {
            try encodeContainer.encode(maxDurationSeconds, forKey: .maxDurationSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let maxDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDurationSeconds)
        maxDurationSeconds = maxDurationSecondsDecoded
    }
}

extension MediaTailorClientTypes {
    /// The configuration for pre-roll ad insertion.
    public struct LivePreRollConfiguration: Swift.Equatable {
        /// The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
        public var adDecisionServerUrl: Swift.String?
        /// The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.
        public var maxDurationSeconds: Swift.Int?

        public init (
            adDecisionServerUrl: Swift.String? = nil,
            maxDurationSeconds: Swift.Int? = nil
        )
        {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.maxDurationSeconds = maxDurationSeconds
        }
    }

}

extension MediaTailorClientTypes.LiveSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case liveSourceName = "LiveSourceName"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfiguration0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfiguration0)
            }
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let liveSourceName = self.liveSourceName {
            try encodeContainer.encode(liveSourceName, forKey: .liveSourceName)
        }
        if let sourceLocationName = self.sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let liveSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .liveSourceName)
        liveSourceName = liveSourceNameDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaTailorClientTypes {
    /// Live source configuration parameters.
    public struct LiveSource: Swift.Equatable {
        /// The ARN for the live source.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp that indicates when the live source was created.
        public var creationTime: ClientRuntime.Date?
        /// The HTTP package configurations for the live source.
        /// This member is required.
        public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
        /// The timestamp that indicates when the live source was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name that's used to refer to a live source.
        /// This member is required.
        public var liveSourceName: Swift.String?
        /// The name of the source location.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The tags assigned to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            liveSourceName: Swift.String? = nil,
            sourceLocationName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.liveSourceName = liveSourceName
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }
    }

}

extension MediaTailorClientTypes.LogConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentEnabled = "PercentEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentEnabled = self.percentEnabled {
            try encodeContainer.encode(percentEnabled, forKey: .percentEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentEnabledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentEnabled)
        percentEnabled = percentEnabledDecoded
    }
}

extension MediaTailorClientTypes {
    /// Returns Amazon CloudWatch log settings for a playback configuration.
    public struct LogConfiguration: Swift.Equatable {
        /// The percentage of session logs that MediaTailor sends to your Cloudwatch Logs account. For example, if your playback configuration has 1000 sessions and percentEnabled is set to 60, MediaTailor sends logs for 600 of the sessions to CloudWatch Logs. MediaTailor decides at random which of the playback configuration sessions to send logs for. If you want to view logs for a specific session, you can use the [debug log mode](https://docs.aws.amazon.com/mediatailor/latest/ug/debug-log-mode.html). Valid values: 0 - 100
        /// This member is required.
        public var percentEnabled: Swift.Int?

        public init (
            percentEnabled: Swift.Int? = nil
        )
        {
            self.percentEnabled = percentEnabled
        }
    }

}

extension MediaTailorClientTypes.ManifestProcessingRules: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adMarkerPassthrough = "AdMarkerPassthrough"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkerPassthrough = self.adMarkerPassthrough {
            try encodeContainer.encode(adMarkerPassthrough, forKey: .adMarkerPassthrough)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkerPassthroughDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AdMarkerPassthrough.self, forKey: .adMarkerPassthrough)
        adMarkerPassthrough = adMarkerPassthroughDecoded
    }
}

extension MediaTailorClientTypes {
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public struct ManifestProcessingRules: Swift.Equatable {
        /// For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
        public var adMarkerPassthrough: MediaTailorClientTypes.AdMarkerPassthrough?

        public init (
            adMarkerPassthrough: MediaTailorClientTypes.AdMarkerPassthrough? = nil
        )
        {
            self.adMarkerPassthrough = adMarkerPassthrough
        }
    }

}

extension MediaTailorClientTypes {
    public enum MessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case spliceInsert
        case timeSignal
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .spliceInsert,
                .timeSignal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .spliceInsert: return "SPLICE_INSERT"
            case .timeSignal: return "TIME_SIGNAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes {
    public enum Mode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case behindLiveEdge
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .behindLiveEdge,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .behindLiveEdge: return "BEHIND_LIVE_EDGE"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes {
    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes {
    public enum OriginManifestType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiPeriod
        case singlePeriod
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginManifestType] {
            return [
                .multiPeriod,
                .singlePeriod,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiPeriod: return "MULTI_PERIOD"
            case .singlePeriod: return "SINGLE_PERIOD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginManifestType(rawValue: rawValue) ?? OriginManifestType.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.PlaybackConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case hlsConfiguration = "HlsConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case logConfiguration = "LogConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case playbackConfigurationArn = "PlaybackConfigurationArn"
        case playbackEndpointPrefix = "PlaybackEndpointPrefix"
        case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adDecisionServerUrl = self.adDecisionServerUrl {
            try encodeContainer.encode(adDecisionServerUrl, forKey: .adDecisionServerUrl)
        }
        if let availSuppression = self.availSuppression {
            try encodeContainer.encode(availSuppression, forKey: .availSuppression)
        }
        if let bumper = self.bumper {
            try encodeContainer.encode(bumper, forKey: .bumper)
        }
        if let cdnConfiguration = self.cdnConfiguration {
            try encodeContainer.encode(cdnConfiguration, forKey: .cdnConfiguration)
        }
        if let configurationAliases = configurationAliases {
            var configurationAliasesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurationAliases)
            for (dictKey0, configurationAliasesResponse0) in configurationAliases {
                var configurationAliasesResponse0Container = configurationAliasesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, __mapOf__string1) in configurationAliasesResponse0 {
                    try configurationAliasesResponse0Container.encode(__mapOf__string1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let dashConfiguration = self.dashConfiguration {
            try encodeContainer.encode(dashConfiguration, forKey: .dashConfiguration)
        }
        if let hlsConfiguration = self.hlsConfiguration {
            try encodeContainer.encode(hlsConfiguration, forKey: .hlsConfiguration)
        }
        if let livePreRollConfiguration = self.livePreRollConfiguration {
            try encodeContainer.encode(livePreRollConfiguration, forKey: .livePreRollConfiguration)
        }
        if let logConfiguration = self.logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if let manifestProcessingRules = self.manifestProcessingRules {
            try encodeContainer.encode(manifestProcessingRules, forKey: .manifestProcessingRules)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let personalizationThresholdSeconds = self.personalizationThresholdSeconds {
            try encodeContainer.encode(personalizationThresholdSeconds, forKey: .personalizationThresholdSeconds)
        }
        if let playbackConfigurationArn = self.playbackConfigurationArn {
            try encodeContainer.encode(playbackConfigurationArn, forKey: .playbackConfigurationArn)
        }
        if let playbackEndpointPrefix = self.playbackEndpointPrefix {
            try encodeContainer.encode(playbackEndpointPrefix, forKey: .playbackEndpointPrefix)
        }
        if let sessionInitializationEndpointPrefix = self.sessionInitializationEndpointPrefix {
            try encodeContainer.encode(sessionInitializationEndpointPrefix, forKey: .sessionInitializationEndpointPrefix)
        }
        if let slateAdUrl = self.slateAdUrl {
            try encodeContainer.encode(slateAdUrl, forKey: .slateAdUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let transcodeProfileName = self.transcodeProfileName {
            try encodeContainer.encode(transcodeProfileName, forKey: .transcodeProfileName)
        }
        if let videoContentSourceUrl = self.videoContentSourceUrl {
            try encodeContainer.encode(videoContentSourceUrl, forKey: .videoContentSourceUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [Swift.String: Swift.String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashConfiguration.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let hlsConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsConfiguration.self, forKey: .hlsConfiguration)
        hlsConfiguration = hlsConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let playbackConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationArn)
        playbackConfigurationArn = playbackConfigurationArnDecoded
        let playbackEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackEndpointPrefix)
        playbackEndpointPrefix = playbackEndpointPrefixDecoded
        let sessionInitializationEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionInitializationEndpointPrefix)
        sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefixDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension MediaTailorClientTypes {
    /// A playback configuration. For information about MediaTailor configurations, see [Working with configurations in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html).
    public struct PlaybackConfiguration: Swift.Equatable {
        /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
        public var adDecisionServerUrl: Swift.String?
        /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
        public var availSuppression: MediaTailorClientTypes.AvailSuppression?
        /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
        public var bumper: MediaTailorClientTypes.Bumper?
        /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
        public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
        /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see [Domain Variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html).
        public var configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
        /// The configuration for a DASH source.
        public var dashConfiguration: MediaTailorClientTypes.DashConfiguration?
        /// The configuration for HLS content.
        public var hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
        /// The configuration for pre-roll ad insertion.
        public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
        /// The Amazon CloudWatch log settings for a playback configuration.
        public var logConfiguration: MediaTailorClientTypes.LogConfiguration?
        /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
        public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
        /// The identifier for the playback configuration.
        public var name: Swift.String?
        /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see [Ad Behavior in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
        public var personalizationThresholdSeconds: Swift.Int?
        /// The Amazon Resource Name (ARN) for the playback configuration.
        public var playbackConfigurationArn: Swift.String?
        /// The URL that the player accesses to get a manifest from AWS Elemental MediaTailor.
        public var playbackEndpointPrefix: Swift.String?
        /// The URL that the player uses to initialize a session that uses client-side reporting.
        public var sessionInitializationEndpointPrefix: Swift.String?
        /// The URL for a video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID playback configurations. For VPAID, the slate is required because MediaTailor provides it in the slots designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
        public var slateAdUrl: Swift.String?
        /// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String:Swift.String]?
        /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
        public var transcodeProfileName: Swift.String?
        /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
        public var videoContentSourceUrl: Swift.String?

        public init (
            adDecisionServerUrl: Swift.String? = nil,
            availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
            bumper: MediaTailorClientTypes.Bumper? = nil,
            cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
            configurationAliases: [Swift.String:[Swift.String:Swift.String]]? = nil,
            dashConfiguration: MediaTailorClientTypes.DashConfiguration? = nil,
            hlsConfiguration: MediaTailorClientTypes.HlsConfiguration? = nil,
            livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
            logConfiguration: MediaTailorClientTypes.LogConfiguration? = nil,
            manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
            name: Swift.String? = nil,
            personalizationThresholdSeconds: Swift.Int? = nil,
            playbackConfigurationArn: Swift.String? = nil,
            playbackEndpointPrefix: Swift.String? = nil,
            sessionInitializationEndpointPrefix: Swift.String? = nil,
            slateAdUrl: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            transcodeProfileName: Swift.String? = nil,
            videoContentSourceUrl: Swift.String? = nil
        )
        {
            self.adDecisionServerUrl = adDecisionServerUrl
            self.availSuppression = availSuppression
            self.bumper = bumper
            self.cdnConfiguration = cdnConfiguration
            self.configurationAliases = configurationAliases
            self.dashConfiguration = dashConfiguration
            self.hlsConfiguration = hlsConfiguration
            self.livePreRollConfiguration = livePreRollConfiguration
            self.logConfiguration = logConfiguration
            self.manifestProcessingRules = manifestProcessingRules
            self.name = name
            self.personalizationThresholdSeconds = personalizationThresholdSeconds
            self.playbackConfigurationArn = playbackConfigurationArn
            self.playbackEndpointPrefix = playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
            self.slateAdUrl = slateAdUrl
            self.tags = tags
            self.transcodeProfileName = transcodeProfileName
            self.videoContentSourceUrl = videoContentSourceUrl
        }
    }

}

extension MediaTailorClientTypes {
    public enum PlaybackMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linear
        case loop
        case sdkUnknown(Swift.String)

        public static var allCases: [PlaybackMode] {
            return [
                .linear,
                .loop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linear: return "LINEAR"
            case .loop: return "LOOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlaybackMode(rawValue: rawValue) ?? PlaybackMode.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.PrefetchConsumption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availMatchingCriteria = "AvailMatchingCriteria"
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availMatchingCriteria = availMatchingCriteria {
            var availMatchingCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availMatchingCriteria)
            for availmatchingcriteria0 in availMatchingCriteria {
                try availMatchingCriteriaContainer.encode(availmatchingcriteria0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availMatchingCriteriaContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.AvailMatchingCriteria?].self, forKey: .availMatchingCriteria)
        var availMatchingCriteriaDecoded0:[MediaTailorClientTypes.AvailMatchingCriteria]? = nil
        if let availMatchingCriteriaContainer = availMatchingCriteriaContainer {
            availMatchingCriteriaDecoded0 = [MediaTailorClientTypes.AvailMatchingCriteria]()
            for structure0 in availMatchingCriteriaContainer {
                if let structure0 = structure0 {
                    availMatchingCriteriaDecoded0?.append(structure0)
                }
            }
        }
        availMatchingCriteria = availMatchingCriteriaDecoded0
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension MediaTailorClientTypes {
    /// A complex type that contains settings that determine how and when that MediaTailor places prefetched ads into upcoming ad breaks.
    public struct PrefetchConsumption: Swift.Equatable {
        /// If you only want MediaTailor to insert prefetched ads into avails (ad breaks) that match specific dynamic variables, such as scte.event_id, set the avail matching criteria.
        public var availMatchingCriteria: [MediaTailorClientTypes.AvailMatchingCriteria]?
        /// The time when MediaTailor no longer considers the prefetched ads for use in an ad break. MediaTailor automatically deletes prefetch schedules no less than seven days after the end time. If you'd like to manually delete the prefetch schedule, you can call DeletePrefetchSchedule.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The time when prefetched ads are considered for use in an ad break. If you don't specify StartTime, the prefetched ads are available after MediaTailor retrives them from the ad decision server.
        public var startTime: ClientRuntime.Date?

        public init (
            availMatchingCriteria: [MediaTailorClientTypes.AvailMatchingCriteria]? = nil,
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.availMatchingCriteria = availMatchingCriteria
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension MediaTailorClientTypes.PrefetchRetrieval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dynamicVariables = "DynamicVariables"
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dynamicVariables = dynamicVariables {
            var dynamicVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dynamicVariables)
            for (dictKey0, __mapOf__string0) in dynamicVariables {
                try dynamicVariablesContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dynamicVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dynamicVariables)
        var dynamicVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let dynamicVariablesContainer = dynamicVariablesContainer {
            dynamicVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in dynamicVariablesContainer {
                if let __string0 = __string0 {
                    dynamicVariablesDecoded0?[key0] = __string0
                }
            }
        }
        dynamicVariables = dynamicVariablesDecoded0
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension MediaTailorClientTypes {
    /// A complex type that contains settings governing when MediaTailor prefetches ads, and which dynamic variables that MediaTailor includes in the request to the ad decision server.
    public struct PrefetchRetrieval: Swift.Equatable {
        /// The dynamic variables to use for substitution during prefetch requests to the ad decision server (ADS). You initially configure [dynamic variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables.html) for the ADS URL when you set up your playback configuration. When you specify DynamicVariables for prefetch retrieval, MediaTailor includes the dynamic variables in the request to the ADS.
        public var dynamicVariables: [Swift.String:Swift.String]?
        /// The time when prefetch retrieval ends for the ad break. Prefetching will be attempted for manifest requests that occur at or before this time.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The time when prefetch retrievals can start for this break. Ad prefetching will be attempted for manifest requests that occur at or after this time. Defaults to the current time. If not specified, the prefetch retrieval starts as soon as possible.
        public var startTime: ClientRuntime.Date?

        public init (
            dynamicVariables: [Swift.String:Swift.String]? = nil,
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.dynamicVariables = dynamicVariables
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension MediaTailorClientTypes.PrefetchSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case consumption = "Consumption"
        case name = "Name"
        case playbackConfigurationName = "PlaybackConfigurationName"
        case retrieval = "Retrieval"
        case streamId = "StreamId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let consumption = self.consumption {
            try encodeContainer.encode(consumption, forKey: .consumption)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let playbackConfigurationName = self.playbackConfigurationName {
            try encodeContainer.encode(playbackConfigurationName, forKey: .playbackConfigurationName)
        }
        if let retrieval = self.retrieval {
            try encodeContainer.encode(retrieval, forKey: .retrieval)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let consumptionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PrefetchConsumption.self, forKey: .consumption)
        consumption = consumptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let playbackConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationName)
        playbackConfigurationName = playbackConfigurationNameDecoded
        let retrievalDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.PrefetchRetrieval.self, forKey: .retrieval)
        retrieval = retrievalDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension MediaTailorClientTypes {
    /// A prefetch schedule allows you to tell MediaTailor to fetch and prepare certain ads before an ad break happens. For more information about ad prefetching, see [Using ad prefetching](https://docs.aws.amazon.com/mediatailor/latest/ug/prefetching-ads.html) in the MediaTailor User Guide.
    public struct PrefetchSchedule: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the prefetch schedule.
        /// This member is required.
        public var arn: Swift.String?
        /// Consumption settings determine how, and when, MediaTailor places the prefetched ads into ad breaks. Ad consumption occurs within a span of time that you define, called a consumption window. You can designate which ad breaks that MediaTailor fills with prefetch ads by setting avail matching criteria.
        /// This member is required.
        public var consumption: MediaTailorClientTypes.PrefetchConsumption?
        /// The name of the prefetch schedule. The name must be unique among all prefetch schedules that are associated with the specified playback configuration.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the playback configuration to create the prefetch schedule for.
        /// This member is required.
        public var playbackConfigurationName: Swift.String?
        /// A complex type that contains settings for prefetch retrieval from the ad decision server (ADS).
        /// This member is required.
        public var retrieval: MediaTailorClientTypes.PrefetchRetrieval?
        /// An optional stream identifier that you can specify in order to prefetch for multiple streams that use the same playback configuration.
        public var streamId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            consumption: MediaTailorClientTypes.PrefetchConsumption? = nil,
            name: Swift.String? = nil,
            playbackConfigurationName: Swift.String? = nil,
            retrieval: MediaTailorClientTypes.PrefetchRetrieval? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.consumption = consumption
            self.name = name
            self.playbackConfigurationName = playbackConfigurationName
            self.retrieval = retrieval
            self.streamId = streamId
        }
    }

}

extension PutChannelPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutChannelPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/policy"
    }
}

public struct PutChannelPolicyInput: Swift.Equatable {
    /// The channel name associated with this Channel Policy.
    /// This member is required.
    public var channelName: Swift.String?
    /// Adds an IAM role that determines the permissions of your channel.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        channelName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.channelName = channelName
        self.policy = policy
    }
}

struct PutChannelPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutChannelPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutChannelPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutChannelPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutChannelPolicyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutChannelPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutChannelPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutPlaybackConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adDecisionServerUrl = self.adDecisionServerUrl {
            try encodeContainer.encode(adDecisionServerUrl, forKey: .adDecisionServerUrl)
        }
        if let availSuppression = self.availSuppression {
            try encodeContainer.encode(availSuppression, forKey: .availSuppression)
        }
        if let bumper = self.bumper {
            try encodeContainer.encode(bumper, forKey: .bumper)
        }
        if let cdnConfiguration = self.cdnConfiguration {
            try encodeContainer.encode(cdnConfiguration, forKey: .cdnConfiguration)
        }
        if let configurationAliases = configurationAliases {
            var configurationAliasesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurationAliases)
            for (dictKey0, configurationAliasesRequest0) in configurationAliases {
                var configurationAliasesRequest0Container = configurationAliasesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, __mapOf__string1) in configurationAliasesRequest0 {
                    try configurationAliasesRequest0Container.encode(__mapOf__string1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let dashConfiguration = self.dashConfiguration {
            try encodeContainer.encode(dashConfiguration, forKey: .dashConfiguration)
        }
        if let livePreRollConfiguration = self.livePreRollConfiguration {
            try encodeContainer.encode(livePreRollConfiguration, forKey: .livePreRollConfiguration)
        }
        if let manifestProcessingRules = self.manifestProcessingRules {
            try encodeContainer.encode(manifestProcessingRules, forKey: .manifestProcessingRules)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let personalizationThresholdSeconds = self.personalizationThresholdSeconds {
            try encodeContainer.encode(personalizationThresholdSeconds, forKey: .personalizationThresholdSeconds)
        }
        if let slateAdUrl = self.slateAdUrl {
            try encodeContainer.encode(slateAdUrl, forKey: .slateAdUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let transcodeProfileName = self.transcodeProfileName {
            try encodeContainer.encode(transcodeProfileName, forKey: .transcodeProfileName)
        }
        if let videoContentSourceUrl = self.videoContentSourceUrl {
            try encodeContainer.encode(videoContentSourceUrl, forKey: .videoContentSourceUrl)
        }
    }
}

extension PutPlaybackConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/playbackConfiguration"
    }
}

public struct PutPlaybackConfigurationInput: Swift.Equatable {
    /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
    public var adDecisionServerUrl: Swift.String?
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var availSuppression: MediaTailorClientTypes.AvailSuppression?
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
    public var bumper: MediaTailorClientTypes.Bumper?
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see [Domain Variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html).
    public var configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    /// The configuration for DASH content.
    public var dashConfiguration: MediaTailorClientTypes.DashConfigurationForPut?
    /// The configuration for pre-roll ad insertion.
    public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    /// The identifier for the playback configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see [Ad Behavior in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var personalizationThresholdSeconds: Swift.Int?
    /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    public var slateAdUrl: Swift.String?
    /// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    public var transcodeProfileName: Swift.String?
    /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    public var videoContentSourceUrl: Swift.String?

    public init (
        adDecisionServerUrl: Swift.String? = nil,
        availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
        bumper: MediaTailorClientTypes.Bumper? = nil,
        cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
        configurationAliases: [Swift.String:[Swift.String:Swift.String]]? = nil,
        dashConfiguration: MediaTailorClientTypes.DashConfigurationForPut? = nil,
        livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
        manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
        name: Swift.String? = nil,
        personalizationThresholdSeconds: Swift.Int? = nil,
        slateAdUrl: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        transcodeProfileName: Swift.String? = nil,
        videoContentSourceUrl: Swift.String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

struct PutPlaybackConfigurationInputBody: Swift.Equatable {
    let adDecisionServerUrl: Swift.String?
    let availSuppression: MediaTailorClientTypes.AvailSuppression?
    let bumper: MediaTailorClientTypes.Bumper?
    let cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    let configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    let dashConfiguration: MediaTailorClientTypes.DashConfigurationForPut?
    let livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    let manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    let name: Swift.String?
    let personalizationThresholdSeconds: Swift.Int?
    let slateAdUrl: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let transcodeProfileName: Swift.String?
    let videoContentSourceUrl: Swift.String?
}

extension PutPlaybackConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [Swift.String: Swift.String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashConfigurationForPut.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension PutPlaybackConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPlaybackConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutPlaybackConfigurationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPlaybackConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutPlaybackConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adDecisionServerUrl = output.adDecisionServerUrl
            self.availSuppression = output.availSuppression
            self.bumper = output.bumper
            self.cdnConfiguration = output.cdnConfiguration
            self.configurationAliases = output.configurationAliases
            self.dashConfiguration = output.dashConfiguration
            self.hlsConfiguration = output.hlsConfiguration
            self.livePreRollConfiguration = output.livePreRollConfiguration
            self.logConfiguration = output.logConfiguration
            self.manifestProcessingRules = output.manifestProcessingRules
            self.name = output.name
            self.personalizationThresholdSeconds = output.personalizationThresholdSeconds
            self.playbackConfigurationArn = output.playbackConfigurationArn
            self.playbackEndpointPrefix = output.playbackEndpointPrefix
            self.sessionInitializationEndpointPrefix = output.sessionInitializationEndpointPrefix
            self.slateAdUrl = output.slateAdUrl
            self.tags = output.tags
            self.transcodeProfileName = output.transcodeProfileName
            self.videoContentSourceUrl = output.videoContentSourceUrl
        } else {
            self.adDecisionServerUrl = nil
            self.availSuppression = nil
            self.bumper = nil
            self.cdnConfiguration = nil
            self.configurationAliases = nil
            self.dashConfiguration = nil
            self.hlsConfiguration = nil
            self.livePreRollConfiguration = nil
            self.logConfiguration = nil
            self.manifestProcessingRules = nil
            self.name = nil
            self.personalizationThresholdSeconds = nil
            self.playbackConfigurationArn = nil
            self.playbackEndpointPrefix = nil
            self.sessionInitializationEndpointPrefix = nil
            self.slateAdUrl = nil
            self.tags = nil
            self.transcodeProfileName = nil
            self.videoContentSourceUrl = nil
        }
    }
}

public struct PutPlaybackConfigurationOutputResponse: Swift.Equatable {
    /// The URL for the ad decision server (ADS). This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing you can provide a static VAST URL. The maximum length is 25,000 characters.
    public var adDecisionServerUrl: Swift.String?
    /// The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see [Ad Suppression](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var availSuppression: MediaTailorClientTypes.AvailSuppression?
    /// The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see [Bumpers](https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
    public var bumper: MediaTailorClientTypes.Bumper?
    /// The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
    public var cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    /// The player parameters and aliases used as dynamic variables during session initialization. For more information, see [Domain Variables](https://docs.aws.amazon.com/mediatailor/latest/ug/variables-domain.html).
    public var configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    /// The configuration for DASH content.
    public var dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    /// The configuration for HLS content.
    public var hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    /// The configuration for pre-roll ad insertion.
    public var livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    /// The Amazon CloudWatch log settings for a playback configuration.
    public var logConfiguration: MediaTailorClientTypes.LogConfiguration?
    /// The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
    public var manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    /// The identifier for the playback configuration.
    public var name: Swift.String?
    /// Defines the maximum duration of underfilled ad time (in seconds) allowed in an ad break. If the duration of underfilled ad time exceeds the personalization threshold, then the personalization of the ad break is abandoned and the underlying content is shown. This feature applies to ad replacement in live and VOD streams, rather than ad insertion, because it relies on an underlying content stream. For more information about ad break behavior, including ad replacement and insertion, see [Ad Behavior in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
    public var personalizationThresholdSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) associated with the playback configuration.
    public var playbackConfigurationArn: Swift.String?
    /// The playback endpoint prefix associated with the playback configuration.
    public var playbackEndpointPrefix: Swift.String?
    /// The session initialization endpoint prefix associated with the playback configuration.
    public var sessionInitializationEndpointPrefix: Swift.String?
    /// The URL for a high-quality video asset to transcode and use to fill in time that's not used by ads. AWS Elemental MediaTailor shows the slate to fill in gaps in media content. Configuring the slate is optional for non-VPAID configurations. For VPAID, the slate is required because MediaTailor provides it in the slots that are designated for dynamic ad content. The slate must be a high-quality asset that contains both audio and video.
    public var slateAdUrl: Swift.String?
    /// The tags to assign to the playback configuration. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The name that is used to associate this playback configuration with a custom transcode profile. This overrides the dynamic transcoding defaults of MediaTailor. Use this only if you have already set up custom profiles with the help of AWS Support.
    public var transcodeProfileName: Swift.String?
    /// The URL prefix for the parent manifest for the stream, minus the asset ID. The maximum length is 512 characters.
    public var videoContentSourceUrl: Swift.String?

    public init (
        adDecisionServerUrl: Swift.String? = nil,
        availSuppression: MediaTailorClientTypes.AvailSuppression? = nil,
        bumper: MediaTailorClientTypes.Bumper? = nil,
        cdnConfiguration: MediaTailorClientTypes.CdnConfiguration? = nil,
        configurationAliases: [Swift.String:[Swift.String:Swift.String]]? = nil,
        dashConfiguration: MediaTailorClientTypes.DashConfiguration? = nil,
        hlsConfiguration: MediaTailorClientTypes.HlsConfiguration? = nil,
        livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration? = nil,
        logConfiguration: MediaTailorClientTypes.LogConfiguration? = nil,
        manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules? = nil,
        name: Swift.String? = nil,
        personalizationThresholdSeconds: Swift.Int? = nil,
        playbackConfigurationArn: Swift.String? = nil,
        playbackEndpointPrefix: Swift.String? = nil,
        sessionInitializationEndpointPrefix: Swift.String? = nil,
        slateAdUrl: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        transcodeProfileName: Swift.String? = nil,
        videoContentSourceUrl: Swift.String? = nil
    )
    {
        self.adDecisionServerUrl = adDecisionServerUrl
        self.availSuppression = availSuppression
        self.bumper = bumper
        self.cdnConfiguration = cdnConfiguration
        self.configurationAliases = configurationAliases
        self.dashConfiguration = dashConfiguration
        self.hlsConfiguration = hlsConfiguration
        self.livePreRollConfiguration = livePreRollConfiguration
        self.logConfiguration = logConfiguration
        self.manifestProcessingRules = manifestProcessingRules
        self.name = name
        self.personalizationThresholdSeconds = personalizationThresholdSeconds
        self.playbackConfigurationArn = playbackConfigurationArn
        self.playbackEndpointPrefix = playbackEndpointPrefix
        self.sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefix
        self.slateAdUrl = slateAdUrl
        self.tags = tags
        self.transcodeProfileName = transcodeProfileName
        self.videoContentSourceUrl = videoContentSourceUrl
    }
}

struct PutPlaybackConfigurationOutputResponseBody: Swift.Equatable {
    let adDecisionServerUrl: Swift.String?
    let availSuppression: MediaTailorClientTypes.AvailSuppression?
    let bumper: MediaTailorClientTypes.Bumper?
    let cdnConfiguration: MediaTailorClientTypes.CdnConfiguration?
    let configurationAliases: [Swift.String:[Swift.String:Swift.String]]?
    let dashConfiguration: MediaTailorClientTypes.DashConfiguration?
    let hlsConfiguration: MediaTailorClientTypes.HlsConfiguration?
    let livePreRollConfiguration: MediaTailorClientTypes.LivePreRollConfiguration?
    let logConfiguration: MediaTailorClientTypes.LogConfiguration?
    let manifestProcessingRules: MediaTailorClientTypes.ManifestProcessingRules?
    let name: Swift.String?
    let personalizationThresholdSeconds: Swift.Int?
    let playbackConfigurationArn: Swift.String?
    let playbackEndpointPrefix: Swift.String?
    let sessionInitializationEndpointPrefix: Swift.String?
    let slateAdUrl: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let transcodeProfileName: Swift.String?
    let videoContentSourceUrl: Swift.String?
}

extension PutPlaybackConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adDecisionServerUrl = "AdDecisionServerUrl"
        case availSuppression = "AvailSuppression"
        case bumper = "Bumper"
        case cdnConfiguration = "CdnConfiguration"
        case configurationAliases = "ConfigurationAliases"
        case dashConfiguration = "DashConfiguration"
        case hlsConfiguration = "HlsConfiguration"
        case livePreRollConfiguration = "LivePreRollConfiguration"
        case logConfiguration = "LogConfiguration"
        case manifestProcessingRules = "ManifestProcessingRules"
        case name = "Name"
        case personalizationThresholdSeconds = "PersonalizationThresholdSeconds"
        case playbackConfigurationArn = "PlaybackConfigurationArn"
        case playbackEndpointPrefix = "PlaybackEndpointPrefix"
        case sessionInitializationEndpointPrefix = "SessionInitializationEndpointPrefix"
        case slateAdUrl = "SlateAdUrl"
        case tags = "tags"
        case transcodeProfileName = "TranscodeProfileName"
        case videoContentSourceUrl = "VideoContentSourceUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adDecisionServerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adDecisionServerUrl)
        adDecisionServerUrl = adDecisionServerUrlDecoded
        let availSuppressionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AvailSuppression.self, forKey: .availSuppression)
        availSuppression = availSuppressionDecoded
        let bumperDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Bumper.self, forKey: .bumper)
        bumper = bumperDecoded
        let cdnConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.CdnConfiguration.self, forKey: .cdnConfiguration)
        cdnConfiguration = cdnConfigurationDecoded
        let configurationAliasesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .configurationAliases)
        var configurationAliasesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let configurationAliasesContainer = configurationAliasesContainer {
            configurationAliasesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, __mapof__string0) in configurationAliasesContainer {
                var __mapof__string0Decoded0: [Swift.String: Swift.String]? = nil
                if let __mapof__string0 = __mapof__string0 {
                    __mapof__string0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, __string1) in __mapof__string0 {
                        if let __string1 = __string1 {
                            __mapof__string0Decoded0?[key1] = __string1
                        }
                    }
                }
                configurationAliasesDecoded0?[key0] = __mapof__string0Decoded0
            }
        }
        configurationAliases = configurationAliasesDecoded0
        let dashConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashConfiguration.self, forKey: .dashConfiguration)
        dashConfiguration = dashConfigurationDecoded
        let hlsConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsConfiguration.self, forKey: .hlsConfiguration)
        hlsConfiguration = hlsConfigurationDecoded
        let livePreRollConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LivePreRollConfiguration.self, forKey: .livePreRollConfiguration)
        livePreRollConfiguration = livePreRollConfigurationDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.LogConfiguration.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
        let manifestProcessingRulesDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ManifestProcessingRules.self, forKey: .manifestProcessingRules)
        manifestProcessingRules = manifestProcessingRulesDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let personalizationThresholdSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .personalizationThresholdSeconds)
        personalizationThresholdSeconds = personalizationThresholdSecondsDecoded
        let playbackConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackConfigurationArn)
        playbackConfigurationArn = playbackConfigurationArnDecoded
        let playbackEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackEndpointPrefix)
        playbackEndpointPrefix = playbackEndpointPrefixDecoded
        let sessionInitializationEndpointPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionInitializationEndpointPrefix)
        sessionInitializationEndpointPrefix = sessionInitializationEndpointPrefixDecoded
        let slateAdUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slateAdUrl)
        slateAdUrl = slateAdUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let transcodeProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transcodeProfileName)
        transcodeProfileName = transcodeProfileNameDecoded
        let videoContentSourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoContentSourceUrl)
        videoContentSourceUrl = videoContentSourceUrlDecoded
    }
}

extension MediaTailorClientTypes {
    public enum RelativePosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afterProgram
        case beforeProgram
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativePosition] {
            return [
                .afterProgram,
                .beforeProgram,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afterProgram: return "AFTER_PROGRAM"
            case .beforeProgram: return "BEFORE_PROGRAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelativePosition(rawValue: rawValue) ?? RelativePosition.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.RequestOutputItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashPlaylistSettings = "DashPlaylistSettings"
        case hlsPlaylistSettings = "HlsPlaylistSettings"
        case manifestName = "ManifestName"
        case sourceGroup = "SourceGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashPlaylistSettings = self.dashPlaylistSettings {
            try encodeContainer.encode(dashPlaylistSettings, forKey: .dashPlaylistSettings)
        }
        if let hlsPlaylistSettings = self.hlsPlaylistSettings {
            try encodeContainer.encode(hlsPlaylistSettings, forKey: .hlsPlaylistSettings)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let sourceGroup = self.sourceGroup {
            try encodeContainer.encode(sourceGroup, forKey: .sourceGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashPlaylistSettingsDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashPlaylistSettings.self, forKey: .dashPlaylistSettings)
        dashPlaylistSettings = dashPlaylistSettingsDecoded
        let hlsPlaylistSettingsDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsPlaylistSettings.self, forKey: .hlsPlaylistSettings)
        hlsPlaylistSettings = hlsPlaylistSettingsDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let sourceGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGroup)
        sourceGroup = sourceGroupDecoded
    }
}

extension MediaTailorClientTypes {
    /// The output configuration for this channel.
    public struct RequestOutputItem: Swift.Equatable {
        /// DASH manifest configuration parameters.
        public var dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings?
        /// HLS playlist configuration parameters.
        public var hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings?
        /// The name of the manifest for the channel. The name appears in the PlaybackUrl.
        /// This member is required.
        public var manifestName: Swift.String?
        /// A string used to match which HttpPackageConfiguration is used for each VodSource.
        /// This member is required.
        public var sourceGroup: Swift.String?

        public init (
            dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings? = nil,
            hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings? = nil,
            manifestName: Swift.String? = nil,
            sourceGroup: Swift.String? = nil
        )
        {
            self.dashPlaylistSettings = dashPlaylistSettings
            self.hlsPlaylistSettings = hlsPlaylistSettings
            self.manifestName = manifestName
            self.sourceGroup = sourceGroup
        }
    }

}

extension MediaTailorClientTypes.ResponseOutputItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashPlaylistSettings = "DashPlaylistSettings"
        case hlsPlaylistSettings = "HlsPlaylistSettings"
        case manifestName = "ManifestName"
        case playbackUrl = "PlaybackUrl"
        case sourceGroup = "SourceGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashPlaylistSettings = self.dashPlaylistSettings {
            try encodeContainer.encode(dashPlaylistSettings, forKey: .dashPlaylistSettings)
        }
        if let hlsPlaylistSettings = self.hlsPlaylistSettings {
            try encodeContainer.encode(hlsPlaylistSettings, forKey: .hlsPlaylistSettings)
        }
        if let manifestName = self.manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let playbackUrl = self.playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let sourceGroup = self.sourceGroup {
            try encodeContainer.encode(sourceGroup, forKey: .sourceGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashPlaylistSettingsDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DashPlaylistSettings.self, forKey: .dashPlaylistSettings)
        dashPlaylistSettings = dashPlaylistSettingsDecoded
        let hlsPlaylistSettingsDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HlsPlaylistSettings.self, forKey: .hlsPlaylistSettings)
        hlsPlaylistSettings = hlsPlaylistSettingsDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let sourceGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceGroup)
        sourceGroup = sourceGroupDecoded
    }
}

extension MediaTailorClientTypes {
    /// The output item response.
    public struct ResponseOutputItem: Swift.Equatable {
        /// DASH manifest configuration settings.
        public var dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings?
        /// HLS manifest configuration settings.
        public var hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings?
        /// The name of the manifest for the channel that will appear in the channel output's playback URL.
        /// This member is required.
        public var manifestName: Swift.String?
        /// The URL used for playback by content players.
        /// This member is required.
        public var playbackUrl: Swift.String?
        /// A string used to associate a package configuration source group with a channel output.
        /// This member is required.
        public var sourceGroup: Swift.String?

        public init (
            dashPlaylistSettings: MediaTailorClientTypes.DashPlaylistSettings? = nil,
            hlsPlaylistSettings: MediaTailorClientTypes.HlsPlaylistSettings? = nil,
            manifestName: Swift.String? = nil,
            playbackUrl: Swift.String? = nil,
            sourceGroup: Swift.String? = nil
        )
        {
            self.dashPlaylistSettings = dashPlaylistSettings
            self.hlsPlaylistSettings = hlsPlaylistSettings
            self.manifestName = manifestName
            self.playbackUrl = playbackUrl
            self.sourceGroup = sourceGroup
        }
    }

}

extension MediaTailorClientTypes.ScheduleAdBreak: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateDurationSeconds = "ApproximateDurationSeconds"
        case approximateStartTime = "ApproximateStartTime"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateDurationSeconds = self.approximateDurationSeconds {
            try encodeContainer.encode(approximateDurationSeconds, forKey: .approximateDurationSeconds)
        }
        if let approximateStartTime = self.approximateStartTime {
            try encodeContainer.encodeTimestamp(approximateStartTime, format: .epochSeconds, forKey: .approximateStartTime)
        }
        if let sourceLocationName = self.sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = self.vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateDurationSeconds)
        approximateDurationSeconds = approximateDurationSecondsDecoded
        let approximateStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .approximateStartTime)
        approximateStartTime = approximateStartTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes {
    /// The schedule's ad break properties.
    public struct ScheduleAdBreak: Swift.Equatable {
        /// The approximate duration of the ad break, in seconds.
        public var approximateDurationSeconds: Swift.Int?
        /// The approximate time that the ad will start playing.
        public var approximateStartTime: ClientRuntime.Date?
        /// The name of the source location containing the VOD source used for the ad break.
        public var sourceLocationName: Swift.String?
        /// The name of the VOD source used for the ad break.
        public var vodSourceName: Swift.String?

        public init (
            approximateDurationSeconds: Swift.Int? = nil,
            approximateStartTime: ClientRuntime.Date? = nil,
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.approximateDurationSeconds = approximateDurationSeconds
            self.approximateStartTime = approximateStartTime
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }

}

extension MediaTailorClientTypes.ScheduleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transition = "Transition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transition = self.transition {
            try encodeContainer.encode(transition, forKey: .transition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.Transition.self, forKey: .transition)
        transition = transitionDecoded
    }
}

extension MediaTailorClientTypes {
    /// Schedule configuration parameters. A channel must be stopped before changes can be made to the schedule.
    public struct ScheduleConfiguration: Swift.Equatable {
        /// Program transition configurations.
        /// This member is required.
        public var transition: MediaTailorClientTypes.Transition?

        public init (
            transition: MediaTailorClientTypes.Transition? = nil
        )
        {
            self.transition = transition
        }
    }

}

extension MediaTailorClientTypes.ScheduleEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateDurationSeconds = "ApproximateDurationSeconds"
        case approximateStartTime = "ApproximateStartTime"
        case arn = "Arn"
        case channelName = "ChannelName"
        case liveSourceName = "LiveSourceName"
        case programName = "ProgramName"
        case scheduleAdBreaks = "ScheduleAdBreaks"
        case scheduleEntryType = "ScheduleEntryType"
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approximateDurationSeconds = self.approximateDurationSeconds {
            try encodeContainer.encode(approximateDurationSeconds, forKey: .approximateDurationSeconds)
        }
        if let approximateStartTime = self.approximateStartTime {
            try encodeContainer.encodeTimestamp(approximateStartTime, format: .epochSeconds, forKey: .approximateStartTime)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let liveSourceName = self.liveSourceName {
            try encodeContainer.encode(liveSourceName, forKey: .liveSourceName)
        }
        if let programName = self.programName {
            try encodeContainer.encode(programName, forKey: .programName)
        }
        if let scheduleAdBreaks = scheduleAdBreaks {
            var scheduleAdBreaksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scheduleAdBreaks)
            for scheduleadbreak0 in scheduleAdBreaks {
                try scheduleAdBreaksContainer.encode(scheduleadbreak0)
            }
        }
        if let scheduleEntryType = self.scheduleEntryType {
            try encodeContainer.encode(scheduleEntryType.rawValue, forKey: .scheduleEntryType)
        }
        if let sourceLocationName = self.sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = self.vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approximateDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .approximateDurationSeconds)
        approximateDurationSeconds = approximateDurationSecondsDecoded
        let approximateStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .approximateStartTime)
        approximateStartTime = approximateStartTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let liveSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .liveSourceName)
        liveSourceName = liveSourceNameDecoded
        let programNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .programName)
        programName = programNameDecoded
        let scheduleAdBreaksContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ScheduleAdBreak?].self, forKey: .scheduleAdBreaks)
        var scheduleAdBreaksDecoded0:[MediaTailorClientTypes.ScheduleAdBreak]? = nil
        if let scheduleAdBreaksContainer = scheduleAdBreaksContainer {
            scheduleAdBreaksDecoded0 = [MediaTailorClientTypes.ScheduleAdBreak]()
            for structure0 in scheduleAdBreaksContainer {
                if let structure0 = structure0 {
                    scheduleAdBreaksDecoded0?.append(structure0)
                }
            }
        }
        scheduleAdBreaks = scheduleAdBreaksDecoded0
        let scheduleEntryTypeDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ScheduleEntryType.self, forKey: .scheduleEntryType)
        scheduleEntryType = scheduleEntryTypeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes {
    /// The properties for a schedule.
    public struct ScheduleEntry: Swift.Equatable {
        /// The approximate duration of this program, in seconds.
        public var approximateDurationSeconds: Swift.Int?
        /// The approximate time that the program will start playing.
        public var approximateStartTime: ClientRuntime.Date?
        /// The ARN of the program.
        /// This member is required.
        public var arn: Swift.String?
        /// The name of the channel that uses this schedule.
        /// This member is required.
        public var channelName: Swift.String?
        /// The name of the live source used for the program.
        public var liveSourceName: Swift.String?
        /// The name of the program.
        /// This member is required.
        public var programName: Swift.String?
        /// The schedule's ad break properties.
        public var scheduleAdBreaks: [MediaTailorClientTypes.ScheduleAdBreak]?
        /// The type of schedule entry.
        public var scheduleEntryType: MediaTailorClientTypes.ScheduleEntryType?
        /// The name of the source location.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The name of the VOD source.
        public var vodSourceName: Swift.String?

        public init (
            approximateDurationSeconds: Swift.Int? = nil,
            approximateStartTime: ClientRuntime.Date? = nil,
            arn: Swift.String? = nil,
            channelName: Swift.String? = nil,
            liveSourceName: Swift.String? = nil,
            programName: Swift.String? = nil,
            scheduleAdBreaks: [MediaTailorClientTypes.ScheduleAdBreak]? = nil,
            scheduleEntryType: MediaTailorClientTypes.ScheduleEntryType? = nil,
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.approximateDurationSeconds = approximateDurationSeconds
            self.approximateStartTime = approximateStartTime
            self.arn = arn
            self.channelName = channelName
            self.liveSourceName = liveSourceName
            self.programName = programName
            self.scheduleAdBreaks = scheduleAdBreaks
            self.scheduleEntryType = scheduleEntryType
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }

}

extension MediaTailorClientTypes {
    public enum ScheduleEntryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fillerSlate
        case program
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleEntryType] {
            return [
                .fillerSlate,
                .program,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fillerSlate: return "FILLER_SLATE"
            case .program: return "PROGRAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduleEntryType(rawValue: rawValue) ?? ScheduleEntryType.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.SecretsManagerAccessTokenConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerName = "HeaderName"
        case secretArn = "SecretArn"
        case secretStringKey = "SecretStringKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerName = self.headerName {
            try encodeContainer.encode(headerName, forKey: .headerName)
        }
        if let secretArn = self.secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let secretStringKey = self.secretStringKey {
            try encodeContainer.encode(secretStringKey, forKey: .secretStringKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let secretStringKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretStringKey)
        secretStringKey = secretStringKeyDecoded
    }
}

extension MediaTailorClientTypes {
    /// AWS Secrets Manager access token configuration parameters. For information about Secrets Manager access token authentication, see [Working with AWS Secrets Manager access token authentication](https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-access-configuration-access-token.html).
    public struct SecretsManagerAccessTokenConfiguration: Swift.Equatable {
        /// The name of the HTTP header used to supply the access token in requests to the source location.
        public var headerName: Swift.String?
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.
        public var secretArn: Swift.String?
        /// The AWS Secrets Manager [SecretString](https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html) key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.
        public var secretStringKey: Swift.String?

        public init (
            headerName: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            secretStringKey: Swift.String? = nil
        )
        {
            self.headerName = headerName
            self.secretArn = secretArn
            self.secretStringKey = secretStringKey
        }
    }

}

extension MediaTailorClientTypes.SegmentDeliveryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseUrl = "BaseUrl"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseUrl = self.baseUrl {
            try encodeContainer.encode(baseUrl, forKey: .baseUrl)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseUrl)
        baseUrl = baseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MediaTailorClientTypes {
    /// The segment delivery configuration settings.
    public struct SegmentDeliveryConfiguration: Swift.Equatable {
        /// The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as https://example.com/some/path. To use a relative URL specify the relative path, such as /some/path*.
        public var baseUrl: Swift.String?
        /// A unique identifier used to distinguish between multiple segment delivery configurations in a source location.
        public var name: Swift.String?

        public init (
            baseUrl: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.baseUrl = baseUrl
            self.name = name
        }
    }

}

extension MediaTailorClientTypes.SegmentationDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case segmentNum = "SegmentNum"
        case segmentationEventId = "SegmentationEventId"
        case segmentationTypeId = "SegmentationTypeId"
        case segmentationUpid = "SegmentationUpid"
        case segmentationUpidType = "SegmentationUpidType"
        case segmentsExpected = "SegmentsExpected"
        case subSegmentNum = "SubSegmentNum"
        case subSegmentsExpected = "SubSegmentsExpected"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let segmentNum = self.segmentNum {
            try encodeContainer.encode(segmentNum, forKey: .segmentNum)
        }
        if let segmentationEventId = self.segmentationEventId {
            try encodeContainer.encode(segmentationEventId, forKey: .segmentationEventId)
        }
        if let segmentationTypeId = self.segmentationTypeId {
            try encodeContainer.encode(segmentationTypeId, forKey: .segmentationTypeId)
        }
        if let segmentationUpid = self.segmentationUpid {
            try encodeContainer.encode(segmentationUpid, forKey: .segmentationUpid)
        }
        if let segmentationUpidType = self.segmentationUpidType {
            try encodeContainer.encode(segmentationUpidType, forKey: .segmentationUpidType)
        }
        if let segmentsExpected = self.segmentsExpected {
            try encodeContainer.encode(segmentsExpected, forKey: .segmentsExpected)
        }
        if let subSegmentNum = self.subSegmentNum {
            try encodeContainer.encode(subSegmentNum, forKey: .subSegmentNum)
        }
        if let subSegmentsExpected = self.subSegmentsExpected {
            try encodeContainer.encode(subSegmentsExpected, forKey: .subSegmentsExpected)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentationEventIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentationEventId)
        segmentationEventId = segmentationEventIdDecoded
        let segmentationUpidTypeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentationUpidType)
        segmentationUpidType = segmentationUpidTypeDecoded
        let segmentationUpidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentationUpid)
        segmentationUpid = segmentationUpidDecoded
        let segmentationTypeIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentationTypeId)
        segmentationTypeId = segmentationTypeIdDecoded
        let segmentNumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentNum)
        segmentNum = segmentNumDecoded
        let segmentsExpectedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .segmentsExpected)
        segmentsExpected = segmentsExpectedDecoded
        let subSegmentNumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .subSegmentNum)
        subSegmentNum = subSegmentNumDecoded
        let subSegmentsExpectedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .subSegmentsExpected)
        subSegmentsExpected = subSegmentsExpectedDecoded
    }
}

extension MediaTailorClientTypes {
    /// The segmentation_descriptor message can contain advanced metadata fields, like content identifiers, to convey a wide range of information about the ad break. MediaTailor writes the ad metadata in the egress manifest as part of the EXT-X-DATERANGE or EventStream ad marker's SCTE-35 data. segmentation_descriptor messages must be sent with the time_signal message type. See the segmentation_descriptor() table of the 2022 SCTE-35 specification for more information.
    public struct SegmentationDescriptor: Swift.Equatable {
        /// The segment number to assign to the segmentation_descriptor.segment_num message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.
        public var segmentNum: Swift.Int?
        /// The Event Identifier to assign to the segmentation_descriptor.segmentation_event_id message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The default value is 1.
        public var segmentationEventId: Swift.Int?
        /// The Type Identifier to assign to the segmentation_descriptor.segmentation_type_id message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 48.
        public var segmentationTypeId: Swift.Int?
        /// The Upid to assign to the segmentation_descriptor.segmentation_upid message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. The value must be a hexadecimal string containing only the characters 0 though 9 and A through F. The default value is "" (an empty string).
        public var segmentationUpid: Swift.String?
        /// The Upid Type to assign to the segmentation_descriptor.segmentation_upid_type message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is 14.
        public var segmentationUpidType: Swift.Int?
        /// The number of segments expected, which is assigned to the segmentation_descriptor.segments_expectedS message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification Values must be between 0 and 256, inclusive. The default value is 0.
        public var segmentsExpected: Swift.Int?
        /// The sub-segment number to assign to the segmentation_descriptor.sub_segment_num message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The defualt value is null.
        public var subSegmentNum: Swift.Int?
        /// The number of sub-segments expected, which is assigned to the segmentation_descriptor.sub_segments_expected message, as defined in section 10.3.3.1 of the 2022 SCTE-35 specification. Values must be between 0 and 256, inclusive. The default value is null.
        public var subSegmentsExpected: Swift.Int?

        public init (
            segmentNum: Swift.Int? = nil,
            segmentationEventId: Swift.Int? = nil,
            segmentationTypeId: Swift.Int? = nil,
            segmentationUpid: Swift.String? = nil,
            segmentationUpidType: Swift.Int? = nil,
            segmentsExpected: Swift.Int? = nil,
            subSegmentNum: Swift.Int? = nil,
            subSegmentsExpected: Swift.Int? = nil
        )
        {
            self.segmentNum = segmentNum
            self.segmentationEventId = segmentationEventId
            self.segmentationTypeId = segmentationTypeId
            self.segmentationUpid = segmentationUpid
            self.segmentationUpidType = segmentationUpidType
            self.segmentsExpected = segmentsExpected
            self.subSegmentNum = subSegmentNum
            self.subSegmentsExpected = subSegmentsExpected
        }
    }

}

extension MediaTailorClientTypes.SlateSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceLocationName = "SourceLocationName"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceLocationName = self.sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let vodSourceName = self.vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes {
    /// Slate VOD source configuration.
    public struct SlateSource: Swift.Equatable {
        /// The name of the source location where the slate VOD source is stored.
        public var sourceLocationName: Swift.String?
        /// The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.
        public var vodSourceName: Swift.String?

        public init (
            sourceLocationName: Swift.String? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.sourceLocationName = sourceLocationName
            self.vodSourceName = vodSourceName
        }
    }

}

extension MediaTailorClientTypes.SourceLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = self.accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let defaultSegmentDeliveryConfiguration = self.defaultSegmentDeliveryConfiguration {
            try encodeContainer.encode(defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
        }
        if let httpConfiguration = self.httpConfiguration {
            try encodeContainer.encode(httpConfiguration, forKey: .httpConfiguration)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let segmentDeliveryConfigurations = segmentDeliveryConfigurations {
            var segmentDeliveryConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentDeliveryConfigurations)
            for segmentdeliveryconfiguration0 in segmentDeliveryConfigurations {
                try segmentDeliveryConfigurationsContainer.encode(segmentdeliveryconfiguration0)
            }
        }
        if let sourceLocationName = self.sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let segmentDeliveryConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.SegmentDeliveryConfiguration?].self, forKey: .segmentDeliveryConfigurations)
        var segmentDeliveryConfigurationsDecoded0:[MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil
        if let segmentDeliveryConfigurationsContainer = segmentDeliveryConfigurationsContainer {
            segmentDeliveryConfigurationsDecoded0 = [MediaTailorClientTypes.SegmentDeliveryConfiguration]()
            for structure0 in segmentDeliveryConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentDeliveryConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentDeliveryConfigurations = segmentDeliveryConfigurationsDecoded0
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaTailorClientTypes {
    /// A source location is a container for sources. For more information about source locations, see [Working with source locations](https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-source-locations.html) in the MediaTailor User Guide.
    public struct SourceLocation: Swift.Equatable {
        /// The access configuration for the source location.
        public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
        /// The ARN of the SourceLocation.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp that indicates when the source location was created.
        public var creationTime: ClientRuntime.Date?
        /// The default segment delivery configuration.
        public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
        /// The HTTP configuration for the source location.
        /// This member is required.
        public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
        /// The timestamp that indicates when the source location was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The segment delivery configurations for the source location.
        public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
        /// The name of the source location.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The tags assigned to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String:Swift.String]?

        public init (
            accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
            httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
            sourceLocationName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessConfiguration = accessConfiguration
            self.arn = arn
            self.creationTime = creationTime
            self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
            self.httpConfiguration = httpConfiguration
            self.lastModifiedTime = lastModifiedTime
            self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
            self.sourceLocationName = sourceLocationName
            self.tags = tags
        }
    }

}

extension MediaTailorClientTypes.SpliceInsertMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availNum = "AvailNum"
        case availsExpected = "AvailsExpected"
        case spliceEventId = "SpliceEventId"
        case uniqueProgramId = "UniqueProgramId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availNum = self.availNum {
            try encodeContainer.encode(availNum, forKey: .availNum)
        }
        if let availsExpected = self.availsExpected {
            try encodeContainer.encode(availsExpected, forKey: .availsExpected)
        }
        if let spliceEventId = self.spliceEventId {
            try encodeContainer.encode(spliceEventId, forKey: .spliceEventId)
        }
        if let uniqueProgramId = self.uniqueProgramId {
            try encodeContainer.encode(uniqueProgramId, forKey: .uniqueProgramId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availNumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availNum)
        availNum = availNumDecoded
        let availsExpectedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availsExpected)
        availsExpected = availsExpectedDecoded
        let spliceEventIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .spliceEventId)
        spliceEventId = spliceEventIdDecoded
        let uniqueProgramIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uniqueProgramId)
        uniqueProgramId = uniqueProgramIdDecoded
    }
}

extension MediaTailorClientTypes {
    /// Splice insert message configuration.
    public struct SpliceInsertMessage: Swift.Equatable {
        /// This is written to splice_insert.avail_num, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public var availNum: Swift.Int?
        /// This is written to splice_insert.avails_expected, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public var availsExpected: Swift.Int?
        /// This is written to splice_insert.splice_event_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 1.
        public var spliceEventId: Swift.Int?
        /// This is written to splice_insert.unique_program_id, as defined in section 9.7.3.1 of the SCTE-35 specification. The default value is 0. Values must be between 0 and 256, inclusive.
        public var uniqueProgramId: Swift.Int?

        public init (
            availNum: Swift.Int? = nil,
            availsExpected: Swift.Int? = nil,
            spliceEventId: Swift.Int? = nil,
            uniqueProgramId: Swift.Int? = nil
        )
        {
            self.availNum = availNum
            self.availsExpected = availsExpected
            self.spliceEventId = spliceEventId
            self.uniqueProgramId = uniqueProgramId
        }
    }

}

extension StartChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/start"
    }
}

public struct StartChannelInput: Swift.Equatable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct StartChannelInputBody: Swift.Equatable {
}

extension StartChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension StopChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())/stop"
    }
}

public struct StopChannelInput: Swift.Equatable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?

    public init (
        channelName: Swift.String? = nil
    )
    {
        self.channelName = channelName
    }
}

struct StopChannelInputBody: Swift.Equatable {
}

extension StopChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension StopChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to assign to the resource. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension MediaTailorClientTypes {
    public enum Tier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Tier] {
            return [
                .basic,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tier(rawValue: rawValue) ?? Tier.sdkUnknown(rawValue)
        }
    }
}

extension MediaTailorClientTypes.TimeSignalMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case segmentationDescriptors = "SegmentationDescriptors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let segmentationDescriptors = segmentationDescriptors {
            var segmentationDescriptorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentationDescriptors)
            for segmentationdescriptor0 in segmentationDescriptors {
                try segmentationDescriptorsContainer.encode(segmentationdescriptor0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentationDescriptorsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.SegmentationDescriptor?].self, forKey: .segmentationDescriptors)
        var segmentationDescriptorsDecoded0:[MediaTailorClientTypes.SegmentationDescriptor]? = nil
        if let segmentationDescriptorsContainer = segmentationDescriptorsContainer {
            segmentationDescriptorsDecoded0 = [MediaTailorClientTypes.SegmentationDescriptor]()
            for structure0 in segmentationDescriptorsContainer {
                if let structure0 = structure0 {
                    segmentationDescriptorsDecoded0?.append(structure0)
                }
            }
        }
        segmentationDescriptors = segmentationDescriptorsDecoded0
    }
}

extension MediaTailorClientTypes {
    /// The SCTE-35 time_signal message can be sent with one or more segmentation_descriptor messages. A time_signal message can be sent only if a single segmentation_descriptor message is sent. The time_signal message contains only the splice_time field which is constructed using a given presentation timestamp. When sending a time_signal message, the splice_command_type field in the splice_info_section message is set to 6 (0x06). See the time_signal() table of the 2022 SCTE-35 specification for more information.
    public struct TimeSignalMessage: Swift.Equatable {
        /// The configurations for the SCTE-35 segmentation_descriptor message(s) sent with the time_signal message.
        public var segmentationDescriptors: [MediaTailorClientTypes.SegmentationDescriptor]?

        public init (
            segmentationDescriptors: [MediaTailorClientTypes.SegmentationDescriptor]? = nil
        )
        {
            self.segmentationDescriptors = segmentationDescriptors
        }
    }

}

extension MediaTailorClientTypes.Transition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationMillis = "DurationMillis"
        case relativePosition = "RelativePosition"
        case relativeProgram = "RelativeProgram"
        case scheduledStartTimeMillis = "ScheduledStartTimeMillis"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationMillis = self.durationMillis {
            try encodeContainer.encode(durationMillis, forKey: .durationMillis)
        }
        if let relativePosition = self.relativePosition {
            try encodeContainer.encode(relativePosition.rawValue, forKey: .relativePosition)
        }
        if let relativeProgram = self.relativeProgram {
            try encodeContainer.encode(relativeProgram, forKey: .relativeProgram)
        }
        if let scheduledStartTimeMillis = self.scheduledStartTimeMillis {
            try encodeContainer.encode(scheduledStartTimeMillis, forKey: .scheduledStartTimeMillis)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationMillis)
        durationMillis = durationMillisDecoded
        let relativePositionDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.RelativePosition.self, forKey: .relativePosition)
        relativePosition = relativePositionDecoded
        let relativeProgramDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativeProgram)
        relativeProgram = relativeProgramDecoded
        let scheduledStartTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scheduledStartTimeMillis)
        scheduledStartTimeMillis = scheduledStartTimeMillisDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension MediaTailorClientTypes {
    /// Program transition configuration.
    public struct Transition: Swift.Equatable {
        /// The duration of the live program in seconds.
        public var durationMillis: Swift.Int?
        /// The position where this program will be inserted relative to the RelativePosition.
        /// This member is required.
        public var relativePosition: MediaTailorClientTypes.RelativePosition?
        /// The name of the program that this program will be inserted next to, as defined by RelativePosition.
        public var relativeProgram: Swift.String?
        /// The date and time that the program is scheduled to start, in epoch milliseconds.
        public var scheduledStartTimeMillis: Swift.Int?
        /// Defines when the program plays in the schedule. You can set the value to ABSOLUTE or RELATIVE. ABSOLUTE - The program plays at a specific wall clock time. This setting can only be used for channels using the LINEARPlaybackMode. Note the following considerations when using ABSOLUTE transitions: If the preceding program in the schedule has a duration that extends past the wall clock time, MediaTailor truncates the preceding program on a common segment boundary. If there are gaps in playback, MediaTailor plays the FillerSlate you configured for your linear channel. RELATIVE - The program is inserted into the schedule either before or after a program that you specify via RelativePosition.
        /// This member is required.
        public var type: Swift.String?

        public init (
            durationMillis: Swift.Int? = nil,
            relativePosition: MediaTailorClientTypes.RelativePosition? = nil,
            relativeProgram: Swift.String? = nil,
            scheduledStartTimeMillis: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.durationMillis = durationMillis
            self.relativePosition = relativePosition
            self.relativeProgram = relativeProgram
            self.scheduledStartTimeMillis = scheduledStartTimeMillis
            self.type = type
        }
    }

}

extension MediaTailorClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dash
        case hls
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .dash,
                .hls,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dash: return "DASH"
            case .hls: return "HLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys associated with the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fillerSlate = "FillerSlate"
        case outputs = "Outputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fillerSlate = self.fillerSlate {
            try encodeContainer.encode(fillerSlate, forKey: .fillerSlate)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for requestoutputitem0 in outputs {
                try outputsContainer.encode(requestoutputitem0)
            }
        }
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelName = channelName else {
            return nil
        }
        return "/channel/\(channelName.urlPercentEncoding())"
    }
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The name of the channel.
    /// This member is required.
    public var channelName: Swift.String?
    /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEARPlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOPPlaybackMode.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The channel's output properties.
    /// This member is required.
    public var outputs: [MediaTailorClientTypes.RequestOutputItem]?

    public init (
        channelName: Swift.String? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        outputs: [MediaTailorClientTypes.RequestOutputItem]? = nil
    )
    {
        self.channelName = channelName
        self.fillerSlate = fillerSlate
        self.outputs = outputs
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let fillerSlate: MediaTailorClientTypes.SlateSource?
    let outputs: [MediaTailorClientTypes.RequestOutputItem]?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fillerSlate = "FillerSlate"
        case outputs = "Outputs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.RequestOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.RequestOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.RequestOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.channelName = output.channelName
            self.channelState = output.channelState
            self.creationTime = output.creationTime
            self.fillerSlate = output.fillerSlate
            self.lastModifiedTime = output.lastModifiedTime
            self.outputs = output.outputs
            self.playbackMode = output.playbackMode
            self.tags = output.tags
            self.tier = output.tier
        } else {
            self.arn = nil
            self.channelName = nil
            self.channelState = nil
            self.creationTime = nil
            self.fillerSlate = nil
            self.lastModifiedTime = nil
            self.outputs = nil
            self.playbackMode = nil
            self.tags = nil
            self.tier = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the channel.
    public var arn: Swift.String?
    /// The name of the channel.
    public var channelName: Swift.String?
    /// Returns the state whether the channel is running or not.
    public var channelState: MediaTailorClientTypes.ChannelState?
    /// The timestamp of when the channel was created.
    public var creationTime: ClientRuntime.Date?
    /// The slate used to fill gaps between programs in the schedule. You must configure filler slate if your channel uses the LINEARPlaybackMode. MediaTailor doesn't support filler slate for channels using the LOOPPlaybackMode.
    public var fillerSlate: MediaTailorClientTypes.SlateSource?
    /// The timestamp that indicates when the channel was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The channel's output properties.
    public var outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    /// The type of playback mode for this channel. LINEAR - Programs play back-to-back only once. LOOP - Programs play back-to-back in an endless loop. When the last program in the schedule plays, playback loops back to the first program in the schedule.
    public var playbackMode: Swift.String?
    /// The tags to assign to the channel. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The tier associated with this Channel.
    public var tier: Swift.String?

    public init (
        arn: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelState: MediaTailorClientTypes.ChannelState? = nil,
        creationTime: ClientRuntime.Date? = nil,
        fillerSlate: MediaTailorClientTypes.SlateSource? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        outputs: [MediaTailorClientTypes.ResponseOutputItem]? = nil,
        playbackMode: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tier: Swift.String? = nil
    )
    {
        self.arn = arn
        self.channelName = channelName
        self.channelState = channelState
        self.creationTime = creationTime
        self.fillerSlate = fillerSlate
        self.lastModifiedTime = lastModifiedTime
        self.outputs = outputs
        self.playbackMode = playbackMode
        self.tags = tags
        self.tier = tier
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let channelName: Swift.String?
    let channelState: MediaTailorClientTypes.ChannelState?
    let creationTime: ClientRuntime.Date?
    let fillerSlate: MediaTailorClientTypes.SlateSource?
    let lastModifiedTime: ClientRuntime.Date?
    let outputs: [MediaTailorClientTypes.ResponseOutputItem]?
    let playbackMode: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let tier: Swift.String?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case channelName = "ChannelName"
        case channelState = "ChannelState"
        case creationTime = "CreationTime"
        case fillerSlate = "FillerSlate"
        case lastModifiedTime = "LastModifiedTime"
        case outputs = "Outputs"
        case playbackMode = "PlaybackMode"
        case tags = "tags"
        case tier = "Tier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelStateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.ChannelState.self, forKey: .channelState)
        channelState = channelStateDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fillerSlateDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.SlateSource.self, forKey: .fillerSlate)
        fillerSlate = fillerSlateDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.ResponseOutputItem?].self, forKey: .outputs)
        var outputsDecoded0:[MediaTailorClientTypes.ResponseOutputItem]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaTailorClientTypes.ResponseOutputItem]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let playbackModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackMode)
        playbackMode = playbackModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let tierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension UpdateLiveSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfiguration0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfiguration0)
            }
        }
    }
}

extension UpdateLiveSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        guard let liveSourceName = liveSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/liveSource/\(liveSourceName.urlPercentEncoding())"
    }
}

public struct UpdateLiveSourceInput: Swift.Equatable {
    /// A list of HTTP package configurations for the live source on this account.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The name of the live source.
    /// This member is required.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with this Live Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
    }
}

struct UpdateLiveSourceInputBody: Swift.Equatable {
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
}

extension UpdateLiveSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
    }
}

extension UpdateLiveSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLiveSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLiveSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLiveSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateLiveSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.liveSourceName = output.liveSourceName
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.liveSourceName = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct UpdateLiveSourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with this live source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the live source was created.
    public var creationTime: ClientRuntime.Date?
    /// A list of HTTP package configurations for the live source on this account.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The timestamp that indicates when the live source was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the live source.
    public var liveSourceName: Swift.String?
    /// The name of the source location associated with the live source.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the live source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        liveSourceName: Swift.String? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.liveSourceName = liveSourceName
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct UpdateLiveSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    let lastModifiedTime: ClientRuntime.Date?
    let liveSourceName: Swift.String?
    let sourceLocationName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateLiveSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case liveSourceName = "LiveSourceName"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let liveSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .liveSourceName)
        liveSourceName = liveSourceNameDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateSourceLocationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessConfiguration = self.accessConfiguration {
            try encodeContainer.encode(accessConfiguration, forKey: .accessConfiguration)
        }
        if let defaultSegmentDeliveryConfiguration = self.defaultSegmentDeliveryConfiguration {
            try encodeContainer.encode(defaultSegmentDeliveryConfiguration, forKey: .defaultSegmentDeliveryConfiguration)
        }
        if let httpConfiguration = self.httpConfiguration {
            try encodeContainer.encode(httpConfiguration, forKey: .httpConfiguration)
        }
        if let segmentDeliveryConfigurations = segmentDeliveryConfigurations {
            var segmentDeliveryConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segmentDeliveryConfigurations)
            for segmentdeliveryconfiguration0 in segmentDeliveryConfigurations {
                try segmentDeliveryConfigurationsContainer.encode(segmentdeliveryconfiguration0)
            }
        }
    }
}

extension UpdateSourceLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())"
    }
}

public struct UpdateSourceLocationInput: Swift.Equatable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The optional configuration for the host server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP configuration for the source location.
    /// This member is required.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// A list of the segment delivery configurations associated with this resource.
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name of the source location.
    /// This member is required.
    public var sourceLocationName: Swift.String?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
    }
}

struct UpdateSourceLocationInputBody: Swift.Equatable {
    let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    let segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
}

extension UpdateSourceLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let segmentDeliveryConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.SegmentDeliveryConfiguration?].self, forKey: .segmentDeliveryConfigurations)
        var segmentDeliveryConfigurationsDecoded0:[MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil
        if let segmentDeliveryConfigurationsContainer = segmentDeliveryConfigurationsContainer {
            segmentDeliveryConfigurationsDecoded0 = [MediaTailorClientTypes.SegmentDeliveryConfiguration]()
            for structure0 in segmentDeliveryConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentDeliveryConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentDeliveryConfigurations = segmentDeliveryConfigurationsDecoded0
    }
}

extension UpdateSourceLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSourceLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSourceLocationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSourceLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSourceLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessConfiguration = output.accessConfiguration
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.defaultSegmentDeliveryConfiguration = output.defaultSegmentDeliveryConfiguration
            self.httpConfiguration = output.httpConfiguration
            self.lastModifiedTime = output.lastModifiedTime
            self.segmentDeliveryConfigurations = output.segmentDeliveryConfigurations
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
        } else {
            self.accessConfiguration = nil
            self.arn = nil
            self.creationTime = nil
            self.defaultSegmentDeliveryConfiguration = nil
            self.httpConfiguration = nil
            self.lastModifiedTime = nil
            self.segmentDeliveryConfigurations = nil
            self.sourceLocationName = nil
            self.tags = nil
        }
    }
}

public struct UpdateSourceLocationOutputResponse: Swift.Equatable {
    /// Access configuration parameters. Configures the type of authentication used to access content from your source location.
    public var accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    /// The Amazon Resource Name (ARN) associated with the source location.
    public var arn: Swift.String?
    /// The timestamp that indicates when the source location was created.
    public var creationTime: ClientRuntime.Date?
    /// The optional configuration for the host server that serves segments.
    public var defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    /// The HTTP configuration for the source location.
    public var httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    /// The timestamp that indicates when the source location was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The segment delivery configurations for the source location. For information about MediaTailor configurations, see [Working with configurations in AWS Elemental MediaTailor](https://docs.aws.amazon.com/mediatailor/latest/ug/configurations.html).
    public var segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    /// The name of the source location.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the source location. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessConfiguration: MediaTailorClientTypes.AccessConfiguration? = nil,
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration? = nil,
        httpConfiguration: MediaTailorClientTypes.HttpConfiguration? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessConfiguration = accessConfiguration
        self.arn = arn
        self.creationTime = creationTime
        self.defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfiguration
        self.httpConfiguration = httpConfiguration
        self.lastModifiedTime = lastModifiedTime
        self.segmentDeliveryConfigurations = segmentDeliveryConfigurations
        self.sourceLocationName = sourceLocationName
        self.tags = tags
    }
}

struct UpdateSourceLocationOutputResponseBody: Swift.Equatable {
    let accessConfiguration: MediaTailorClientTypes.AccessConfiguration?
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let defaultSegmentDeliveryConfiguration: MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration?
    let httpConfiguration: MediaTailorClientTypes.HttpConfiguration?
    let lastModifiedTime: ClientRuntime.Date?
    let segmentDeliveryConfigurations: [MediaTailorClientTypes.SegmentDeliveryConfiguration]?
    let sourceLocationName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateSourceLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessConfiguration = "AccessConfiguration"
        case arn = "Arn"
        case creationTime = "CreationTime"
        case defaultSegmentDeliveryConfiguration = "DefaultSegmentDeliveryConfiguration"
        case httpConfiguration = "HttpConfiguration"
        case lastModifiedTime = "LastModifiedTime"
        case segmentDeliveryConfigurations = "SegmentDeliveryConfigurations"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.AccessConfiguration.self, forKey: .accessConfiguration)
        accessConfiguration = accessConfigurationDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let defaultSegmentDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.DefaultSegmentDeliveryConfiguration.self, forKey: .defaultSegmentDeliveryConfiguration)
        defaultSegmentDeliveryConfiguration = defaultSegmentDeliveryConfigurationDecoded
        let httpConfigurationDecoded = try containerValues.decodeIfPresent(MediaTailorClientTypes.HttpConfiguration.self, forKey: .httpConfiguration)
        httpConfiguration = httpConfigurationDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let segmentDeliveryConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.SegmentDeliveryConfiguration?].self, forKey: .segmentDeliveryConfigurations)
        var segmentDeliveryConfigurationsDecoded0:[MediaTailorClientTypes.SegmentDeliveryConfiguration]? = nil
        if let segmentDeliveryConfigurationsContainer = segmentDeliveryConfigurationsContainer {
            segmentDeliveryConfigurationsDecoded0 = [MediaTailorClientTypes.SegmentDeliveryConfiguration]()
            for structure0 in segmentDeliveryConfigurationsContainer {
                if let structure0 = structure0 {
                    segmentDeliveryConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        segmentDeliveryConfigurations = segmentDeliveryConfigurationsDecoded0
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateVodSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfiguration0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfiguration0)
            }
        }
    }
}

extension UpdateVodSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceLocationName = sourceLocationName else {
            return nil
        }
        guard let vodSourceName = vodSourceName else {
            return nil
        }
        return "/sourceLocation/\(sourceLocationName.urlPercentEncoding())/vodSource/\(vodSourceName.urlPercentEncoding())"
    }
}

public struct UpdateVodSourceInput: Swift.Equatable {
    /// A list of HTTP package configurations for the VOD source on this account.
    /// This member is required.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The name of the source location associated with this VOD Source.
    /// This member is required.
    public var sourceLocationName: Swift.String?
    /// The name of the VOD source.
    /// This member is required.
    public var vodSourceName: Swift.String?

    public init (
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        sourceLocationName: Swift.String? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.httpPackageConfigurations = httpPackageConfigurations
        self.sourceLocationName = sourceLocationName
        self.vodSourceName = vodSourceName
    }
}

struct UpdateVodSourceInputBody: Swift.Equatable {
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
}

extension UpdateVodSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPackageConfigurations = "HttpPackageConfigurations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
    }
}

extension UpdateVodSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVodSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVodSourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVodSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVodSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.httpPackageConfigurations = output.httpPackageConfigurations
            self.lastModifiedTime = output.lastModifiedTime
            self.sourceLocationName = output.sourceLocationName
            self.tags = output.tags
            self.vodSourceName = output.vodSourceName
        } else {
            self.arn = nil
            self.creationTime = nil
            self.httpPackageConfigurations = nil
            self.lastModifiedTime = nil
            self.sourceLocationName = nil
            self.tags = nil
            self.vodSourceName = nil
        }
    }
}

public struct UpdateVodSourceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the VOD source.
    public var arn: Swift.String?
    /// The timestamp that indicates when the VOD source was created.
    public var creationTime: ClientRuntime.Date?
    /// A list of HTTP package configurations for the VOD source on this account.
    public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    /// The timestamp that indicates when the VOD source was last modified.
    public var lastModifiedTime: ClientRuntime.Date?
    /// The name of the source location associated with the VOD source.
    public var sourceLocationName: Swift.String?
    /// The tags to assign to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
    public var tags: [Swift.String:Swift.String]?
    /// The name of the VOD source.
    public var vodSourceName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
        lastModifiedTime: ClientRuntime.Date? = nil,
        sourceLocationName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vodSourceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.httpPackageConfigurations = httpPackageConfigurations
        self.lastModifiedTime = lastModifiedTime
        self.sourceLocationName = sourceLocationName
        self.tags = tags
        self.vodSourceName = vodSourceName
    }
}

struct UpdateVodSourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
    let lastModifiedTime: ClientRuntime.Date?
    let sourceLocationName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let vodSourceName: Swift.String?
}

extension UpdateVodSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes.VodSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case httpPackageConfigurations = "HttpPackageConfigurations"
        case lastModifiedTime = "LastModifiedTime"
        case sourceLocationName = "SourceLocationName"
        case tags = "tags"
        case vodSourceName = "VodSourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let httpPackageConfigurations = httpPackageConfigurations {
            var httpPackageConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpPackageConfigurations)
            for httppackageconfiguration0 in httpPackageConfigurations {
                try httpPackageConfigurationsContainer.encode(httppackageconfiguration0)
            }
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encodeTimestamp(lastModifiedTime, format: .epochSeconds, forKey: .lastModifiedTime)
        }
        if let sourceLocationName = self.sourceLocationName {
            try encodeContainer.encode(sourceLocationName, forKey: .sourceLocationName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapOf__string0) in tags {
                try tagsContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vodSourceName = self.vodSourceName {
            try encodeContainer.encode(vodSourceName, forKey: .vodSourceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let httpPackageConfigurationsContainer = try containerValues.decodeIfPresent([MediaTailorClientTypes.HttpPackageConfiguration?].self, forKey: .httpPackageConfigurations)
        var httpPackageConfigurationsDecoded0:[MediaTailorClientTypes.HttpPackageConfiguration]? = nil
        if let httpPackageConfigurationsContainer = httpPackageConfigurationsContainer {
            httpPackageConfigurationsDecoded0 = [MediaTailorClientTypes.HttpPackageConfiguration]()
            for structure0 in httpPackageConfigurationsContainer {
                if let structure0 = structure0 {
                    httpPackageConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        httpPackageConfigurations = httpPackageConfigurationsDecoded0
        let lastModifiedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let sourceLocationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLocationName)
        sourceLocationName = sourceLocationNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let vodSourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vodSourceName)
        vodSourceName = vodSourceNameDecoded
    }
}

extension MediaTailorClientTypes {
    /// VOD source configuration parameters.
    public struct VodSource: Swift.Equatable {
        /// The ARN for the VOD source.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp that indicates when the VOD source was created.
        public var creationTime: ClientRuntime.Date?
        /// The HTTP package configurations for the VOD source.
        /// This member is required.
        public var httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]?
        /// The timestamp that indicates when the VOD source was last modified.
        public var lastModifiedTime: ClientRuntime.Date?
        /// The name of the source location that the VOD source is associated with.
        /// This member is required.
        public var sourceLocationName: Swift.String?
        /// The tags assigned to the VOD source. Tags are key-value pairs that you can associate with Amazon resources to help with organization, access control, and cost tracking. For more information, see [Tagging AWS Elemental MediaTailor Resources](https://docs.aws.amazon.com/mediatailor/latest/ug/tagging.html).
        public var tags: [Swift.String:Swift.String]?
        /// The name of the VOD source.
        /// This member is required.
        public var vodSourceName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            httpPackageConfigurations: [MediaTailorClientTypes.HttpPackageConfiguration]? = nil,
            lastModifiedTime: ClientRuntime.Date? = nil,
            sourceLocationName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vodSourceName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.httpPackageConfigurations = httpPackageConfigurations
            self.lastModifiedTime = lastModifiedTime
            self.sourceLocationName = sourceLocationName
            self.tags = tags
            self.vodSourceName = vodSourceName
        }
    }

}
