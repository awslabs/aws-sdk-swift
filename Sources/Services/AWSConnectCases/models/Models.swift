// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes.BasicLayout: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moreInfo
        case topPanel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moreInfo = self.moreInfo {
            try encodeContainer.encode(moreInfo, forKey: .moreInfo)
        }
        if let topPanel = self.topPanel {
            try encodeContainer.encode(topPanel, forKey: .topPanel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topPanelDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutSections.self, forKey: .topPanel)
        topPanel = topPanelDecoded
        let moreInfoDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutSections.self, forKey: .moreInfo)
        moreInfo = moreInfoDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Content specific to BasicLayout type. It configures fields in the top panel and More Info tab of agent application.
    public struct BasicLayout: Swift.Equatable {
        /// This represents sections in a tab of the page layout.
        public var moreInfo: ConnectCasesClientTypes.LayoutSections?
        /// This represents sections in a panel of the page layout.
        public var topPanel: ConnectCasesClientTypes.LayoutSections?

        public init (
            moreInfo: ConnectCasesClientTypes.LayoutSections? = nil,
            topPanel: ConnectCasesClientTypes.LayoutSections? = nil
        )
        {
            self.moreInfo = moreInfo
            self.topPanel = topPanel
        }
    }

}

extension BatchGetFieldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldidentifier0 in fields {
                try fieldsContainer.encode(fieldidentifier0)
            }
        }
    }
}

extension BatchGetFieldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields-batch"
    }
}

public struct BatchGetFieldInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A list of unique field identifiers.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldIdentifier]?

    public init (
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil
    )
    {
        self.domainId = domainId
        self.fields = fields
    }
}

struct BatchGetFieldInputBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldIdentifier]?
}

extension BatchGetFieldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldIdentifier?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldIdentifier]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldIdentifier]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension BatchGetFieldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetFieldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetFieldOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetFieldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetFieldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.fields = output.fields
        } else {
            self.errors = nil
            self.fields = nil
        }
    }
}

public struct BatchGetFieldOutputResponse: Swift.Equatable {
    /// A list of field errors.
    /// This member is required.
    public var errors: [ConnectCasesClientTypes.FieldError]?
    /// A list of detailed field information.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.GetFieldResponse]?

    public init (
        errors: [ConnectCasesClientTypes.FieldError]? = nil,
        fields: [ConnectCasesClientTypes.GetFieldResponse]? = nil
    )
    {
        self.errors = errors
        self.fields = fields
    }
}

struct BatchGetFieldOutputResponseBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.GetFieldResponse]?
    let errors: [ConnectCasesClientTypes.FieldError]?
}

extension BatchGetFieldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case fields
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.GetFieldResponse?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.GetFieldResponse]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.GetFieldResponse]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldError?].self, forKey: .errors)
        var errorsDecoded0:[ConnectCasesClientTypes.FieldError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ConnectCasesClientTypes.FieldError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchPutFieldOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for fieldoption0 in options {
                try optionsContainer.encode(fieldoption0)
            }
        }
    }
}

extension BatchPutFieldOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let fieldId = fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())/options"
    }
}

public struct BatchPutFieldOptionsInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?
    /// A list of FieldOption objects.
    /// This member is required.
    public var options: [ConnectCasesClientTypes.FieldOption]?

    public init (
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil,
        options: [ConnectCasesClientTypes.FieldOption]? = nil
    )
    {
        self.domainId = domainId
        self.fieldId = fieldId
        self.options = options
    }
}

struct BatchPutFieldOptionsInputBody: Swift.Equatable {
    let options: [ConnectCasesClientTypes.FieldOption]?
}

extension BatchPutFieldOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldOption?].self, forKey: .options)
        var optionsDecoded0:[ConnectCasesClientTypes.FieldOption]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [ConnectCasesClientTypes.FieldOption]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
    }
}

extension BatchPutFieldOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutFieldOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchPutFieldOptionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutFieldOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchPutFieldOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchPutFieldOptionsOutputResponse: Swift.Equatable {
    /// A list of field errors.
    public var errors: [ConnectCasesClientTypes.FieldOptionError]?

    public init (
        errors: [ConnectCasesClientTypes.FieldOptionError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchPutFieldOptionsOutputResponseBody: Swift.Equatable {
    let errors: [ConnectCasesClientTypes.FieldOptionError]?
}

extension BatchPutFieldOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldOptionError?].self, forKey: .errors)
        var errorsDecoded0:[ConnectCasesClientTypes.FieldOptionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ConnectCasesClientTypes.FieldOptionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ConnectCasesClientTypes.CaseEventIncludedData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldidentifier0 in fields {
                try fieldsContainer.encode(fieldidentifier0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldIdentifier?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldIdentifier]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldIdentifier]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// Details of what case data is published through the case event stream.
    public struct CaseEventIncludedData: Swift.Equatable {
        /// List of field identifiers.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.FieldIdentifier]?

        public init (
            fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil
        )
        {
            self.fields = fields
        }
    }

}

extension ConnectCasesClientTypes.CaseFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andall = "andAll"
        case field
        case not
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .andall(andall):
                var andallContainer = container.nestedUnkeyedContainer(forKey: .andall)
                for casefilter0 in andall {
                    try andallContainer.encode(casefilter0)
                }
            case let .field(field):
                try container.encode(field, forKey: .field)
            case let .not(not):
                try container.encode(not, forKey: .not)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldFilter.self, forKey: .field)
        if let field = fieldDecoded {
            self = .field(field)
            return
        }
        let notDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.CaseFilter.self, forKey: .not)
        if let not = notDecoded {
            self = .not(not)
            return
        }
        let andallContainer = try values.decodeIfPresent([ConnectCasesClientTypes.CaseFilter?].self, forKey: .andall)
        var andallDecoded0:[ConnectCasesClientTypes.CaseFilter]? = nil
        if let andallContainer = andallContainer {
            andallDecoded0 = [ConnectCasesClientTypes.CaseFilter]()
            for union0 in andallContainer {
                if let union0 = union0 {
                    andallDecoded0?.append(union0)
                }
            }
        }
        if let andall = andallDecoded0 {
            self = .andall(andall)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// A filter for cases. Only one value can be provided.
    public indirect enum CaseFilter: Swift.Equatable {
        /// A list of fields to filter on.
        case field(ConnectCasesClientTypes.FieldFilter)
        /// A filter for cases. Only one value can be provided.
        case not(ConnectCasesClientTypes.CaseFilter)
        /// Provides "and all" filtering.
        case andall([ConnectCasesClientTypes.CaseFilter])
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.CaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = self.caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Case summary information.
    public struct CaseSummary: Swift.Equatable {
        /// A unique identifier of the case.
        /// This member is required.
        public var caseId: Swift.String?
        /// A unique identifier of a template.
        /// This member is required.
        public var templateId: Swift.String?

        public init (
            caseId: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.templateId = templateId
        }
    }

}

extension ConnectCasesClientTypes {
    public enum CommentBodyTextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case sdkUnknown(Swift.String)

        public static var allCases: [CommentBodyTextType] {
            return [
                .plaintext,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "Text/Plain"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommentBodyTextType(rawValue: rawValue) ?? CommentBodyTextType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.CommentContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case contentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.CommentBodyTextType.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Represents the content of a Comment to be returned to agents.
    public struct CommentContent: Swift.Equatable {
        /// Text in the body of a Comment on a case.
        /// This member is required.
        public var body: Swift.String?
        /// Type of the text in the box of a Comment on a case.
        /// This member is required.
        public var contentType: ConnectCasesClientTypes.CommentBodyTextType?

        public init (
            body: Swift.String? = nil,
            contentType: ConnectCasesClientTypes.CommentBodyTextType? = nil
        )
        {
            self.body = body
            self.contentType = contentType
        }
    }

}

extension ConnectCasesClientTypes.CommentFilter: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ConnectCasesClientTypes {
    /// A filter for related items of type Comment.
    public struct CommentFilter: Swift.Equatable {

        public init () { }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes.Contact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension ConnectCasesClientTypes {
    /// An object that represents an Amazon Connect contact object.
    public struct Contact: Swift.Equatable {
        /// A unique identifier of a contact in Amazon Connect.
        /// This member is required.
        public var contactArn: Swift.String?

        public init (
            contactArn: Swift.String? = nil
        )
        {
            self.contactArn = contactArn
        }
    }

}

extension ConnectCasesClientTypes.ContactContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case connectedToSystemTime
        case contactArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let connectedToSystemTime = self.connectedToSystemTime {
            try encodeContainer.encodeTimestamp(connectedToSystemTime, format: .dateTime, forKey: .connectedToSystemTime)
        }
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let channelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channel)
        channel = channelDecoded
        let connectedToSystemTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .connectedToSystemTime)
        connectedToSystemTime = connectedToSystemTimeDecoded
    }
}

extension ConnectCasesClientTypes {
    /// An object that represents a content of an Amazon Connect contact object.
    public struct ContactContent: Swift.Equatable {
        /// A list of channels to filter on for related items of type Contact.
        /// This member is required.
        public var channel: Swift.String?
        /// The difference between the InitiationTimestamp and the DisconnectTimestamp of the contact.
        /// This member is required.
        public var connectedToSystemTime: ClientRuntime.Date?
        /// A unique identifier of a contact in Amazon Connect.
        /// This member is required.
        public var contactArn: Swift.String?

        public init (
            channel: Swift.String? = nil,
            connectedToSystemTime: ClientRuntime.Date? = nil,
            contactArn: Swift.String? = nil
        )
        {
            self.channel = channel
            self.connectedToSystemTime = connectedToSystemTime
            self.contactArn = contactArn
        }
    }

}

extension ConnectCasesClientTypes.ContactFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case contactArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            var channelContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channel)
            for channel0 in channel {
                try channelContainer.encode(channel0)
            }
        }
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .channel)
        var channelDecoded0:[Swift.String]? = nil
        if let channelContainer = channelContainer {
            channelDecoded0 = [Swift.String]()
            for string0 in channelContainer {
                if let string0 = string0 {
                    channelDecoded0?.append(string0)
                }
            }
        }
        channel = channelDecoded0
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension ConnectCasesClientTypes {
    /// A filter for related items of type Contact.
    public struct ContactFilter: Swift.Equatable {
        /// A list of channels to filter on for related items of type Contact.
        public var channel: [Swift.String]?
        /// A unique identifier of a contact in Amazon Connect.
        public var contactArn: Swift.String?

        public init (
            channel: [Swift.String]? = nil,
            contactArn: Swift.String? = nil
        )
        {
            self.channel = channel
            self.contactArn = contactArn
        }
    }

}

extension CreateCaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case fields
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldvalue0 in fields {
                try fieldsContainer.encode(fieldvalue0)
            }
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }
}

extension CreateCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases"
    }
}

public struct CreateCaseInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// An array of objects with field ID (matching ListFields/DescribeField) and value union data.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldValue]?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldValue]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainId = domainId
        self.fields = fields
        self.templateId = templateId
    }
}

struct CreateCaseInputBody: Swift.Equatable {
    let templateId: Swift.String?
    let fields: [ConnectCasesClientTypes.FieldValue]?
    let clientToken: Swift.String?
}

extension CreateCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case fields
        case templateId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.caseArn = output.caseArn
            self.caseId = output.caseId
        } else {
            self.caseArn = nil
            self.caseId = nil
        }
    }
}

public struct CreateCaseOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the case.
    /// This member is required.
    public var caseArn: Swift.String?
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?

    public init (
        caseArn: Swift.String? = nil,
        caseId: Swift.String? = nil
    )
    {
        self.caseArn = caseArn
        self.caseId = caseId
    }
}

struct CreateCaseOutputResponseBody: Swift.Equatable {
    let caseId: Swift.String?
    let caseArn: Swift.String?
}

extension CreateCaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseArn
        case caseId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let caseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseArn)
        caseArn = caseArnDecoded
    }
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domains"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// The name for your Cases domain. It must be unique for your Amazon Web Services account.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainArn = output.domainArn
            self.domainId = output.domainId
            self.domainStatus = output.domainStatus
        } else {
            self.domainArn = nil
            self.domainId = nil
            self.domainStatus = nil
        }
    }
}

public struct CreateDomainOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Cases domain.
    /// This member is required.
    public var domainArn: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The status of the domain.
    /// This member is required.
    public var domainStatus: ConnectCasesClientTypes.DomainStatus?

    public init (
        domainArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        domainStatus: ConnectCasesClientTypes.DomainStatus? = nil
    )
    {
        self.domainArn = domainArn
        self.domainId = domainId
        self.domainStatus = domainStatus
    }
}

struct CreateDomainOutputResponseBody: Swift.Equatable {
    let domainId: Swift.String?
    let domainArn: Swift.String?
    let domainStatus: ConnectCasesClientTypes.DomainStatus?
}

extension CreateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainArn
        case domainId
        case domainStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainArn)
        domainArn = domainArnDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension CreateFieldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateFieldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields"
    }
}

public struct CreateFieldInput: Swift.Equatable {
    /// The description of the field.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the field.
    /// This member is required.
    public var name: Swift.String?
    /// Defines the data type, some system constraints, and default display of the field.
    /// This member is required.
    public var type: ConnectCasesClientTypes.FieldType?

    public init (
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        type: ConnectCasesClientTypes.FieldType? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.type = type
    }
}

struct CreateFieldInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: ConnectCasesClientTypes.FieldType?
    let description: Swift.String?
}

extension CreateFieldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateFieldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFieldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFieldOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFieldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFieldOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fieldArn = output.fieldArn
            self.fieldId = output.fieldId
        } else {
            self.fieldArn = nil
            self.fieldId = nil
        }
    }
}

public struct CreateFieldOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the field.
    /// This member is required.
    public var fieldArn: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?

    public init (
        fieldArn: Swift.String? = nil,
        fieldId: Swift.String? = nil
    )
    {
        self.fieldArn = fieldArn
        self.fieldId = fieldId
    }
}

struct CreateFieldOutputResponseBody: Swift.Equatable {
    let fieldId: Swift.String?
    let fieldArn: Swift.String?
}

extension CreateFieldOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldArn
        case fieldId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let fieldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldArn)
        fieldArn = fieldArnDecoded
    }
}

extension CreateLayoutInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateLayoutInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts"
    }
}

public struct CreateLayoutInput: Swift.Equatable {
    /// Information about which fields will be present in the layout, and information about the order of the fields.
    /// This member is required.
    public var content: ConnectCasesClientTypes.LayoutContent?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the layout. It must be unique for the Cases domain.
    /// This member is required.
    public var name: Swift.String?

    public init (
        content: ConnectCasesClientTypes.LayoutContent? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.content = content
        self.domainId = domainId
        self.name = name
    }
}

struct CreateLayoutInputBody: Swift.Equatable {
    let name: Swift.String?
    let content: ConnectCasesClientTypes.LayoutContent?
}

extension CreateLayoutInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension CreateLayoutOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLayoutOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLayoutOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLayoutOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLayoutOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layoutArn = output.layoutArn
            self.layoutId = output.layoutId
        } else {
            self.layoutArn = nil
            self.layoutId = nil
        }
    }
}

public struct CreateLayoutOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created layout.
    /// This member is required.
    public var layoutArn: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?

    public init (
        layoutArn: Swift.String? = nil,
        layoutId: Swift.String? = nil
    )
    {
        self.layoutArn = layoutArn
        self.layoutId = layoutId
    }
}

struct CreateLayoutOutputResponseBody: Swift.Equatable {
    let layoutId: Swift.String?
    let layoutArn: Swift.String?
}

extension CreateLayoutOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layoutArn
        case layoutId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutId)
        layoutId = layoutIdDecoded
        let layoutArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutArn)
        layoutArn = layoutArnDecoded
    }
}

extension CreateRelatedItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateRelatedItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let caseId = caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())/related-items"
    }
}

public struct CreateRelatedItemInput: Swift.Equatable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The content of a related item to be created.
    /// This member is required.
    public var content: ConnectCasesClientTypes.RelatedItemInputContent?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The type of a related item.
    /// This member is required.
    public var type: ConnectCasesClientTypes.RelatedItemType?

    public init (
        caseId: Swift.String? = nil,
        content: ConnectCasesClientTypes.RelatedItemInputContent? = nil,
        domainId: Swift.String? = nil,
        type: ConnectCasesClientTypes.RelatedItemType? = nil
    )
    {
        self.caseId = caseId
        self.content = content
        self.domainId = domainId
        self.type = type
    }
}

struct CreateRelatedItemInputBody: Swift.Equatable {
    let type: ConnectCasesClientTypes.RelatedItemType?
    let content: ConnectCasesClientTypes.RelatedItemInputContent?
}

extension CreateRelatedItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemInputContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension CreateRelatedItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRelatedItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRelatedItemOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRelatedItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRelatedItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.relatedItemArn = output.relatedItemArn
            self.relatedItemId = output.relatedItemId
        } else {
            self.relatedItemArn = nil
            self.relatedItemId = nil
        }
    }
}

public struct CreateRelatedItemOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the related item.
    /// This member is required.
    public var relatedItemArn: Swift.String?
    /// The unique identifier of the related item.
    /// This member is required.
    public var relatedItemId: Swift.String?

    public init (
        relatedItemArn: Swift.String? = nil,
        relatedItemId: Swift.String? = nil
    )
    {
        self.relatedItemArn = relatedItemArn
        self.relatedItemId = relatedItemId
    }
}

struct CreateRelatedItemOutputResponseBody: Swift.Equatable {
    let relatedItemId: Swift.String?
    let relatedItemArn: Swift.String?
}

extension CreateRelatedItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relatedItemArn
        case relatedItemId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedItemId)
        relatedItemId = relatedItemIdDecoded
        let relatedItemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedItemArn)
        relatedItemArn = relatedItemArnDecoded
    }
}

extension CreateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let layoutConfiguration = self.layoutConfiguration {
            try encodeContainer.encode(layoutConfiguration, forKey: .layoutConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredFields = requiredFields {
            var requiredFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredFields)
            for requiredfield0 in requiredFields {
                try requiredFieldsContainer.encode(requiredfield0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension CreateTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates"
    }
}

public struct CreateTemplateInput: Swift.Equatable {
    /// A brief description of the template.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Configuration of layouts associated to the template.
    public var layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    /// A name for the template. It must be unique per domain.
    /// This member is required.
    public var name: Swift.String?
    /// A list of fields that must contain a value for a case to be successfully created with this template.
    public var requiredFields: [ConnectCasesClientTypes.RequiredField]?
    /// The status of the template.
    public var status: ConnectCasesClientTypes.TemplateStatus?

    public init (
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration? = nil,
        name: Swift.String? = nil,
        requiredFields: [ConnectCasesClientTypes.RequiredField]? = nil,
        status: ConnectCasesClientTypes.TemplateStatus? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.layoutConfiguration = layoutConfiguration
        self.name = name
        self.requiredFields = requiredFields
        self.status = status
    }
}

struct CreateTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    let requiredFields: [ConnectCasesClientTypes.RequiredField]?
    let status: ConnectCasesClientTypes.TemplateStatus?
}

extension CreateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let layoutConfigurationDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutConfiguration.self, forKey: .layoutConfiguration)
        layoutConfiguration = layoutConfigurationDecoded
        let requiredFieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.RequiredField?].self, forKey: .requiredFields)
        var requiredFieldsDecoded0:[ConnectCasesClientTypes.RequiredField]? = nil
        if let requiredFieldsContainer = requiredFieldsContainer {
            requiredFieldsDecoded0 = [ConnectCasesClientTypes.RequiredField]()
            for structure0 in requiredFieldsContainer {
                if let structure0 = structure0 {
                    requiredFieldsDecoded0?.append(structure0)
                }
            }
        }
        requiredFields = requiredFieldsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.templateArn = nil
            self.templateId = nil
        }
    }
}

public struct CreateTemplateOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created template.
    /// This member is required.
    public var templateArn: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct CreateTemplateOutputResponseBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
}

extension CreateTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateArn
        case templateId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init (
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension ConnectCasesClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .creationFailed,
                .creationInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creationFailed: return "CreationFailed"
            case .creationInProgress: return "CreationInProgress"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainArn
        case domainId
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainArn = self.domainArn {
            try encodeContainer.encode(domainArn, forKey: .domainArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainArn)
        domainArn = domainArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for the summarized details of the domain.
    public struct DomainSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the domain.
        /// This member is required.
        public var domainArn: Swift.String?
        /// The unique identifier of the domain.
        /// This member is required.
        public var domainId: Swift.String?
        /// The name of the domain.
        /// This member is required.
        public var name: Swift.String?

        public init (
            domainArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.domainArn = domainArn
            self.domainId = domainId
            self.name = name
        }
    }

}

extension ConnectCasesClientTypes.EventBridgeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case includedData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let includedData = self.includedData {
            try encodeContainer.encode(includedData, forKey: .includedData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let includedDataDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.EventIncludedData.self, forKey: .includedData)
        includedData = includedDataDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
    public struct EventBridgeConfiguration: Swift.Equatable {
        /// Indicates whether the to broadcast case event data to the customer.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Details of what case and related item data is published through the case event stream.
        public var includedData: ConnectCasesClientTypes.EventIncludedData?

        public init (
            enabled: Swift.Bool? = nil,
            includedData: ConnectCasesClientTypes.EventIncludedData? = nil
        )
        {
            self.enabled = enabled
            self.includedData = includedData
        }
    }

}

extension ConnectCasesClientTypes.EventIncludedData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseData
        case relatedItemData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseData = self.caseData {
            try encodeContainer.encode(caseData, forKey: .caseData)
        }
        if let relatedItemData = self.relatedItemData {
            try encodeContainer.encode(relatedItemData, forKey: .relatedItemData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseDataDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.CaseEventIncludedData.self, forKey: .caseData)
        caseData = caseDataDecoded
        let relatedItemDataDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemEventIncludedData.self, forKey: .relatedItemData)
        relatedItemData = relatedItemDataDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Details of what case and related item data is published through the case event stream.
    public struct EventIncludedData: Swift.Equatable {
        /// Details of what case data is published through the case event stream.
        public var caseData: ConnectCasesClientTypes.CaseEventIncludedData?
        /// Details of what related item data is published through the case event stream.
        public var relatedItemData: ConnectCasesClientTypes.RelatedItemEventIncludedData?

        public init (
            caseData: ConnectCasesClientTypes.CaseEventIncludedData? = nil,
            relatedItemData: ConnectCasesClientTypes.RelatedItemEventIncludedData? = nil
        )
        {
            self.caseData = caseData
            self.relatedItemData = relatedItemData
        }
    }

}

extension ConnectCasesClientTypes.FieldError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case id
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for errors on fields.
    public struct FieldError: Swift.Equatable {
        /// The error code from getting a field.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The field identifier that caused the error.
        /// This member is required.
        public var id: Swift.String?
        /// The error message from getting a field.
        public var message: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }
    }

}

extension ConnectCasesClientTypes.FieldFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contains
        case equalto = "equalTo"
        case greaterthan = "greaterThan"
        case greaterthanorequalto = "greaterThanOrEqualTo"
        case lessthan = "lessThan"
        case lessthanorequalto = "lessThanOrEqualTo"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .contains(contains):
                try container.encode(contains, forKey: .contains)
            case let .equalto(equalto):
                try container.encode(equalto, forKey: .equalto)
            case let .greaterthan(greaterthan):
                try container.encode(greaterthan, forKey: .greaterthan)
            case let .greaterthanorequalto(greaterthanorequalto):
                try container.encode(greaterthanorequalto, forKey: .greaterthanorequalto)
            case let .lessthan(lessthan):
                try container.encode(lessthan, forKey: .lessthan)
            case let .lessthanorequalto(lessthanorequalto):
                try container.encode(lessthanorequalto, forKey: .lessthanorequalto)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let equaltoDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .equalto)
        if let equalto = equaltoDecoded {
            self = .equalto(equalto)
            return
        }
        let containsDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .contains)
        if let contains = containsDecoded {
            self = .contains(contains)
            return
        }
        let greaterthanDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .greaterthan)
        if let greaterthan = greaterthanDecoded {
            self = .greaterthan(greaterthan)
            return
        }
        let greaterthanorequaltoDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .greaterthanorequalto)
        if let greaterthanorequalto = greaterthanorequaltoDecoded {
            self = .greaterthanorequalto(greaterthanorequalto)
            return
        }
        let lessthanDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .lessthan)
        if let lessthan = lessthanDecoded {
            self = .lessthan(lessthan)
            return
        }
        let lessthanorequaltoDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .lessthanorequalto)
        if let lessthanorequalto = lessthanorequaltoDecoded {
            self = .lessthanorequalto(lessthanorequalto)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// A filter for fields. Only one value can be provided.
    public enum FieldFilter: Swift.Equatable {
        /// Object containing field identifier and value information.
        case equalto(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case contains(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case greaterthan(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case greaterthanorequalto(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case lessthan(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case lessthanorequalto(ConnectCasesClientTypes.FieldValue)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.FieldGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fielditem0 in fields {
                try fieldsContainer.encode(fielditem0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldItem?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldItem]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldItem]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// Object for a group of fields and associated properties.
    public struct FieldGroup: Swift.Equatable {
        /// Represents an ordered list containing field related information.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.FieldItem]?
        /// Name of the field group.
        public var name: Swift.String?

        public init (
            fields: [ConnectCasesClientTypes.FieldItem]? = nil,
            name: Swift.String? = nil
        )
        {
            self.fields = fields
            self.name = name
        }
    }

}

extension ConnectCasesClientTypes.FieldIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for unique identifier of a field.
    public struct FieldIdentifier: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension ConnectCasesClientTypes.FieldItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for field related information.
    public struct FieldItem: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension ConnectCasesClientTypes {
    public enum FieldNamespace: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldNamespace] {
            return [
                .custom,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .system: return "System"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldNamespace(rawValue: rawValue) ?? FieldNamespace.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.FieldOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for field Options information.
    public struct FieldOption: Swift.Equatable {
        /// Describes whether the FieldOption is active (displayed) or inactive.
        /// This member is required.
        public var active: Swift.Bool?
        /// FieldOptionName has max length 100 and disallows trailing spaces.
        /// This member is required.
        public var name: Swift.String?
        /// FieldOptionValue has max length 100 and must be alphanumeric with hyphens and underscores.
        /// This member is required.
        public var value: Swift.String?

        public init (
            active: Swift.Bool? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.active = active
            self.name = name
            self.value = value
        }
    }

}

extension ConnectCasesClientTypes.FieldOptionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for field Options errors.
    public struct FieldOptionError: Swift.Equatable {
        /// Error code from creating or updating field option.
        /// This member is required.
        public var errorCode: Swift.String?
        /// Error message from creating or updating field option.
        /// This member is required.
        public var message: Swift.String?
        /// The field option value that caused the error.
        /// This member is required.
        public var value: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
            self.value = value
        }
    }

}

extension ConnectCasesClientTypes.FieldSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldArn
        case fieldId
        case name
        case namespace
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldArn = self.fieldArn {
            try encodeContainer.encode(fieldArn, forKey: .fieldArn)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace.rawValue, forKey: .namespace)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let fieldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldArn)
        fieldArn = fieldArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldType.self, forKey: .type)
        type = typeDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldNamespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for the summarized details of the field.
    public struct FieldSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the field.
        /// This member is required.
        public var fieldArn: Swift.String?
        /// The unique identifier of a field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// Name of the field.
        /// This member is required.
        public var name: Swift.String?
        /// The namespace of a field.
        /// This member is required.
        public var namespace: ConnectCasesClientTypes.FieldNamespace?
        /// The type of a field.
        /// This member is required.
        public var type: ConnectCasesClientTypes.FieldType?

        public init (
            fieldArn: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: ConnectCasesClientTypes.FieldNamespace? = nil,
            type: ConnectCasesClientTypes.FieldType? = nil
        )
        {
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.type = type
        }
    }

}

extension ConnectCasesClientTypes {
    public enum FieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case dateTime
        case number
        case singleSelect
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldType] {
            return [
                .boolean,
                .dateTime,
                .number,
                .singleSelect,
                .text,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "Boolean"
            case .dateTime: return "DateTime"
            case .number: return "Number"
            case .singleSelect: return "SingleSelect"
            case .text: return "Text"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldType(rawValue: rawValue) ?? FieldType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.FieldValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldValueUnion.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for case field values.
    public struct FieldValue: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?
        /// Union of potential field value types.
        /// This member is required.
        public var value: ConnectCasesClientTypes.FieldValueUnion?

        public init (
            id: Swift.String? = nil,
            value: ConnectCasesClientTypes.FieldValueUnion? = nil
        )
        {
            self.id = id
            self.value = value
        }
    }

}

extension ConnectCasesClientTypes.FieldValueUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanvalue = "booleanValue"
        case doublevalue = "doubleValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// Object to store union of Field values.
    public enum FieldValueUnion: Swift.Equatable {
        /// String value type.
        case stringvalue(Swift.String)
        /// Can be either null, or have a Double number value type. Only one value can be provided.
        case doublevalue(Swift.Double)
        /// Can be either null, or have a Boolean value type. Only one value can be provided.
        case booleanvalue(Swift.Bool)
        case sdkUnknown(Swift.String)
    }

}

extension GetCaseEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/case-event-configuration"
    }
}

public struct GetCaseEventConfigurationInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init (
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct GetCaseEventConfigurationInputBody: Swift.Equatable {
}

extension GetCaseEventConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCaseEventConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCaseEventConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCaseEventConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCaseEventConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCaseEventConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventBridge = output.eventBridge
        } else {
            self.eventBridge = nil
        }
    }
}

public struct GetCaseEventConfigurationOutputResponse: Swift.Equatable {
    /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
    /// This member is required.
    public var eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?

    public init (
        eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration? = nil
    )
    {
        self.eventBridge = eventBridge
    }
}

struct GetCaseEventConfigurationOutputResponseBody: Swift.Equatable {
    let eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?
}

extension GetCaseEventConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBridge
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBridgeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.EventBridgeConfiguration.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
    }
}

extension GetCaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldidentifier0 in fields {
                try fieldsContainer.encode(fieldidentifier0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let caseId = caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())"
    }
}

public struct GetCaseInput: Swift.Equatable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A list of unique field identifiers.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldIdentifier]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.fields = fields
        self.nextToken = nextToken
    }
}

struct GetCaseInputBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldIdentifier]?
    let nextToken: Swift.String?
}

extension GetCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldIdentifier?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldIdentifier]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldIdentifier]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.nextToken = output.nextToken
            self.tags = output.tags
            self.templateId = output.templateId
        } else {
            self.fields = nil
            self.nextToken = nil
            self.tags = nil
            self.templateId = nil
        }
    }
}

public struct GetCaseOutputResponse: Swift.Equatable {
    /// A list of detailed field information.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldValue]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        fields: [ConnectCasesClientTypes.FieldValue]? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.fields = fields
        self.nextToken = nextToken
        self.tags = tags
        self.templateId = templateId
    }
}

struct GetCaseOutputResponseBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldValue]?
    let templateId: Swift.String?
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String?]?
}

extension GetCaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case nextToken
        case tags
        case templateId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())"
    }
}

public struct GetDomainInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init (
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct GetDomainInputBody: Swift.Equatable {
}

extension GetDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdTime = output.createdTime
            self.domainArn = output.domainArn
            self.domainId = output.domainId
            self.domainStatus = output.domainStatus
            self.name = output.name
            self.tags = output.tags
        } else {
            self.createdTime = nil
            self.domainArn = nil
            self.domainId = nil
            self.domainStatus = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetDomainOutputResponse: Swift.Equatable {
    /// The timestamp when the Cases domain was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the Cases domain.
    /// This member is required.
    public var domainArn: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The status of the Cases domain.
    /// This member is required.
    public var domainStatus: ConnectCasesClientTypes.DomainStatus?
    /// The name of the Cases domain.
    /// This member is required.
    public var name: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?

    public init (
        createdTime: ClientRuntime.Date? = nil,
        domainArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        domainStatus: ConnectCasesClientTypes.DomainStatus? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.createdTime = createdTime
        self.domainArn = domainArn
        self.domainId = domainId
        self.domainStatus = domainStatus
        self.name = name
        self.tags = tags
    }
}

struct GetDomainOutputResponseBody: Swift.Equatable {
    let domainId: Swift.String?
    let domainArn: Swift.String?
    let name: Swift.String?
    let createdTime: ClientRuntime.Date?
    let domainStatus: ConnectCasesClientTypes.DomainStatus?
    let tags: [Swift.String:Swift.String?]?
}

extension GetDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime
        case domainArn
        case domainId
        case domainStatus
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainArn)
        domainArn = domainArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectCasesClientTypes.GetFieldResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case fieldArn
        case fieldId
        case name
        case namespace
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fieldArn = self.fieldArn {
            try encodeContainer.encode(fieldArn, forKey: .fieldArn)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace.rawValue, forKey: .namespace)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fieldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldArn)
        fieldArn = fieldArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldType.self, forKey: .type)
        type = typeDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldNamespace.self, forKey: .namespace)
        namespace = namespaceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// Object to store detailed field information.
    public struct GetFieldResponse: Swift.Equatable {
        /// Description of the field.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the field.
        /// This member is required.
        public var fieldArn: Swift.String?
        /// Unique identifier of the field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// Name of the field.
        /// This member is required.
        public var name: Swift.String?
        /// Namespace of the field.
        /// This member is required.
        public var namespace: ConnectCasesClientTypes.FieldNamespace?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String?]?
        /// Type of the field.
        /// This member is required.
        public var type: ConnectCasesClientTypes.FieldType?

        public init (
            description: Swift.String? = nil,
            fieldArn: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: ConnectCasesClientTypes.FieldNamespace? = nil,
            tags: [Swift.String:Swift.String?]? = nil,
            type: ConnectCasesClientTypes.FieldType? = nil
        )
        {
            self.description = description
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.tags = tags
            self.type = type
        }
    }

}

extension GetLayoutInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let layoutId = layoutId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts/\(layoutId.urlPercentEncoding())"
    }
}

public struct GetLayoutInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        layoutId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.layoutId = layoutId
    }
}

struct GetLayoutInputBody: Swift.Equatable {
}

extension GetLayoutInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLayoutOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayoutOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLayoutOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayoutOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLayoutOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.layoutArn = output.layoutArn
            self.layoutId = output.layoutId
            self.name = output.name
            self.tags = output.tags
        } else {
            self.content = nil
            self.layoutArn = nil
            self.layoutId = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetLayoutOutputResponse: Swift.Equatable {
    /// Information about which fields will be present in the layout, the order of the fields, and read-only attribute of the field.
    /// This member is required.
    public var content: ConnectCasesClientTypes.LayoutContent?
    /// The Amazon Resource Name (ARN) of the newly created layout.
    /// This member is required.
    public var layoutArn: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?
    /// The name of the layout. It must be unique.
    /// This member is required.
    public var name: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?

    public init (
        content: ConnectCasesClientTypes.LayoutContent? = nil,
        layoutArn: Swift.String? = nil,
        layoutId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.content = content
        self.layoutArn = layoutArn
        self.layoutId = layoutId
        self.name = name
        self.tags = tags
    }
}

struct GetLayoutOutputResponseBody: Swift.Equatable {
    let layoutId: Swift.String?
    let layoutArn: Swift.String?
    let name: Swift.String?
    let content: ConnectCasesClientTypes.LayoutContent?
    let tags: [Swift.String:Swift.String?]?
}

extension GetLayoutOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case layoutArn
        case layoutId
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutId)
        layoutId = layoutIdDecoded
        let layoutArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutArn)
        layoutArn = layoutArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutContent.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension GetTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct GetTemplateInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.templateId = templateId
    }
}

struct GetTemplateInputBody: Swift.Equatable {
}

extension GetTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.layoutConfiguration = output.layoutConfiguration
            self.name = output.name
            self.requiredFields = output.requiredFields
            self.status = output.status
            self.tags = output.tags
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.description = nil
            self.layoutConfiguration = nil
            self.name = nil
            self.requiredFields = nil
            self.status = nil
            self.tags = nil
            self.templateArn = nil
            self.templateId = nil
        }
    }
}

public struct GetTemplateOutputResponse: Swift.Equatable {
    /// A brief description of the template.
    public var description: Swift.String?
    /// Configuration of layouts associated to the template.
    public var layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    /// The name of the template.
    /// This member is required.
    public var name: Swift.String?
    /// A list of fields that must contain a value for a case to be successfully created with this template.
    public var requiredFields: [ConnectCasesClientTypes.RequiredField]?
    /// The status of the template.
    /// This member is required.
    public var status: ConnectCasesClientTypes.TemplateStatus?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?
    /// The Amazon Resource Name (ARN) of the template.
    /// This member is required.
    public var templateArn: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        description: Swift.String? = nil,
        layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration? = nil,
        name: Swift.String? = nil,
        requiredFields: [ConnectCasesClientTypes.RequiredField]? = nil,
        status: ConnectCasesClientTypes.TemplateStatus? = nil,
        tags: [Swift.String:Swift.String?]? = nil,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.description = description
        self.layoutConfiguration = layoutConfiguration
        self.name = name
        self.requiredFields = requiredFields
        self.status = status
        self.tags = tags
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct GetTemplateOutputResponseBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    let requiredFields: [ConnectCasesClientTypes.RequiredField]?
    let tags: [Swift.String:Swift.String?]?
    let status: ConnectCasesClientTypes.TemplateStatus?
}

extension GetTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
        case tags
        case templateArn
        case templateId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let layoutConfigurationDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutConfiguration.self, forKey: .layoutConfiguration)
        layoutConfiguration = layoutConfigurationDecoded
        let requiredFieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.RequiredField?].self, forKey: .requiredFields)
        var requiredFieldsDecoded0:[ConnectCasesClientTypes.RequiredField]? = nil
        if let requiredFieldsContainer = requiredFieldsContainer {
            requiredFieldsDecoded0 = [ConnectCasesClientTypes.RequiredField]()
            for structure0 in requiredFieldsContainer {
                if let structure0 = structure0 {
                    requiredFieldsDecoded0?.append(structure0)
                }
            }
        }
        requiredFields = requiredFieldsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We couldn't process your request because of an issue with the server. Try again later.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes.LayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLayout
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLayout = self.defaultLayout {
            try encodeContainer.encode(defaultLayout, forKey: .defaultLayout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLayoutDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultLayout)
        defaultLayout = defaultLayoutDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object to store configuration of layouts associated to the template.
    public struct LayoutConfiguration: Swift.Equatable {
        /// Unique identifier of a layout.
        public var defaultLayout: Swift.String?

        public init (
            defaultLayout: Swift.String? = nil
        )
        {
            self.defaultLayout = defaultLayout
        }
    }

}

extension ConnectCasesClientTypes.LayoutContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basic
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .basic(basic):
                try container.encode(basic, forKey: .basic)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let basicDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.BasicLayout.self, forKey: .basic)
        if let basic = basicDecoded {
            self = .basic(basic)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// Object to store union of different versions of layout content.
    public enum LayoutContent: Swift.Equatable {
        /// Content specific to BasicLayout type. It configures fields in the top panel and More Info tab of Cases user interface.
        case basic(ConnectCasesClientTypes.BasicLayout)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.LayoutSections: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sections
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sections = sections {
            var sectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sections)
            for section0 in sections {
                try sectionsContainer.encode(section0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.Section?].self, forKey: .sections)
        var sectionsDecoded0:[ConnectCasesClientTypes.Section]? = nil
        if let sectionsContainer = sectionsContainer {
            sectionsDecoded0 = [ConnectCasesClientTypes.Section]()
            for union0 in sectionsContainer {
                if let union0 = union0 {
                    sectionsDecoded0?.append(union0)
                }
            }
        }
        sections = sectionsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// Ordered list containing different kinds of sections that can be added. A LayoutSections object can only contain one section.
    public struct LayoutSections: Swift.Equatable {
        /// Ordered list containing different kinds of sections that can be added.
        public var sections: [ConnectCasesClientTypes.Section]?

        public init (
            sections: [ConnectCasesClientTypes.Section]? = nil
        )
        {
            self.sections = sections
        }
    }

}

extension ConnectCasesClientTypes.LayoutSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layoutArn
        case layoutId
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layoutArn = self.layoutArn {
            try encodeContainer.encode(layoutArn, forKey: .layoutArn)
        }
        if let layoutId = self.layoutId {
            try encodeContainer.encode(layoutId, forKey: .layoutId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutId)
        layoutId = layoutIdDecoded
        let layoutArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutArn)
        layoutArn = layoutArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for the summarized details of the layout.
    public struct LayoutSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the layout.
        /// This member is required.
        public var layoutArn: Swift.String?
        /// The unique identifier for of the layout.
        /// This member is required.
        public var layoutId: Swift.String?
        /// The name of the layout.
        /// This member is required.
        public var name: Swift.String?

        public init (
            layoutArn: Swift.String? = nil,
            layoutId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.layoutArn = layoutArn
            self.layoutId = layoutId
            self.name = name
        }
    }

}

extension ListCasesForContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCasesForContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/list-cases-for-contact"
    }
}

public struct ListCasesForContactInput: Swift.Equatable {
    /// A unique identifier of a contact in Amazon Connect.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        contactArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCasesForContactInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCasesForContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCasesForContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCasesForContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCasesForContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCasesForContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCasesForContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cases = output.cases
            self.nextToken = output.nextToken
        } else {
            self.cases = nil
            self.nextToken = nil
        }
    }
}

public struct ListCasesForContactOutputResponse: Swift.Equatable {
    /// A list of Case summary information.
    /// This member is required.
    public var cases: [ConnectCasesClientTypes.CaseSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        cases: [ConnectCasesClientTypes.CaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

struct ListCasesForContactOutputResponseBody: Swift.Equatable {
    let cases: [ConnectCasesClientTypes.CaseSummary]?
    let nextToken: Swift.String?
}

extension ListCasesForContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cases
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let casesContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.CaseSummary?].self, forKey: .cases)
        var casesDecoded0:[ConnectCasesClientTypes.CaseSummary]? = nil
        if let casesContainer = casesContainer {
            casesDecoded0 = [ConnectCasesClientTypes.CaseSummary]()
            for structure0 in casesContainer {
                if let structure0 = structure0 {
                    casesDecoded0?.append(structure0)
                }
            }
        }
        cases = casesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domains-list"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
}

extension ListDomainsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDomainsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Swift.Equatable {
    /// The Cases domain.
    /// This member is required.
    public var domains: [ConnectCasesClientTypes.DomainSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        domains: [ConnectCasesClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Swift.Equatable {
    let domains: [ConnectCasesClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[ConnectCasesClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [ConnectCasesClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFieldOptionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let values = values {
                values.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "values".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListFieldOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let fieldId = fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())/options-list"
    }
}

public struct ListFieldOptionsInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of FieldOption values to filter on for ListFieldOptions.
    public var values: [Swift.String]?

    public init (
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.domainId = domainId
        self.fieldId = fieldId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.values = values
    }
}

struct ListFieldOptionsInputBody: Swift.Equatable {
}

extension ListFieldOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFieldOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFieldOptionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFieldOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.options = output.options
        } else {
            self.nextToken = nil
            self.options = nil
        }
    }
}

public struct ListFieldOptionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of FieldOption objects.
    /// This member is required.
    public var options: [ConnectCasesClientTypes.FieldOption]?

    public init (
        nextToken: Swift.String? = nil,
        options: [ConnectCasesClientTypes.FieldOption]? = nil
    )
    {
        self.nextToken = nextToken
        self.options = options
    }
}

struct ListFieldOptionsOutputResponseBody: Swift.Equatable {
    let options: [ConnectCasesClientTypes.FieldOption]?
    let nextToken: Swift.String?
}

extension ListFieldOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case options
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldOption?].self, forKey: .options)
        var optionsDecoded0:[ConnectCasesClientTypes.FieldOption]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [ConnectCasesClientTypes.FieldOption]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFieldsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListFieldsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields-list"
    }
}

public struct ListFieldsInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFieldsInputBody: Swift.Equatable {
}

extension ListFieldsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFieldsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFieldsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFieldsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.nextToken = output.nextToken
        } else {
            self.fields = nil
            self.nextToken = nil
        }
    }
}

public struct ListFieldsOutputResponse: Swift.Equatable {
    /// List of detailed field information.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        fields: [ConnectCasesClientTypes.FieldSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fields = fields
        self.nextToken = nextToken
    }
}

struct ListFieldsOutputResponseBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldSummary]?
    let nextToken: Swift.String?
}

extension ListFieldsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldSummary?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldSummary]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldSummary]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLayoutsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListLayoutsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts-list"
    }
}

public struct ListLayoutsInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLayoutsInputBody: Swift.Equatable {
}

extension ListLayoutsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLayoutsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLayoutsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLayoutsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLayoutsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLayoutsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layouts = output.layouts
            self.nextToken = output.nextToken
        } else {
            self.layouts = nil
            self.nextToken = nil
        }
    }
}

public struct ListLayoutsOutputResponse: Swift.Equatable {
    /// The layouts for the domain.
    /// This member is required.
    public var layouts: [ConnectCasesClientTypes.LayoutSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        layouts: [ConnectCasesClientTypes.LayoutSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.layouts = layouts
        self.nextToken = nextToken
    }
}

struct ListLayoutsOutputResponseBody: Swift.Equatable {
    let layouts: [ConnectCasesClientTypes.LayoutSummary]?
    let nextToken: Swift.String?
}

extension ListLayoutsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layouts
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.LayoutSummary?].self, forKey: .layouts)
        var layoutsDecoded0:[ConnectCasesClientTypes.LayoutSummary]? = nil
        if let layoutsContainer = layoutsContainer {
            layoutsDecoded0 = [ConnectCasesClientTypes.LayoutSummary]()
            for structure0 in layoutsContainer {
                if let structure0 = structure0 {
                    layoutsDecoded0?.append(structure0)
                }
            }
        }
        layouts = layoutsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN)
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?

    public init (
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String?]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let status = status {
                status.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates-list"
    }
}

public struct ListTemplatesInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of status values to filter on.
    public var status: [ConnectCasesClientTypes.TemplateStatus]?

    public init (
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: [ConnectCasesClientTypes.TemplateStatus]? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListTemplatesInputBody: Swift.Equatable {
}

extension ListTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTemplatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templates = output.templates
        } else {
            self.nextToken = nil
            self.templates = nil
        }
    }
}

public struct ListTemplatesOutputResponse: Swift.Equatable {
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// List of template summary objects.
    /// This member is required.
    public var templates: [ConnectCasesClientTypes.TemplateSummary]?

    public init (
        nextToken: Swift.String? = nil,
        templates: [ConnectCasesClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

struct ListTemplatesOutputResponseBody: Swift.Equatable {
    let templates: [ConnectCasesClientTypes.TemplateSummary]?
    let nextToken: Swift.String?
}

extension ListTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templates
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.TemplateSummary?].self, forKey: .templates)
        var templatesDecoded0:[ConnectCasesClientTypes.TemplateSummary]? = nil
        if let templatesContainer = templatesContainer {
            templatesDecoded0 = [ConnectCasesClientTypes.TemplateSummary]()
            for structure0 in templatesContainer {
                if let structure0 = structure0 {
                    templatesDecoded0?.append(structure0)
                }
            }
        }
        templates = templatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ConnectCasesClientTypes {
    public enum Order: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Asc"
            case .descending: return "Desc"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
        }
    }
}

extension PutCaseEventConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBridge
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBridge = self.eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
    }
}

extension PutCaseEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/case-event-configuration"
    }
}

public struct PutCaseEventConfigurationInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
    /// This member is required.
    public var eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?

    public init (
        domainId: Swift.String? = nil,
        eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration? = nil
    )
    {
        self.domainId = domainId
        self.eventBridge = eventBridge
    }
}

struct PutCaseEventConfigurationInputBody: Swift.Equatable {
    let eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?
}

extension PutCaseEventConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBridge
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBridgeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.EventBridgeConfiguration.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
    }
}

extension PutCaseEventConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCaseEventConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutCaseEventConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCaseEventConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutCaseEventConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension ConnectCasesClientTypes.RelatedItemContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case contact
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .comment(comment):
                try container.encode(comment, forKey: .comment)
            case let .contact(contact):
                try container.encode(contact, forKey: .contact)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.ContactContent.self, forKey: .contact)
        if let contact = contactDecoded {
            self = .contact(contact)
            return
        }
        let commentDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.CommentContent.self, forKey: .comment)
        if let comment = commentDecoded {
            self = .comment(comment)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// Represents the content of a particular type of related item.
    public enum RelatedItemContent: Swift.Equatable {
        /// Represents the content of a contact to be returned to agents.
        case contact(ConnectCasesClientTypes.ContactContent)
        /// Represents the content of a comment to be returned to agents.
        case comment(ConnectCasesClientTypes.CommentContent)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.RelatedItemEventIncludedData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeContent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeContent = self.includeContent {
            try encodeContainer.encode(includeContent, forKey: .includeContent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeContentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeContent)
        includeContent = includeContentDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Details of what related item data is published through the case event stream.
    public struct RelatedItemEventIncludedData: Swift.Equatable {
        /// Details of what related item data is published through the case event stream.
        /// This member is required.
        public var includeContent: Swift.Bool?

        public init (
            includeContent: Swift.Bool? = nil
        )
        {
            self.includeContent = includeContent
        }
    }

}

extension ConnectCasesClientTypes.RelatedItemInputContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case contact
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .comment(comment):
                try container.encode(comment, forKey: .comment)
            case let .contact(contact):
                try container.encode(contact, forKey: .contact)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.Contact.self, forKey: .contact)
        if let contact = contactDecoded {
            self = .contact(contact)
            return
        }
        let commentDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.CommentContent.self, forKey: .comment)
        if let comment = commentDecoded {
            self = .comment(comment)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// Represents the content of a related item to be created.
    public enum RelatedItemInputContent: Swift.Equatable {
        /// Object representing a contact in Amazon Connect as an API request field.
        case contact(ConnectCasesClientTypes.Contact)
        /// Represents the content of a comment to be returned to agents.
        case comment(ConnectCasesClientTypes.CommentContent)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes {
    public enum RelatedItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case comment
        case contact
        case sdkUnknown(Swift.String)

        public static var allCases: [RelatedItemType] {
            return [
                .comment,
                .contact,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .comment: return "Comment"
            case .contact: return "Contact"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelatedItemType(rawValue: rawValue) ?? RelatedItemType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.RelatedItemTypeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case contact
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .comment(comment):
                try container.encode(comment, forKey: .comment)
            case let .contact(contact):
                try container.encode(contact, forKey: .contact)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.ContactFilter.self, forKey: .contact)
        if let contact = contactDecoded {
            self = .contact(contact)
            return
        }
        let commentDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.CommentFilter.self, forKey: .comment)
        if let comment = commentDecoded {
            self = .comment(comment)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// The list of types of related items and their parameters to use for filtering.
    public enum RelatedItemTypeFilter: Swift.Equatable {
        /// A filter for related items of type Contact.
        case contact(ConnectCasesClientTypes.ContactFilter)
        /// A filter for related items of type Comment.
        case comment(ConnectCasesClientTypes.CommentFilter)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.RequiredField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
    }
}

extension ConnectCasesClientTypes {
    /// List of fields that must have a value provided to create a case.
    public struct RequiredField: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var fieldId: Swift.String?

        public init (
            fieldId: Swift.String? = nil
        )
        {
            self.fieldId = fieldId
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Unique identifier of the resource affected.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SearchCasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case filter
        case maxResults
        case nextToken
        case searchTerm
        case sorts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldidentifier0 in fields {
                try fieldsContainer.encode(fieldidentifier0)
            }
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchTerm = self.searchTerm {
            try encodeContainer.encode(searchTerm, forKey: .searchTerm)
        }
        if let sorts = sorts {
            var sortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sorts)
            for sort0 in sorts {
                try sortsContainer.encode(sort0)
            }
        }
    }
}

extension SearchCasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases-search"
    }
}

public struct SearchCasesInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The list of field identifiers to be returned as part of the response.
    public var fields: [ConnectCasesClientTypes.FieldIdentifier]?
    /// A list of filter objects.
    public var filter: ConnectCasesClientTypes.CaseFilter?
    /// The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A word or phrase used to perform a quick search.
    public var searchTerm: Swift.String?
    /// A list of sorts where each sort specifies a field and their sort order to be applied to the results.
    public var sorts: [ConnectCasesClientTypes.Sort]?

    public init (
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil,
        filter: ConnectCasesClientTypes.CaseFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchTerm: Swift.String? = nil,
        sorts: [ConnectCasesClientTypes.Sort]? = nil
    )
    {
        self.domainId = domainId
        self.fields = fields
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchTerm = searchTerm
        self.sorts = sorts
    }
}

struct SearchCasesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let searchTerm: Swift.String?
    let filter: ConnectCasesClientTypes.CaseFilter?
    let sorts: [ConnectCasesClientTypes.Sort]?
    let fields: [ConnectCasesClientTypes.FieldIdentifier]?
}

extension SearchCasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case filter
        case maxResults
        case nextToken
        case searchTerm
        case sorts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let searchTermDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchTerm)
        searchTerm = searchTermDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.CaseFilter.self, forKey: .filter)
        filter = filterDecoded
        let sortsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.Sort?].self, forKey: .sorts)
        var sortsDecoded0:[ConnectCasesClientTypes.Sort]? = nil
        if let sortsContainer = sortsContainer {
            sortsDecoded0 = [ConnectCasesClientTypes.Sort]()
            for structure0 in sortsContainer {
                if let structure0 = structure0 {
                    sortsDecoded0?.append(structure0)
                }
            }
        }
        sorts = sortsDecoded0
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldIdentifier?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldIdentifier]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldIdentifier]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension SearchCasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchCasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchCasesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchCasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchCasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cases = output.cases
            self.nextToken = output.nextToken
        } else {
            self.cases = nil
            self.nextToken = nil
        }
    }
}

public struct SearchCasesOutputResponse: Swift.Equatable {
    /// A list of case documents where each case contains the properties CaseId and Fields where each field is a complex union structure.
    /// This member is required.
    public var cases: [ConnectCasesClientTypes.SearchCasesResponseItem?]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        cases: [ConnectCasesClientTypes.SearchCasesResponseItem?]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

struct SearchCasesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let cases: [ConnectCasesClientTypes.SearchCasesResponseItem?]?
}

extension SearchCasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cases
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let casesContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.SearchCasesResponseItem?].self, forKey: .cases)
        var casesDecoded0:[ConnectCasesClientTypes.SearchCasesResponseItem?]? = nil
        if let casesContainer = casesContainer {
            casesDecoded0 = [ConnectCasesClientTypes.SearchCasesResponseItem?]()
            for structure0 in casesContainer {
                casesDecoded0?.append(structure0)
            }
        }
        cases = casesDecoded0
    }
}

extension ConnectCasesClientTypes.SearchCasesResponseItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
        case fields
        case tags
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = self.caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldvalue0 in fields {
                try fieldsContainer.encode(fieldvalue0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// A list of items that represent cases.
    public struct SearchCasesResponseItem: Swift.Equatable {
        /// A unique identifier of the case.
        /// This member is required.
        public var caseId: Swift.String?
        /// List of case field values.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.FieldValue]?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String?]?
        /// A unique identifier of a template.
        /// This member is required.
        public var templateId: Swift.String?

        public init (
            caseId: Swift.String? = nil,
            fields: [ConnectCasesClientTypes.FieldValue]? = nil,
            tags: [Swift.String:Swift.String?]? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.fields = fields
            self.tags = tags
            self.templateId = templateId
        }
    }

}

extension SearchRelatedItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for relateditemtypefilter0 in filters {
                try filtersContainer.encode(relateditemtypefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchRelatedItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let caseId = caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())/related-items-search"
    }
}

public struct SearchRelatedItemsInput: Swift.Equatable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The list of types of related items and their parameters to use for filtering.
    public var filters: [ConnectCasesClientTypes.RelatedItemTypeFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        filters: [ConnectCasesClientTypes.RelatedItemTypeFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchRelatedItemsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [ConnectCasesClientTypes.RelatedItemTypeFilter]?
}

extension SearchRelatedItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.RelatedItemTypeFilter?].self, forKey: .filters)
        var filtersDecoded0:[ConnectCasesClientTypes.RelatedItemTypeFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ConnectCasesClientTypes.RelatedItemTypeFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchRelatedItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchRelatedItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchRelatedItemsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchRelatedItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchRelatedItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.relatedItems = output.relatedItems
        } else {
            self.nextToken = nil
            self.relatedItems = nil
        }
    }
}

public struct SearchRelatedItemsOutputResponse: Swift.Equatable {
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of items related to a case.
    /// This member is required.
    public var relatedItems: [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]?

    public init (
        nextToken: Swift.String? = nil,
        relatedItems: [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]? = nil
    )
    {
        self.nextToken = nextToken
        self.relatedItems = relatedItems
    }
}

struct SearchRelatedItemsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let relatedItems: [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]?
}

extension SearchRelatedItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case relatedItems
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let relatedItemsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.SearchRelatedItemsResponseItem?].self, forKey: .relatedItems)
        var relatedItemsDecoded0:[ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]? = nil
        if let relatedItemsContainer = relatedItemsContainer {
            relatedItemsDecoded0 = [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]()
            for structure0 in relatedItemsContainer {
                relatedItemsDecoded0?.append(structure0)
            }
        }
        relatedItems = relatedItemsDecoded0
    }
}

extension ConnectCasesClientTypes.SearchRelatedItemsResponseItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationTime
        case content
        case relatedItemId
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationTime = self.associationTime {
            try encodeContainer.encodeTimestamp(associationTime, format: .dateTime, forKey: .associationTime)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let relatedItemId = self.relatedItemId {
            try encodeContainer.encode(relatedItemId, forKey: .relatedItemId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedItemId)
        relatedItemId = relatedItemIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemType.self, forKey: .type)
        type = typeDecoded
        let associationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .associationTime)
        associationTime = associationTimeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemContent.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// A list of items that represent RelatedItems.
    public struct SearchRelatedItemsResponseItem: Swift.Equatable {
        /// Time at which a related item was associated with a case.
        /// This member is required.
        public var associationTime: ClientRuntime.Date?
        /// Represents the content of a particular type of related item.
        /// This member is required.
        public var content: ConnectCasesClientTypes.RelatedItemContent?
        /// Unique identifier of a related item.
        /// This member is required.
        public var relatedItemId: Swift.String?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String?]?
        /// Type of a related item.
        /// This member is required.
        public var type: ConnectCasesClientTypes.RelatedItemType?

        public init (
            associationTime: ClientRuntime.Date? = nil,
            content: ConnectCasesClientTypes.RelatedItemContent? = nil,
            relatedItemId: Swift.String? = nil,
            tags: [Swift.String:Swift.String?]? = nil,
            type: ConnectCasesClientTypes.RelatedItemType? = nil
        )
        {
            self.associationTime = associationTime
            self.content = content
            self.relatedItemId = relatedItemId
            self.tags = tags
            self.type = type
        }
    }

}

extension ConnectCasesClientTypes.Section: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldgroup = "fieldGroup"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .fieldgroup(fieldgroup):
                try container.encode(fieldgroup, forKey: .fieldgroup)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fieldgroupDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldGroup.self, forKey: .fieldgroup)
        if let fieldgroup = fieldgroupDecoded {
            self = .fieldgroup(fieldgroup)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// This represents a sections within a panel or tab of the page layout.
    public enum Section: Swift.Equatable {
        /// Consists of a group of fields and associated properties.
        case fieldgroup(ConnectCasesClientTypes.FieldGroup)
        case sdkUnknown(Swift.String)
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service quota has been exceeded. For a list of service quotas, see [Amazon Connect Service Quotas](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html) in the Amazon Connect Administrator Guide.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes.Sort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.Order.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ConnectCasesClientTypes {
    /// A structured set of sort terms.
    public struct Sort: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// A structured set of sort terms
        /// This member is required.
        public var sortOrder: ConnectCasesClientTypes.Order?

        public init (
            fieldId: Swift.String? = nil,
            sortOrder: ConnectCasesClientTypes.Order? = nil
        )
        {
            self.fieldId = fieldId
            self.sortOrder = sortOrder
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN)
    /// This member is required.
    public var arn: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String?]?

    public init (
        arn: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String?]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ConnectCasesClientTypes {
    public enum TemplateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateStatus(rawValue: rawValue) ?? TemplateStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.TemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
        case templateArn
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let templateArn = self.templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Template summary information.
    public struct TemplateSummary: Swift.Equatable {
        /// The template name.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the template.
        /// This member is required.
        public var status: ConnectCasesClientTypes.TemplateStatus?
        /// The Amazon Resource Name (ARN) of the template.
        /// This member is required.
        public var templateArn: Swift.String?
        /// The unique identifier for the template.
        /// This member is required.
        public var templateId: Swift.String?

        public init (
            name: Swift.String? = nil,
            status: ConnectCasesClientTypes.TemplateStatus? = nil,
            templateArn: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The rate has been exceeded for this API. Please try again after a few minutes.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN)
    /// This member is required.
    public var arn: Swift.String?
    /// List of tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateCaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldvalue0 in fields {
                try fieldsContainer.encode(fieldvalue0)
            }
        }
    }
}

extension UpdateCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let caseId = caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())"
    }
}

public struct UpdateCaseInput: Swift.Equatable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// An array of objects with fieldId (matching ListFields/DescribeField) and value union data, structured identical to CreateCase.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldValue]?

    public init (
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldValue]? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.fields = fields
    }
}

struct UpdateCaseInputBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldValue]?
}

extension UpdateCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension UpdateCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCaseOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateFieldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateFieldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let fieldId = fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())"
    }
}

public struct UpdateFieldInput: Swift.Equatable {
    /// The description of a field.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?
    /// The name of the field.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.fieldId = fieldId
        self.name = name
    }
}

struct UpdateFieldInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateFieldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateFieldOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFieldOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFieldOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFieldOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFieldOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateLayoutInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateLayoutInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let layoutId = layoutId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts/\(layoutId.urlPercentEncoding())"
    }
}

public struct UpdateLayoutInput: Swift.Equatable {
    /// Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field.
    public var content: ConnectCasesClientTypes.LayoutContent?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?
    /// The name of the layout. It must be unique per domain.
    public var name: Swift.String?

    public init (
        content: ConnectCasesClientTypes.LayoutContent? = nil,
        domainId: Swift.String? = nil,
        layoutId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.content = content
        self.domainId = domainId
        self.layoutId = layoutId
        self.name = name
    }
}

struct UpdateLayoutInputBody: Swift.Equatable {
    let name: Swift.String?
    let content: ConnectCasesClientTypes.LayoutContent?
}

extension UpdateLayoutInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateLayoutOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLayoutOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLayoutOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLayoutOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLayoutOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let layoutConfiguration = self.layoutConfiguration {
            try encodeContainer.encode(layoutConfiguration, forKey: .layoutConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredFields = requiredFields {
            var requiredFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredFields)
            for requiredfield0 in requiredFields {
                try requiredFieldsContainer.encode(requiredfield0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct UpdateTemplateInput: Swift.Equatable {
    /// A brief description of the template.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Configuration of layouts associated to the template.
    public var layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    /// The name of the template. It must be unique per domain.
    public var name: Swift.String?
    /// A list of fields that must contain a value for a case to be successfully created with this template.
    public var requiredFields: [ConnectCasesClientTypes.RequiredField]?
    /// The status of the template.
    public var status: ConnectCasesClientTypes.TemplateStatus?
    /// A unique identifier for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init (
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration? = nil,
        name: Swift.String? = nil,
        requiredFields: [ConnectCasesClientTypes.RequiredField]? = nil,
        status: ConnectCasesClientTypes.TemplateStatus? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.layoutConfiguration = layoutConfiguration
        self.name = name
        self.requiredFields = requiredFields
        self.status = status
        self.templateId = templateId
    }
}

struct UpdateTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    let requiredFields: [ConnectCasesClientTypes.RequiredField]?
    let status: ConnectCasesClientTypes.TemplateStatus?
}

extension UpdateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let layoutConfigurationDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutConfiguration.self, forKey: .layoutConfiguration)
        layoutConfiguration = layoutConfigurationDecoded
        let requiredFieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.RequiredField?].self, forKey: .requiredFields)
        var requiredFieldsDecoded0:[ConnectCasesClientTypes.RequiredField]? = nil
        if let requiredFieldsContainer = requiredFieldsContainer {
            requiredFieldsDecoded0 = [ConnectCasesClientTypes.RequiredField]()
            for structure0 in requiredFieldsContainer {
                if let structure0 = structure0 {
                    requiredFieldsDecoded0?.append(structure0)
                }
            }
        }
        requiredFields = requiredFieldsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTemplateOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request isn't valid. Check the syntax and try again.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
