// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes.BasicLayout: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moreInfo
        case topPanel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moreInfo = self.moreInfo {
            try encodeContainer.encode(moreInfo, forKey: .moreInfo)
        }
        if let topPanel = self.topPanel {
            try encodeContainer.encode(topPanel, forKey: .topPanel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topPanelDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutSections.self, forKey: .topPanel)
        topPanel = topPanelDecoded
        let moreInfoDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutSections.self, forKey: .moreInfo)
        moreInfo = moreInfoDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Content specific to BasicLayout type. It configures fields in the top panel and More Info tab of agent application.
    public struct BasicLayout: Swift.Equatable {
        /// This represents sections in a tab of the page layout.
        public var moreInfo: ConnectCasesClientTypes.LayoutSections?
        /// This represents sections in a panel of the page layout.
        public var topPanel: ConnectCasesClientTypes.LayoutSections?

        public init(
            moreInfo: ConnectCasesClientTypes.LayoutSections? = nil,
            topPanel: ConnectCasesClientTypes.LayoutSections? = nil
        )
        {
            self.moreInfo = moreInfo
            self.topPanel = topPanel
        }
    }

}

extension BatchGetFieldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldidentifier0 in fields {
                try fieldsContainer.encode(fieldidentifier0)
            }
        }
    }
}

extension BatchGetFieldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields-batch"
    }
}

public struct BatchGetFieldInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A list of unique field identifiers.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldIdentifier]?

    public init(
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil
    )
    {
        self.domainId = domainId
        self.fields = fields
    }
}

struct BatchGetFieldInputBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldIdentifier]?
}

extension BatchGetFieldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldIdentifier?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldIdentifier]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldIdentifier]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension BatchGetFieldOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetFieldOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.fields = output.fields
        } else {
            self.errors = nil
            self.fields = nil
        }
    }
}

public struct BatchGetFieldOutput: Swift.Equatable {
    /// A list of field errors.
    /// This member is required.
    public var errors: [ConnectCasesClientTypes.FieldError]?
    /// A list of detailed field information.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.GetFieldResponse]?

    public init(
        errors: [ConnectCasesClientTypes.FieldError]? = nil,
        fields: [ConnectCasesClientTypes.GetFieldResponse]? = nil
    )
    {
        self.errors = errors
        self.fields = fields
    }
}

struct BatchGetFieldOutputBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.GetFieldResponse]?
    let errors: [ConnectCasesClientTypes.FieldError]?
}

extension BatchGetFieldOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case fields
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.GetFieldResponse?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.GetFieldResponse]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.GetFieldResponse]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldError?].self, forKey: .errors)
        var errorsDecoded0:[ConnectCasesClientTypes.FieldError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ConnectCasesClientTypes.FieldError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetFieldOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchPutFieldOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = options {
            var optionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .options)
            for fieldoption0 in options {
                try optionsContainer.encode(fieldoption0)
            }
        }
    }
}

extension BatchPutFieldOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let fieldId = fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())/options"
    }
}

public struct BatchPutFieldOptionsInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?
    /// A list of FieldOption objects.
    /// This member is required.
    public var options: [ConnectCasesClientTypes.FieldOption]?

    public init(
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil,
        options: [ConnectCasesClientTypes.FieldOption]? = nil
    )
    {
        self.domainId = domainId
        self.fieldId = fieldId
        self.options = options
    }
}

struct BatchPutFieldOptionsInputBody: Swift.Equatable {
    let options: [ConnectCasesClientTypes.FieldOption]?
}

extension BatchPutFieldOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldOption?].self, forKey: .options)
        var optionsDecoded0:[ConnectCasesClientTypes.FieldOption]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [ConnectCasesClientTypes.FieldOption]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
    }
}

extension BatchPutFieldOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchPutFieldOptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchPutFieldOptionsOutput: Swift.Equatable {
    /// A list of field errors.
    public var errors: [ConnectCasesClientTypes.FieldOptionError]?

    public init(
        errors: [ConnectCasesClientTypes.FieldOptionError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchPutFieldOptionsOutputBody: Swift.Equatable {
    let errors: [ConnectCasesClientTypes.FieldOptionError]?
}

extension BatchPutFieldOptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldOptionError?].self, forKey: .errors)
        var errorsDecoded0:[ConnectCasesClientTypes.FieldOptionError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ConnectCasesClientTypes.FieldOptionError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchPutFieldOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCasesClientTypes.CaseEventIncludedData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldidentifier0 in fields {
                try fieldsContainer.encode(fieldidentifier0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldIdentifier?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldIdentifier]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldIdentifier]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// Details of what case data is published through the case event stream.
    public struct CaseEventIncludedData: Swift.Equatable {
        /// List of field identifiers.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.FieldIdentifier]?

        public init(
            fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil
        )
        {
            self.fields = fields
        }
    }

}

extension ConnectCasesClientTypes.CaseFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case andall = "andAll"
        case field
        case not
        case orall = "orAll"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .andall(andall):
                var andallContainer = container.nestedUnkeyedContainer(forKey: .andall)
                for casefilter0 in andall {
                    try andallContainer.encode(casefilter0)
                }
            case let .field(field):
                try container.encode(field, forKey: .field)
            case let .not(not):
                try container.encode(not, forKey: .not)
            case let .orall(orall):
                var orallContainer = container.nestedUnkeyedContainer(forKey: .orall)
                for casefilter0 in orall {
                    try orallContainer.encode(casefilter0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldFilter.self, forKey: .field)
        if let field = fieldDecoded {
            self = .field(field)
            return
        }
        let notDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.CaseFilter.self, forKey: .not)
        if let not = notDecoded {
            self = .not(not)
            return
        }
        let andallContainer = try values.decodeIfPresent([ConnectCasesClientTypes.CaseFilter?].self, forKey: .andall)
        var andallDecoded0:[ConnectCasesClientTypes.CaseFilter]? = nil
        if let andallContainer = andallContainer {
            andallDecoded0 = [ConnectCasesClientTypes.CaseFilter]()
            for union0 in andallContainer {
                if let union0 = union0 {
                    andallDecoded0?.append(union0)
                }
            }
        }
        if let andall = andallDecoded0 {
            self = .andall(andall)
            return
        }
        let orallContainer = try values.decodeIfPresent([ConnectCasesClientTypes.CaseFilter?].self, forKey: .orall)
        var orallDecoded0:[ConnectCasesClientTypes.CaseFilter]? = nil
        if let orallContainer = orallContainer {
            orallDecoded0 = [ConnectCasesClientTypes.CaseFilter]()
            for union0 in orallContainer {
                if let union0 = union0 {
                    orallDecoded0?.append(union0)
                }
            }
        }
        if let orall = orallDecoded0 {
            self = .orall(orall)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// A filter for cases. Only one value can be provided.
    public indirect enum CaseFilter: Swift.Equatable {
        /// A list of fields to filter on.
        case field(ConnectCasesClientTypes.FieldFilter)
        /// A filter for cases. Only one value can be provided.
        case not(ConnectCasesClientTypes.CaseFilter)
        /// Provides "and all" filtering.
        case andall([ConnectCasesClientTypes.CaseFilter])
        /// Provides "or all" filtering.
        case orall([ConnectCasesClientTypes.CaseFilter])
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.CaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = self.caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Case summary information.
    public struct CaseSummary: Swift.Equatable {
        /// A unique identifier of the case.
        /// This member is required.
        public var caseId: Swift.String?
        /// A unique identifier of a template.
        /// This member is required.
        public var templateId: Swift.String?

        public init(
            caseId: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.templateId = templateId
        }
    }

}

extension ConnectCasesClientTypes {
    public enum CommentBodyTextType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case plaintext
        case sdkUnknown(Swift.String)

        public static var allCases: [CommentBodyTextType] {
            return [
                .plaintext,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "Text/Plain"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommentBodyTextType(rawValue: rawValue) ?? CommentBodyTextType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.CommentContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case contentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.CommentBodyTextType.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Represents the content of a Comment to be returned to agents.
    public struct CommentContent: Swift.Equatable {
        /// Text in the body of a Comment on a case.
        /// This member is required.
        public var body: Swift.String?
        /// Type of the text in the box of a Comment on a case.
        /// This member is required.
        public var contentType: ConnectCasesClientTypes.CommentBodyTextType?

        public init(
            body: Swift.String? = nil,
            contentType: ConnectCasesClientTypes.CommentBodyTextType? = nil
        )
        {
            self.body = body
            self.contentType = contentType
        }
    }

}

extension ConnectCasesClientTypes.CommentFilter: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ConnectCasesClientTypes {
    /// A filter for related items of type Comment.
    public struct CommentFilter: Swift.Equatable {

        public init() { }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes.Contact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension ConnectCasesClientTypes {
    /// An object that represents an Amazon Connect contact object.
    public struct Contact: Swift.Equatable {
        /// A unique identifier of a contact in Amazon Connect.
        /// This member is required.
        public var contactArn: Swift.String?

        public init(
            contactArn: Swift.String? = nil
        )
        {
            self.contactArn = contactArn
        }
    }

}

extension ConnectCasesClientTypes.ContactContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case connectedToSystemTime
        case contactArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let connectedToSystemTime = self.connectedToSystemTime {
            try encodeContainer.encodeTimestamp(connectedToSystemTime, format: .dateTime, forKey: .connectedToSystemTime)
        }
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let channelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channel)
        channel = channelDecoded
        let connectedToSystemTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .connectedToSystemTime)
        connectedToSystemTime = connectedToSystemTimeDecoded
    }
}

extension ConnectCasesClientTypes {
    /// An object that represents a content of an Amazon Connect contact object.
    public struct ContactContent: Swift.Equatable {
        /// A list of channels to filter on for related items of type Contact.
        /// This member is required.
        public var channel: Swift.String?
        /// The difference between the InitiationTimestamp and the DisconnectTimestamp of the contact.
        /// This member is required.
        public var connectedToSystemTime: ClientRuntime.Date?
        /// A unique identifier of a contact in Amazon Connect.
        /// This member is required.
        public var contactArn: Swift.String?

        public init(
            channel: Swift.String? = nil,
            connectedToSystemTime: ClientRuntime.Date? = nil,
            contactArn: Swift.String? = nil
        )
        {
            self.channel = channel
            self.connectedToSystemTime = connectedToSystemTime
            self.contactArn = contactArn
        }
    }

}

extension ConnectCasesClientTypes.ContactFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case contactArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = channel {
            var channelContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channel)
            for channel0 in channel {
                try channelContainer.encode(channel0)
            }
        }
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .channel)
        var channelDecoded0:[Swift.String]? = nil
        if let channelContainer = channelContainer {
            channelDecoded0 = [Swift.String]()
            for string0 in channelContainer {
                if let string0 = string0 {
                    channelDecoded0?.append(string0)
                }
            }
        }
        channel = channelDecoded0
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension ConnectCasesClientTypes {
    /// A filter for related items of type Contact.
    public struct ContactFilter: Swift.Equatable {
        /// A list of channels to filter on for related items of type Contact.
        public var channel: [Swift.String]?
        /// A unique identifier of a contact in Amazon Connect.
        public var contactArn: Swift.String?

        public init(
            channel: [Swift.String]? = nil,
            contactArn: Swift.String? = nil
        )
        {
            self.channel = channel
            self.contactArn = contactArn
        }
    }

}

extension CreateCaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case fields
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldvalue0 in fields {
                try fieldsContainer.encode(fieldvalue0)
            }
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }
}

extension CreateCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases"
    }
}

public struct CreateCaseInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// An array of objects with field ID (matching ListFields/DescribeField) and value union data.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldValue]?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldValue]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainId = domainId
        self.fields = fields
        self.templateId = templateId
    }
}

struct CreateCaseInputBody: Swift.Equatable {
    let templateId: Swift.String?
    let fields: [ConnectCasesClientTypes.FieldValue]?
    let clientToken: Swift.String?
}

extension CreateCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case fields
        case templateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateCaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.caseArn = output.caseArn
            self.caseId = output.caseId
        } else {
            self.caseArn = nil
            self.caseId = nil
        }
    }
}

public struct CreateCaseOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the case.
    /// This member is required.
    public var caseArn: Swift.String?
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?

    public init(
        caseArn: Swift.String? = nil,
        caseId: Swift.String? = nil
    )
    {
        self.caseArn = caseArn
        self.caseId = caseId
    }
}

struct CreateCaseOutputBody: Swift.Equatable {
    let caseId: Swift.String?
    let caseArn: Swift.String?
}

extension CreateCaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseArn
        case caseId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let caseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseArn)
        caseArn = caseArnDecoded
    }
}

enum CreateCaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domains"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// The name for your Cases domain. It must be unique for your Amazon Web Services account.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainArn = output.domainArn
            self.domainId = output.domainId
            self.domainStatus = output.domainStatus
        } else {
            self.domainArn = nil
            self.domainId = nil
            self.domainStatus = nil
        }
    }
}

public struct CreateDomainOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the Cases domain.
    /// This member is required.
    public var domainArn: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The status of the domain.
    /// This member is required.
    public var domainStatus: ConnectCasesClientTypes.DomainStatus?

    public init(
        domainArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        domainStatus: ConnectCasesClientTypes.DomainStatus? = nil
    )
    {
        self.domainArn = domainArn
        self.domainId = domainId
        self.domainStatus = domainStatus
    }
}

struct CreateDomainOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let domainArn: Swift.String?
    let domainStatus: ConnectCasesClientTypes.DomainStatus?
}

extension CreateDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainArn
        case domainId
        case domainStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainArn)
        domainArn = domainArnDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

enum CreateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFieldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateFieldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields"
    }
}

public struct CreateFieldInput: Swift.Equatable {
    /// The description of the field.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the field.
    /// This member is required.
    public var name: Swift.String?
    /// Defines the data type, some system constraints, and default display of the field.
    /// This member is required.
    public var type: ConnectCasesClientTypes.FieldType?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        type: ConnectCasesClientTypes.FieldType? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.type = type
    }
}

struct CreateFieldInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: ConnectCasesClientTypes.FieldType?
    let description: Swift.String?
}

extension CreateFieldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateFieldOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFieldOutputBody = try responseDecoder.decode(responseBody: data)
            self.fieldArn = output.fieldArn
            self.fieldId = output.fieldId
        } else {
            self.fieldArn = nil
            self.fieldId = nil
        }
    }
}

public struct CreateFieldOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the field.
    /// This member is required.
    public var fieldArn: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?

    public init(
        fieldArn: Swift.String? = nil,
        fieldId: Swift.String? = nil
    )
    {
        self.fieldArn = fieldArn
        self.fieldId = fieldId
    }
}

struct CreateFieldOutputBody: Swift.Equatable {
    let fieldId: Swift.String?
    let fieldArn: Swift.String?
}

extension CreateFieldOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldArn
        case fieldId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let fieldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldArn)
        fieldArn = fieldArnDecoded
    }
}

enum CreateFieldOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLayoutInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateLayoutInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts"
    }
}

public struct CreateLayoutInput: Swift.Equatable {
    /// Information about which fields will be present in the layout, and information about the order of the fields.
    /// This member is required.
    public var content: ConnectCasesClientTypes.LayoutContent?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the layout. It must be unique for the Cases domain.
    /// This member is required.
    public var name: Swift.String?

    public init(
        content: ConnectCasesClientTypes.LayoutContent? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.content = content
        self.domainId = domainId
        self.name = name
    }
}

struct CreateLayoutInputBody: Swift.Equatable {
    let name: Swift.String?
    let content: ConnectCasesClientTypes.LayoutContent?
}

extension CreateLayoutInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension CreateLayoutOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLayoutOutputBody = try responseDecoder.decode(responseBody: data)
            self.layoutArn = output.layoutArn
            self.layoutId = output.layoutId
        } else {
            self.layoutArn = nil
            self.layoutId = nil
        }
    }
}

public struct CreateLayoutOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created layout.
    /// This member is required.
    public var layoutArn: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?

    public init(
        layoutArn: Swift.String? = nil,
        layoutId: Swift.String? = nil
    )
    {
        self.layoutArn = layoutArn
        self.layoutId = layoutId
    }
}

struct CreateLayoutOutputBody: Swift.Equatable {
    let layoutId: Swift.String?
    let layoutArn: Swift.String?
}

extension CreateLayoutOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layoutArn
        case layoutId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutId)
        layoutId = layoutIdDecoded
        let layoutArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutArn)
        layoutArn = layoutArnDecoded
    }
}

enum CreateLayoutOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRelatedItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateRelatedItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let caseId = caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())/related-items"
    }
}

public struct CreateRelatedItemInput: Swift.Equatable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The content of a related item to be created.
    /// This member is required.
    public var content: ConnectCasesClientTypes.RelatedItemInputContent?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The type of a related item.
    /// This member is required.
    public var type: ConnectCasesClientTypes.RelatedItemType?

    public init(
        caseId: Swift.String? = nil,
        content: ConnectCasesClientTypes.RelatedItemInputContent? = nil,
        domainId: Swift.String? = nil,
        type: ConnectCasesClientTypes.RelatedItemType? = nil
    )
    {
        self.caseId = caseId
        self.content = content
        self.domainId = domainId
        self.type = type
    }
}

struct CreateRelatedItemInputBody: Swift.Equatable {
    let type: ConnectCasesClientTypes.RelatedItemType?
    let content: ConnectCasesClientTypes.RelatedItemInputContent?
}

extension CreateRelatedItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemInputContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension CreateRelatedItemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRelatedItemOutputBody = try responseDecoder.decode(responseBody: data)
            self.relatedItemArn = output.relatedItemArn
            self.relatedItemId = output.relatedItemId
        } else {
            self.relatedItemArn = nil
            self.relatedItemId = nil
        }
    }
}

public struct CreateRelatedItemOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the related item.
    /// This member is required.
    public var relatedItemArn: Swift.String?
    /// The unique identifier of the related item.
    /// This member is required.
    public var relatedItemId: Swift.String?

    public init(
        relatedItemArn: Swift.String? = nil,
        relatedItemId: Swift.String? = nil
    )
    {
        self.relatedItemArn = relatedItemArn
        self.relatedItemId = relatedItemId
    }
}

struct CreateRelatedItemOutputBody: Swift.Equatable {
    let relatedItemId: Swift.String?
    let relatedItemArn: Swift.String?
}

extension CreateRelatedItemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relatedItemArn
        case relatedItemId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedItemId)
        relatedItemId = relatedItemIdDecoded
        let relatedItemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedItemArn)
        relatedItemArn = relatedItemArnDecoded
    }
}

enum CreateRelatedItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let layoutConfiguration = self.layoutConfiguration {
            try encodeContainer.encode(layoutConfiguration, forKey: .layoutConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredFields = requiredFields {
            var requiredFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredFields)
            for requiredfield0 in requiredFields {
                try requiredFieldsContainer.encode(requiredfield0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension CreateTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates"
    }
}

public struct CreateTemplateInput: Swift.Equatable {
    /// A brief description of the template.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Configuration of layouts associated to the template.
    public var layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    /// A name for the template. It must be unique per domain.
    /// This member is required.
    public var name: Swift.String?
    /// A list of fields that must contain a value for a case to be successfully created with this template.
    public var requiredFields: [ConnectCasesClientTypes.RequiredField]?
    /// The status of the template.
    public var status: ConnectCasesClientTypes.TemplateStatus?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration? = nil,
        name: Swift.String? = nil,
        requiredFields: [ConnectCasesClientTypes.RequiredField]? = nil,
        status: ConnectCasesClientTypes.TemplateStatus? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.layoutConfiguration = layoutConfiguration
        self.name = name
        self.requiredFields = requiredFields
        self.status = status
    }
}

struct CreateTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    let requiredFields: [ConnectCasesClientTypes.RequiredField]?
    let status: ConnectCasesClientTypes.TemplateStatus?
}

extension CreateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let layoutConfigurationDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutConfiguration.self, forKey: .layoutConfiguration)
        layoutConfiguration = layoutConfigurationDecoded
        let requiredFieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.RequiredField?].self, forKey: .requiredFields)
        var requiredFieldsDecoded0:[ConnectCasesClientTypes.RequiredField]? = nil
        if let requiredFieldsContainer = requiredFieldsContainer {
            requiredFieldsDecoded0 = [ConnectCasesClientTypes.RequiredField]()
            for structure0 in requiredFieldsContainer {
                if let structure0 = structure0 {
                    requiredFieldsDecoded0?.append(structure0)
                }
            }
        }
        requiredFields = requiredFieldsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.templateArn = nil
            self.templateId = nil
        }
    }
}

public struct CreateTemplateOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the newly created template.
    /// This member is required.
    public var templateArn: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct CreateTemplateOutputBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
}

extension CreateTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateArn
        case templateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
    }
}

enum CreateTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDomainOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCasesClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .creationFailed,
                .creationInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creationFailed: return "CreationFailed"
            case .creationInProgress: return "CreationInProgress"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainArn
        case domainId
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainArn = self.domainArn {
            try encodeContainer.encode(domainArn, forKey: .domainArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainArn)
        domainArn = domainArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for the summarized details of the domain.
    public struct DomainSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the domain.
        /// This member is required.
        public var domainArn: Swift.String?
        /// The unique identifier of the domain.
        /// This member is required.
        public var domainId: Swift.String?
        /// The name of the domain.
        /// This member is required.
        public var name: Swift.String?

        public init(
            domainArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.domainArn = domainArn
            self.domainId = domainId
            self.name = name
        }
    }

}

extension ConnectCasesClientTypes.EmptyFieldValue: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ConnectCasesClientTypes {
    /// An empty value. You cannot set EmptyFieldValue on a field that is required on a case template. This structure will never have any data members. It signifies an empty value on a case field.
    public struct EmptyFieldValue: Swift.Equatable {

        public init() { }
    }

}

extension ConnectCasesClientTypes.EventBridgeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case includedData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let includedData = self.includedData {
            try encodeContainer.encode(includedData, forKey: .includedData)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let includedDataDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.EventIncludedData.self, forKey: .includedData)
        includedData = includedDataDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
    public struct EventBridgeConfiguration: Swift.Equatable {
        /// Indicates whether the to broadcast case event data to the customer.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Details of what case and related item data is published through the case event stream.
        public var includedData: ConnectCasesClientTypes.EventIncludedData?

        public init(
            enabled: Swift.Bool? = nil,
            includedData: ConnectCasesClientTypes.EventIncludedData? = nil
        )
        {
            self.enabled = enabled
            self.includedData = includedData
        }
    }

}

extension ConnectCasesClientTypes.EventIncludedData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseData
        case relatedItemData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseData = self.caseData {
            try encodeContainer.encode(caseData, forKey: .caseData)
        }
        if let relatedItemData = self.relatedItemData {
            try encodeContainer.encode(relatedItemData, forKey: .relatedItemData)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseDataDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.CaseEventIncludedData.self, forKey: .caseData)
        caseData = caseDataDecoded
        let relatedItemDataDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemEventIncludedData.self, forKey: .relatedItemData)
        relatedItemData = relatedItemDataDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Details of what case and related item data is published through the case event stream.
    public struct EventIncludedData: Swift.Equatable {
        /// Details of what case data is published through the case event stream.
        public var caseData: ConnectCasesClientTypes.CaseEventIncludedData?
        /// Details of what related item data is published through the case event stream.
        public var relatedItemData: ConnectCasesClientTypes.RelatedItemEventIncludedData?

        public init(
            caseData: ConnectCasesClientTypes.CaseEventIncludedData? = nil,
            relatedItemData: ConnectCasesClientTypes.RelatedItemEventIncludedData? = nil
        )
        {
            self.caseData = caseData
            self.relatedItemData = relatedItemData
        }
    }

}

extension ConnectCasesClientTypes.FieldError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case id
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for errors on fields.
    public struct FieldError: Swift.Equatable {
        /// The error code from getting a field.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The field identifier that caused the error.
        /// This member is required.
        public var id: Swift.String?
        /// The error message from getting a field.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }
    }

}

extension ConnectCasesClientTypes.FieldFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contains
        case equalto = "equalTo"
        case greaterthan = "greaterThan"
        case greaterthanorequalto = "greaterThanOrEqualTo"
        case lessthan = "lessThan"
        case lessthanorequalto = "lessThanOrEqualTo"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .contains(contains):
                try container.encode(contains, forKey: .contains)
            case let .equalto(equalto):
                try container.encode(equalto, forKey: .equalto)
            case let .greaterthan(greaterthan):
                try container.encode(greaterthan, forKey: .greaterthan)
            case let .greaterthanorequalto(greaterthanorequalto):
                try container.encode(greaterthanorequalto, forKey: .greaterthanorequalto)
            case let .lessthan(lessthan):
                try container.encode(lessthan, forKey: .lessthan)
            case let .lessthanorequalto(lessthanorequalto):
                try container.encode(lessthanorequalto, forKey: .lessthanorequalto)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let equaltoDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .equalto)
        if let equalto = equaltoDecoded {
            self = .equalto(equalto)
            return
        }
        let containsDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .contains)
        if let contains = containsDecoded {
            self = .contains(contains)
            return
        }
        let greaterthanDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .greaterthan)
        if let greaterthan = greaterthanDecoded {
            self = .greaterthan(greaterthan)
            return
        }
        let greaterthanorequaltoDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .greaterthanorequalto)
        if let greaterthanorequalto = greaterthanorequaltoDecoded {
            self = .greaterthanorequalto(greaterthanorequalto)
            return
        }
        let lessthanDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .lessthan)
        if let lessthan = lessthanDecoded {
            self = .lessthan(lessthan)
            return
        }
        let lessthanorequaltoDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldValue.self, forKey: .lessthanorequalto)
        if let lessthanorequalto = lessthanorequaltoDecoded {
            self = .lessthanorequalto(lessthanorequalto)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// A filter for fields. Only one value can be provided.
    public enum FieldFilter: Swift.Equatable {
        /// Object containing field identifier and value information.
        case equalto(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case contains(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case greaterthan(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case greaterthanorequalto(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case lessthan(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case lessthanorequalto(ConnectCasesClientTypes.FieldValue)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.FieldGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fielditem0 in fields {
                try fieldsContainer.encode(fielditem0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldItem?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldItem]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldItem]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// Object for a group of fields and associated properties.
    public struct FieldGroup: Swift.Equatable {
        /// Represents an ordered list containing field related information.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.FieldItem]?
        /// Name of the field group.
        public var name: Swift.String?

        public init(
            fields: [ConnectCasesClientTypes.FieldItem]? = nil,
            name: Swift.String? = nil
        )
        {
            self.fields = fields
            self.name = name
        }
    }

}

extension ConnectCasesClientTypes.FieldIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for unique identifier of a field.
    public struct FieldIdentifier: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension ConnectCasesClientTypes.FieldItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for field related information.
    public struct FieldItem: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension ConnectCasesClientTypes {
    public enum FieldNamespace: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldNamespace] {
            return [
                .custom,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .system: return "System"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldNamespace(rawValue: rawValue) ?? FieldNamespace.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.FieldOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for field Options information.
    public struct FieldOption: Swift.Equatable {
        /// Describes whether the FieldOption is active (displayed) or inactive.
        /// This member is required.
        public var active: Swift.Bool?
        /// FieldOptionName has max length 100 and disallows trailing spaces.
        /// This member is required.
        public var name: Swift.String?
        /// FieldOptionValue has max length 100 and must be alphanumeric with hyphens and underscores.
        /// This member is required.
        public var value: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.active = active
            self.name = name
            self.value = value
        }
    }

}

extension ConnectCasesClientTypes.FieldOptionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for field Options errors.
    public struct FieldOptionError: Swift.Equatable {
        /// Error code from creating or updating field option.
        /// This member is required.
        public var errorCode: Swift.String?
        /// Error message from creating or updating field option.
        /// This member is required.
        public var message: Swift.String?
        /// The field option value that caused the error.
        /// This member is required.
        public var value: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
            self.value = value
        }
    }

}

extension ConnectCasesClientTypes.FieldSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldArn
        case fieldId
        case name
        case namespace
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldArn = self.fieldArn {
            try encodeContainer.encode(fieldArn, forKey: .fieldArn)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace.rawValue, forKey: .namespace)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let fieldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldArn)
        fieldArn = fieldArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldType.self, forKey: .type)
        type = typeDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldNamespace.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for the summarized details of the field.
    public struct FieldSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the field.
        /// This member is required.
        public var fieldArn: Swift.String?
        /// The unique identifier of a field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// Name of the field.
        /// This member is required.
        public var name: Swift.String?
        /// The namespace of a field.
        /// This member is required.
        public var namespace: ConnectCasesClientTypes.FieldNamespace?
        /// The type of a field.
        /// This member is required.
        public var type: ConnectCasesClientTypes.FieldType?

        public init(
            fieldArn: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: ConnectCasesClientTypes.FieldNamespace? = nil,
            type: ConnectCasesClientTypes.FieldType? = nil
        )
        {
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.type = type
        }
    }

}

extension ConnectCasesClientTypes {
    public enum FieldType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case dateTime
        case number
        case singleSelect
        case text
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldType] {
            return [
                .boolean,
                .dateTime,
                .number,
                .singleSelect,
                .text,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "Boolean"
            case .dateTime: return "DateTime"
            case .number: return "Number"
            case .singleSelect: return "SingleSelect"
            case .text: return "Text"
            case .url: return "Url"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FieldType(rawValue: rawValue) ?? FieldType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.FieldValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldValueUnion.self, forKey: .value)
        value = valueDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for case field values.
    public struct FieldValue: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?
        /// Union of potential field value types.
        /// This member is required.
        public var value: ConnectCasesClientTypes.FieldValueUnion?

        public init(
            id: Swift.String? = nil,
            value: ConnectCasesClientTypes.FieldValueUnion? = nil
        )
        {
            self.id = id
            self.value = value
        }
    }

}

extension ConnectCasesClientTypes.FieldValueUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanvalue = "booleanValue"
        case doublevalue = "doubleValue"
        case emptyvalue = "emptyValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .emptyvalue(emptyvalue):
                try container.encode(emptyvalue, forKey: .emptyvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        let emptyvalueDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.EmptyFieldValue.self, forKey: .emptyvalue)
        if let emptyvalue = emptyvalueDecoded {
            self = .emptyvalue(emptyvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// Object to store union of Field values.
    public enum FieldValueUnion: Swift.Equatable {
        /// String value type.
        case stringvalue(Swift.String)
        /// Can be either null, or have a Double number value type. Only one value can be provided.
        case doublevalue(Swift.Double)
        /// Can be either null, or have a Boolean value type. Only one value can be provided.
        case booleanvalue(Swift.Bool)
        /// An empty value.
        case emptyvalue(ConnectCasesClientTypes.EmptyFieldValue)
        case sdkUnknown(Swift.String)
    }

}

extension GetCaseEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/case-event-configuration"
    }
}

public struct GetCaseEventConfigurationInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct GetCaseEventConfigurationInputBody: Swift.Equatable {
}

extension GetCaseEventConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCaseEventConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCaseEventConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventBridge = output.eventBridge
        } else {
            self.eventBridge = nil
        }
    }
}

public struct GetCaseEventConfigurationOutput: Swift.Equatable {
    /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
    /// This member is required.
    public var eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?

    public init(
        eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration? = nil
    )
    {
        self.eventBridge = eventBridge
    }
}

struct GetCaseEventConfigurationOutputBody: Swift.Equatable {
    let eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?
}

extension GetCaseEventConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBridge
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBridgeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.EventBridgeConfiguration.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
    }
}

enum GetCaseEventConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldidentifier0 in fields {
                try fieldsContainer.encode(fieldidentifier0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let caseId = caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())"
    }
}

public struct GetCaseInput: Swift.Equatable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A list of unique field identifiers.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldIdentifier]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.fields = fields
        self.nextToken = nextToken
    }
}

struct GetCaseInputBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldIdentifier]?
    let nextToken: Swift.String?
}

extension GetCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldIdentifier?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldIdentifier]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldIdentifier]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.nextToken = output.nextToken
            self.tags = output.tags
            self.templateId = output.templateId
        } else {
            self.fields = nil
            self.nextToken = nil
            self.tags = nil
            self.templateId = nil
        }
    }
}

public struct GetCaseOutput: Swift.Equatable {
    /// A list of detailed field information.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldValue]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        fields: [ConnectCasesClientTypes.FieldValue]? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.fields = fields
        self.nextToken = nextToken
        self.tags = tags
        self.templateId = templateId
    }
}

struct GetCaseOutputBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldValue]?
    let templateId: Swift.String?
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String?]?
}

extension GetCaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case nextToken
        case tags
        case templateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

enum GetCaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())"
    }
}

public struct GetDomainInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct GetDomainInputBody: Swift.Equatable {
}

extension GetDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTime = output.createdTime
            self.domainArn = output.domainArn
            self.domainId = output.domainId
            self.domainStatus = output.domainStatus
            self.name = output.name
            self.tags = output.tags
        } else {
            self.createdTime = nil
            self.domainArn = nil
            self.domainId = nil
            self.domainStatus = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetDomainOutput: Swift.Equatable {
    /// The timestamp when the Cases domain was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) for the Cases domain.
    /// This member is required.
    public var domainArn: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The status of the Cases domain.
    /// This member is required.
    public var domainStatus: ConnectCasesClientTypes.DomainStatus?
    /// The name of the Cases domain.
    /// This member is required.
    public var name: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?

    public init(
        createdTime: ClientRuntime.Date? = nil,
        domainArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        domainStatus: ConnectCasesClientTypes.DomainStatus? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.createdTime = createdTime
        self.domainArn = domainArn
        self.domainId = domainId
        self.domainStatus = domainStatus
        self.name = name
        self.tags = tags
    }
}

struct GetDomainOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let domainArn: Swift.String?
    let name: Swift.String?
    let createdTime: ClientRuntime.Date?
    let domainStatus: ConnectCasesClientTypes.DomainStatus?
    let tags: [Swift.String:Swift.String?]?
}

extension GetDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime
        case domainArn
        case domainId
        case domainStatus
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainArn)
        domainArn = domainArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

enum GetDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCasesClientTypes.GetFieldResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case fieldArn
        case fieldId
        case name
        case namespace
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fieldArn = self.fieldArn {
            try encodeContainer.encode(fieldArn, forKey: .fieldArn)
        }
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace.rawValue, forKey: .namespace)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fieldArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldArn)
        fieldArn = fieldArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldType.self, forKey: .type)
        type = typeDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.FieldNamespace.self, forKey: .namespace)
        namespace = namespaceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// Object to store detailed field information.
    public struct GetFieldResponse: Swift.Equatable {
        /// Description of the field.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the field.
        /// This member is required.
        public var fieldArn: Swift.String?
        /// Unique identifier of the field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// Name of the field.
        /// This member is required.
        public var name: Swift.String?
        /// Namespace of the field.
        /// This member is required.
        public var namespace: ConnectCasesClientTypes.FieldNamespace?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String?]?
        /// Type of the field.
        /// This member is required.
        public var type: ConnectCasesClientTypes.FieldType?

        public init(
            description: Swift.String? = nil,
            fieldArn: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: ConnectCasesClientTypes.FieldNamespace? = nil,
            tags: [Swift.String:Swift.String?]? = nil,
            type: ConnectCasesClientTypes.FieldType? = nil
        )
        {
            self.description = description
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.tags = tags
            self.type = type
        }
    }

}

extension GetLayoutInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let layoutId = layoutId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts/\(layoutId.urlPercentEncoding())"
    }
}

public struct GetLayoutInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        layoutId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.layoutId = layoutId
    }
}

struct GetLayoutInputBody: Swift.Equatable {
}

extension GetLayoutInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLayoutOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLayoutOutputBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
            self.layoutArn = output.layoutArn
            self.layoutId = output.layoutId
            self.name = output.name
            self.tags = output.tags
        } else {
            self.content = nil
            self.layoutArn = nil
            self.layoutId = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetLayoutOutput: Swift.Equatable {
    /// Information about which fields will be present in the layout, the order of the fields, and read-only attribute of the field.
    /// This member is required.
    public var content: ConnectCasesClientTypes.LayoutContent?
    /// The Amazon Resource Name (ARN) of the newly created layout.
    /// This member is required.
    public var layoutArn: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?
    /// The name of the layout. It must be unique.
    /// This member is required.
    public var name: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?

    public init(
        content: ConnectCasesClientTypes.LayoutContent? = nil,
        layoutArn: Swift.String? = nil,
        layoutId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.content = content
        self.layoutArn = layoutArn
        self.layoutId = layoutId
        self.name = name
        self.tags = tags
    }
}

struct GetLayoutOutputBody: Swift.Equatable {
    let layoutId: Swift.String?
    let layoutArn: Swift.String?
    let name: Swift.String?
    let content: ConnectCasesClientTypes.LayoutContent?
    let tags: [Swift.String:Swift.String?]?
}

extension GetLayoutOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case layoutArn
        case layoutId
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutId)
        layoutId = layoutIdDecoded
        let layoutArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutArn)
        layoutArn = layoutArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutContent.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

enum GetLayoutOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct GetTemplateInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.templateId = templateId
    }
}

struct GetTemplateInputBody: Swift.Equatable {
}

extension GetTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.layoutConfiguration = output.layoutConfiguration
            self.name = output.name
            self.requiredFields = output.requiredFields
            self.status = output.status
            self.tags = output.tags
            self.templateArn = output.templateArn
            self.templateId = output.templateId
        } else {
            self.description = nil
            self.layoutConfiguration = nil
            self.name = nil
            self.requiredFields = nil
            self.status = nil
            self.tags = nil
            self.templateArn = nil
            self.templateId = nil
        }
    }
}

public struct GetTemplateOutput: Swift.Equatable {
    /// A brief description of the template.
    public var description: Swift.String?
    /// Configuration of layouts associated to the template.
    public var layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    /// The name of the template.
    /// This member is required.
    public var name: Swift.String?
    /// A list of fields that must contain a value for a case to be successfully created with this template.
    public var requiredFields: [ConnectCasesClientTypes.RequiredField]?
    /// The status of the template.
    /// This member is required.
    public var status: ConnectCasesClientTypes.TemplateStatus?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?
    /// The Amazon Resource Name (ARN) of the template.
    /// This member is required.
    public var templateArn: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        description: Swift.String? = nil,
        layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration? = nil,
        name: Swift.String? = nil,
        requiredFields: [ConnectCasesClientTypes.RequiredField]? = nil,
        status: ConnectCasesClientTypes.TemplateStatus? = nil,
        tags: [Swift.String:Swift.String?]? = nil,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.description = description
        self.layoutConfiguration = layoutConfiguration
        self.name = name
        self.requiredFields = requiredFields
        self.status = status
        self.tags = tags
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

struct GetTemplateOutputBody: Swift.Equatable {
    let templateId: Swift.String?
    let templateArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    let requiredFields: [ConnectCasesClientTypes.RequiredField]?
    let tags: [Swift.String:Swift.String?]?
    let status: ConnectCasesClientTypes.TemplateStatus?
}

extension GetTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
        case tags
        case templateArn
        case templateId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let layoutConfigurationDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutConfiguration.self, forKey: .layoutConfiguration)
        layoutConfiguration = layoutConfigurationDecoded
        let requiredFieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.RequiredField?].self, forKey: .requiredFields)
        var requiredFieldsDecoded0:[ConnectCasesClientTypes.RequiredField]? = nil
        if let requiredFieldsContainer = requiredFieldsContainer {
            requiredFieldsDecoded0 = [ConnectCasesClientTypes.RequiredField]()
            for structure0 in requiredFieldsContainer {
                if let structure0 = structure0 {
                    requiredFieldsDecoded0?.append(structure0)
                }
            }
        }
        requiredFields = requiredFieldsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We couldn't process your request because of an issue with the server. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes.LayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultLayout
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLayout = self.defaultLayout {
            try encodeContainer.encode(defaultLayout, forKey: .defaultLayout)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLayoutDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultLayout)
        defaultLayout = defaultLayoutDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object to store configuration of layouts associated to the template.
    public struct LayoutConfiguration: Swift.Equatable {
        /// Unique identifier of a layout.
        public var defaultLayout: Swift.String?

        public init(
            defaultLayout: Swift.String? = nil
        )
        {
            self.defaultLayout = defaultLayout
        }
    }

}

extension ConnectCasesClientTypes.LayoutContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basic
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .basic(basic):
                try container.encode(basic, forKey: .basic)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let basicDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.BasicLayout.self, forKey: .basic)
        if let basic = basicDecoded {
            self = .basic(basic)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// Object to store union of different versions of layout content.
    public enum LayoutContent: Swift.Equatable {
        /// Content specific to BasicLayout type. It configures fields in the top panel and More Info tab of Cases user interface.
        case basic(ConnectCasesClientTypes.BasicLayout)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.LayoutSections: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sections
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sections = sections {
            var sectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sections)
            for section0 in sections {
                try sectionsContainer.encode(section0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sectionsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.Section?].self, forKey: .sections)
        var sectionsDecoded0:[ConnectCasesClientTypes.Section]? = nil
        if let sectionsContainer = sectionsContainer {
            sectionsDecoded0 = [ConnectCasesClientTypes.Section]()
            for union0 in sectionsContainer {
                if let union0 = union0 {
                    sectionsDecoded0?.append(union0)
                }
            }
        }
        sections = sectionsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// Ordered list containing different kinds of sections that can be added. A LayoutSections object can only contain one section.
    public struct LayoutSections: Swift.Equatable {
        /// Ordered list containing different kinds of sections that can be added.
        public var sections: [ConnectCasesClientTypes.Section]?

        public init(
            sections: [ConnectCasesClientTypes.Section]? = nil
        )
        {
            self.sections = sections
        }
    }

}

extension ConnectCasesClientTypes.LayoutSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layoutArn
        case layoutId
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layoutArn = self.layoutArn {
            try encodeContainer.encode(layoutArn, forKey: .layoutArn)
        }
        if let layoutId = self.layoutId {
            try encodeContainer.encode(layoutId, forKey: .layoutId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutId)
        layoutId = layoutIdDecoded
        let layoutArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layoutArn)
        layoutArn = layoutArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Object for the summarized details of the layout.
    public struct LayoutSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the layout.
        /// This member is required.
        public var layoutArn: Swift.String?
        /// The unique identifier for of the layout.
        /// This member is required.
        public var layoutId: Swift.String?
        /// The name of the layout.
        /// This member is required.
        public var name: Swift.String?

        public init(
            layoutArn: Swift.String? = nil,
            layoutId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.layoutArn = layoutArn
            self.layoutId = layoutId
            self.name = name
        }
    }

}

extension ListCasesForContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCasesForContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/list-cases-for-contact"
    }
}

public struct ListCasesForContactInput: Swift.Equatable {
    /// A unique identifier of a contact in Amazon Connect.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCasesForContactInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCasesForContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCasesForContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCasesForContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.cases = output.cases
            self.nextToken = output.nextToken
        } else {
            self.cases = nil
            self.nextToken = nil
        }
    }
}

public struct ListCasesForContactOutput: Swift.Equatable {
    /// A list of Case summary information.
    /// This member is required.
    public var cases: [ConnectCasesClientTypes.CaseSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        cases: [ConnectCasesClientTypes.CaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

struct ListCasesForContactOutputBody: Swift.Equatable {
    let cases: [ConnectCasesClientTypes.CaseSummary]?
    let nextToken: Swift.String?
}

extension ListCasesForContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cases
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let casesContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.CaseSummary?].self, forKey: .cases)
        var casesDecoded0:[ConnectCasesClientTypes.CaseSummary]? = nil
        if let casesContainer = casesContainer {
            casesDecoded0 = [ConnectCasesClientTypes.CaseSummary]()
            for structure0 in casesContainer {
                if let structure0 = structure0 {
                    casesDecoded0?.append(structure0)
                }
            }
        }
        cases = casesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCasesForContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDomainsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domains-list"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
}

extension ListDomainsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutput: Swift.Equatable {
    /// The Cases domain.
    /// This member is required.
    public var domains: [ConnectCasesClientTypes.DomainSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        domains: [ConnectCasesClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputBody: Swift.Equatable {
    let domains: [ConnectCasesClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[ConnectCasesClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [ConnectCasesClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFieldOptionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let values = values {
                values.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "values".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListFieldOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let fieldId = fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())/options-list"
    }
}

public struct ListFieldOptionsInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of FieldOption values to filter on for ListFieldOptions.
    public var values: [Swift.String]?

    public init(
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.domainId = domainId
        self.fieldId = fieldId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.values = values
    }
}

struct ListFieldOptionsInputBody: Swift.Equatable {
}

extension ListFieldOptionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFieldOptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.options = output.options
        } else {
            self.nextToken = nil
            self.options = nil
        }
    }
}

public struct ListFieldOptionsOutput: Swift.Equatable {
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of FieldOption objects.
    /// This member is required.
    public var options: [ConnectCasesClientTypes.FieldOption]?

    public init(
        nextToken: Swift.String? = nil,
        options: [ConnectCasesClientTypes.FieldOption]? = nil
    )
    {
        self.nextToken = nextToken
        self.options = options
    }
}

struct ListFieldOptionsOutputBody: Swift.Equatable {
    let options: [ConnectCasesClientTypes.FieldOption]?
    let nextToken: Swift.String?
}

extension ListFieldOptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case options
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldOption?].self, forKey: .options)
        var optionsDecoded0:[ConnectCasesClientTypes.FieldOption]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [ConnectCasesClientTypes.FieldOption]()
            for structure0 in optionsContainer {
                if let structure0 = structure0 {
                    optionsDecoded0?.append(structure0)
                }
            }
        }
        options = optionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFieldOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFieldsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListFieldsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields-list"
    }
}

public struct ListFieldsInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFieldsInputBody: Swift.Equatable {
}

extension ListFieldsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFieldsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFieldsOutputBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.nextToken = output.nextToken
        } else {
            self.fields = nil
            self.nextToken = nil
        }
    }
}

public struct ListFieldsOutput: Swift.Equatable {
    /// List of detailed field information.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        fields: [ConnectCasesClientTypes.FieldSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fields = fields
        self.nextToken = nextToken
    }
}

struct ListFieldsOutputBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldSummary]?
    let nextToken: Swift.String?
}

extension ListFieldsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldSummary?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldSummary]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldSummary]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFieldsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLayoutsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListLayoutsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts-list"
    }
}

public struct ListLayoutsInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLayoutsInputBody: Swift.Equatable {
}

extension ListLayoutsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLayoutsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLayoutsOutputBody = try responseDecoder.decode(responseBody: data)
            self.layouts = output.layouts
            self.nextToken = output.nextToken
        } else {
            self.layouts = nil
            self.nextToken = nil
        }
    }
}

public struct ListLayoutsOutput: Swift.Equatable {
    /// The layouts for the domain.
    /// This member is required.
    public var layouts: [ConnectCasesClientTypes.LayoutSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        layouts: [ConnectCasesClientTypes.LayoutSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.layouts = layouts
        self.nextToken = nextToken
    }
}

struct ListLayoutsOutputBody: Swift.Equatable {
    let layouts: [ConnectCasesClientTypes.LayoutSummary]?
    let nextToken: Swift.String?
}

extension ListLayoutsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layouts
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.LayoutSummary?].self, forKey: .layouts)
        var layoutsDecoded0:[ConnectCasesClientTypes.LayoutSummary]? = nil
        if let layoutsContainer = layoutsContainer {
            layoutsDecoded0 = [ConnectCasesClientTypes.LayoutSummary]()
            for structure0 in layoutsContainer {
                if let structure0 = structure0 {
                    layoutsDecoded0?.append(structure0)
                }
            }
        }
        layouts = layoutsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLayoutsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN)
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String?]?

    public init(
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String?]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let status = status {
                status.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates-list"
    }
}

public struct ListTemplatesInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of status values to filter on.
    public var status: [ConnectCasesClientTypes.TemplateStatus]?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: [ConnectCasesClientTypes.TemplateStatus]? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListTemplatesInputBody: Swift.Equatable {
}

extension ListTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templates = output.templates
        } else {
            self.nextToken = nil
            self.templates = nil
        }
    }
}

public struct ListTemplatesOutput: Swift.Equatable {
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// List of template summary objects.
    /// This member is required.
    public var templates: [ConnectCasesClientTypes.TemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templates: [ConnectCasesClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

struct ListTemplatesOutputBody: Swift.Equatable {
    let templates: [ConnectCasesClientTypes.TemplateSummary]?
    let nextToken: Swift.String?
}

extension ListTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.TemplateSummary?].self, forKey: .templates)
        var templatesDecoded0:[ConnectCasesClientTypes.TemplateSummary]? = nil
        if let templatesContainer = templatesContainer {
            templatesDecoded0 = [ConnectCasesClientTypes.TemplateSummary]()
            for structure0 in templatesContainer {
                if let structure0 = structure0 {
                    templatesDecoded0?.append(structure0)
                }
            }
        }
        templates = templatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCasesClientTypes {
    public enum Order: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Asc"
            case .descending: return "Desc"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
        }
    }
}

extension PutCaseEventConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBridge
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBridge = self.eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
    }
}

extension PutCaseEventConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/case-event-configuration"
    }
}

public struct PutCaseEventConfigurationInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
    /// This member is required.
    public var eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?

    public init(
        domainId: Swift.String? = nil,
        eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration? = nil
    )
    {
        self.domainId = domainId
        self.eventBridge = eventBridge
    }
}

struct PutCaseEventConfigurationInputBody: Swift.Equatable {
    let eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?
}

extension PutCaseEventConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBridge
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBridgeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.EventBridgeConfiguration.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
    }
}

extension PutCaseEventConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutCaseEventConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutCaseEventConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCasesClientTypes.RelatedItemContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case contact
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .comment(comment):
                try container.encode(comment, forKey: .comment)
            case let .contact(contact):
                try container.encode(contact, forKey: .contact)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.ContactContent.self, forKey: .contact)
        if let contact = contactDecoded {
            self = .contact(contact)
            return
        }
        let commentDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.CommentContent.self, forKey: .comment)
        if let comment = commentDecoded {
            self = .comment(comment)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// Represents the content of a particular type of related item.
    public enum RelatedItemContent: Swift.Equatable {
        /// Represents the content of a contact to be returned to agents.
        case contact(ConnectCasesClientTypes.ContactContent)
        /// Represents the content of a comment to be returned to agents.
        case comment(ConnectCasesClientTypes.CommentContent)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.RelatedItemEventIncludedData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeContent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeContent = self.includeContent {
            try encodeContainer.encode(includeContent, forKey: .includeContent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeContentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeContent)
        includeContent = includeContentDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Details of what related item data is published through the case event stream.
    public struct RelatedItemEventIncludedData: Swift.Equatable {
        /// Details of what related item data is published through the case event stream.
        /// This member is required.
        public var includeContent: Swift.Bool?

        public init(
            includeContent: Swift.Bool? = nil
        )
        {
            self.includeContent = includeContent
        }
    }

}

extension ConnectCasesClientTypes.RelatedItemInputContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case contact
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .comment(comment):
                try container.encode(comment, forKey: .comment)
            case let .contact(contact):
                try container.encode(contact, forKey: .contact)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.Contact.self, forKey: .contact)
        if let contact = contactDecoded {
            self = .contact(contact)
            return
        }
        let commentDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.CommentContent.self, forKey: .comment)
        if let comment = commentDecoded {
            self = .comment(comment)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// Represents the content of a related item to be created.
    public enum RelatedItemInputContent: Swift.Equatable {
        /// Object representing a contact in Amazon Connect as an API request field.
        case contact(ConnectCasesClientTypes.Contact)
        /// Represents the content of a comment to be returned to agents.
        case comment(ConnectCasesClientTypes.CommentContent)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes {
    public enum RelatedItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case comment
        case contact
        case sdkUnknown(Swift.String)

        public static var allCases: [RelatedItemType] {
            return [
                .comment,
                .contact,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .comment: return "Comment"
            case .contact: return "Contact"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelatedItemType(rawValue: rawValue) ?? RelatedItemType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.RelatedItemTypeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case contact
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .comment(comment):
                try container.encode(comment, forKey: .comment)
            case let .contact(contact):
                try container.encode(contact, forKey: .contact)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.ContactFilter.self, forKey: .contact)
        if let contact = contactDecoded {
            self = .contact(contact)
            return
        }
        let commentDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.CommentFilter.self, forKey: .comment)
        if let comment = commentDecoded {
            self = .comment(comment)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// The list of types of related items and their parameters to use for filtering.
    public enum RelatedItemTypeFilter: Swift.Equatable {
        /// A filter for related items of type Contact.
        case contact(ConnectCasesClientTypes.ContactFilter)
        /// A filter for related items of type Comment.
        case comment(ConnectCasesClientTypes.CommentFilter)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCasesClientTypes.RequiredField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
    }
}

extension ConnectCasesClientTypes {
    /// List of fields that must have a value provided to create a case.
    public struct RequiredField: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var fieldId: Swift.String?

        public init(
            fieldId: Swift.String? = nil
        )
        {
            self.fieldId = fieldId
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Unique identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SearchCasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case filter
        case maxResults
        case nextToken
        case searchTerm
        case sorts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldidentifier0 in fields {
                try fieldsContainer.encode(fieldidentifier0)
            }
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let searchTerm = self.searchTerm {
            try encodeContainer.encode(searchTerm, forKey: .searchTerm)
        }
        if let sorts = sorts {
            var sortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sorts)
            for sort0 in sorts {
                try sortsContainer.encode(sort0)
            }
        }
    }
}

extension SearchCasesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases-search"
    }
}

public struct SearchCasesInput: Swift.Equatable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The list of field identifiers to be returned as part of the response.
    public var fields: [ConnectCasesClientTypes.FieldIdentifier]?
    /// A list of filter objects.
    public var filter: ConnectCasesClientTypes.CaseFilter?
    /// The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A word or phrase used to perform a quick search.
    public var searchTerm: Swift.String?
    /// A list of sorts where each sort specifies a field and their sort order to be applied to the results.
    public var sorts: [ConnectCasesClientTypes.Sort]?

    public init(
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil,
        filter: ConnectCasesClientTypes.CaseFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchTerm: Swift.String? = nil,
        sorts: [ConnectCasesClientTypes.Sort]? = nil
    )
    {
        self.domainId = domainId
        self.fields = fields
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchTerm = searchTerm
        self.sorts = sorts
    }
}

struct SearchCasesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let searchTerm: Swift.String?
    let filter: ConnectCasesClientTypes.CaseFilter?
    let sorts: [ConnectCasesClientTypes.Sort]?
    let fields: [ConnectCasesClientTypes.FieldIdentifier]?
}

extension SearchCasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case filter
        case maxResults
        case nextToken
        case searchTerm
        case sorts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let searchTermDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchTerm)
        searchTerm = searchTermDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.CaseFilter.self, forKey: .filter)
        filter = filterDecoded
        let sortsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.Sort?].self, forKey: .sorts)
        var sortsDecoded0:[ConnectCasesClientTypes.Sort]? = nil
        if let sortsContainer = sortsContainer {
            sortsDecoded0 = [ConnectCasesClientTypes.Sort]()
            for structure0 in sortsContainer {
                if let structure0 = structure0 {
                    sortsDecoded0?.append(structure0)
                }
            }
        }
        sorts = sortsDecoded0
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldIdentifier?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldIdentifier]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldIdentifier]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension SearchCasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchCasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.cases = output.cases
            self.nextToken = output.nextToken
        } else {
            self.cases = nil
            self.nextToken = nil
        }
    }
}

public struct SearchCasesOutput: Swift.Equatable {
    /// A list of case documents where each case contains the properties CaseId and Fields where each field is a complex union structure.
    /// This member is required.
    public var cases: [ConnectCasesClientTypes.SearchCasesResponseItem?]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        cases: [ConnectCasesClientTypes.SearchCasesResponseItem?]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

struct SearchCasesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let cases: [ConnectCasesClientTypes.SearchCasesResponseItem?]?
}

extension SearchCasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cases
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let casesContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.SearchCasesResponseItem?].self, forKey: .cases)
        var casesDecoded0:[ConnectCasesClientTypes.SearchCasesResponseItem?]? = nil
        if let casesContainer = casesContainer {
            casesDecoded0 = [ConnectCasesClientTypes.SearchCasesResponseItem?]()
            for structure0 in casesContainer {
                casesDecoded0?.append(structure0)
            }
        }
        cases = casesDecoded0
    }
}

enum SearchCasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCasesClientTypes.SearchCasesResponseItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
        case fields
        case tags
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = self.caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldvalue0 in fields {
                try fieldsContainer.encode(fieldvalue0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// A list of items that represent cases.
    public struct SearchCasesResponseItem: Swift.Equatable {
        /// A unique identifier of the case.
        /// This member is required.
        public var caseId: Swift.String?
        /// List of case field values.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.FieldValue]?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String?]?
        /// A unique identifier of a template.
        /// This member is required.
        public var templateId: Swift.String?

        public init(
            caseId: Swift.String? = nil,
            fields: [ConnectCasesClientTypes.FieldValue]? = nil,
            tags: [Swift.String:Swift.String?]? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.fields = fields
            self.tags = tags
            self.templateId = templateId
        }
    }

}

extension SearchRelatedItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for relateditemtypefilter0 in filters {
                try filtersContainer.encode(relateditemtypefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension SearchRelatedItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let caseId = caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())/related-items-search"
    }
}

public struct SearchRelatedItemsInput: Swift.Equatable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The list of types of related items and their parameters to use for filtering.
    public var filters: [ConnectCasesClientTypes.RelatedItemTypeFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        filters: [ConnectCasesClientTypes.RelatedItemTypeFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchRelatedItemsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [ConnectCasesClientTypes.RelatedItemTypeFilter]?
}

extension SearchRelatedItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.RelatedItemTypeFilter?].self, forKey: .filters)
        var filtersDecoded0:[ConnectCasesClientTypes.RelatedItemTypeFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ConnectCasesClientTypes.RelatedItemTypeFilter]()
            for union0 in filtersContainer {
                if let union0 = union0 {
                    filtersDecoded0?.append(union0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension SearchRelatedItemsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchRelatedItemsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.relatedItems = output.relatedItems
        } else {
            self.nextToken = nil
            self.relatedItems = nil
        }
    }
}

public struct SearchRelatedItemsOutput: Swift.Equatable {
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of items related to a case.
    /// This member is required.
    public var relatedItems: [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]?

    public init(
        nextToken: Swift.String? = nil,
        relatedItems: [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]? = nil
    )
    {
        self.nextToken = nextToken
        self.relatedItems = relatedItems
    }
}

struct SearchRelatedItemsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let relatedItems: [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]?
}

extension SearchRelatedItemsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case relatedItems
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let relatedItemsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.SearchRelatedItemsResponseItem?].self, forKey: .relatedItems)
        var relatedItemsDecoded0:[ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]? = nil
        if let relatedItemsContainer = relatedItemsContainer {
            relatedItemsDecoded0 = [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]()
            for structure0 in relatedItemsContainer {
                relatedItemsDecoded0?.append(structure0)
            }
        }
        relatedItems = relatedItemsDecoded0
    }
}

enum SearchRelatedItemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCasesClientTypes.SearchRelatedItemsResponseItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationTime
        case content
        case relatedItemId
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationTime = self.associationTime {
            try encodeContainer.encodeTimestamp(associationTime, format: .dateTime, forKey: .associationTime)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let relatedItemId = self.relatedItemId {
            try encodeContainer.encode(relatedItemId, forKey: .relatedItemId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedItemId)
        relatedItemId = relatedItemIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemType.self, forKey: .type)
        type = typeDecoded
        let associationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .associationTime)
        associationTime = associationTimeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.RelatedItemContent.self, forKey: .content)
        content = contentDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectCasesClientTypes {
    /// A list of items that represent RelatedItems.
    public struct SearchRelatedItemsResponseItem: Swift.Equatable {
        /// Time at which a related item was associated with a case.
        /// This member is required.
        public var associationTime: ClientRuntime.Date?
        /// Represents the content of a particular type of related item.
        /// This member is required.
        public var content: ConnectCasesClientTypes.RelatedItemContent?
        /// Unique identifier of a related item.
        /// This member is required.
        public var relatedItemId: Swift.String?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String?]?
        /// Type of a related item.
        /// This member is required.
        public var type: ConnectCasesClientTypes.RelatedItemType?

        public init(
            associationTime: ClientRuntime.Date? = nil,
            content: ConnectCasesClientTypes.RelatedItemContent? = nil,
            relatedItemId: Swift.String? = nil,
            tags: [Swift.String:Swift.String?]? = nil,
            type: ConnectCasesClientTypes.RelatedItemType? = nil
        )
        {
            self.associationTime = associationTime
            self.content = content
            self.relatedItemId = relatedItemId
            self.tags = tags
            self.type = type
        }
    }

}

extension ConnectCasesClientTypes.Section: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldgroup = "fieldGroup"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .fieldgroup(fieldgroup):
                try container.encode(fieldgroup, forKey: .fieldgroup)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fieldgroupDecoded = try values.decodeIfPresent(ConnectCasesClientTypes.FieldGroup.self, forKey: .fieldgroup)
        if let fieldgroup = fieldgroupDecoded {
            self = .fieldgroup(fieldgroup)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCasesClientTypes {
    /// This represents a sections within a panel or tab of the page layout.
    public enum Section: Swift.Equatable {
        /// Consists of a group of fields and associated properties.
        case fieldgroup(ConnectCasesClientTypes.FieldGroup)
        case sdkUnknown(Swift.String)
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service quota has been exceeded. For a list of service quotas, see [Amazon Connect Service Quotas](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html) in the Amazon Connect Administrator Guide.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCasesClientTypes.Sort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldId
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldId = self.fieldId {
            try encodeContainer.encode(fieldId, forKey: .fieldId)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldId)
        fieldId = fieldIdDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.Order.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ConnectCasesClientTypes {
    /// A structured set of sort terms.
    public struct Sort: Swift.Equatable {
        /// Unique identifier of a field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// A structured set of sort terms
        /// This member is required.
        public var sortOrder: ConnectCasesClientTypes.Order?

        public init(
            fieldId: Swift.String? = nil,
            sortOrder: ConnectCasesClientTypes.Order? = nil
        )
        {
            self.fieldId = fieldId
            self.sortOrder = sortOrder
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN)
    /// This member is required.
    public var arn: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String?]?

    public init(
        arn: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String?]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, string0) in tagsContainer {
                tagsDecoded0?[key0] = string0
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCasesClientTypes {
    public enum TemplateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateStatus(rawValue: rawValue) ?? TemplateStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCasesClientTypes.TemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
        case templateArn
        case templateId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let templateArn = self.templateArn {
            try encodeContainer.encode(templateArn, forKey: .templateArn)
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConnectCasesClientTypes {
    /// Template summary information.
    public struct TemplateSummary: Swift.Equatable {
        /// The template name.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the template.
        /// This member is required.
        public var status: ConnectCasesClientTypes.TemplateStatus?
        /// The Amazon Resource Name (ARN) of the template.
        /// This member is required.
        public var templateArn: Swift.String?
        /// The unique identifier for the template.
        /// This member is required.
        public var templateId: Swift.String?

        public init(
            name: Swift.String? = nil,
            status: ConnectCasesClientTypes.TemplateStatus? = nil,
            templateArn: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The rate has been exceeded for this API. Please try again after a few minutes.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN)
    /// This member is required.
    public var arn: Swift.String?
    /// List of tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for fieldvalue0 in fields {
                try fieldsContainer.encode(fieldvalue0)
            }
        }
    }
}

extension UpdateCaseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let caseId = caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())"
    }
}

public struct UpdateCaseInput: Swift.Equatable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// An array of objects with fieldId (matching ListFields/DescribeField) and value union data, structured identical to CreateCase.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldValue]?

    public init(
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldValue]? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.fields = fields
    }
}

struct UpdateCaseInputBody: Swift.Equatable {
    let fields: [ConnectCasesClientTypes.FieldValue]?
}

extension UpdateCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.FieldValue?].self, forKey: .fields)
        var fieldsDecoded0:[ConnectCasesClientTypes.FieldValue]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ConnectCasesClientTypes.FieldValue]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension UpdateCaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateCaseOutput: Swift.Equatable {

    public init() { }
}

enum UpdateCaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFieldInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateFieldInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let fieldId = fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())"
    }
}

public struct UpdateFieldInput: Swift.Equatable {
    /// The description of a field.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?
    /// The name of the field.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.fieldId = fieldId
        self.name = name
    }
}

struct UpdateFieldInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateFieldInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateFieldOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFieldOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFieldOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLayoutInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateLayoutInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let layoutId = layoutId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts/\(layoutId.urlPercentEncoding())"
    }
}

public struct UpdateLayoutInput: Swift.Equatable {
    /// Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field.
    public var content: ConnectCasesClientTypes.LayoutContent?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?
    /// The name of the layout. It must be unique per domain.
    public var name: Swift.String?

    public init(
        content: ConnectCasesClientTypes.LayoutContent? = nil,
        domainId: Swift.String? = nil,
        layoutId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.content = content
        self.domainId = domainId
        self.layoutId = layoutId
        self.name = name
    }
}

struct UpdateLayoutInputBody: Swift.Equatable {
    let name: Swift.String?
    let content: ConnectCasesClientTypes.LayoutContent?
}

extension UpdateLayoutInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateLayoutOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLayoutOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLayoutOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let layoutConfiguration = self.layoutConfiguration {
            try encodeContainer.encode(layoutConfiguration, forKey: .layoutConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredFields = requiredFields {
            var requiredFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredFields)
            for requiredfield0 in requiredFields {
                try requiredFieldsContainer.encode(requiredfield0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainId = domainId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct UpdateTemplateInput: Swift.Equatable {
    /// A brief description of the template.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Configuration of layouts associated to the template.
    public var layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    /// The name of the template. It must be unique per domain.
    public var name: Swift.String?
    /// A list of fields that must contain a value for a case to be successfully created with this template.
    public var requiredFields: [ConnectCasesClientTypes.RequiredField]?
    /// The status of the template.
    public var status: ConnectCasesClientTypes.TemplateStatus?
    /// A unique identifier for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration? = nil,
        name: Swift.String? = nil,
        requiredFields: [ConnectCasesClientTypes.RequiredField]? = nil,
        status: ConnectCasesClientTypes.TemplateStatus? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.layoutConfiguration = layoutConfiguration
        self.name = name
        self.requiredFields = requiredFields
        self.status = status
        self.templateId = templateId
    }
}

struct UpdateTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    let requiredFields: [ConnectCasesClientTypes.RequiredField]?
    let status: ConnectCasesClientTypes.TemplateStatus?
}

extension UpdateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case layoutConfiguration
        case name
        case requiredFields
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let layoutConfigurationDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.LayoutConfiguration.self, forKey: .layoutConfiguration)
        layoutConfiguration = layoutConfigurationDecoded
        let requiredFieldsContainer = try containerValues.decodeIfPresent([ConnectCasesClientTypes.RequiredField?].self, forKey: .requiredFields)
        var requiredFieldsDecoded0:[ConnectCasesClientTypes.RequiredField]? = nil
        if let requiredFieldsContainer = requiredFieldsContainer {
            requiredFieldsDecoded0 = [ConnectCasesClientTypes.RequiredField]()
            for structure0 in requiredFieldsContainer {
                if let structure0 = structure0 {
                    requiredFieldsDecoded0?.append(structure0)
                }
            }
        }
        requiredFields = requiredFieldsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ConnectCasesClientTypes.TemplateStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateTemplateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request isn't valid. Check the syntax and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
