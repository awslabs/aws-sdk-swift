//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.optionalFormOf
@_spi(SmithyReadWrite) import func SmithyReadWrite.sparseFormOf
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// We couldn't process your request because of an issue with the server. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Unique identifier of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The rate has been exceeded for this API. Please try again after a few minutes.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request isn't valid. Check the syntax and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectCasesClientTypes {

    /// An empty value. You cannot set EmptyFieldValue on a field that is required on a case template. This structure will never have any data members. It signifies an empty value on a case field.
    public struct EmptyFieldValue: Swift.Sendable {

        public init() { }
    }
}

extension ConnectCasesClientTypes {

    /// Object to store union of Field values. The Summary system field accepts 1500 characters while all other fields accept 500 characters.
    public enum FieldValueUnion: Swift.Sendable {
        /// String value type.
        case stringvalue(Swift.String)
        /// Can be either null, or have a Double number value type. Only one value can be provided.
        case doublevalue(Swift.Double)
        /// Can be either null, or have a Boolean value type. Only one value can be provided.
        case booleanvalue(Swift.Bool)
        /// An empty value.
        case emptyvalue(ConnectCasesClientTypes.EmptyFieldValue)
        /// Represents the user that performed the audit.
        case userarnvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension ConnectCasesClientTypes {

    /// Object for case field values.
    public struct FieldValue: Swift.Sendable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?
        /// Union of potential field value types.
        /// This member is required.
        public var value: ConnectCasesClientTypes.FieldValueUnion?

        public init(
            id: Swift.String? = nil,
            value: ConnectCasesClientTypes.FieldValueUnion? = nil
        )
        {
            self.id = id
            self.value = value
        }
    }
}

extension ConnectCasesClientTypes {

    /// Represents the identity of the person who performed the action.
    public enum UserUnion: Swift.Sendable {
        /// Represents the Amazon Connect ARN of the user.
        case userarn(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateCaseInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// An array of objects with field ID (matching ListFields/DescribeField) and value union data.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldValue]?
    /// Represents the identity of the person who performed the action.
    public var performedBy: ConnectCasesClientTypes.UserUnion?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldValue]? = nil,
        performedBy: ConnectCasesClientTypes.UserUnion? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainId = domainId
        self.fields = fields
        self.performedBy = performedBy
        self.templateId = templateId
    }
}

public struct CreateCaseOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the case.
    /// This member is required.
    public var caseArn: Swift.String?
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?

    public init(
        caseArn: Swift.String? = nil,
        caseId: Swift.String? = nil
    )
    {
        self.caseArn = caseArn
        self.caseId = caseId
    }
}

extension ConnectCasesClientTypes {

    /// Object for unique identifier of a field.
    public struct FieldIdentifier: Swift.Sendable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

public struct GetCaseInput: Swift.Sendable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A list of unique field identifiers.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldIdentifier]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.fields = fields
        self.nextToken = nextToken
    }
}

public struct GetCaseOutput: Swift.Sendable {
    /// A list of detailed field information.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldValue]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String?]?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        fields: [ConnectCasesClientTypes.FieldValue]? = nil,
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String?]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.fields = fields
        self.nextToken = nextToken
        self.tags = tags
        self.templateId = templateId
    }
}

public struct GetCaseAuditEventsInput: Swift.Sendable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of audit events to return. The current maximum supported value is 25. This is also the default when no other value is provided.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectCasesClientTypes {

    /// Object to store union of Field values.
    public enum AuditEventFieldValueUnion: Swift.Sendable {
        /// Can be either null, or have a String value type. Only one value can be provided.
        case stringvalue(Swift.String)
        /// Can be either null, or have a Double value type. Only one value can be provided.
        case doublevalue(Swift.Double)
        /// Can be either null, or have a Boolean value type. Only one value can be provided.
        case booleanvalue(Swift.Bool)
        /// An empty value. You cannot set EmptyFieldValue on a field that is required on a case template. This structure will never have any data members. It signifies an empty value on a case field.
        case emptyvalue(ConnectCasesClientTypes.EmptyFieldValue)
        /// Can be either null, or have a String value type formatted as an ARN. Only one value can be provided.
        case userarnvalue(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension ConnectCasesClientTypes {

    /// Fields for audit event.
    public struct AuditEventField: Swift.Sendable {
        /// Unique identifier of field in an Audit History entry.
        /// This member is required.
        public var eventFieldId: Swift.String?
        /// Union of potential field value types.
        /// This member is required.
        public var newValue: ConnectCasesClientTypes.AuditEventFieldValueUnion?
        /// Union of potential field value types.
        public var oldValue: ConnectCasesClientTypes.AuditEventFieldValueUnion?

        public init(
            eventFieldId: Swift.String? = nil,
            newValue: ConnectCasesClientTypes.AuditEventFieldValueUnion? = nil,
            oldValue: ConnectCasesClientTypes.AuditEventFieldValueUnion? = nil
        )
        {
            self.eventFieldId = eventFieldId
            self.newValue = newValue
            self.oldValue = oldValue
        }
    }
}

extension ConnectCasesClientTypes {

    /// Information of the user which performed the audit.
    public struct AuditEventPerformedBy: Swift.Sendable {
        /// Unique identifier of an IAM role.
        /// This member is required.
        public var iamPrincipalArn: Swift.String?
        /// Represents the identity of the person who performed the action.
        public var user: ConnectCasesClientTypes.UserUnion?

        public init(
            iamPrincipalArn: Swift.String? = nil,
            user: ConnectCasesClientTypes.UserUnion? = nil
        )
        {
            self.iamPrincipalArn = iamPrincipalArn
            self.user = user
        }
    }
}

extension ConnectCasesClientTypes {

    public enum RelatedItemType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case comment
        case contact
        case file
        case sdkUnknown(Swift.String)

        public static var allCases: [RelatedItemType] {
            return [
                .comment,
                .contact,
                .file
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .comment: return "Comment"
            case .contact: return "Contact"
            case .file: return "File"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectCasesClientTypes {

    public enum AuditEventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case caseCreated
        case caseUpdated
        case relatedItemCreated
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditEventType] {
            return [
                .caseCreated,
                .caseUpdated,
                .relatedItemCreated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .caseCreated: return "Case.Created"
            case .caseUpdated: return "Case.Updated"
            case .relatedItemCreated: return "RelatedItem.Created"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectCasesClientTypes {

    /// Represents the content of a particular audit event.
    public struct AuditEvent: Swift.Sendable {
        /// Unique identifier of a case audit history event.
        /// This member is required.
        public var eventId: Swift.String?
        /// A list of Case Audit History event fields.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.AuditEventField?]?
        /// Information of the user which performed the audit.
        public var performedBy: ConnectCasesClientTypes.AuditEventPerformedBy?
        /// Time at which an Audit History event took place.
        /// This member is required.
        public var performedTime: Foundation.Date?
        /// The Type of the related item.
        public var relatedItemType: ConnectCasesClientTypes.RelatedItemType?
        /// The Type of an audit history event.
        /// This member is required.
        public var type: ConnectCasesClientTypes.AuditEventType?

        public init(
            eventId: Swift.String? = nil,
            fields: [ConnectCasesClientTypes.AuditEventField?]? = nil,
            performedBy: ConnectCasesClientTypes.AuditEventPerformedBy? = nil,
            performedTime: Foundation.Date? = nil,
            relatedItemType: ConnectCasesClientTypes.RelatedItemType? = nil,
            type: ConnectCasesClientTypes.AuditEventType? = nil
        )
        {
            self.eventId = eventId
            self.fields = fields
            self.performedBy = performedBy
            self.performedTime = performedTime
            self.relatedItemType = relatedItemType
            self.type = type
        }
    }
}

public struct GetCaseAuditEventsOutput: Swift.Sendable {
    /// A list of case audits where each represents a particular edit of the case.
    /// This member is required.
    public var auditEvents: [ConnectCasesClientTypes.AuditEvent?]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        auditEvents: [ConnectCasesClientTypes.AuditEvent?]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.auditEvents = auditEvents
        self.nextToken = nextToken
    }
}

public struct ListCasesForContactInput: Swift.Sendable {
    /// A unique identifier of a contact in Amazon Connect.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectCasesClientTypes {

    /// Case summary information.
    public struct CaseSummary: Swift.Sendable {
        /// A unique identifier of the case.
        /// This member is required.
        public var caseId: Swift.String?
        /// A unique identifier of a template.
        /// This member is required.
        public var templateId: Swift.String?

        public init(
            caseId: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.templateId = templateId
        }
    }
}

public struct ListCasesForContactOutput: Swift.Sendable {
    /// A list of Case summary information.
    /// This member is required.
    public var cases: [ConnectCasesClientTypes.CaseSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        cases: [ConnectCasesClientTypes.CaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

/// The service quota has been exceeded. For a list of service quotas, see [Amazon Connect Service Quotas](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html) in the Amazon Connect Administrator Guide.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConnectCasesClientTypes {

    public enum CommentBodyTextType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plaintext
        case sdkUnknown(Swift.String)

        public static var allCases: [CommentBodyTextType] {
            return [
                .plaintext
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "Text/Plain"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectCasesClientTypes {

    /// Represents the content of a Comment to be returned to agents.
    public struct CommentContent: Swift.Sendable {
        /// Text in the body of a Comment on a case.
        /// This member is required.
        public var body: Swift.String?
        /// Type of the text in the box of a Comment on a case.
        /// This member is required.
        public var contentType: ConnectCasesClientTypes.CommentBodyTextType?

        public init(
            body: Swift.String? = nil,
            contentType: ConnectCasesClientTypes.CommentBodyTextType? = nil
        )
        {
            self.body = body
            self.contentType = contentType
        }
    }
}

extension ConnectCasesClientTypes {

    /// An object that represents an Amazon Connect contact object.
    public struct Contact: Swift.Sendable {
        /// A unique identifier of a contact in Amazon Connect.
        /// This member is required.
        public var contactArn: Swift.String?

        public init(
            contactArn: Swift.String? = nil
        )
        {
            self.contactArn = contactArn
        }
    }
}

extension ConnectCasesClientTypes {

    /// An object that represents a content of an Amazon Connect file object.
    public struct FileContent: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of a File in Amazon Connect.
        /// This member is required.
        public var fileArn: Swift.String?

        public init(
            fileArn: Swift.String? = nil
        )
        {
            self.fileArn = fileArn
        }
    }
}

extension ConnectCasesClientTypes {

    /// Represents the content of a related item to be created.
    public enum RelatedItemInputContent: Swift.Sendable {
        /// Object representing a contact in Amazon Connect as an API request field.
        case contact(ConnectCasesClientTypes.Contact)
        /// Represents the content of a comment to be returned to agents.
        case comment(ConnectCasesClientTypes.CommentContent)
        /// A file of related items.
        case file(ConnectCasesClientTypes.FileContent)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateRelatedItemInput: Swift.Sendable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The content of a related item to be created.
    /// This member is required.
    public var content: ConnectCasesClientTypes.RelatedItemInputContent?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Represents the creator of the related item.
    public var performedBy: ConnectCasesClientTypes.UserUnion?
    /// The type of a related item.
    /// This member is required.
    public var type: ConnectCasesClientTypes.RelatedItemType?

    public init(
        caseId: Swift.String? = nil,
        content: ConnectCasesClientTypes.RelatedItemInputContent? = nil,
        domainId: Swift.String? = nil,
        performedBy: ConnectCasesClientTypes.UserUnion? = nil,
        type: ConnectCasesClientTypes.RelatedItemType? = nil
    )
    {
        self.caseId = caseId
        self.content = content
        self.domainId = domainId
        self.performedBy = performedBy
        self.type = type
    }
}

public struct CreateRelatedItemOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the related item.
    /// This member is required.
    public var relatedItemArn: Swift.String?
    /// The unique identifier of the related item.
    /// This member is required.
    public var relatedItemId: Swift.String?

    public init(
        relatedItemArn: Swift.String? = nil,
        relatedItemId: Swift.String? = nil
    )
    {
        self.relatedItemArn = relatedItemArn
        self.relatedItemId = relatedItemId
    }
}

extension ConnectCasesClientTypes {

    /// A filter for related items of type Comment.
    public struct CommentFilter: Swift.Sendable {

        public init() { }
    }
}

extension ConnectCasesClientTypes {

    /// A filter for related items of type Contact.
    public struct ContactFilter: Swift.Sendable {
        /// A list of channels to filter on for related items of type Contact.
        public var channel: [Swift.String]?
        /// A unique identifier of a contact in Amazon Connect.
        public var contactArn: Swift.String?

        public init(
            channel: [Swift.String]? = nil,
            contactArn: Swift.String? = nil
        )
        {
            self.channel = channel
            self.contactArn = contactArn
        }
    }
}

extension ConnectCasesClientTypes {

    /// A filter for related items of type File.
    public struct FileFilter: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the file.
        public var fileArn: Swift.String?

        public init(
            fileArn: Swift.String? = nil
        )
        {
            self.fileArn = fileArn
        }
    }
}

extension ConnectCasesClientTypes {

    /// The list of types of related items and their parameters to use for filtering.
    public enum RelatedItemTypeFilter: Swift.Sendable {
        /// A filter for related items of type Contact.
        case contact(ConnectCasesClientTypes.ContactFilter)
        /// A filter for related items of type Comment.
        case comment(ConnectCasesClientTypes.CommentFilter)
        /// A filter for related items of this type of File.
        case file(ConnectCasesClientTypes.FileFilter)
        case sdkUnknown(Swift.String)
    }
}

public struct SearchRelatedItemsInput: Swift.Sendable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The list of types of related items and their parameters to use for filtering.
    public var filters: [ConnectCasesClientTypes.RelatedItemTypeFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        filters: [ConnectCasesClientTypes.RelatedItemTypeFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectCasesClientTypes {

    /// An object that represents a content of an Amazon Connect contact object.
    public struct ContactContent: Swift.Sendable {
        /// A list of channels to filter on for related items of type Contact.
        /// This member is required.
        public var channel: Swift.String?
        /// The difference between the InitiationTimestamp and the DisconnectTimestamp of the contact.
        /// This member is required.
        public var connectedToSystemTime: Foundation.Date?
        /// A unique identifier of a contact in Amazon Connect.
        /// This member is required.
        public var contactArn: Swift.String?

        public init(
            channel: Swift.String? = nil,
            connectedToSystemTime: Foundation.Date? = nil,
            contactArn: Swift.String? = nil
        )
        {
            self.channel = channel
            self.connectedToSystemTime = connectedToSystemTime
            self.contactArn = contactArn
        }
    }
}

extension ConnectCasesClientTypes {

    /// Represents the content of a particular type of related item.
    public enum RelatedItemContent: Swift.Sendable {
        /// Represents the content of a contact to be returned to agents.
        case contact(ConnectCasesClientTypes.ContactContent)
        /// Represents the content of a comment to be returned to agents.
        case comment(ConnectCasesClientTypes.CommentContent)
        /// Represents the content of a File to be returned to agents.
        case file(ConnectCasesClientTypes.FileContent)
        case sdkUnknown(Swift.String)
    }
}

extension ConnectCasesClientTypes {

    /// A list of items that represent RelatedItems.
    public struct SearchRelatedItemsResponseItem: Swift.Sendable {
        /// Time at which a related item was associated with a case.
        /// This member is required.
        public var associationTime: Foundation.Date?
        /// Represents the content of a particular type of related item.
        /// This member is required.
        public var content: ConnectCasesClientTypes.RelatedItemContent?
        /// Represents the creator of the related item.
        public var performedBy: ConnectCasesClientTypes.UserUnion?
        /// Unique identifier of a related item.
        /// This member is required.
        public var relatedItemId: Swift.String?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String?]?
        /// Type of a related item.
        /// This member is required.
        public var type: ConnectCasesClientTypes.RelatedItemType?

        public init(
            associationTime: Foundation.Date? = nil,
            content: ConnectCasesClientTypes.RelatedItemContent? = nil,
            performedBy: ConnectCasesClientTypes.UserUnion? = nil,
            relatedItemId: Swift.String? = nil,
            tags: [Swift.String: Swift.String?]? = nil,
            type: ConnectCasesClientTypes.RelatedItemType? = nil
        )
        {
            self.associationTime = associationTime
            self.content = content
            self.performedBy = performedBy
            self.relatedItemId = relatedItemId
            self.tags = tags
            self.type = type
        }
    }
}

public struct SearchRelatedItemsOutput: Swift.Sendable {
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of items related to a case.
    /// This member is required.
    public var relatedItems: [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]?

    public init(
        nextToken: Swift.String? = nil,
        relatedItems: [ConnectCasesClientTypes.SearchRelatedItemsResponseItem?]? = nil
    )
    {
        self.nextToken = nextToken
        self.relatedItems = relatedItems
    }
}

extension ConnectCasesClientTypes {

    /// A filter for fields. Only one value can be provided.
    public enum FieldFilter: Swift.Sendable {
        /// Object containing field identifier and value information.
        case equalto(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case contains(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case greaterthan(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case greaterthanorequalto(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case lessthan(ConnectCasesClientTypes.FieldValue)
        /// Object containing field identifier and value information.
        case lessthanorequalto(ConnectCasesClientTypes.FieldValue)
        case sdkUnknown(Swift.String)
    }
}

extension ConnectCasesClientTypes {

    public enum Order: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Asc"
            case .descending: return "Desc"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectCasesClientTypes {

    /// A structured set of sort terms.
    public struct Sort: Swift.Sendable {
        /// Unique identifier of a field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// A structured set of sort terms
        /// This member is required.
        public var sortOrder: ConnectCasesClientTypes.Order?

        public init(
            fieldId: Swift.String? = nil,
            sortOrder: ConnectCasesClientTypes.Order? = nil
        )
        {
            self.fieldId = fieldId
            self.sortOrder = sortOrder
        }
    }
}

extension ConnectCasesClientTypes {

    /// A list of items that represent cases.
    public struct SearchCasesResponseItem: Swift.Sendable {
        /// A unique identifier of the case.
        /// This member is required.
        public var caseId: Swift.String?
        /// List of case field values.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.FieldValue]?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String?]?
        /// A unique identifier of a template.
        /// This member is required.
        public var templateId: Swift.String?

        public init(
            caseId: Swift.String? = nil,
            fields: [ConnectCasesClientTypes.FieldValue]? = nil,
            tags: [Swift.String: Swift.String?]? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.fields = fields
            self.tags = tags
            self.templateId = templateId
        }
    }
}

public struct SearchCasesOutput: Swift.Sendable {
    /// A list of case documents where each case contains the properties CaseId and Fields where each field is a complex union structure.
    /// This member is required.
    public var cases: [ConnectCasesClientTypes.SearchCasesResponseItem?]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        cases: [ConnectCasesClientTypes.SearchCasesResponseItem?]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

public struct UpdateCaseInput: Swift.Sendable {
    /// A unique identifier of the case.
    /// This member is required.
    public var caseId: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// An array of objects with fieldId (matching ListFields/DescribeField) and value union data, structured identical to CreateCase.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldValue]?
    /// Represents the identity of the person who performed the action.
    public var performedBy: ConnectCasesClientTypes.UserUnion?

    public init(
        caseId: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldValue]? = nil,
        performedBy: ConnectCasesClientTypes.UserUnion? = nil
    )
    {
        self.caseId = caseId
        self.domainId = domainId
        self.fields = fields
        self.performedBy = performedBy
    }
}

public struct UpdateCaseOutput: Swift.Sendable {

    public init() { }
}

public struct CreateDomainInput: Swift.Sendable {
    /// The name for your Cases domain. It must be unique for your Amazon Web Services account.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension ConnectCasesClientTypes {

    public enum DomainStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creationFailed
        case creationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .creationFailed,
                .creationInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creationFailed: return "CreationFailed"
            case .creationInProgress: return "CreationInProgress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDomainOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the Cases domain.
    /// This member is required.
    public var domainArn: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The status of the domain.
    /// This member is required.
    public var domainStatus: ConnectCasesClientTypes.DomainStatus?

    public init(
        domainArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        domainStatus: ConnectCasesClientTypes.DomainStatus? = nil
    )
    {
        self.domainArn = domainArn
        self.domainId = domainId
        self.domainStatus = domainStatus
    }
}

public struct DeleteDomainInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

public struct DeleteDomainOutput: Swift.Sendable {

    public init() { }
}

public struct GetCaseEventConfigurationInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

extension ConnectCasesClientTypes {

    /// Details of what case data is published through the case event stream.
    public struct CaseEventIncludedData: Swift.Sendable {
        /// List of field identifiers.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.FieldIdentifier]?

        public init(
            fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil
        )
        {
            self.fields = fields
        }
    }
}

extension ConnectCasesClientTypes {

    /// Details of what related item data is published through the case event stream.
    public struct RelatedItemEventIncludedData: Swift.Sendable {
        /// Details of what related item data is published through the case event stream.
        /// This member is required.
        public var includeContent: Swift.Bool?

        public init(
            includeContent: Swift.Bool? = nil
        )
        {
            self.includeContent = includeContent
        }
    }
}

extension ConnectCasesClientTypes {

    /// Details of what case and related item data is published through the case event stream.
    public struct EventIncludedData: Swift.Sendable {
        /// Details of what case data is published through the case event stream.
        public var caseData: ConnectCasesClientTypes.CaseEventIncludedData?
        /// Details of what related item data is published through the case event stream.
        public var relatedItemData: ConnectCasesClientTypes.RelatedItemEventIncludedData?

        public init(
            caseData: ConnectCasesClientTypes.CaseEventIncludedData? = nil,
            relatedItemData: ConnectCasesClientTypes.RelatedItemEventIncludedData? = nil
        )
        {
            self.caseData = caseData
            self.relatedItemData = relatedItemData
        }
    }
}

extension ConnectCasesClientTypes {

    /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
    public struct EventBridgeConfiguration: Swift.Sendable {
        /// Indicates whether the to broadcast case event data to the customer.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Details of what case and related item data is published through the case event stream.
        public var includedData: ConnectCasesClientTypes.EventIncludedData?

        public init(
            enabled: Swift.Bool? = nil,
            includedData: ConnectCasesClientTypes.EventIncludedData? = nil
        )
        {
            self.enabled = enabled
            self.includedData = includedData
        }
    }
}

public struct GetCaseEventConfigurationOutput: Swift.Sendable {
    /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
    /// This member is required.
    public var eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?

    public init(
        eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration? = nil
    )
    {
        self.eventBridge = eventBridge
    }
}

public struct GetDomainInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

public struct GetDomainOutput: Swift.Sendable {
    /// The timestamp when the Cases domain was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) for the Cases domain.
    /// This member is required.
    public var domainArn: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The status of the Cases domain.
    /// This member is required.
    public var domainStatus: ConnectCasesClientTypes.DomainStatus?
    /// The name of the Cases domain.
    /// This member is required.
    public var name: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        createdTime: Foundation.Date? = nil,
        domainArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        domainStatus: ConnectCasesClientTypes.DomainStatus? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.createdTime = createdTime
        self.domainArn = domainArn
        self.domainId = domainId
        self.domainStatus = domainStatus
        self.name = name
        self.tags = tags
    }
}

public struct ListDomainsInput: Swift.Sendable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectCasesClientTypes {

    /// Object for the summarized details of the domain.
    public struct DomainSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the domain.
        /// This member is required.
        public var domainArn: Swift.String?
        /// The unique identifier of the domain.
        /// This member is required.
        public var domainId: Swift.String?
        /// The name of the domain.
        /// This member is required.
        public var name: Swift.String?

        public init(
            domainArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.domainArn = domainArn
            self.domainId = domainId
            self.name = name
        }
    }
}

public struct ListDomainsOutput: Swift.Sendable {
    /// The Cases domain.
    /// This member is required.
    public var domains: [ConnectCasesClientTypes.DomainSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        domains: [ConnectCasesClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

public struct PutCaseEventConfigurationInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Configuration to enable EventBridge case event delivery and determine what data is delivered.
    /// This member is required.
    public var eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration?

    public init(
        domainId: Swift.String? = nil,
        eventBridge: ConnectCasesClientTypes.EventBridgeConfiguration? = nil
    )
    {
        self.domainId = domainId
        self.eventBridge = eventBridge
    }
}

public struct PutCaseEventConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct BatchGetFieldInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A list of unique field identifiers.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldIdentifier]?

    public init(
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil
    )
    {
        self.domainId = domainId
        self.fields = fields
    }
}

extension ConnectCasesClientTypes {

    /// Object for errors on fields.
    public struct FieldError: Swift.Sendable {
        /// The error code from getting a field.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The field identifier that caused the error.
        /// This member is required.
        public var id: Swift.String?
        /// The error message from getting a field.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.id = id
            self.message = message
        }
    }
}

extension ConnectCasesClientTypes {

    public enum FieldNamespace: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldNamespace] {
            return [
                .custom,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .system: return "System"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectCasesClientTypes {

    public enum FieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case dateTime
        case number
        case singleSelect
        case text
        case url
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldType] {
            return [
                .boolean,
                .dateTime,
                .number,
                .singleSelect,
                .text,
                .url,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "Boolean"
            case .dateTime: return "DateTime"
            case .number: return "Number"
            case .singleSelect: return "SingleSelect"
            case .text: return "Text"
            case .url: return "Url"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConnectCasesClientTypes {

    /// Object to store detailed field information.
    public struct GetFieldResponse: Swift.Sendable {
        /// Timestamp at which the resource was created.
        public var createdTime: Foundation.Date?
        /// Denotes whether or not the resource has been deleted.
        public var deleted: Swift.Bool
        /// Description of the field.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the field.
        /// This member is required.
        public var fieldArn: Swift.String?
        /// Unique identifier of the field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// Timestamp at which the resource was created or last modified.
        public var lastModifiedTime: Foundation.Date?
        /// Name of the field.
        /// This member is required.
        public var name: Swift.String?
        /// Namespace of the field.
        /// This member is required.
        public var namespace: ConnectCasesClientTypes.FieldNamespace?
        /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
        public var tags: [Swift.String: Swift.String?]?
        /// Type of the field.
        /// This member is required.
        public var type: ConnectCasesClientTypes.FieldType?

        public init(
            createdTime: Foundation.Date? = nil,
            deleted: Swift.Bool = false,
            description: Swift.String? = nil,
            fieldArn: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            namespace: ConnectCasesClientTypes.FieldNamespace? = nil,
            tags: [Swift.String: Swift.String?]? = nil,
            type: ConnectCasesClientTypes.FieldType? = nil
        )
        {
            self.createdTime = createdTime
            self.deleted = deleted
            self.description = description
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.namespace = namespace
            self.tags = tags
            self.type = type
        }
    }
}

public struct BatchGetFieldOutput: Swift.Sendable {
    /// A list of field errors.
    /// This member is required.
    public var errors: [ConnectCasesClientTypes.FieldError]?
    /// A list of detailed field information.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.GetFieldResponse]?

    public init(
        errors: [ConnectCasesClientTypes.FieldError]? = nil,
        fields: [ConnectCasesClientTypes.GetFieldResponse]? = nil
    )
    {
        self.errors = errors
        self.fields = fields
    }
}

extension ConnectCasesClientTypes {

    /// Object for field Options information.
    public struct FieldOption: Swift.Sendable {
        /// Describes whether the FieldOption is active (displayed) or inactive.
        /// This member is required.
        public var active: Swift.Bool?
        /// FieldOptionName has max length 100 and disallows trailing spaces.
        /// This member is required.
        public var name: Swift.String?
        /// FieldOptionValue has max length 100 and must be alphanumeric with hyphens and underscores.
        /// This member is required.
        public var value: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.active = active
            self.name = name
            self.value = value
        }
    }
}

public struct BatchPutFieldOptionsInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?
    /// A list of FieldOption objects.
    /// This member is required.
    public var options: [ConnectCasesClientTypes.FieldOption]?

    public init(
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil,
        options: [ConnectCasesClientTypes.FieldOption]? = nil
    )
    {
        self.domainId = domainId
        self.fieldId = fieldId
        self.options = options
    }
}

extension ConnectCasesClientTypes {

    /// Object for field Options errors.
    public struct FieldOptionError: Swift.Sendable {
        /// Error code from creating or updating field option.
        /// This member is required.
        public var errorCode: Swift.String?
        /// Error message from creating or updating field option.
        /// This member is required.
        public var message: Swift.String?
        /// The field option value that caused the error.
        /// This member is required.
        public var value: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
            self.value = value
        }
    }
}

public struct BatchPutFieldOptionsOutput: Swift.Sendable {
    /// A list of field errors.
    public var errors: [ConnectCasesClientTypes.FieldOptionError]?

    public init(
        errors: [ConnectCasesClientTypes.FieldOptionError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct CreateFieldInput: Swift.Sendable {
    /// The description of the field.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the field.
    /// This member is required.
    public var name: Swift.String?
    /// Defines the data type, some system constraints, and default display of the field.
    /// This member is required.
    public var type: ConnectCasesClientTypes.FieldType?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        type: ConnectCasesClientTypes.FieldType? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.type = type
    }
}

public struct CreateFieldOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the field.
    /// This member is required.
    public var fieldArn: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?

    public init(
        fieldArn: Swift.String? = nil,
        fieldId: Swift.String? = nil
    )
    {
        self.fieldArn = fieldArn
        self.fieldId = fieldId
    }
}

public struct DeleteFieldInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Unique identifier of the field.
    /// This member is required.
    public var fieldId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fieldId = fieldId
    }
}

public struct DeleteFieldOutput: Swift.Sendable {

    public init() { }
}

public struct ListFieldOptionsInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of FieldOption values to filter on for ListFieldOptions.
    public var values: [Swift.String]?

    public init(
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        values: [Swift.String]? = nil
    )
    {
        self.domainId = domainId
        self.fieldId = fieldId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.values = values
    }
}

public struct ListFieldOptionsOutput: Swift.Sendable {
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of FieldOption objects.
    /// This member is required.
    public var options: [ConnectCasesClientTypes.FieldOption]?

    public init(
        nextToken: Swift.String? = nil,
        options: [ConnectCasesClientTypes.FieldOption]? = nil
    )
    {
        self.nextToken = nextToken
        self.options = options
    }
}

public struct ListFieldsInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectCasesClientTypes {

    /// Object for the summarized details of the field.
    public struct FieldSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the field.
        /// This member is required.
        public var fieldArn: Swift.String?
        /// The unique identifier of a field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// Name of the field.
        /// This member is required.
        public var name: Swift.String?
        /// The namespace of a field.
        /// This member is required.
        public var namespace: ConnectCasesClientTypes.FieldNamespace?
        /// The type of a field.
        /// This member is required.
        public var type: ConnectCasesClientTypes.FieldType?

        public init(
            fieldArn: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: ConnectCasesClientTypes.FieldNamespace? = nil,
            type: ConnectCasesClientTypes.FieldType? = nil
        )
        {
            self.fieldArn = fieldArn
            self.fieldId = fieldId
            self.name = name
            self.namespace = namespace
            self.type = type
        }
    }
}

public struct ListFieldsOutput: Swift.Sendable {
    /// List of detailed field information.
    /// This member is required.
    public var fields: [ConnectCasesClientTypes.FieldSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        fields: [ConnectCasesClientTypes.FieldSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fields = fields
        self.nextToken = nextToken
    }
}

public struct UpdateFieldInput: Swift.Sendable {
    /// The description of a field.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of a field.
    /// This member is required.
    public var fieldId: Swift.String?
    /// The name of the field.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        fieldId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.fieldId = fieldId
        self.name = name
    }
}

public struct UpdateFieldOutput: Swift.Sendable {

    public init() { }
}

extension ConnectCasesClientTypes {

    /// Object for field related information.
    public struct FieldItem: Swift.Sendable {
        /// Unique identifier of a field.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

extension ConnectCasesClientTypes {

    /// Object for a group of fields and associated properties.
    public struct FieldGroup: Swift.Sendable {
        /// Represents an ordered list containing field related information.
        /// This member is required.
        public var fields: [ConnectCasesClientTypes.FieldItem]?
        /// Name of the field group.
        public var name: Swift.String?

        public init(
            fields: [ConnectCasesClientTypes.FieldItem]? = nil,
            name: Swift.String? = nil
        )
        {
            self.fields = fields
            self.name = name
        }
    }
}

extension ConnectCasesClientTypes {

    /// This represents a sections within a panel or tab of the page layout.
    public enum Section: Swift.Sendable {
        /// Consists of a group of fields and associated properties.
        case fieldgroup(ConnectCasesClientTypes.FieldGroup)
        case sdkUnknown(Swift.String)
    }
}

extension ConnectCasesClientTypes {

    /// Ordered list containing different kinds of sections that can be added. A LayoutSections object can only contain one section.
    public struct LayoutSections: Swift.Sendable {
        /// Ordered list containing different kinds of sections that can be added.
        public var sections: [ConnectCasesClientTypes.Section]?

        public init(
            sections: [ConnectCasesClientTypes.Section]? = nil
        )
        {
            self.sections = sections
        }
    }
}

extension ConnectCasesClientTypes {

    /// Content specific to BasicLayout type. It configures fields in the top panel and More Info tab of agent application.
    public struct BasicLayout: Swift.Sendable {
        /// This represents sections in a tab of the page layout.
        public var moreInfo: ConnectCasesClientTypes.LayoutSections?
        /// This represents sections in a panel of the page layout.
        public var topPanel: ConnectCasesClientTypes.LayoutSections?

        public init(
            moreInfo: ConnectCasesClientTypes.LayoutSections? = nil,
            topPanel: ConnectCasesClientTypes.LayoutSections? = nil
        )
        {
            self.moreInfo = moreInfo
            self.topPanel = topPanel
        }
    }
}

extension ConnectCasesClientTypes {

    /// Object to store union of different versions of layout content.
    public enum LayoutContent: Swift.Sendable {
        /// Content specific to BasicLayout type. It configures fields in the top panel and More Info tab of Cases user interface.
        case basic(ConnectCasesClientTypes.BasicLayout)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateLayoutInput: Swift.Sendable {
    /// Information about which fields will be present in the layout, and information about the order of the fields.
    /// This member is required.
    public var content: ConnectCasesClientTypes.LayoutContent?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the layout. It must be unique for the Cases domain.
    /// This member is required.
    public var name: Swift.String?

    public init(
        content: ConnectCasesClientTypes.LayoutContent? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.content = content
        self.domainId = domainId
        self.name = name
    }
}

public struct CreateLayoutOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the newly created layout.
    /// This member is required.
    public var layoutArn: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?

    public init(
        layoutArn: Swift.String? = nil,
        layoutId: Swift.String? = nil
    )
    {
        self.layoutArn = layoutArn
        self.layoutId = layoutId
    }
}

public struct DeleteLayoutInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        layoutId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.layoutId = layoutId
    }
}

public struct DeleteLayoutOutput: Swift.Sendable {

    public init() { }
}

public struct GetLayoutInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        layoutId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.layoutId = layoutId
    }
}

public struct GetLayoutOutput: Swift.Sendable {
    /// Information about which fields will be present in the layout, the order of the fields, and read-only attribute of the field.
    /// This member is required.
    public var content: ConnectCasesClientTypes.LayoutContent?
    /// Timestamp at which the resource was created.
    public var createdTime: Foundation.Date?
    /// Denotes whether or not the resource has been deleted.
    public var deleted: Swift.Bool
    /// Timestamp at which the resource was created or last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the newly created layout.
    /// This member is required.
    public var layoutArn: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?
    /// The name of the layout. It must be unique.
    /// This member is required.
    public var name: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        content: ConnectCasesClientTypes.LayoutContent? = nil,
        createdTime: Foundation.Date? = nil,
        deleted: Swift.Bool = false,
        lastModifiedTime: Foundation.Date? = nil,
        layoutArn: Swift.String? = nil,
        layoutId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.content = content
        self.createdTime = createdTime
        self.deleted = deleted
        self.lastModifiedTime = lastModifiedTime
        self.layoutArn = layoutArn
        self.layoutId = layoutId
        self.name = name
        self.tags = tags
    }
}

public struct ListLayoutsInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConnectCasesClientTypes {

    /// Object for the summarized details of the layout.
    public struct LayoutSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the layout.
        /// This member is required.
        public var layoutArn: Swift.String?
        /// The unique identifier for of the layout.
        /// This member is required.
        public var layoutId: Swift.String?
        /// The name of the layout.
        /// This member is required.
        public var name: Swift.String?

        public init(
            layoutArn: Swift.String? = nil,
            layoutId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.layoutArn = layoutArn
            self.layoutId = layoutId
            self.name = name
        }
    }
}

public struct ListLayoutsOutput: Swift.Sendable {
    /// The layouts for the domain.
    /// This member is required.
    public var layouts: [ConnectCasesClientTypes.LayoutSummary]?
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        layouts: [ConnectCasesClientTypes.LayoutSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.layouts = layouts
        self.nextToken = nextToken
    }
}

public struct UpdateLayoutInput: Swift.Sendable {
    /// Information about which fields will be present in the layout, the order of the fields.
    public var content: ConnectCasesClientTypes.LayoutContent?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The unique identifier of the layout.
    /// This member is required.
    public var layoutId: Swift.String?
    /// The name of the layout. It must be unique per domain.
    public var name: Swift.String?

    public init(
        content: ConnectCasesClientTypes.LayoutContent? = nil,
        domainId: Swift.String? = nil,
        layoutId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.content = content
        self.domainId = domainId
        self.layoutId = layoutId
        self.name = name
    }
}

public struct UpdateLayoutOutput: Swift.Sendable {

    public init() { }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN)
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN)
    /// This member is required.
    public var arn: Swift.String?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        arn: Swift.String? = nil,
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

extension ConnectCasesClientTypes {

    /// Object to store configuration of layouts associated to the template.
    public struct LayoutConfiguration: Swift.Sendable {
        /// Unique identifier of a layout.
        public var defaultLayout: Swift.String?

        public init(
            defaultLayout: Swift.String? = nil
        )
        {
            self.defaultLayout = defaultLayout
        }
    }
}

extension ConnectCasesClientTypes {

    /// List of fields that must have a value provided to create a case.
    public struct RequiredField: Swift.Sendable {
        /// Unique identifier of a field.
        /// This member is required.
        public var fieldId: Swift.String?

        public init(
            fieldId: Swift.String? = nil
        )
        {
            self.fieldId = fieldId
        }
    }
}

extension ConnectCasesClientTypes {

    public enum TemplateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTemplateInput: Swift.Sendable {
    /// A brief description of the template.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Configuration of layouts associated to the template.
    public var layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    /// A name for the template. It must be unique per domain.
    /// This member is required.
    public var name: Swift.String?
    /// A list of fields that must contain a value for a case to be successfully created with this template.
    public var requiredFields: [ConnectCasesClientTypes.RequiredField]?
    /// The status of the template.
    public var status: ConnectCasesClientTypes.TemplateStatus?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration? = nil,
        name: Swift.String? = nil,
        requiredFields: [ConnectCasesClientTypes.RequiredField]? = nil,
        status: ConnectCasesClientTypes.TemplateStatus? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.layoutConfiguration = layoutConfiguration
        self.name = name
        self.requiredFields = requiredFields
        self.status = status
    }
}

public struct CreateTemplateOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the newly created template.
    /// This member is required.
    public var templateArn: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

public struct DeleteTemplateInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.templateId = templateId
    }
}

public struct DeleteTemplateOutput: Swift.Sendable {

    public init() { }
}

public struct GetTemplateInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.templateId = templateId
    }
}

public struct GetTemplateOutput: Swift.Sendable {
    /// Timestamp at which the resource was created.
    public var createdTime: Foundation.Date?
    /// Denotes whether or not the resource has been deleted.
    public var deleted: Swift.Bool
    /// A brief description of the template.
    public var description: Swift.String?
    /// Timestamp at which the resource was created or last modified.
    public var lastModifiedTime: Foundation.Date?
    /// Configuration of layouts associated to the template.
    public var layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    /// The name of the template.
    /// This member is required.
    public var name: Swift.String?
    /// A list of fields that must contain a value for a case to be successfully created with this template.
    public var requiredFields: [ConnectCasesClientTypes.RequiredField]?
    /// The status of the template.
    /// This member is required.
    public var status: ConnectCasesClientTypes.TemplateStatus?
    /// A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.
    public var tags: [Swift.String: Swift.String?]?
    /// The Amazon Resource Name (ARN) of the template.
    /// This member is required.
    public var templateArn: Swift.String?
    /// A unique identifier of a template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        createdTime: Foundation.Date? = nil,
        deleted: Swift.Bool = false,
        description: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration? = nil,
        name: Swift.String? = nil,
        requiredFields: [ConnectCasesClientTypes.RequiredField]? = nil,
        status: ConnectCasesClientTypes.TemplateStatus? = nil,
        tags: [Swift.String: Swift.String?]? = nil,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.createdTime = createdTime
        self.deleted = deleted
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.layoutConfiguration = layoutConfiguration
        self.name = name
        self.requiredFields = requiredFields
        self.status = status
        self.tags = tags
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

public struct ListTemplatesInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of status values to filter on.
    public var status: [ConnectCasesClientTypes.TemplateStatus]?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: [ConnectCasesClientTypes.TemplateStatus]? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension ConnectCasesClientTypes {

    /// Template summary information.
    public struct TemplateSummary: Swift.Sendable {
        /// The template name.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the template.
        /// This member is required.
        public var status: ConnectCasesClientTypes.TemplateStatus?
        /// The Amazon Resource Name (ARN) of the template.
        /// This member is required.
        public var templateArn: Swift.String?
        /// The unique identifier for the template.
        /// This member is required.
        public var templateId: Swift.String?

        public init(
            name: Swift.String? = nil,
            status: ConnectCasesClientTypes.TemplateStatus? = nil,
            templateArn: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.templateArn = templateArn
            self.templateId = templateId
        }
    }
}

public struct ListTemplatesOutput: Swift.Sendable {
    /// The token for the next set of results. This is null if there are no more results to return.
    public var nextToken: Swift.String?
    /// List of template summary objects.
    /// This member is required.
    public var templates: [ConnectCasesClientTypes.TemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        templates: [ConnectCasesClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

public struct UpdateTemplateInput: Swift.Sendable {
    /// A brief description of the template.
    public var description: Swift.String?
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// Configuration of layouts associated to the template.
    public var layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration?
    /// The name of the template. It must be unique per domain.
    public var name: Swift.String?
    /// A list of fields that must contain a value for a case to be successfully created with this template.
    public var requiredFields: [ConnectCasesClientTypes.RequiredField]?
    /// The status of the template.
    public var status: ConnectCasesClientTypes.TemplateStatus?
    /// A unique identifier for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        layoutConfiguration: ConnectCasesClientTypes.LayoutConfiguration? = nil,
        name: Swift.String? = nil,
        requiredFields: [ConnectCasesClientTypes.RequiredField]? = nil,
        status: ConnectCasesClientTypes.TemplateStatus? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.layoutConfiguration = layoutConfiguration
        self.name = name
        self.requiredFields = requiredFields
        self.status = status
        self.templateId = templateId
    }
}

public struct UpdateTemplateOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN)
    /// This member is required.
    public var arn: Swift.String?
    /// List of tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

extension ConnectCasesClientTypes {

    /// A filter for cases. Only one value can be provided.
    public indirect enum CaseFilter: Swift.Sendable {
        /// A list of fields to filter on.
        case field(ConnectCasesClientTypes.FieldFilter)
        /// A filter for cases. Only one value can be provided.
        case not(ConnectCasesClientTypes.CaseFilter)
        /// Provides "and all" filtering.
        case andall([ConnectCasesClientTypes.CaseFilter])
        /// Provides "or all" filtering.
        case orall([ConnectCasesClientTypes.CaseFilter])
        case sdkUnknown(Swift.String)
    }
}

public struct SearchCasesInput: Swift.Sendable {
    /// The unique identifier of the Cases domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The list of field identifiers to be returned as part of the response.
    public var fields: [ConnectCasesClientTypes.FieldIdentifier]?
    /// A list of filter objects.
    public var filter: ConnectCasesClientTypes.CaseFilter?
    /// The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A word or phrase used to perform a quick search.
    public var searchTerm: Swift.String?
    /// A list of sorts where each sort specifies a field and their sort order to be applied to the results.
    public var sorts: [ConnectCasesClientTypes.Sort]?

    public init(
        domainId: Swift.String? = nil,
        fields: [ConnectCasesClientTypes.FieldIdentifier]? = nil,
        filter: ConnectCasesClientTypes.CaseFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchTerm: Swift.String? = nil,
        sorts: [ConnectCasesClientTypes.Sort]? = nil
    )
    {
        self.domainId = domainId
        self.fields = fields
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchTerm = searchTerm
        self.sorts = sorts
    }
}

extension BatchGetFieldInput {

    static func urlPathProvider(_ value: BatchGetFieldInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields-batch"
    }
}

extension BatchPutFieldOptionsInput {

    static func urlPathProvider(_ value: BatchPutFieldOptionsInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let fieldId = value.fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())/options"
    }
}

extension CreateCaseInput {

    static func urlPathProvider(_ value: CreateCaseInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases"
    }
}

extension CreateDomainInput {

    static func urlPathProvider(_ value: CreateDomainInput) -> Swift.String? {
        return "/domains"
    }
}

extension CreateFieldInput {

    static func urlPathProvider(_ value: CreateFieldInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields"
    }
}

extension CreateLayoutInput {

    static func urlPathProvider(_ value: CreateLayoutInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts"
    }
}

extension CreateRelatedItemInput {

    static func urlPathProvider(_ value: CreateRelatedItemInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let caseId = value.caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())/related-items"
    }
}

extension CreateTemplateInput {

    static func urlPathProvider(_ value: CreateTemplateInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates"
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())"
    }
}

extension DeleteFieldInput {

    static func urlPathProvider(_ value: DeleteFieldInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let fieldId = value.fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())"
    }
}

extension DeleteLayoutInput {

    static func urlPathProvider(_ value: DeleteLayoutInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let layoutId = value.layoutId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts/\(layoutId.urlPercentEncoding())"
    }
}

extension DeleteTemplateInput {

    static func urlPathProvider(_ value: DeleteTemplateInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

extension GetCaseInput {

    static func urlPathProvider(_ value: GetCaseInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let caseId = value.caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())"
    }
}

extension GetCaseAuditEventsInput {

    static func urlPathProvider(_ value: GetCaseAuditEventsInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let caseId = value.caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())/audit-history"
    }
}

extension GetCaseEventConfigurationInput {

    static func urlPathProvider(_ value: GetCaseEventConfigurationInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/case-event-configuration"
    }
}

extension GetDomainInput {

    static func urlPathProvider(_ value: GetDomainInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())"
    }
}

extension GetLayoutInput {

    static func urlPathProvider(_ value: GetLayoutInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let layoutId = value.layoutId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts/\(layoutId.urlPercentEncoding())"
    }
}

extension GetTemplateInput {

    static func urlPathProvider(_ value: GetTemplateInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

extension ListCasesForContactInput {

    static func urlPathProvider(_ value: ListCasesForContactInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/list-cases-for-contact"
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/domains-list"
    }
}

extension ListDomainsInput {

    static func queryItemProvider(_ value: ListDomainsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListFieldOptionsInput {

    static func urlPathProvider(_ value: ListFieldOptionsInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let fieldId = value.fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())/options-list"
    }
}

extension ListFieldOptionsInput {

    static func queryItemProvider(_ value: ListFieldOptionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let values = value.values {
            values.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "values".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListFieldsInput {

    static func urlPathProvider(_ value: ListFieldsInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields-list"
    }
}

extension ListFieldsInput {

    static func queryItemProvider(_ value: ListFieldsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListLayoutsInput {

    static func urlPathProvider(_ value: ListLayoutsInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts-list"
    }
}

extension ListLayoutsInput {

    static func queryItemProvider(_ value: ListLayoutsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

extension ListTemplatesInput {

    static func urlPathProvider(_ value: ListTemplatesInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates-list"
    }
}

extension ListTemplatesInput {

    static func queryItemProvider(_ value: ListTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let status = value.status {
            status.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension PutCaseEventConfigurationInput {

    static func urlPathProvider(_ value: PutCaseEventConfigurationInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/case-event-configuration"
    }
}

extension SearchCasesInput {

    static func urlPathProvider(_ value: SearchCasesInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases-search"
    }
}

extension SearchRelatedItemsInput {

    static func urlPathProvider(_ value: SearchRelatedItemsInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let caseId = value.caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())/related-items-search"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateCaseInput {

    static func urlPathProvider(_ value: UpdateCaseInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let caseId = value.caseId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/cases/\(caseId.urlPercentEncoding())"
    }
}

extension UpdateFieldInput {

    static func urlPathProvider(_ value: UpdateFieldInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let fieldId = value.fieldId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/fields/\(fieldId.urlPercentEncoding())"
    }
}

extension UpdateLayoutInput {

    static func urlPathProvider(_ value: UpdateLayoutInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let layoutId = value.layoutId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/layouts/\(layoutId.urlPercentEncoding())"
    }
}

extension UpdateTemplateInput {

    static func urlPathProvider(_ value: UpdateTemplateInput) -> Swift.String? {
        guard let domainId = value.domainId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/domains/\(domainId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

extension BatchGetFieldInput {

    static func write(value: BatchGetFieldInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: ConnectCasesClientTypes.FieldIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchPutFieldOptionsInput {

    static func write(value: BatchPutFieldOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["options"].writeList(value.options, memberWritingClosure: ConnectCasesClientTypes.FieldOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCaseInput {

    static func write(value: CreateCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["fields"].writeList(value.fields, memberWritingClosure: ConnectCasesClientTypes.FieldValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["performedBy"].write(value.performedBy, with: ConnectCasesClientTypes.UserUnion.write(value:to:))
        try writer["templateId"].write(value.templateId)
    }
}

extension CreateDomainInput {

    static func write(value: CreateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension CreateFieldInput {

    static func write(value: CreateFieldInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension CreateLayoutInput {

    static func write(value: CreateLayoutInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: ConnectCasesClientTypes.LayoutContent.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension CreateRelatedItemInput {

    static func write(value: CreateRelatedItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: ConnectCasesClientTypes.RelatedItemInputContent.write(value:to:))
        try writer["performedBy"].write(value.performedBy, with: ConnectCasesClientTypes.UserUnion.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension CreateTemplateInput {

    static func write(value: CreateTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["layoutConfiguration"].write(value.layoutConfiguration, with: ConnectCasesClientTypes.LayoutConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["requiredFields"].writeList(value.requiredFields, memberWritingClosure: ConnectCasesClientTypes.RequiredField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["status"].write(value.status)
    }
}

extension GetCaseInput {

    static func write(value: GetCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: ConnectCasesClientTypes.FieldIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetCaseAuditEventsInput {

    static func write(value: GetCaseAuditEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListCasesForContactInput {

    static func write(value: ListCasesForContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contactArn"].write(value.contactArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension PutCaseEventConfigurationInput {

    static func write(value: PutCaseEventConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventBridge"].write(value.eventBridge, with: ConnectCasesClientTypes.EventBridgeConfiguration.write(value:to:))
    }
}

extension SearchCasesInput {

    static func write(value: SearchCasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: ConnectCasesClientTypes.FieldIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filter"].write(value.filter, with: ConnectCasesClientTypes.CaseFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["searchTerm"].write(value.searchTerm)
        try writer["sorts"].writeList(value.sorts, memberWritingClosure: ConnectCasesClientTypes.Sort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SearchRelatedItemsInput {

    static func write(value: SearchRelatedItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ConnectCasesClientTypes.RelatedItemTypeFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateCaseInput {

    static func write(value: UpdateCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: ConnectCasesClientTypes.FieldValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["performedBy"].write(value.performedBy, with: ConnectCasesClientTypes.UserUnion.write(value:to:))
    }
}

extension UpdateFieldInput {

    static func write(value: UpdateFieldInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateLayoutInput {

    static func write(value: UpdateLayoutInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content, with: ConnectCasesClientTypes.LayoutContent.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension UpdateTemplateInput {

    static func write(value: UpdateTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["layoutConfiguration"].write(value.layoutConfiguration, with: ConnectCasesClientTypes.LayoutConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["requiredFields"].writeList(value.requiredFields, memberWritingClosure: ConnectCasesClientTypes.RequiredField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["status"].write(value.status)
    }
}

extension BatchGetFieldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetFieldOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetFieldOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.FieldError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.GetFieldResponse.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchPutFieldOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchPutFieldOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchPutFieldOptionsOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.FieldOptionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCaseOutput()
        value.caseArn = try reader["caseArn"].readIfPresent() ?? ""
        value.caseId = try reader["caseId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainOutput()
        value.domainArn = try reader["domainArn"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.domainStatus = try reader["domainStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateFieldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFieldOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFieldOutput()
        value.fieldArn = try reader["fieldArn"].readIfPresent() ?? ""
        value.fieldId = try reader["fieldId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateLayoutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLayoutOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLayoutOutput()
        value.layoutArn = try reader["layoutArn"].readIfPresent() ?? ""
        value.layoutId = try reader["layoutId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateRelatedItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRelatedItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRelatedItemOutput()
        value.relatedItemArn = try reader["relatedItemArn"].readIfPresent() ?? ""
        value.relatedItemId = try reader["relatedItemId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTemplateOutput()
        value.templateArn = try reader["templateArn"].readIfPresent() ?? ""
        value.templateId = try reader["templateId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainOutput {
        return DeleteDomainOutput()
    }
}

extension DeleteFieldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFieldOutput {
        return DeleteFieldOutput()
    }
}

extension DeleteLayoutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLayoutOutput {
        return DeleteLayoutOutput()
    }
}

extension DeleteTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTemplateOutput {
        return DeleteTemplateOutput()
    }
}

extension GetCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCaseOutput()
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.FieldValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateId = try reader["templateId"].readIfPresent() ?? ""
        return value
    }
}

extension GetCaseAuditEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCaseAuditEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCaseAuditEventsOutput()
        value.auditEvents = try reader["auditEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: ConnectCasesClientTypes.AuditEvent.read(from:)), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetCaseEventConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCaseEventConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCaseEventConfigurationOutput()
        value.eventBridge = try reader["eventBridge"].readIfPresent(with: ConnectCasesClientTypes.EventBridgeConfiguration.read(from:))
        return value
    }
}

extension GetDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainOutput()
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.domainArn = try reader["domainArn"].readIfPresent() ?? ""
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.domainStatus = try reader["domainStatus"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetLayoutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLayoutOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLayoutOutput()
        value.content = try reader["content"].readIfPresent(with: ConnectCasesClientTypes.LayoutContent.read(from:))
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deleted = try reader["deleted"].readIfPresent() ?? false
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.layoutArn = try reader["layoutArn"].readIfPresent() ?? ""
        value.layoutId = try reader["layoutId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTemplateOutput()
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deleted = try reader["deleted"].readIfPresent() ?? false
        value.description = try reader["description"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.layoutConfiguration = try reader["layoutConfiguration"].readIfPresent(with: ConnectCasesClientTypes.LayoutConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.requiredFields = try reader["requiredFields"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.RequiredField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.templateArn = try reader["templateArn"].readIfPresent() ?? ""
        value.templateId = try reader["templateId"].readIfPresent() ?? ""
        return value
    }
}

extension ListCasesForContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCasesForContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCasesForContactOutput()
        value.cases = try reader["cases"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.CaseSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsOutput()
        value.domains = try reader["domains"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.DomainSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFieldOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFieldOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFieldOptionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.options = try reader["options"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.FieldOption.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListFieldsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFieldsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFieldsOutput()
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.FieldSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListLayoutsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLayoutsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLayoutsOutput()
        value.layouts = try reader["layouts"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.LayoutSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTemplatesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.templates = try reader["templates"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.TemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PutCaseEventConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutCaseEventConfigurationOutput {
        return PutCaseEventConfigurationOutput()
    }
}

extension SearchCasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchCasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchCasesOutput()
        value.cases = try reader["cases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: ConnectCasesClientTypes.SearchCasesResponseItem.read(from:)), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension SearchRelatedItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchRelatedItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchRelatedItemsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.relatedItems = try reader["relatedItems"].readListIfPresent(memberReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: ConnectCasesClientTypes.SearchRelatedItemsResponseItem.read(from:)), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCaseOutput {
        return UpdateCaseOutput()
    }
}

extension UpdateFieldOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFieldOutput {
        return UpdateFieldOutput()
    }
}

extension UpdateLayoutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLayoutOutput {
        return UpdateLayoutOutput()
    }
}

extension UpdateTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTemplateOutput {
        return UpdateTemplateOutput()
    }
}

enum BatchGetFieldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchPutFieldOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFieldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLayoutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRelatedItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFieldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLayoutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCaseAuditEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCaseEventConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLayoutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCasesForContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFieldOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFieldsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLayoutsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutCaseEventConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchCasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchRelatedItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFieldOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLayoutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConnectCasesClientTypes.GetFieldResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.GetFieldResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.GetFieldResponse()
        value.fieldId = try reader["fieldId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.fieldArn = try reader["fieldArn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.namespace = try reader["namespace"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.deleted = try reader["deleted"].readIfPresent() ?? false
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ConnectCasesClientTypes.FieldError {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FieldError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.FieldError()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ConnectCasesClientTypes.FieldOptionError {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FieldOptionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.FieldOptionError()
        value.message = try reader["message"].readIfPresent() ?? ""
        value.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectCasesClientTypes.FieldValue {

    static func write(value: ConnectCasesClientTypes.FieldValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["value"].write(value.value, with: ConnectCasesClientTypes.FieldValueUnion.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FieldValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.FieldValue()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent(with: ConnectCasesClientTypes.FieldValueUnion.read(from:))
        return value
    }
}

extension ConnectCasesClientTypes.FieldValueUnion {

    static func write(value: ConnectCasesClientTypes.FieldValueUnion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .booleanvalue(booleanvalue):
                try writer["booleanValue"].write(booleanvalue)
            case let .doublevalue(doublevalue):
                try writer["doubleValue"].write(doublevalue)
            case let .emptyvalue(emptyvalue):
                try writer["emptyValue"].write(emptyvalue, with: ConnectCasesClientTypes.EmptyFieldValue.write(value:to:))
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .userarnvalue(userarnvalue):
                try writer["userArnValue"].write(userarnvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FieldValueUnion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "doubleValue":
                return .doublevalue(try reader["doubleValue"].read())
            case "booleanValue":
                return .booleanvalue(try reader["booleanValue"].read())
            case "emptyValue":
                return .emptyvalue(try reader["emptyValue"].read(with: ConnectCasesClientTypes.EmptyFieldValue.read(from:)))
            case "userArnValue":
                return .userarnvalue(try reader["userArnValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectCasesClientTypes.EmptyFieldValue {

    static func write(value: ConnectCasesClientTypes.EmptyFieldValue?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.EmptyFieldValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return ConnectCasesClientTypes.EmptyFieldValue()
    }
}

extension ConnectCasesClientTypes.AuditEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.AuditEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.AuditEvent()
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.relatedItemType = try reader["relatedItemType"].readIfPresent()
        value.performedTime = try reader["performedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: ConnectCasesClientTypes.AuditEventField.read(from:)), memberNodeInfo: "member", isFlattened: false) ?? []
        value.performedBy = try reader["performedBy"].readIfPresent(with: ConnectCasesClientTypes.AuditEventPerformedBy.read(from:))
        return value
    }
}

extension ConnectCasesClientTypes.AuditEventPerformedBy {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.AuditEventPerformedBy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.AuditEventPerformedBy()
        value.user = try reader["user"].readIfPresent(with: ConnectCasesClientTypes.UserUnion.read(from:))
        value.iamPrincipalArn = try reader["iamPrincipalArn"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectCasesClientTypes.UserUnion {

    static func write(value: ConnectCasesClientTypes.UserUnion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .userarn(userarn):
                try writer["userArn"].write(userarn)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.UserUnion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "userArn":
                return .userarn(try reader["userArn"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectCasesClientTypes.AuditEventField {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.AuditEventField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.AuditEventField()
        value.eventFieldId = try reader["eventFieldId"].readIfPresent() ?? ""
        value.oldValue = try reader["oldValue"].readIfPresent(with: ConnectCasesClientTypes.AuditEventFieldValueUnion.read(from:))
        value.newValue = try reader["newValue"].readIfPresent(with: ConnectCasesClientTypes.AuditEventFieldValueUnion.read(from:))
        return value
    }
}

extension ConnectCasesClientTypes.AuditEventFieldValueUnion {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.AuditEventFieldValueUnion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "doubleValue":
                return .doublevalue(try reader["doubleValue"].read())
            case "booleanValue":
                return .booleanvalue(try reader["booleanValue"].read())
            case "emptyValue":
                return .emptyvalue(try reader["emptyValue"].read(with: ConnectCasesClientTypes.EmptyFieldValue.read(from:)))
            case "userArnValue":
                return .userarnvalue(try reader["userArnValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectCasesClientTypes.EventBridgeConfiguration {

    static func write(value: ConnectCasesClientTypes.EventBridgeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["includedData"].write(value.includedData, with: ConnectCasesClientTypes.EventIncludedData.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.EventBridgeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.EventBridgeConfiguration()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.includedData = try reader["includedData"].readIfPresent(with: ConnectCasesClientTypes.EventIncludedData.read(from:))
        return value
    }
}

extension ConnectCasesClientTypes.EventIncludedData {

    static func write(value: ConnectCasesClientTypes.EventIncludedData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caseData"].write(value.caseData, with: ConnectCasesClientTypes.CaseEventIncludedData.write(value:to:))
        try writer["relatedItemData"].write(value.relatedItemData, with: ConnectCasesClientTypes.RelatedItemEventIncludedData.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.EventIncludedData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.EventIncludedData()
        value.caseData = try reader["caseData"].readIfPresent(with: ConnectCasesClientTypes.CaseEventIncludedData.read(from:))
        value.relatedItemData = try reader["relatedItemData"].readIfPresent(with: ConnectCasesClientTypes.RelatedItemEventIncludedData.read(from:))
        return value
    }
}

extension ConnectCasesClientTypes.RelatedItemEventIncludedData {

    static func write(value: ConnectCasesClientTypes.RelatedItemEventIncludedData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeContent"].write(value.includeContent)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.RelatedItemEventIncludedData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.RelatedItemEventIncludedData()
        value.includeContent = try reader["includeContent"].readIfPresent() ?? false
        return value
    }
}

extension ConnectCasesClientTypes.CaseEventIncludedData {

    static func write(value: ConnectCasesClientTypes.CaseEventIncludedData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: ConnectCasesClientTypes.FieldIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.CaseEventIncludedData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.CaseEventIncludedData()
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.FieldIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConnectCasesClientTypes.FieldIdentifier {

    static func write(value: ConnectCasesClientTypes.FieldIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FieldIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.FieldIdentifier()
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectCasesClientTypes.LayoutContent {

    static func write(value: ConnectCasesClientTypes.LayoutContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .basic(basic):
                try writer["basic"].write(basic, with: ConnectCasesClientTypes.BasicLayout.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.LayoutContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "basic":
                return .basic(try reader["basic"].read(with: ConnectCasesClientTypes.BasicLayout.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectCasesClientTypes.BasicLayout {

    static func write(value: ConnectCasesClientTypes.BasicLayout?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["moreInfo"].write(value.moreInfo, with: ConnectCasesClientTypes.LayoutSections.write(value:to:))
        try writer["topPanel"].write(value.topPanel, with: ConnectCasesClientTypes.LayoutSections.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.BasicLayout {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.BasicLayout()
        value.topPanel = try reader["topPanel"].readIfPresent(with: ConnectCasesClientTypes.LayoutSections.read(from:))
        value.moreInfo = try reader["moreInfo"].readIfPresent(with: ConnectCasesClientTypes.LayoutSections.read(from:))
        return value
    }
}

extension ConnectCasesClientTypes.LayoutSections {

    static func write(value: ConnectCasesClientTypes.LayoutSections?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sections"].writeList(value.sections, memberWritingClosure: ConnectCasesClientTypes.Section.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.LayoutSections {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.LayoutSections()
        value.sections = try reader["sections"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.Section.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectCasesClientTypes.Section {

    static func write(value: ConnectCasesClientTypes.Section?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fieldgroup(fieldgroup):
                try writer["fieldGroup"].write(fieldgroup, with: ConnectCasesClientTypes.FieldGroup.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.Section {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "fieldGroup":
                return .fieldgroup(try reader["fieldGroup"].read(with: ConnectCasesClientTypes.FieldGroup.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectCasesClientTypes.FieldGroup {

    static func write(value: ConnectCasesClientTypes.FieldGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: ConnectCasesClientTypes.FieldItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FieldGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.FieldGroup()
        value.name = try reader["name"].readIfPresent()
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.FieldItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConnectCasesClientTypes.FieldItem {

    static func write(value: ConnectCasesClientTypes.FieldItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FieldItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.FieldItem()
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectCasesClientTypes.LayoutConfiguration {

    static func write(value: ConnectCasesClientTypes.LayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultLayout"].write(value.defaultLayout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.LayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.LayoutConfiguration()
        value.defaultLayout = try reader["defaultLayout"].readIfPresent()
        return value
    }
}

extension ConnectCasesClientTypes.RequiredField {

    static func write(value: ConnectCasesClientTypes.RequiredField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fieldId"].write(value.fieldId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.RequiredField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.RequiredField()
        value.fieldId = try reader["fieldId"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectCasesClientTypes.CaseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.CaseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.CaseSummary()
        value.caseId = try reader["caseId"].readIfPresent() ?? ""
        value.templateId = try reader["templateId"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectCasesClientTypes.DomainSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.DomainSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.DomainSummary()
        value.domainId = try reader["domainId"].readIfPresent() ?? ""
        value.domainArn = try reader["domainArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectCasesClientTypes.FieldOption {

    static func write(value: ConnectCasesClientTypes.FieldOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["active"].write(value.active)
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FieldOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.FieldOption()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        value.active = try reader["active"].readIfPresent() ?? false
        return value
    }
}

extension ConnectCasesClientTypes.FieldSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FieldSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.FieldSummary()
        value.fieldId = try reader["fieldId"].readIfPresent() ?? ""
        value.fieldArn = try reader["fieldArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.namespace = try reader["namespace"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConnectCasesClientTypes.LayoutSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.LayoutSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.LayoutSummary()
        value.layoutId = try reader["layoutId"].readIfPresent() ?? ""
        value.layoutArn = try reader["layoutArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectCasesClientTypes.TemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.TemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.TemplateSummary()
        value.templateId = try reader["templateId"].readIfPresent() ?? ""
        value.templateArn = try reader["templateArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConnectCasesClientTypes.SearchCasesResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.SearchCasesResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.SearchCasesResponseItem()
        value.caseId = try reader["caseId"].readIfPresent() ?? ""
        value.templateId = try reader["templateId"].readIfPresent() ?? ""
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: ConnectCasesClientTypes.FieldValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ConnectCasesClientTypes.SearchRelatedItemsResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.SearchRelatedItemsResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.SearchRelatedItemsResponseItem()
        value.relatedItemId = try reader["relatedItemId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.associationTime = try reader["associationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.content = try reader["content"].readIfPresent(with: ConnectCasesClientTypes.RelatedItemContent.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.performedBy = try reader["performedBy"].readIfPresent(with: ConnectCasesClientTypes.UserUnion.read(from:))
        return value
    }
}

extension ConnectCasesClientTypes.RelatedItemContent {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.RelatedItemContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "contact":
                return .contact(try reader["contact"].read(with: ConnectCasesClientTypes.ContactContent.read(from:)))
            case "comment":
                return .comment(try reader["comment"].read(with: ConnectCasesClientTypes.CommentContent.read(from:)))
            case "file":
                return .file(try reader["file"].read(with: ConnectCasesClientTypes.FileContent.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ConnectCasesClientTypes.FileContent {

    static func write(value: ConnectCasesClientTypes.FileContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileArn"].write(value.fileArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.FileContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.FileContent()
        value.fileArn = try reader["fileArn"].readIfPresent() ?? ""
        return value
    }
}

extension ConnectCasesClientTypes.CommentContent {

    static func write(value: ConnectCasesClientTypes.CommentContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
        try writer["contentType"].write(value.contentType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.CommentContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.CommentContent()
        value.body = try reader["body"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConnectCasesClientTypes.ContactContent {

    static func read(from reader: SmithyJSON.Reader) throws -> ConnectCasesClientTypes.ContactContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConnectCasesClientTypes.ContactContent()
        value.contactArn = try reader["contactArn"].readIfPresent() ?? ""
        value.channel = try reader["channel"].readIfPresent() ?? ""
        value.connectedToSystemTime = try reader["connectedToSystemTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ConnectCasesClientTypes.RelatedItemInputContent {

    static func write(value: ConnectCasesClientTypes.RelatedItemInputContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .comment(comment):
                try writer["comment"].write(comment, with: ConnectCasesClientTypes.CommentContent.write(value:to:))
            case let .contact(contact):
                try writer["contact"].write(contact, with: ConnectCasesClientTypes.Contact.write(value:to:))
            case let .file(file):
                try writer["file"].write(file, with: ConnectCasesClientTypes.FileContent.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension ConnectCasesClientTypes.Contact {

    static func write(value: ConnectCasesClientTypes.Contact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contactArn"].write(value.contactArn)
    }
}

extension ConnectCasesClientTypes.CaseFilter {

    static func write(value: ConnectCasesClientTypes.CaseFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .andall(andall):
                try writer["andAll"].writeList(andall, memberWritingClosure: ConnectCasesClientTypes.CaseFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .field(field):
                try writer["field"].write(field, with: ConnectCasesClientTypes.FieldFilter.write(value:to:))
            case let .not(not):
                try writer["not"].write(not, with: ConnectCasesClientTypes.CaseFilter.write(value:to:))
            case let .orall(orall):
                try writer["orAll"].writeList(orall, memberWritingClosure: ConnectCasesClientTypes.CaseFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension ConnectCasesClientTypes.FieldFilter {

    static func write(value: ConnectCasesClientTypes.FieldFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .contains(contains):
                try writer["contains"].write(contains, with: ConnectCasesClientTypes.FieldValue.write(value:to:))
            case let .equalto(equalto):
                try writer["equalTo"].write(equalto, with: ConnectCasesClientTypes.FieldValue.write(value:to:))
            case let .greaterthan(greaterthan):
                try writer["greaterThan"].write(greaterthan, with: ConnectCasesClientTypes.FieldValue.write(value:to:))
            case let .greaterthanorequalto(greaterthanorequalto):
                try writer["greaterThanOrEqualTo"].write(greaterthanorequalto, with: ConnectCasesClientTypes.FieldValue.write(value:to:))
            case let .lessthan(lessthan):
                try writer["lessThan"].write(lessthan, with: ConnectCasesClientTypes.FieldValue.write(value:to:))
            case let .lessthanorequalto(lessthanorequalto):
                try writer["lessThanOrEqualTo"].write(lessthanorequalto, with: ConnectCasesClientTypes.FieldValue.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension ConnectCasesClientTypes.Sort {

    static func write(value: ConnectCasesClientTypes.Sort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fieldId"].write(value.fieldId)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ConnectCasesClientTypes.RelatedItemTypeFilter {

    static func write(value: ConnectCasesClientTypes.RelatedItemTypeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .comment(comment):
                try writer["comment"].write(comment, with: ConnectCasesClientTypes.CommentFilter.write(value:to:))
            case let .contact(contact):
                try writer["contact"].write(contact, with: ConnectCasesClientTypes.ContactFilter.write(value:to:))
            case let .file(file):
                try writer["file"].write(file, with: ConnectCasesClientTypes.FileFilter.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension ConnectCasesClientTypes.FileFilter {

    static func write(value: ConnectCasesClientTypes.FileFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileArn"].write(value.fileArn)
    }
}

extension ConnectCasesClientTypes.CommentFilter {

    static func write(value: ConnectCasesClientTypes.CommentFilter?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ConnectCasesClientTypes.ContactFilter {

    static func write(value: ConnectCasesClientTypes.ContactFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channel"].writeList(value.channel, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["contactArn"].write(value.contactArn)
    }
}

public enum ConnectCasesClientTypes {}
