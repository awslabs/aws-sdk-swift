// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let xAmzErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.xAmzErrorType = xAmzErrorTypeHeaderValue
        } else {
            self.properties.xAmzErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A header that defines the error encountered while processing the request.
        public internal(set) var xAmzErrorType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        xAmzErrorType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.xAmzErrorType = xAmzErrorType
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectCampaignsClientTypes.AgentlessDialerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dialingCapacity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dialingCapacity = self.dialingCapacity {
            try encodeContainer.encode(dialingCapacity, forKey: .dialingCapacity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dialingCapacityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dialingCapacity)
        dialingCapacity = dialingCapacityDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Agentless Dialer config
    public struct AgentlessDialerConfig: Swift.Equatable {
        /// Allocates dialing capacity for this campaign between multiple active campaigns
        public var dialingCapacity: Swift.Double?

        public init(
            dialingCapacity: Swift.Double? = nil
        )
        {
            self.dialingCapacity = dialingCapacity
        }
    }

}

extension ConnectCampaignsClientTypes.AnswerMachineDetectionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableAnswerMachineDetection
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableAnswerMachineDetection = self.enableAnswerMachineDetection {
            try encodeContainer.encode(enableAnswerMachineDetection, forKey: .enableAnswerMachineDetection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAnswerMachineDetectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableAnswerMachineDetection)
        enableAnswerMachineDetection = enableAnswerMachineDetectionDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Answering Machine Detection config
    public struct AnswerMachineDetectionConfig: Swift.Equatable {
        /// Enable or disable answering machine detection
        /// This member is required.
        public var enableAnswerMachineDetection: Swift.Bool?

        public init(
            enableAnswerMachineDetection: Swift.Bool? = nil
        )
        {
            self.enableAnswerMachineDetection = enableAnswerMachineDetection
        }
    }

}

extension ConnectCampaignsClientTypes.Campaign: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case connectInstanceId
        case dialerConfig
        case id
        case name
        case outboundCallConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectInstanceId = self.connectInstanceId {
            try encodeContainer.encode(connectInstanceId, forKey: .connectInstanceId)
        }
        if let dialerConfig = self.dialerConfig {
            try encodeContainer.encode(dialerConfig, forKey: .dialerConfig)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundCallConfig = self.outboundCallConfig {
            try encodeContainer.encode(outboundCallConfig, forKey: .outboundCallConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectInstanceId)
        connectInstanceId = connectInstanceIdDecoded
        let dialerConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.DialerConfig.self, forKey: .dialerConfig)
        dialerConfig = dialerConfigDecoded
        let outboundCallConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.OutboundCallConfig.self, forKey: .outboundCallConfig)
        outboundCallConfig = outboundCallConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ConnectCampaignsClientTypes {
    /// An Amazon Connect campaign.
    public struct Campaign: Swift.Equatable {
        /// The resource name of an Amazon Connect campaign.
        /// This member is required.
        public var arn: Swift.String?
        /// Amazon Connect Instance Id
        /// This member is required.
        public var connectInstanceId: Swift.String?
        /// The possible types of dialer config parameters
        /// This member is required.
        public var dialerConfig: ConnectCampaignsClientTypes.DialerConfig?
        /// Identifier representing a Campaign
        /// This member is required.
        public var id: Swift.String?
        /// The name of an Amazon Connect Campaign name.
        /// This member is required.
        public var name: Swift.String?
        /// The configuration used for outbound calls.
        /// This member is required.
        public var outboundCallConfig: ConnectCampaignsClientTypes.OutboundCallConfig?
        /// Tag map with key and value.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            connectInstanceId: Swift.String? = nil,
            dialerConfig: ConnectCampaignsClientTypes.DialerConfig? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            outboundCallConfig: ConnectCampaignsClientTypes.OutboundCallConfig? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.connectInstanceId = connectInstanceId
            self.dialerConfig = dialerConfig
            self.id = id
            self.name = name
            self.outboundCallConfig = outboundCallConfig
            self.tags = tags
        }
    }

}

extension ConnectCampaignsClientTypes.CampaignFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIdFilter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIdFilter = self.instanceIdFilter {
            try encodeContainer.encode(instanceIdFilter, forKey: .instanceIdFilter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdFilterDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.InstanceIdFilter.self, forKey: .instanceIdFilter)
        instanceIdFilter = instanceIdFilterDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Filter model by type
    public struct CampaignFilters: Swift.Equatable {
        /// Connect instance identifier filter
        public var instanceIdFilter: ConnectCampaignsClientTypes.InstanceIdFilter?

        public init(
            instanceIdFilter: ConnectCampaignsClientTypes.InstanceIdFilter? = nil
        )
        {
            self.instanceIdFilter = instanceIdFilter
        }
    }

}

extension ConnectCampaignsClientTypes {
    /// State of a campaign
    public enum CampaignState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Campaign is in failed state
        case failed
        /// Campaign is in initialized state
        case initialized
        /// Campaign is in paused state
        case paused
        /// Campaign is in running state
        case running
        /// Campaign is in stopped state
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [CampaignState] {
            return [
                .failed,
                .initialized,
                .paused,
                .running,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .initialized: return "Initialized"
            case .paused: return "Paused"
            case .running: return "Running"
            case .stopped: return "Stopped"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CampaignState(rawValue: rawValue) ?? CampaignState.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCampaignsClientTypes.CampaignSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case connectInstanceId
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectInstanceId = self.connectInstanceId {
            try encodeContainer.encode(connectInstanceId, forKey: .connectInstanceId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectInstanceId)
        connectInstanceId = connectInstanceIdDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// An Amazon Connect campaign summary.
    public struct CampaignSummary: Swift.Equatable {
        /// The resource name of an Amazon Connect campaign.
        /// This member is required.
        public var arn: Swift.String?
        /// Amazon Connect Instance Id
        /// This member is required.
        public var connectInstanceId: Swift.String?
        /// Identifier representing a Campaign
        /// This member is required.
        public var id: Swift.String?
        /// The name of an Amazon Connect Campaign name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            connectInstanceId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.connectInstanceId = connectInstanceId
            self.id = id
            self.name = name
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let xAmzErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.xAmzErrorType = xAmzErrorTypeHeaderValue
        } else {
            self.properties.xAmzErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A header that defines the error encountered while processing the request.
        public internal(set) var xAmzErrorType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        xAmzErrorType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.xAmzErrorType = xAmzErrorType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectInstanceId
        case dialerConfig
        case name
        case outboundCallConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectInstanceId = self.connectInstanceId {
            try encodeContainer.encode(connectInstanceId, forKey: .connectInstanceId)
        }
        if let dialerConfig = self.dialerConfig {
            try encodeContainer.encode(dialerConfig, forKey: .dialerConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundCallConfig = self.outboundCallConfig {
            try encodeContainer.encode(outboundCallConfig, forKey: .outboundCallConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/campaigns"
    }
}

/// The request for Create Campaign API.
public struct CreateCampaignInput: Swift.Equatable {
    /// Amazon Connect Instance Id
    /// This member is required.
    public var connectInstanceId: Swift.String?
    /// The possible types of dialer config parameters
    /// This member is required.
    public var dialerConfig: ConnectCampaignsClientTypes.DialerConfig?
    /// The name of an Amazon Connect Campaign name.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration used for outbound calls.
    /// This member is required.
    public var outboundCallConfig: ConnectCampaignsClientTypes.OutboundCallConfig?
    /// Tag map with key and value.
    public var tags: [Swift.String:Swift.String]?

    public init(
        connectInstanceId: Swift.String? = nil,
        dialerConfig: ConnectCampaignsClientTypes.DialerConfig? = nil,
        name: Swift.String? = nil,
        outboundCallConfig: ConnectCampaignsClientTypes.OutboundCallConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.connectInstanceId = connectInstanceId
        self.dialerConfig = dialerConfig
        self.name = name
        self.outboundCallConfig = outboundCallConfig
        self.tags = tags
    }
}

struct CreateCampaignInputBody: Swift.Equatable {
    let name: Swift.String?
    let connectInstanceId: Swift.String?
    let dialerConfig: ConnectCampaignsClientTypes.DialerConfig?
    let outboundCallConfig: ConnectCampaignsClientTypes.OutboundCallConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectInstanceId
        case dialerConfig
        case name
        case outboundCallConfig
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectInstanceId)
        connectInstanceId = connectInstanceIdDecoded
        let dialerConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.DialerConfig.self, forKey: .dialerConfig)
        dialerConfig = dialerConfigDecoded
        let outboundCallConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.OutboundCallConfig.self, forKey: .outboundCallConfig)
        outboundCallConfig = outboundCallConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCampaignOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.tags = nil
        }
    }
}

/// The response for Create Campaign API
public struct CreateCampaignOutput: Swift.Equatable {
    /// The resource name of an Amazon Connect campaign.
    public var arn: Swift.String?
    /// Identifier representing a Campaign
    public var id: Swift.String?
    /// Tag map with key and value.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.tags = tags
    }
}

struct CreateCampaignOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCampaignOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())"
    }
}

/// DeleteCampaignRequest
public struct DeleteCampaignInput: Swift.Equatable {
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteCampaignInputBody: Swift.Equatable {
}

extension DeleteCampaignInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCampaignOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConnectInstanceConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectInstanceId = connectInstanceId else {
            return nil
        }
        return "/connect-instance/\(connectInstanceId.urlPercentEncoding())/config"
    }
}

/// DeleteCampaignRequest
public struct DeleteConnectInstanceConfigInput: Swift.Equatable {
    /// Amazon Connect Instance Id
    /// This member is required.
    public var connectInstanceId: Swift.String?

    public init(
        connectInstanceId: Swift.String? = nil
    )
    {
        self.connectInstanceId = connectInstanceId
    }
}

struct DeleteConnectInstanceConfigInputBody: Swift.Equatable {
}

extension DeleteConnectInstanceConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConnectInstanceConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConnectInstanceConfigOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConnectInstanceConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInstanceOnboardingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectInstanceId = connectInstanceId else {
            return nil
        }
        return "/connect-instance/\(connectInstanceId.urlPercentEncoding())/onboarding"
    }
}

/// The request for DeleteInstanceOnboardingJob API.
public struct DeleteInstanceOnboardingJobInput: Swift.Equatable {
    /// Amazon Connect Instance Id
    /// This member is required.
    public var connectInstanceId: Swift.String?

    public init(
        connectInstanceId: Swift.String? = nil
    )
    {
        self.connectInstanceId = connectInstanceId
    }
}

struct DeleteInstanceOnboardingJobInputBody: Swift.Equatable {
}

extension DeleteInstanceOnboardingJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInstanceOnboardingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInstanceOnboardingJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInstanceOnboardingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateException": return try await InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())"
    }
}

/// DescribeCampaignRequests
public struct DescribeCampaignInput: Swift.Equatable {
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeCampaignInputBody: Swift.Equatable {
}

extension DescribeCampaignInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCampaignOutputBody = try responseDecoder.decode(responseBody: data)
            self.campaign = output.campaign
        } else {
            self.campaign = nil
        }
    }
}

/// DescribeCampaignResponse
public struct DescribeCampaignOutput: Swift.Equatable {
    /// An Amazon Connect campaign.
    public var campaign: ConnectCampaignsClientTypes.Campaign?

    public init(
        campaign: ConnectCampaignsClientTypes.Campaign? = nil
    )
    {
        self.campaign = campaign
    }
}

struct DescribeCampaignOutputBody: Swift.Equatable {
    let campaign: ConnectCampaignsClientTypes.Campaign?
}

extension DescribeCampaignOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaign
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.Campaign.self, forKey: .campaign)
        campaign = campaignDecoded
    }
}

enum DescribeCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCampaignsClientTypes.DialRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case clientToken
        case expirationTime
        case phoneNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .dateTime, forKey: .expirationTime)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ConnectCampaignsClientTypes.DialRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DialRequest(clientToken: \(Swift.String(describing: clientToken)), expirationTime: \(Swift.String(describing: expirationTime)), attributes: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\")"}
}

extension ConnectCampaignsClientTypes {
    /// A dial request for a campaign.
    public struct DialRequest: Swift.Equatable {
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in contact flows just like any other contact attributes.
        /// This member is required.
        public var attributes: [Swift.String:Swift.String]?
        /// Client provided parameter used for idempotency. Its value must be unique for each request.
        /// This member is required.
        public var clientToken: Swift.String?
        /// Timestamp with no UTC offset or timezone
        /// This member is required.
        public var expirationTime: ClientRuntime.Date?
        /// The phone number of the customer, in E.164 format.
        /// This member is required.
        public var phoneNumber: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            clientToken: Swift.String? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.clientToken = clientToken
            self.expirationTime = expirationTime
            self.phoneNumber = phoneNumber
        }
    }

}

extension ConnectCampaignsClientTypes.DialerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentlessdialerconfig = "agentlessDialerConfig"
        case predictivedialerconfig = "predictiveDialerConfig"
        case progressivedialerconfig = "progressiveDialerConfig"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .agentlessdialerconfig(agentlessdialerconfig):
                try container.encode(agentlessdialerconfig, forKey: .agentlessdialerconfig)
            case let .predictivedialerconfig(predictivedialerconfig):
                try container.encode(predictivedialerconfig, forKey: .predictivedialerconfig)
            case let .progressivedialerconfig(progressivedialerconfig):
                try container.encode(progressivedialerconfig, forKey: .progressivedialerconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let progressivedialerconfigDecoded = try values.decodeIfPresent(ConnectCampaignsClientTypes.ProgressiveDialerConfig.self, forKey: .progressivedialerconfig)
        if let progressivedialerconfig = progressivedialerconfigDecoded {
            self = .progressivedialerconfig(progressivedialerconfig)
            return
        }
        let predictivedialerconfigDecoded = try values.decodeIfPresent(ConnectCampaignsClientTypes.PredictiveDialerConfig.self, forKey: .predictivedialerconfig)
        if let predictivedialerconfig = predictivedialerconfigDecoded {
            self = .predictivedialerconfig(predictivedialerconfig)
            return
        }
        let agentlessdialerconfigDecoded = try values.decodeIfPresent(ConnectCampaignsClientTypes.AgentlessDialerConfig.self, forKey: .agentlessdialerconfig)
        if let agentlessdialerconfig = agentlessdialerconfigDecoded {
            self = .agentlessdialerconfig(agentlessdialerconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension ConnectCampaignsClientTypes {
    /// The possible types of dialer config parameters
    public enum DialerConfig: Swift.Equatable {
        /// Progressive Dialer config
        case progressivedialerconfig(ConnectCampaignsClientTypes.ProgressiveDialerConfig)
        /// Predictive Dialer config
        case predictivedialerconfig(ConnectCampaignsClientTypes.PredictiveDialerConfig)
        /// Agentless Dialer config
        case agentlessdialerconfig(ConnectCampaignsClientTypes.AgentlessDialerConfig)
        case sdkUnknown(Swift.String)
    }

}

extension ConnectCampaignsClientTypes.EncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case encryptionType
        case keyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let keyArn = self.keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Encryption config for Connect Instance. Note that sensitive data will always be encrypted. If disabled, service will perform encryption with its own key. If enabled, a KMS key id needs to be provided and KMS charges will apply. KMS is only type supported
    public struct EncryptionConfig: Swift.Equatable {
        /// Boolean to indicate if custom encryption has been enabled.
        /// This member is required.
        public var enabled: Swift.Bool
        /// Server-side encryption type.
        public var encryptionType: ConnectCampaignsClientTypes.EncryptionType?
        /// KMS key id/arn for encryption config.
        public var keyArn: Swift.String?

        public init(
            enabled: Swift.Bool = false,
            encryptionType: ConnectCampaignsClientTypes.EncryptionType? = nil,
            keyArn: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.encryptionType = encryptionType
            self.keyArn = keyArn
        }
    }

}

extension ConnectCampaignsClientTypes {
    /// Server-side encryption type.
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCampaignsClientTypes.FailedCampaignStateResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignId
        case failureCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignId = self.campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.GetCampaignStateBatchFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Failed response of campaign state
    public struct FailedCampaignStateResponse: Swift.Equatable {
        /// Identifier representing a Campaign
        public var campaignId: Swift.String?
        /// A predefined code indicating the error that caused the failure in getting state of campaigns
        public var failureCode: ConnectCampaignsClientTypes.GetCampaignStateBatchFailureCode?

        public init(
            campaignId: Swift.String? = nil,
            failureCode: ConnectCampaignsClientTypes.GetCampaignStateBatchFailureCode? = nil
        )
        {
            self.campaignId = campaignId
            self.failureCode = failureCode
        }
    }

}

extension ConnectCampaignsClientTypes.FailedRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case failureCode
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.FailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// A failed request identified by the unique client token.
    public struct FailedRequest: Swift.Equatable {
        /// Client provided parameter used for idempotency. Its value must be unique for each request.
        public var clientToken: Swift.String?
        /// A predefined code indicating the error that caused the failure.
        public var failureCode: ConnectCampaignsClientTypes.FailureCode?
        /// Identifier representing a Dial request
        public var id: Swift.String?

        public init(
            clientToken: Swift.String? = nil,
            failureCode: ConnectCampaignsClientTypes.FailureCode? = nil,
            id: Swift.String? = nil
        )
        {
            self.clientToken = clientToken
            self.failureCode = failureCode
            self.id = id
        }
    }

}

extension ConnectCampaignsClientTypes {
    /// A predefined code indicating the error that caused the failure.
    public enum FailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The request failed to satisfy the constraints specified by the service
        case invalidInput
        /// Request throttled due to large number of pending dial requests
        case requestThrottled
        /// Unexpected error during processing of request
        case unknownError
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureCode] {
            return [
                .invalidInput,
                .requestThrottled,
                .unknownError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidInput: return "InvalidInput"
            case .requestThrottled: return "RequestThrottled"
            case .unknownError: return "UnknownError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureCode(rawValue: rawValue) ?? FailureCode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCampaignsClientTypes {
    /// A predefined code indicating the error that caused the failure in getting state of campaigns
    public enum GetCampaignStateBatchFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The specified resource was not found
        case resourceNotFound
        /// Unexpected error during processing of request
        case unknownError
        case sdkUnknown(Swift.String)

        public static var allCases: [GetCampaignStateBatchFailureCode] {
            return [
                .resourceNotFound,
                .unknownError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resourceNotFound: return "ResourceNotFound"
            case .unknownError: return "UnknownError"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GetCampaignStateBatchFailureCode(rawValue: rawValue) ?? GetCampaignStateBatchFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension GetCampaignStateBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignIds = campaignIds {
            var campaignIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .campaignIds)
            for campaignid0 in campaignIds {
                try campaignIdsContainer.encode(campaignid0)
            }
        }
    }
}

extension GetCampaignStateBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/campaigns-state"
    }
}

/// GetCampaignStateBatchRequest
public struct GetCampaignStateBatchInput: Swift.Equatable {
    /// List of CampaignId
    /// This member is required.
    public var campaignIds: [Swift.String]?

    public init(
        campaignIds: [Swift.String]? = nil
    )
    {
        self.campaignIds = campaignIds
    }
}

struct GetCampaignStateBatchInputBody: Swift.Equatable {
    let campaignIds: [Swift.String]?
}

extension GetCampaignStateBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .campaignIds)
        var campaignIdsDecoded0:[Swift.String]? = nil
        if let campaignIdsContainer = campaignIdsContainer {
            campaignIdsDecoded0 = [Swift.String]()
            for string0 in campaignIdsContainer {
                if let string0 = string0 {
                    campaignIdsDecoded0?.append(string0)
                }
            }
        }
        campaignIds = campaignIdsDecoded0
    }
}

extension GetCampaignStateBatchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCampaignStateBatchOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
            self.successfulRequests = output.successfulRequests
        } else {
            self.failedRequests = nil
            self.successfulRequests = nil
        }
    }
}

/// GetCampaignStateBatchResponse
public struct GetCampaignStateBatchOutput: Swift.Equatable {
    /// List of failed requests of campaign state
    public var failedRequests: [ConnectCampaignsClientTypes.FailedCampaignStateResponse]?
    /// List of successful response of campaign state
    public var successfulRequests: [ConnectCampaignsClientTypes.SuccessfulCampaignStateResponse]?

    public init(
        failedRequests: [ConnectCampaignsClientTypes.FailedCampaignStateResponse]? = nil,
        successfulRequests: [ConnectCampaignsClientTypes.SuccessfulCampaignStateResponse]? = nil
    )
    {
        self.failedRequests = failedRequests
        self.successfulRequests = successfulRequests
    }
}

struct GetCampaignStateBatchOutputBody: Swift.Equatable {
    let successfulRequests: [ConnectCampaignsClientTypes.SuccessfulCampaignStateResponse]?
    let failedRequests: [ConnectCampaignsClientTypes.FailedCampaignStateResponse]?
}

extension GetCampaignStateBatchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests
        case successfulRequests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulRequestsContainer = try containerValues.decodeIfPresent([ConnectCampaignsClientTypes.SuccessfulCampaignStateResponse?].self, forKey: .successfulRequests)
        var successfulRequestsDecoded0:[ConnectCampaignsClientTypes.SuccessfulCampaignStateResponse]? = nil
        if let successfulRequestsContainer = successfulRequestsContainer {
            successfulRequestsDecoded0 = [ConnectCampaignsClientTypes.SuccessfulCampaignStateResponse]()
            for structure0 in successfulRequestsContainer {
                if let structure0 = structure0 {
                    successfulRequestsDecoded0?.append(structure0)
                }
            }
        }
        successfulRequests = successfulRequestsDecoded0
        let failedRequestsContainer = try containerValues.decodeIfPresent([ConnectCampaignsClientTypes.FailedCampaignStateResponse?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[ConnectCampaignsClientTypes.FailedCampaignStateResponse]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [ConnectCampaignsClientTypes.FailedCampaignStateResponse]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

enum GetCampaignStateBatchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCampaignStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())/state"
    }
}

/// GetCampaignStateRequest
public struct GetCampaignStateInput: Swift.Equatable {
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetCampaignStateInputBody: Swift.Equatable {
}

extension GetCampaignStateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCampaignStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCampaignStateOutputBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

/// GetCampaignStateResponse
public struct GetCampaignStateOutput: Swift.Equatable {
    /// State of a campaign
    public var state: ConnectCampaignsClientTypes.CampaignState?

    public init(
        state: ConnectCampaignsClientTypes.CampaignState? = nil
    )
    {
        self.state = state
    }
}

struct GetCampaignStateOutputBody: Swift.Equatable {
    let state: ConnectCampaignsClientTypes.CampaignState?
}

extension GetCampaignStateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.CampaignState.self, forKey: .state)
        state = stateDecoded
    }
}

enum GetCampaignStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConnectInstanceConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectInstanceId = connectInstanceId else {
            return nil
        }
        return "/connect-instance/\(connectInstanceId.urlPercentEncoding())/config"
    }
}

/// GetConnectInstanceConfigRequest
public struct GetConnectInstanceConfigInput: Swift.Equatable {
    /// Amazon Connect Instance Id
    /// This member is required.
    public var connectInstanceId: Swift.String?

    public init(
        connectInstanceId: Swift.String? = nil
    )
    {
        self.connectInstanceId = connectInstanceId
    }
}

struct GetConnectInstanceConfigInputBody: Swift.Equatable {
}

extension GetConnectInstanceConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectInstanceConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConnectInstanceConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectInstanceConfig = output.connectInstanceConfig
        } else {
            self.connectInstanceConfig = nil
        }
    }
}

/// GetConnectInstanceConfigResponse
public struct GetConnectInstanceConfigOutput: Swift.Equatable {
    /// Instance config object
    public var connectInstanceConfig: ConnectCampaignsClientTypes.InstanceConfig?

    public init(
        connectInstanceConfig: ConnectCampaignsClientTypes.InstanceConfig? = nil
    )
    {
        self.connectInstanceConfig = connectInstanceConfig
    }
}

struct GetConnectInstanceConfigOutputBody: Swift.Equatable {
    let connectInstanceConfig: ConnectCampaignsClientTypes.InstanceConfig?
}

extension GetConnectInstanceConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectInstanceConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectInstanceConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.InstanceConfig.self, forKey: .connectInstanceConfig)
        connectInstanceConfig = connectInstanceConfigDecoded
    }
}

enum GetConnectInstanceConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInstanceOnboardingJobStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectInstanceId = connectInstanceId else {
            return nil
        }
        return "/connect-instance/\(connectInstanceId.urlPercentEncoding())/onboarding"
    }
}

/// GetInstanceOnboardingJobStatusRequest
public struct GetInstanceOnboardingJobStatusInput: Swift.Equatable {
    /// Amazon Connect Instance Id
    /// This member is required.
    public var connectInstanceId: Swift.String?

    public init(
        connectInstanceId: Swift.String? = nil
    )
    {
        self.connectInstanceId = connectInstanceId
    }
}

struct GetInstanceOnboardingJobStatusInputBody: Swift.Equatable {
}

extension GetInstanceOnboardingJobStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetInstanceOnboardingJobStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInstanceOnboardingJobStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectInstanceOnboardingJobStatus = output.connectInstanceOnboardingJobStatus
        } else {
            self.connectInstanceOnboardingJobStatus = nil
        }
    }
}

/// GetInstanceOnboardingJobStatusResponse
public struct GetInstanceOnboardingJobStatusOutput: Swift.Equatable {
    /// Instance onboarding job status object
    public var connectInstanceOnboardingJobStatus: ConnectCampaignsClientTypes.InstanceOnboardingJobStatus?

    public init(
        connectInstanceOnboardingJobStatus: ConnectCampaignsClientTypes.InstanceOnboardingJobStatus? = nil
    )
    {
        self.connectInstanceOnboardingJobStatus = connectInstanceOnboardingJobStatus
    }
}

struct GetInstanceOnboardingJobStatusOutputBody: Swift.Equatable {
    let connectInstanceOnboardingJobStatus: ConnectCampaignsClientTypes.InstanceOnboardingJobStatus?
}

extension GetInstanceOnboardingJobStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectInstanceOnboardingJobStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectInstanceOnboardingJobStatusDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.InstanceOnboardingJobStatus.self, forKey: .connectInstanceOnboardingJobStatus)
        connectInstanceOnboardingJobStatus = connectInstanceOnboardingJobStatusDecoded
    }
}

enum GetInstanceOnboardingJobStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCampaignsClientTypes.InstanceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectInstanceId
        case encryptionConfig
        case serviceLinkedRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectInstanceId = self.connectInstanceId {
            try encodeContainer.encode(connectInstanceId, forKey: .connectInstanceId)
        }
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let serviceLinkedRoleArn = self.serviceLinkedRoleArn {
            try encodeContainer.encode(serviceLinkedRoleArn, forKey: .serviceLinkedRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectInstanceId)
        connectInstanceId = connectInstanceIdDecoded
        let serviceLinkedRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceLinkedRoleArn)
        serviceLinkedRoleArn = serviceLinkedRoleArnDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Instance config object
    public struct InstanceConfig: Swift.Equatable {
        /// Amazon Connect Instance Id
        /// This member is required.
        public var connectInstanceId: Swift.String?
        /// Encryption config for Connect Instance. Note that sensitive data will always be encrypted. If disabled, service will perform encryption with its own key. If enabled, a KMS key id needs to be provided and KMS charges will apply. KMS is only type supported
        /// This member is required.
        public var encryptionConfig: ConnectCampaignsClientTypes.EncryptionConfig?
        /// Service linked role arn
        /// This member is required.
        public var serviceLinkedRoleArn: Swift.String?

        public init(
            connectInstanceId: Swift.String? = nil,
            encryptionConfig: ConnectCampaignsClientTypes.EncryptionConfig? = nil,
            serviceLinkedRoleArn: Swift.String? = nil
        )
        {
            self.connectInstanceId = connectInstanceId
            self.encryptionConfig = encryptionConfig
            self.serviceLinkedRoleArn = serviceLinkedRoleArn
        }
    }

}

extension ConnectCampaignsClientTypes.InstanceIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.InstanceIdFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Connect instance identifier filter
    public struct InstanceIdFilter: Swift.Equatable {
        /// Operators for Connect instance identifier filter
        /// This member is required.
        public var `operator`: ConnectCampaignsClientTypes.InstanceIdFilterOperator?
        /// Amazon Connect Instance Id
        /// This member is required.
        public var value: Swift.String?

        public init(
            `operator`: ConnectCampaignsClientTypes.InstanceIdFilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.`operator` = `operator`
            self.value = value
        }
    }

}

extension ConnectCampaignsClientTypes {
    /// Operators for Connect instance identifier filter
    public enum InstanceIdFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Equals operator
        case eq
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceIdFilterOperator] {
            return [
                .eq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eq: return "Eq"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceIdFilterOperator(rawValue: rawValue) ?? InstanceIdFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCampaignsClientTypes {
    /// Enumeration of the possible failure codes for instance onboarding job
    public enum InstanceOnboardingJobFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventBridgeAccessDenied
        case eventBridgeManagedRuleLimitExceeded
        case iamAccessDenied
        case internalFailure
        case kmsAccessDenied
        case kmsKeyNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceOnboardingJobFailureCode] {
            return [
                .eventBridgeAccessDenied,
                .eventBridgeManagedRuleLimitExceeded,
                .iamAccessDenied,
                .internalFailure,
                .kmsAccessDenied,
                .kmsKeyNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventBridgeAccessDenied: return "EVENT_BRIDGE_ACCESS_DENIED"
            case .eventBridgeManagedRuleLimitExceeded: return "EVENT_BRIDGE_MANAGED_RULE_LIMIT_EXCEEDED"
            case .iamAccessDenied: return "IAM_ACCESS_DENIED"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .kmsAccessDenied: return "KMS_ACCESS_DENIED"
            case .kmsKeyNotFound: return "KMS_KEY_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceOnboardingJobFailureCode(rawValue: rawValue) ?? InstanceOnboardingJobFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectCampaignsClientTypes.InstanceOnboardingJobStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectInstanceId
        case failureCode
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectInstanceId = self.connectInstanceId {
            try encodeContainer.encode(connectInstanceId, forKey: .connectInstanceId)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectInstanceId)
        connectInstanceId = connectInstanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.InstanceOnboardingJobStatusCode.self, forKey: .status)
        status = statusDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.InstanceOnboardingJobFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Instance onboarding job status object
    public struct InstanceOnboardingJobStatus: Swift.Equatable {
        /// Amazon Connect Instance Id
        /// This member is required.
        public var connectInstanceId: Swift.String?
        /// Enumeration of the possible failure codes for instance onboarding job
        public var failureCode: ConnectCampaignsClientTypes.InstanceOnboardingJobFailureCode?
        /// Enumeration of the possible states for instance onboarding job
        /// This member is required.
        public var status: ConnectCampaignsClientTypes.InstanceOnboardingJobStatusCode?

        public init(
            connectInstanceId: Swift.String? = nil,
            failureCode: ConnectCampaignsClientTypes.InstanceOnboardingJobFailureCode? = nil,
            status: ConnectCampaignsClientTypes.InstanceOnboardingJobStatusCode? = nil
        )
        {
            self.connectInstanceId = connectInstanceId
            self.failureCode = failureCode
            self.status = status
        }
    }

}

extension ConnectCampaignsClientTypes {
    /// Enumeration of the possible states for instance onboarding job
    public enum InstanceOnboardingJobStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceOnboardingJobStatusCode] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceOnboardingJobStatusCode(rawValue: rawValue) ?? InstanceOnboardingJobStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let xAmzErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.xAmzErrorType = xAmzErrorTypeHeaderValue
        } else {
            self.properties.xAmzErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request processing failed because of an error or failure with the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A header that defines the error encountered while processing the request.
        public internal(set) var xAmzErrorType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        xAmzErrorType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.xAmzErrorType = xAmzErrorType
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCampaignStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let xAmzErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.xAmzErrorType = xAmzErrorTypeHeaderValue
        } else {
            self.properties.xAmzErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCampaignStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.state = output.state
        } else {
            self.properties.message = nil
            self.properties.state = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the campaign.
public struct InvalidCampaignStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// State of a campaign
        /// This member is required.
        public internal(set) var state: ConnectCampaignsClientTypes.CampaignState? = nil
        /// A header that defines the error encountered while processing the request.
        public internal(set) var xAmzErrorType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCampaignStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        state: ConnectCampaignsClientTypes.CampaignState? = nil,
        xAmzErrorType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.state = state
        self.properties.xAmzErrorType = xAmzErrorType
    }
}

struct InvalidCampaignStateExceptionBody: Swift.Equatable {
    let state: ConnectCampaignsClientTypes.CampaignState?
    let message: Swift.String?
}

extension InvalidCampaignStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.CampaignState.self, forKey: .state)
        state = stateDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let xAmzErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.xAmzErrorType = xAmzErrorTypeHeaderValue
        } else {
            self.properties.xAmzErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state.
public struct InvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A header that defines the error encountered while processing the request.
        public internal(set) var xAmzErrorType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        xAmzErrorType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.xAmzErrorType = xAmzErrorType
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCampaignsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCampaignsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/campaigns-summary"
    }
}

/// ListCampaignsRequest
public struct ListCampaignsInput: Swift.Equatable {
    /// Filter model by type
    public var filters: ConnectCampaignsClientTypes.CampaignFilters?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: ConnectCampaignsClientTypes.CampaignFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCampaignsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: ConnectCampaignsClientTypes.CampaignFilters?
}

extension ListCampaignsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.CampaignFilters.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListCampaignsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCampaignsOutputBody = try responseDecoder.decode(responseBody: data)
            self.campaignSummaryList = output.campaignSummaryList
            self.nextToken = output.nextToken
        } else {
            self.campaignSummaryList = nil
            self.nextToken = nil
        }
    }
}

/// ListCampaignsResponse
public struct ListCampaignsOutput: Swift.Equatable {
    /// A list of Amazon Connect campaigns.
    public var campaignSummaryList: [ConnectCampaignsClientTypes.CampaignSummary]?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        campaignSummaryList: [ConnectCampaignsClientTypes.CampaignSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaignSummaryList = campaignSummaryList
        self.nextToken = nextToken
    }
}

struct ListCampaignsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let campaignSummaryList: [ConnectCampaignsClientTypes.CampaignSummary]?
}

extension ListCampaignsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignSummaryList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let campaignSummaryListContainer = try containerValues.decodeIfPresent([ConnectCampaignsClientTypes.CampaignSummary?].self, forKey: .campaignSummaryList)
        var campaignSummaryListDecoded0:[ConnectCampaignsClientTypes.CampaignSummary]? = nil
        if let campaignSummaryListContainer = campaignSummaryListContainer {
            campaignSummaryListDecoded0 = [ConnectCampaignsClientTypes.CampaignSummary]()
            for structure0 in campaignSummaryListContainer {
                if let structure0 = structure0 {
                    campaignSummaryListDecoded0?.append(structure0)
                }
            }
        }
        campaignSummaryList = campaignSummaryListDecoded0
    }
}

enum ListCampaignsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

/// ListTagsForResource
public struct ListTagsForResourceInput: Swift.Equatable {
    /// Arn
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// ListTagsForResponse
public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Tag map with key and value.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCampaignsClientTypes.OutboundCallConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerMachineDetectionConfig
        case connectContactFlowId
        case connectQueueId
        case connectSourcePhoneNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerMachineDetectionConfig = self.answerMachineDetectionConfig {
            try encodeContainer.encode(answerMachineDetectionConfig, forKey: .answerMachineDetectionConfig)
        }
        if let connectContactFlowId = self.connectContactFlowId {
            try encodeContainer.encode(connectContactFlowId, forKey: .connectContactFlowId)
        }
        if let connectQueueId = self.connectQueueId {
            try encodeContainer.encode(connectQueueId, forKey: .connectQueueId)
        }
        if let connectSourcePhoneNumber = self.connectSourcePhoneNumber {
            try encodeContainer.encode(connectSourcePhoneNumber, forKey: .connectSourcePhoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectContactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectContactFlowId)
        connectContactFlowId = connectContactFlowIdDecoded
        let connectSourcePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectSourcePhoneNumber)
        connectSourcePhoneNumber = connectSourcePhoneNumberDecoded
        let connectQueueIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectQueueId)
        connectQueueId = connectQueueIdDecoded
        let answerMachineDetectionConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.AnswerMachineDetectionConfig.self, forKey: .answerMachineDetectionConfig)
        answerMachineDetectionConfig = answerMachineDetectionConfigDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// The configuration used for outbound calls.
    public struct OutboundCallConfig: Swift.Equatable {
        /// Answering Machine Detection config
        public var answerMachineDetectionConfig: ConnectCampaignsClientTypes.AnswerMachineDetectionConfig?
        /// The identifier of the contact flow for the outbound call.
        /// This member is required.
        public var connectContactFlowId: Swift.String?
        /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the contact flow is used. If you do not specify a queue, you must specify a source phone number.
        public var connectQueueId: Swift.String?
        /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
        public var connectSourcePhoneNumber: Swift.String?

        public init(
            answerMachineDetectionConfig: ConnectCampaignsClientTypes.AnswerMachineDetectionConfig? = nil,
            connectContactFlowId: Swift.String? = nil,
            connectQueueId: Swift.String? = nil,
            connectSourcePhoneNumber: Swift.String? = nil
        )
        {
            self.answerMachineDetectionConfig = answerMachineDetectionConfig
            self.connectContactFlowId = connectContactFlowId
            self.connectQueueId = connectQueueId
            self.connectSourcePhoneNumber = connectSourcePhoneNumber
        }
    }

}

extension PauseCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())/pause"
    }
}

/// PauseCampaignRequest
public struct PauseCampaignInput: Swift.Equatable {
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct PauseCampaignInputBody: Swift.Equatable {
}

extension PauseCampaignInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension PauseCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PauseCampaignOutput: Swift.Equatable {

    public init() { }
}

enum PauseCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCampaignStateException": return try await InvalidCampaignStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCampaignsClientTypes.PredictiveDialerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthAllocation
        case dialingCapacity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthAllocation = self.bandwidthAllocation {
            try encodeContainer.encode(bandwidthAllocation, forKey: .bandwidthAllocation)
        }
        if let dialingCapacity = self.dialingCapacity {
            try encodeContainer.encode(dialingCapacity, forKey: .dialingCapacity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bandwidthAllocationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .bandwidthAllocation)
        bandwidthAllocation = bandwidthAllocationDecoded
        let dialingCapacityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dialingCapacity)
        dialingCapacity = dialingCapacityDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Predictive Dialer config
    public struct PredictiveDialerConfig: Swift.Equatable {
        /// The bandwidth allocation of a queue resource.
        /// This member is required.
        public var bandwidthAllocation: Swift.Double?
        /// Allocates dialing capacity for this campaign between multiple active campaigns
        public var dialingCapacity: Swift.Double?

        public init(
            bandwidthAllocation: Swift.Double? = nil,
            dialingCapacity: Swift.Double? = nil
        )
        {
            self.bandwidthAllocation = bandwidthAllocation
            self.dialingCapacity = dialingCapacity
        }
    }

}

extension ConnectCampaignsClientTypes.ProgressiveDialerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthAllocation
        case dialingCapacity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidthAllocation = self.bandwidthAllocation {
            try encodeContainer.encode(bandwidthAllocation, forKey: .bandwidthAllocation)
        }
        if let dialingCapacity = self.dialingCapacity {
            try encodeContainer.encode(dialingCapacity, forKey: .dialingCapacity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bandwidthAllocationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .bandwidthAllocation)
        bandwidthAllocation = bandwidthAllocationDecoded
        let dialingCapacityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dialingCapacity)
        dialingCapacity = dialingCapacityDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Progressive Dialer config
    public struct ProgressiveDialerConfig: Swift.Equatable {
        /// The bandwidth allocation of a queue resource.
        /// This member is required.
        public var bandwidthAllocation: Swift.Double?
        /// Allocates dialing capacity for this campaign between multiple active campaigns
        public var dialingCapacity: Swift.Double?

        public init(
            bandwidthAllocation: Swift.Double? = nil,
            dialingCapacity: Swift.Double? = nil
        )
        {
            self.bandwidthAllocation = bandwidthAllocation
            self.dialingCapacity = dialingCapacity
        }
    }

}

extension PutDialRequestBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dialRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dialRequests = dialRequests {
            var dialRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dialRequests)
            for dialrequest0 in dialRequests {
                try dialRequestsContainer.encode(dialrequest0)
            }
        }
    }
}

extension PutDialRequestBatchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())/dial-requests"
    }
}

/// PutDialRequestBatchRequest
public struct PutDialRequestBatchInput: Swift.Equatable {
    /// A list of dial requests.
    /// This member is required.
    public var dialRequests: [ConnectCampaignsClientTypes.DialRequest]?
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        dialRequests: [ConnectCampaignsClientTypes.DialRequest]? = nil,
        id: Swift.String? = nil
    )
    {
        self.dialRequests = dialRequests
        self.id = id
    }
}

struct PutDialRequestBatchInputBody: Swift.Equatable {
    let dialRequests: [ConnectCampaignsClientTypes.DialRequest]?
}

extension PutDialRequestBatchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dialRequests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dialRequestsContainer = try containerValues.decodeIfPresent([ConnectCampaignsClientTypes.DialRequest?].self, forKey: .dialRequests)
        var dialRequestsDecoded0:[ConnectCampaignsClientTypes.DialRequest]? = nil
        if let dialRequestsContainer = dialRequestsContainer {
            dialRequestsDecoded0 = [ConnectCampaignsClientTypes.DialRequest]()
            for structure0 in dialRequestsContainer {
                if let structure0 = structure0 {
                    dialRequestsDecoded0?.append(structure0)
                }
            }
        }
        dialRequests = dialRequestsDecoded0
    }
}

extension PutDialRequestBatchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutDialRequestBatchOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedRequests = output.failedRequests
            self.successfulRequests = output.successfulRequests
        } else {
            self.failedRequests = nil
            self.successfulRequests = nil
        }
    }
}

/// PutDialRequestBatchResponse
public struct PutDialRequestBatchOutput: Swift.Equatable {
    /// A list of failed requests.
    public var failedRequests: [ConnectCampaignsClientTypes.FailedRequest]?
    /// A list of successful requests identified by the unique client token.
    public var successfulRequests: [ConnectCampaignsClientTypes.SuccessfulRequest]?

    public init(
        failedRequests: [ConnectCampaignsClientTypes.FailedRequest]? = nil,
        successfulRequests: [ConnectCampaignsClientTypes.SuccessfulRequest]? = nil
    )
    {
        self.failedRequests = failedRequests
        self.successfulRequests = successfulRequests
    }
}

struct PutDialRequestBatchOutputBody: Swift.Equatable {
    let successfulRequests: [ConnectCampaignsClientTypes.SuccessfulRequest]?
    let failedRequests: [ConnectCampaignsClientTypes.FailedRequest]?
}

extension PutDialRequestBatchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedRequests
        case successfulRequests
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulRequestsContainer = try containerValues.decodeIfPresent([ConnectCampaignsClientTypes.SuccessfulRequest?].self, forKey: .successfulRequests)
        var successfulRequestsDecoded0:[ConnectCampaignsClientTypes.SuccessfulRequest]? = nil
        if let successfulRequestsContainer = successfulRequestsContainer {
            successfulRequestsDecoded0 = [ConnectCampaignsClientTypes.SuccessfulRequest]()
            for structure0 in successfulRequestsContainer {
                if let structure0 = structure0 {
                    successfulRequestsDecoded0?.append(structure0)
                }
            }
        }
        successfulRequests = successfulRequestsDecoded0
        let failedRequestsContainer = try containerValues.decodeIfPresent([ConnectCampaignsClientTypes.FailedRequest?].self, forKey: .failedRequests)
        var failedRequestsDecoded0:[ConnectCampaignsClientTypes.FailedRequest]? = nil
        if let failedRequestsContainer = failedRequestsContainer {
            failedRequestsDecoded0 = [ConnectCampaignsClientTypes.FailedRequest]()
            for structure0 in failedRequestsContainer {
                if let structure0 = structure0 {
                    failedRequestsDecoded0?.append(structure0)
                }
            }
        }
        failedRequests = failedRequestsDecoded0
    }
}

enum PutDialRequestBatchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCampaignStateException": return try await InvalidCampaignStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let xAmzErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.xAmzErrorType = xAmzErrorTypeHeaderValue
        } else {
            self.properties.xAmzErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A header that defines the error encountered while processing the request.
        public internal(set) var xAmzErrorType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        xAmzErrorType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.xAmzErrorType = xAmzErrorType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResumeCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())/resume"
    }
}

/// ResumeCampaignRequest
public struct ResumeCampaignInput: Swift.Equatable {
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct ResumeCampaignInputBody: Swift.Equatable {
}

extension ResumeCampaignInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ResumeCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResumeCampaignOutput: Swift.Equatable {

    public init() { }
}

enum ResumeCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCampaignStateException": return try await InvalidCampaignStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let xAmzErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.xAmzErrorType = xAmzErrorTypeHeaderValue
        } else {
            self.properties.xAmzErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A header that defines the error encountered while processing the request.
        public internal(set) var xAmzErrorType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        xAmzErrorType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.xAmzErrorType = xAmzErrorType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())/start"
    }
}

/// StartCampaignRequest
public struct StartCampaignInput: Swift.Equatable {
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StartCampaignInputBody: Swift.Equatable {
}

extension StartCampaignInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartCampaignOutput: Swift.Equatable {

    public init() { }
}

enum StartCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCampaignStateException": return try await InvalidCampaignStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartInstanceOnboardingJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
    }
}

extension StartInstanceOnboardingJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectInstanceId = connectInstanceId else {
            return nil
        }
        return "/connect-instance/\(connectInstanceId.urlPercentEncoding())/onboarding"
    }
}

/// The request for StartInstanceOnboardingJob API.
public struct StartInstanceOnboardingJobInput: Swift.Equatable {
    /// Amazon Connect Instance Id
    /// This member is required.
    public var connectInstanceId: Swift.String?
    /// Encryption config for Connect Instance. Note that sensitive data will always be encrypted. If disabled, service will perform encryption with its own key. If enabled, a KMS key id needs to be provided and KMS charges will apply. KMS is only type supported
    /// This member is required.
    public var encryptionConfig: ConnectCampaignsClientTypes.EncryptionConfig?

    public init(
        connectInstanceId: Swift.String? = nil,
        encryptionConfig: ConnectCampaignsClientTypes.EncryptionConfig? = nil
    )
    {
        self.connectInstanceId = connectInstanceId
        self.encryptionConfig = encryptionConfig
    }
}

struct StartInstanceOnboardingJobInputBody: Swift.Equatable {
    let encryptionConfig: ConnectCampaignsClientTypes.EncryptionConfig?
}

extension StartInstanceOnboardingJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

extension StartInstanceOnboardingJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartInstanceOnboardingJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectInstanceOnboardingJobStatus = output.connectInstanceOnboardingJobStatus
        } else {
            self.connectInstanceOnboardingJobStatus = nil
        }
    }
}

/// The response for StartInstanceOnboardingJob API.
public struct StartInstanceOnboardingJobOutput: Swift.Equatable {
    /// Instance onboarding job status object
    public var connectInstanceOnboardingJobStatus: ConnectCampaignsClientTypes.InstanceOnboardingJobStatus?

    public init(
        connectInstanceOnboardingJobStatus: ConnectCampaignsClientTypes.InstanceOnboardingJobStatus? = nil
    )
    {
        self.connectInstanceOnboardingJobStatus = connectInstanceOnboardingJobStatus
    }
}

struct StartInstanceOnboardingJobOutputBody: Swift.Equatable {
    let connectInstanceOnboardingJobStatus: ConnectCampaignsClientTypes.InstanceOnboardingJobStatus?
}

extension StartInstanceOnboardingJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectInstanceOnboardingJobStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectInstanceOnboardingJobStatusDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.InstanceOnboardingJobStatus.self, forKey: .connectInstanceOnboardingJobStatus)
        connectInstanceOnboardingJobStatus = connectInstanceOnboardingJobStatusDecoded
    }
}

enum StartInstanceOnboardingJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())/stop"
    }
}

/// StopCampaignRequest
public struct StopCampaignInput: Swift.Equatable {
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StopCampaignInputBody: Swift.Equatable {
}

extension StopCampaignInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopCampaignOutput: Swift.Equatable {

    public init() { }
}

enum StopCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCampaignStateException": return try await InvalidCampaignStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectCampaignsClientTypes.SuccessfulCampaignStateResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignId
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignId = self.campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.CampaignState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// Successful response of campaign state
    public struct SuccessfulCampaignStateResponse: Swift.Equatable {
        /// Identifier representing a Campaign
        public var campaignId: Swift.String?
        /// State of a campaign
        public var state: ConnectCampaignsClientTypes.CampaignState?

        public init(
            campaignId: Swift.String? = nil,
            state: ConnectCampaignsClientTypes.CampaignState? = nil
        )
        {
            self.campaignId = campaignId
            self.state = state
        }
    }

}

extension ConnectCampaignsClientTypes.SuccessfulRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension ConnectCampaignsClientTypes {
    /// A successful request identified by the unique client token.
    public struct SuccessfulRequest: Swift.Equatable {
        /// Client provided parameter used for idempotency. Its value must be unique for each request.
        public var clientToken: Swift.String?
        /// Identifier representing a Dial request
        public var id: Swift.String?

        public init(
            clientToken: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.clientToken = clientToken
            self.id = id
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

/// TagResourceRequest
public struct TagResourceInput: Swift.Equatable {
    /// Arn
    /// This member is required.
    public var arn: Swift.String?
    /// Tag map with key and value.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let xAmzErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.xAmzErrorType = xAmzErrorTypeHeaderValue
        } else {
            self.properties.xAmzErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A header that defines the error encountered while processing the request.
        public internal(set) var xAmzErrorType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        xAmzErrorType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.xAmzErrorType = xAmzErrorType
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let arn = arn else {
            return nil
        }
        return "/tags/\(arn.urlPercentEncoding())"
    }
}

/// UntagResourceRequest
public struct UntagResourceInput: Swift.Equatable {
    /// Arn
    /// This member is required.
    public var arn: Swift.String?
    /// List of tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCampaignDialerConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dialerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dialerConfig = self.dialerConfig {
            try encodeContainer.encode(dialerConfig, forKey: .dialerConfig)
        }
    }
}

extension UpdateCampaignDialerConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())/dialer-config"
    }
}

/// UpdateCampaignDialerConfigRequest
public struct UpdateCampaignDialerConfigInput: Swift.Equatable {
    /// The possible types of dialer config parameters
    /// This member is required.
    public var dialerConfig: ConnectCampaignsClientTypes.DialerConfig?
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        dialerConfig: ConnectCampaignsClientTypes.DialerConfig? = nil,
        id: Swift.String? = nil
    )
    {
        self.dialerConfig = dialerConfig
        self.id = id
    }
}

struct UpdateCampaignDialerConfigInputBody: Swift.Equatable {
    let dialerConfig: ConnectCampaignsClientTypes.DialerConfig?
}

extension UpdateCampaignDialerConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dialerConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dialerConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.DialerConfig.self, forKey: .dialerConfig)
        dialerConfig = dialerConfigDecoded
    }
}

extension UpdateCampaignDialerConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateCampaignDialerConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateCampaignDialerConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCampaignNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCampaignNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())/name"
    }
}

/// UpdateCampaignNameRequest
public struct UpdateCampaignNameInput: Swift.Equatable {
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?
    /// The name of an Amazon Connect Campaign name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
    }
}

struct UpdateCampaignNameInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateCampaignNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateCampaignNameOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateCampaignNameOutput: Swift.Equatable {

    public init() { }
}

enum UpdateCampaignNameOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCampaignOutboundCallConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerMachineDetectionConfig
        case connectContactFlowId
        case connectSourcePhoneNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let answerMachineDetectionConfig = self.answerMachineDetectionConfig {
            try encodeContainer.encode(answerMachineDetectionConfig, forKey: .answerMachineDetectionConfig)
        }
        if let connectContactFlowId = self.connectContactFlowId {
            try encodeContainer.encode(connectContactFlowId, forKey: .connectContactFlowId)
        }
        if let connectSourcePhoneNumber = self.connectSourcePhoneNumber {
            try encodeContainer.encode(connectSourcePhoneNumber, forKey: .connectSourcePhoneNumber)
        }
    }
}

extension UpdateCampaignOutboundCallConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/campaigns/\(id.urlPercentEncoding())/outbound-call-config"
    }
}

/// UpdateCampaignOutboundCallConfigRequest
public struct UpdateCampaignOutboundCallConfigInput: Swift.Equatable {
    /// Answering Machine Detection config
    public var answerMachineDetectionConfig: ConnectCampaignsClientTypes.AnswerMachineDetectionConfig?
    /// The identifier of the contact flow for the outbound call.
    public var connectContactFlowId: Swift.String?
    /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
    public var connectSourcePhoneNumber: Swift.String?
    /// Identifier representing a Campaign
    /// This member is required.
    public var id: Swift.String?

    public init(
        answerMachineDetectionConfig: ConnectCampaignsClientTypes.AnswerMachineDetectionConfig? = nil,
        connectContactFlowId: Swift.String? = nil,
        connectSourcePhoneNumber: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.answerMachineDetectionConfig = answerMachineDetectionConfig
        self.connectContactFlowId = connectContactFlowId
        self.connectSourcePhoneNumber = connectSourcePhoneNumber
        self.id = id
    }
}

struct UpdateCampaignOutboundCallConfigInputBody: Swift.Equatable {
    let connectContactFlowId: Swift.String?
    let connectSourcePhoneNumber: Swift.String?
    let answerMachineDetectionConfig: ConnectCampaignsClientTypes.AnswerMachineDetectionConfig?
}

extension UpdateCampaignOutboundCallConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case answerMachineDetectionConfig
        case connectContactFlowId
        case connectSourcePhoneNumber
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectContactFlowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectContactFlowId)
        connectContactFlowId = connectContactFlowIdDecoded
        let connectSourcePhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectSourcePhoneNumber)
        connectSourcePhoneNumber = connectSourcePhoneNumberDecoded
        let answerMachineDetectionConfigDecoded = try containerValues.decodeIfPresent(ConnectCampaignsClientTypes.AnswerMachineDetectionConfig.self, forKey: .answerMachineDetectionConfig)
        answerMachineDetectionConfig = answerMachineDetectionConfigDecoded
    }
}

extension UpdateCampaignOutboundCallConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateCampaignOutboundCallConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateCampaignOutboundCallConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let xAmzErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            self.properties.xAmzErrorType = xAmzErrorTypeHeaderValue
        } else {
            self.properties.xAmzErrorType = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A header that defines the error encountered while processing the request.
        public internal(set) var xAmzErrorType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        xAmzErrorType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.xAmzErrorType = xAmzErrorType
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
