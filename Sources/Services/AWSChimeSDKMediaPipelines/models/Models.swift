// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
        case compositedVideo = "CompositedVideo"
        case content = "Content"
        case dataChannel = "DataChannel"
        case meetingEvents = "MeetingEvents"
        case transcriptionMessages = "TranscriptionMessages"
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let compositedVideo = self.compositedVideo {
            try encodeContainer.encode(compositedVideo, forKey: .compositedVideo)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let dataChannel = self.dataChannel {
            try encodeContainer.encode(dataChannel, forKey: .dataChannel)
        }
        if let meetingEvents = self.meetingEvents {
            try encodeContainer.encode(meetingEvents, forKey: .meetingEvents)
        }
        if let transcriptionMessages = self.transcriptionMessages {
            try encodeContainer.encode(transcriptionMessages, forKey: .transcriptionMessages)
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration.self, forKey: .audio)
        audio = audioDecoded
        let videoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration.self, forKey: .video)
        video = videoDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration.self, forKey: .content)
        content = contentDecoded
        let dataChannelDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration.self, forKey: .dataChannel)
        dataChannel = dataChannelDecoded
        let transcriptionMessagesDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration.self, forKey: .transcriptionMessages)
        transcriptionMessages = transcriptionMessagesDecoded
        let meetingEventsDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration.self, forKey: .meetingEvents)
        meetingEvents = meetingEventsDecoded
        let compositedVideoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration.self, forKey: .compositedVideo)
        compositedVideo = compositedVideoDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration for the artifacts concatenation.
    public struct ArtifactsConcatenationConfiguration: Swift.Equatable {
        /// The configuration for the audio artifacts concatenation.
        /// This member is required.
        public var audio: ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration?
        /// The configuration for the composited video artifacts concatenation.
        /// This member is required.
        public var compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration?
        /// The configuration for the content artifacts concatenation.
        /// This member is required.
        public var content: ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration?
        /// The configuration for the data channel artifacts concatenation.
        /// This member is required.
        public var dataChannel: ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration?
        /// The configuration for the meeting events artifacts concatenation.
        /// This member is required.
        public var meetingEvents: ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration?
        /// The configuration for the transcription messages artifacts concatenation.
        /// This member is required.
        public var transcriptionMessages: ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration?
        /// The configuration for the video artifacts concatenation.
        /// This member is required.
        public var video: ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration?

        public init (
            audio: ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration? = nil,
            compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration? = nil,
            content: ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration? = nil,
            dataChannel: ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration? = nil,
            meetingEvents: ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration? = nil,
            transcriptionMessages: ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration? = nil,
            video: ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration? = nil
        )
        {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.dataChannel = dataChannel
            self.meetingEvents = meetingEvents
            self.transcriptionMessages = transcriptionMessages
            self.video = video
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ArtifactsConcatenationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsConcatenationState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactsConcatenationState(rawValue: rawValue) ?? ArtifactsConcatenationState.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
        case compositedVideo = "CompositedVideo"
        case content = "Content"
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let compositedVideo = self.compositedVideo {
            try encodeContainer.encode(compositedVideo, forKey: .compositedVideo)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration.self, forKey: .audio)
        audio = audioDecoded
        let videoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration.self, forKey: .video)
        video = videoDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration.self, forKey: .content)
        content = contentDecoded
        let compositedVideoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration.self, forKey: .compositedVideo)
        compositedVideo = compositedVideoDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration for the artifacts.
    public struct ArtifactsConfiguration: Swift.Equatable {
        /// The configuration for the audio artifacts.
        /// This member is required.
        public var audio: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration?
        /// Enables video compositing.
        public var compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration?
        /// The configuration for the content artifacts.
        /// This member is required.
        public var content: ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration?
        /// The configuration for the video artifacts.
        /// This member is required.
        public var video: ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration?

        public init (
            audio: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration? = nil,
            compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration? = nil,
            content: ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration? = nil,
            video: ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration? = nil
        )
        {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.video = video
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ArtifactsState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactsState(rawValue: rawValue) ?? ArtifactsState.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum AudioArtifactsConcatenationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioArtifactsConcatenationState] {
            return [
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudioArtifactsConcatenationState(rawValue: rawValue) ?? AudioArtifactsConcatenationState.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The audio artifact configuration object.
    public struct AudioArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the audio artifact configuration object.
        /// This member is required.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.AudioMuxType?

        public init (
            muxType: ChimeSDKMediaPipelinesClientTypes.AudioMuxType? = nil
        )
        {
            self.muxType = muxType
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum AudioChannelsOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mono
        case stereo
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioChannelsOption] {
            return [
                .mono,
                .stereo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mono: return "Mono"
            case .stereo: return "Stereo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudioChannelsOption(rawValue: rawValue) ?? AudioChannelsOption.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The audio artifact concatenation configuration object.
    public struct AudioConcatenationConfiguration: Swift.Equatable {
        /// Enables the name object, where name is the name of the configuration object, such as AudioConcatenation.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConcatenationState?

        public init (
            state: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum AudioMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audioonly
        case audiowithactivespeakervideo
        case audiowithcompositedvideo
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioMuxType] {
            return [
                .audioonly,
                .audiowithactivespeakervideo,
                .audiowithcompositedvideo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audioonly: return "AudioOnly"
            case .audiowithactivespeakervideo: return "AudioWithActiveSpeakerVideo"
            case .audiowithcompositedvideo: return "AudioWithCompositedVideo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudioMuxType(rawValue: rawValue) ?? AudioMuxType.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsConfiguration = "ArtifactsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsConfiguration = self.artifactsConfiguration {
            try encodeContainer.encode(artifactsConfiguration, forKey: .artifactsConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration.self, forKey: .artifactsConfiguration)
        artifactsConfiguration = artifactsConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object of the Amazon Chime SDK meeting concatenation for a specified media pipeline.
    public struct ChimeSdkMeetingConcatenationConfiguration: Swift.Equatable {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting concatenation.
        /// This member is required.
        public var artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration?

        public init (
            artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration? = nil
        )
        {
            self.artifactsConfiguration = artifactsConfiguration
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsConfiguration = "ArtifactsConfiguration"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsConfiguration = self.artifactsConfiguration {
            try encodeContainer.encode(artifactsConfiguration, forKey: .artifactsConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let artifactsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration.self, forKey: .artifactsConfiguration)
        artifactsConfiguration = artifactsConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object of the Amazon Chime SDK meeting for a specified media pipeline. SourceType must be ChimeSdkMeeting.
    public struct ChimeSdkMeetingConfiguration: Swift.Equatable {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting.
        public var artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration?
        /// The source configuration for a specified media pipline.
        public var sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration?

        public init (
            artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration? = nil,
            sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration? = nil
        )
        {
            self.artifactsConfiguration = artifactsConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case compositedVideo = "CompositedVideo"
        case muxType = "MuxType"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let compositedVideo = self.compositedVideo {
            try encodeContainer.encode(compositedVideo, forKey: .compositedVideo)
        }
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LiveConnectorMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
        let compositedVideoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration.self, forKey: .compositedVideo)
        compositedVideo = compositedVideoDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChimeSdkMeetingLiveConnectorConfiguration(compositedVideo: \(Swift.String(describing: compositedVideo)), muxType: \(Swift.String(describing: muxType)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), arn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The media pipeline's configuration object.
    public struct ChimeSdkMeetingLiveConnectorConfiguration: Swift.Equatable {
        /// The configuration object's Chime SDK meeting ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// The media pipeline's composited video.
        public var compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration?
        /// The configuration object's multiplex type.
        /// This member is required.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorMuxType?
        /// The source configuration settings of the media pipeline's configuration object.
        public var sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration?

        public init (
            arn: Swift.String? = nil,
            compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration? = nil,
            muxType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorMuxType? = nil,
            sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration? = nil
        )
        {
            self.arn = arn
            self.compositedVideo = compositedVideo
            self.muxType = muxType
            self.sourceConfiguration = sourceConfiguration
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gridViewConfiguration = "GridViewConfiguration"
        case layout = "Layout"
        case resolution = "Resolution"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gridViewConfiguration = self.gridViewConfiguration {
            try encodeContainer.encode(gridViewConfiguration, forKey: .gridViewConfiguration)
        }
        if let layout = self.layout {
            try encodeContainer.encode(layout.rawValue, forKey: .layout)
        }
        if let resolution = self.resolution {
            try encodeContainer.encode(resolution.rawValue, forKey: .resolution)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LayoutOption.self, forKey: .layout)
        layout = layoutDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ResolutionOption.self, forKey: .resolution)
        resolution = resolutionDecoded
        let gridViewConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration.self, forKey: .gridViewConfiguration)
        gridViewConfiguration = gridViewConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Describes the configuration for the composited video artifacts.
    public struct CompositedVideoArtifactsConfiguration: Swift.Equatable {
        /// The GridView configuration setting.
        /// This member is required.
        public var gridViewConfiguration: ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration?
        /// The layout setting, such as GridView in the configuration object.
        public var layout: ChimeSDKMediaPipelinesClientTypes.LayoutOption?
        /// The video resolution setting in the configuration object. Default: HD at 1280 x 720. FHD resolution: 1920 x 1080.
        public var resolution: ChimeSDKMediaPipelinesClientTypes.ResolutionOption?

        public init (
            gridViewConfiguration: ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration? = nil,
            layout: ChimeSDKMediaPipelinesClientTypes.LayoutOption? = nil,
            resolution: ChimeSDKMediaPipelinesClientTypes.ResolutionOption? = nil
        )
        {
            self.gridViewConfiguration = gridViewConfiguration
            self.layout = layout
            self.resolution = resolution
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The composited video configuration object for a specified media pipeline. SourceType must be ChimeSdkMeeting.
    public struct CompositedVideoConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init (
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ConcatenationSink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketSinkConfiguration = "S3BucketSinkConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketSinkConfiguration = self.s3BucketSinkConfiguration {
            try encodeContainer.encode(s3BucketSinkConfiguration, forKey: .s3BucketSinkConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ConcatenationSinkType.self, forKey: .type)
        type = typeDecoded
        let s3BucketSinkConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration.self, forKey: .s3BucketSinkConfiguration)
        s3BucketSinkConfiguration = s3BucketSinkConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The data sink of the configuration object.
    public struct ConcatenationSink: Swift.Equatable {
        /// The configuration settings for an Amazon S3 bucket sink.
        /// This member is required.
        public var s3BucketSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration?
        /// The type of data sink in the configuration object.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSinkType?

        public init (
            s3BucketSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSinkType? = nil
        )
        {
            self.s3BucketSinkConfiguration = s3BucketSinkConfiguration
            self.type = type
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ConcatenationSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [ConcatenationSinkType] {
            return [
                .s3bucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConcatenationSinkType(rawValue: rawValue) ?? ConcatenationSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ConcatenationSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipelineSourceConfiguration = "MediaCapturePipelineSourceConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaCapturePipelineSourceConfiguration = self.mediaCapturePipelineSourceConfiguration {
            try encodeContainer.encode(mediaCapturePipelineSourceConfiguration, forKey: .mediaCapturePipelineSourceConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ConcatenationSourceType.self, forKey: .type)
        type = typeDecoded
        let mediaCapturePipelineSourceConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration.self, forKey: .mediaCapturePipelineSourceConfiguration)
        mediaCapturePipelineSourceConfiguration = mediaCapturePipelineSourceConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The source type and media pipeline configuration settings in a configuration object.
    public struct ConcatenationSource: Swift.Equatable {
        /// The concatenation settings for the media pipeline in a configuration object.
        /// This member is required.
        public var mediaCapturePipelineSourceConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration?
        /// The type of concatenation source in a configuration object.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSourceType?

        public init (
            mediaCapturePipelineSourceConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSourceType? = nil
        )
        {
            self.mediaCapturePipelineSourceConfiguration = mediaCapturePipelineSourceConfiguration
            self.type = type
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ConcatenationSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mediacapturepipeline
        case sdkUnknown(Swift.String)

        public static var allCases: [ConcatenationSourceType] {
            return [
                .mediacapturepipeline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mediacapturepipeline: return "MediaCapturePipeline"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConcatenationSourceType(rawValue: rawValue) ?? ConcatenationSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsState.self, forKey: .state)
        state = stateDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The content artifact object.
    public struct ContentArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the artifact configuration.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.ContentMuxType?
        /// Indicates whether the content artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState?

        public init (
            muxType: ChimeSDKMediaPipelinesClientTypes.ContentMuxType? = nil,
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The composited content configuration object for a specified media pipeline.
    public struct ContentConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init (
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ContentMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contentonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentMuxType] {
            return [
                .contentonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contentonly: return "ContentOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentMuxType(rawValue: rawValue) ?? ContentMuxType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ContentShareLayoutOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case horizontal
        case presenteronly
        case vertical
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentShareLayoutOption] {
            return [
                .horizontal,
                .presenteronly,
                .vertical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .horizontal: return "Horizontal"
            case .presenteronly: return "PresenterOnly"
            case .vertical: return "Vertical"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentShareLayoutOption(rawValue: rawValue) ?? ContentShareLayoutOption.sdkUnknown(rawValue)
        }
    }
}

extension CreateMediaCapturePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaCapturePipelineInput(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension CreateMediaCapturePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-capture-pipelines"
    }
}

public struct CreateMediaCapturePipelineInput: Swift.Equatable {
    /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
    public var chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
    /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.
    public var clientRequestToken: Swift.String?
    /// The ARN of the sink type.
    /// This member is required.
    public var sinkArn: Swift.String?
    /// Destination type to which the media artifacts are saved. You must use an S3 bucket.
    /// This member is required.
    public var sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType?
    /// ARN of the source from which the media artifacts are captured.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.
    /// This member is required.
    public var sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?
    /// The tag key-value pairs.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init (
        chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration? = nil,
        clientRequestToken: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType? = nil,
        sourceArn: Swift.String? = nil,
        sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
        self.clientRequestToken = clientRequestToken
        self.sinkArn = sinkArn
        self.sinkType = sinkType
        self.sourceArn = sourceArn
        self.sourceType = sourceType
        self.tags = tags
    }
}

struct CreateMediaCapturePipelineInputBody: Swift.Equatable {
    let sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?
    let sourceArn: Swift.String?
    let sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType?
    let sinkArn: Swift.String?
    let clientRequestToken: Swift.String?
    let chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension CreateMediaCapturePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMediaCapturePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMediaCapturePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMediaCapturePipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMediaCapturePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMediaCapturePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct CreateMediaCapturePipelineOutputResponse: Swift.Equatable {
    /// A media pipeline object, the ID, source type, source ARN, sink type, and sink ARN of a media pipeline object.
    public var mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?

    public init (
        mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct CreateMediaCapturePipelineOutputResponseBody: Swift.Equatable {
    let mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?
}

extension CreateMediaCapturePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

extension CreateMediaConcatenationPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaConcatenationPipelineInput(sinks: \(Swift.String(describing: sinks)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension CreateMediaConcatenationPipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for concatenationsink0 in sinks {
                try sinksContainer.encode(concatenationsink0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for concatenationsource0 in sources {
                try sourcesContainer.encode(concatenationsource0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaConcatenationPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-concatenation-pipelines"
    }
}

public struct CreateMediaConcatenationPipelineInput: Swift.Equatable {
    /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media concatenation pipeline request.
    public var clientRequestToken: Swift.String?
    /// An object that specifies the data sinks for the media concatenation pipeline.
    /// This member is required.
    public var sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]?
    /// An object that specifies the sources for the media concatenation pipeline.
    /// This member is required.
    public var sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]?
    /// The tags associated with the media concatenation pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil,
        sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sinks = sinks
        self.sources = sources
        self.tags = tags
    }
}

struct CreateMediaConcatenationPipelineInputBody: Swift.Equatable {
    let sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]?
    let sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension CreateMediaConcatenationPipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.ConcatenationSource?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.ConcatenationSink?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMediaConcatenationPipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMediaConcatenationPipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMediaConcatenationPipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMediaConcatenationPipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMediaConcatenationPipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaConcatenationPipeline = output.mediaConcatenationPipeline
        } else {
            self.mediaConcatenationPipeline = nil
        }
    }
}

public struct CreateMediaConcatenationPipelineOutputResponse: Swift.Equatable {
    /// A media concatenation pipeline object, the ID, source type, MediaPipelineARN, and sink of a media concatenation pipeline object.
    public var mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline?

    public init (
        mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline? = nil
    )
    {
        self.mediaConcatenationPipeline = mediaConcatenationPipeline
    }
}

struct CreateMediaConcatenationPipelineOutputResponseBody: Swift.Equatable {
    let mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline?
}

extension CreateMediaConcatenationPipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaConcatenationPipeline = "MediaConcatenationPipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaConcatenationPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline.self, forKey: .mediaConcatenationPipeline)
        mediaConcatenationPipeline = mediaConcatenationPipelineDecoded
    }
}

extension CreateMediaLiveConnectorPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaLiveConnectorPipelineInput(sinks: \(Swift.String(describing: sinks)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension CreateMediaLiveConnectorPipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for liveconnectorsinkconfiguration0 in sinks {
                try sinksContainer.encode(liveconnectorsinkconfiguration0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for liveconnectorsourceconfiguration0 in sources {
                try sourcesContainer.encode(liveconnectorsourceconfiguration0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaLiveConnectorPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-live-connector-pipelines"
    }
}

public struct CreateMediaLiveConnectorPipelineInput: Swift.Equatable {
    /// The token assigned to the client making the request.
    public var clientRequestToken: Swift.String?
    /// The media pipeline's data sinks.
    /// This member is required.
    public var sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]?
    /// The media pipeline's data sources.
    /// This member is required.
    public var sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]?
    /// The tags associated with the media pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil,
        sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sinks = sinks
        self.sources = sources
        self.tags = tags
    }
}

struct CreateMediaLiveConnectorPipelineInputBody: Swift.Equatable {
    let sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]?
    let sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension CreateMediaLiveConnectorPipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMediaLiveConnectorPipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMediaLiveConnectorPipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMediaLiveConnectorPipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMediaLiveConnectorPipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMediaLiveConnectorPipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaLiveConnectorPipeline = output.mediaLiveConnectorPipeline
        } else {
            self.mediaLiveConnectorPipeline = nil
        }
    }
}

public struct CreateMediaLiveConnectorPipelineOutputResponse: Swift.Equatable {
    /// The new media pipeline.
    public var mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline?

    public init (
        mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline? = nil
    )
    {
        self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
    }
}

struct CreateMediaLiveConnectorPipelineOutputResponseBody: Swift.Equatable {
    let mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline?
}

extension CreateMediaLiveConnectorPipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaLiveConnectorPipeline = "MediaLiveConnectorPipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaLiveConnectorPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline.self, forKey: .mediaLiveConnectorPipeline)
        mediaLiveConnectorPipeline = mediaLiveConnectorPipelineDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The content configuration object's data channel.
    public struct DataChannelConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init (
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension DeleteMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct DeleteMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the media pipeline being deleted.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init (
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct DeleteMediaCapturePipelineInputBody: Swift.Equatable {
}

extension DeleteMediaCapturePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaCapturePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMediaCapturePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMediaCapturePipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMediaCapturePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMediaCapturePipelineOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteMediaPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct DeleteMediaPipelineInput: Swift.Equatable {
    /// The ID of the media pipeline to delete.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init (
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct DeleteMediaPipelineInputBody: Swift.Equatable {
}

extension DeleteMediaPipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaPipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMediaPipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMediaPipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMediaPipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMediaPipelineOutputResponse: Swift.Equatable {

    public init () { }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badrequest
        case forbidden
        case notfound
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttling
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .badrequest,
                .forbidden,
                .notfound,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badrequest: return "BadRequest"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttling: return "Throttling"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct GetMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init (
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct GetMediaCapturePipelineInputBody: Swift.Equatable {
}

extension GetMediaCapturePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMediaCapturePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMediaCapturePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMediaCapturePipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMediaCapturePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMediaCapturePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct GetMediaCapturePipelineOutputResponse: Swift.Equatable {
    /// The media pipeline object.
    public var mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?

    public init (
        mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct GetMediaCapturePipelineOutputResponseBody: Swift.Equatable {
    let mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?
}

extension GetMediaCapturePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

extension GetMediaPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct GetMediaPipelineInput: Swift.Equatable {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init (
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct GetMediaPipelineInputBody: Swift.Equatable {
}

extension GetMediaPipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMediaPipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMediaPipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMediaPipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMediaPipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMediaPipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaPipeline = output.mediaPipeline
        } else {
            self.mediaPipeline = nil
        }
    }
}

public struct GetMediaPipelineOutputResponse: Swift.Equatable {
    /// The media pipeline object.
    public var mediaPipeline: ChimeSDKMediaPipelinesClientTypes.MediaPipeline?

    public init (
        mediaPipeline: ChimeSDKMediaPipelinesClientTypes.MediaPipeline? = nil
    )
    {
        self.mediaPipeline = mediaPipeline
    }
}

struct GetMediaPipelineOutputResponseBody: Swift.Equatable {
    let mediaPipeline: ChimeSDKMediaPipelinesClientTypes.MediaPipeline?
}

extension GetMediaPipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPipeline = "MediaPipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipeline.self, forKey: .mediaPipeline)
        mediaPipeline = mediaPipelineDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentShareLayout = "ContentShareLayout"
        case presenterOnlyConfiguration = "PresenterOnlyConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentShareLayout = self.contentShareLayout {
            try encodeContainer.encode(contentShareLayout.rawValue, forKey: .contentShareLayout)
        }
        if let presenterOnlyConfiguration = self.presenterOnlyConfiguration {
            try encodeContainer.encode(presenterOnlyConfiguration, forKey: .presenterOnlyConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentShareLayoutDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentShareLayoutOption.self, forKey: .contentShareLayout)
        contentShareLayout = contentShareLayoutDecoded
        let presenterOnlyConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration.self, forKey: .presenterOnlyConfiguration)
        presenterOnlyConfiguration = presenterOnlyConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Specifies the type of grid layout.
    public struct GridViewConfiguration: Swift.Equatable {
        /// Defines the layout of the video tiles when content sharing is enabled.
        /// This member is required.
        public var contentShareLayout: ChimeSDKMediaPipelinesClientTypes.ContentShareLayoutOption?
        /// Defines the configuration options for a presenter only video tile.
        public var presenterOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration?

        public init (
            contentShareLayout: ChimeSDKMediaPipelinesClientTypes.ContentShareLayoutOption? = nil,
            presenterOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration? = nil
        )
        {
            self.contentShareLayout = contentShareLayout
            self.presenterOnlyConfiguration = presenterOnlyConfiguration
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum LayoutOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gridview
        case sdkUnknown(Swift.String)

        public static var allCases: [LayoutOption] {
            return [
                .gridview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gridview: return "GridView"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayoutOption(rawValue: rawValue) ?? LayoutOption.sdkUnknown(rawValue)
        }
    }
}

extension ListMediaCapturePipelinesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMediaCapturePipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-capture-pipelines"
    }
}

public struct ListMediaCapturePipelinesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesInputBody: Swift.Equatable {
}

extension ListMediaCapturePipelinesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMediaCapturePipelinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMediaCapturePipelinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMediaCapturePipelinesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMediaCapturePipelinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMediaCapturePipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipelines = output.mediaCapturePipelines
            self.nextToken = output.nextToken
        } else {
            self.mediaCapturePipelines = nil
            self.nextToken = nil
        }
    }
}

public struct ListMediaCapturePipelinesOutputResponse: Swift.Equatable {
    /// The media pipeline objects in the list.
    public var mediaCapturePipelines: [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        mediaCapturePipelines: [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaCapturePipelines = mediaCapturePipelines
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesOutputResponseBody: Swift.Equatable {
    let mediaCapturePipelines: [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]?
    let nextToken: Swift.String?
}

extension ListMediaCapturePipelinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipelines = "MediaCapturePipelines"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelinesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary?].self, forKey: .mediaCapturePipelines)
        var mediaCapturePipelinesDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]? = nil
        if let mediaCapturePipelinesContainer = mediaCapturePipelinesContainer {
            mediaCapturePipelinesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]()
            for structure0 in mediaCapturePipelinesContainer {
                if let structure0 = structure0 {
                    mediaCapturePipelinesDecoded0?.append(structure0)
                }
            }
        }
        mediaCapturePipelines = mediaCapturePipelinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMediaPipelinesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMediaPipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-pipelines"
    }
}

public struct ListMediaPipelinesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMediaPipelinesInputBody: Swift.Equatable {
}

extension ListMediaPipelinesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMediaPipelinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMediaPipelinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMediaPipelinesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMediaPipelinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMediaPipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaPipelines = output.mediaPipelines
            self.nextToken = output.nextToken
        } else {
            self.mediaPipelines = nil
            self.nextToken = nil
        }
    }
}

public struct ListMediaPipelinesOutputResponse: Swift.Equatable {
    /// The media pipeline objects in the list.
    public var mediaPipelines: [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        mediaPipelines: [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaPipelines = mediaPipelines
        self.nextToken = nextToken
    }
}

struct ListMediaPipelinesOutputResponseBody: Swift.Equatable {
    let mediaPipelines: [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]?
    let nextToken: Swift.String?
}

extension ListMediaPipelinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPipelines = "MediaPipelines"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelinesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary?].self, forKey: .mediaPipelines)
        var mediaPipelinesDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]? = nil
        if let mediaPipelinesContainer = mediaPipelinesContainer {
            mediaPipelinesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]()
            for structure0 in mediaPipelinesContainer {
                if let structure0 = structure0 {
                    mediaPipelinesDecoded0?.append(structure0)
                }
            }
        }
        mediaPipelines = mediaPipelinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceARN = resourceARN else {
                let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's region, resource ID, and pipeline ID.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the specified media pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init (
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum LiveConnectorMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audiowithactivespeakervideo
        case audiowithcompositedvideo
        case sdkUnknown(Swift.String)

        public static var allCases: [LiveConnectorMuxType] {
            return [
                .audiowithactivespeakervideo,
                .audiowithcompositedvideo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audiowithactivespeakervideo: return "AudioWithActiveSpeakerVideo"
            case .audiowithcompositedvideo: return "AudioWithCompositedVideo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LiveConnectorMuxType(rawValue: rawValue) ?? LiveConnectorMuxType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioChannels = "AudioChannels"
        case audioSampleRate = "AudioSampleRate"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChannels = self.audioChannels {
            try encodeContainer.encode(audioChannels.rawValue, forKey: .audioChannels)
        }
        if let audioSampleRate = self.audioSampleRate {
            try encodeContainer.encode(audioSampleRate, forKey: .audioSampleRate)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let audioChannelsDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioChannelsOption.self, forKey: .audioChannels)
        audioChannels = audioChannelsDecoded
        let audioSampleRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioSampleRate)
        audioSampleRate = audioSampleRateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LiveConnectorRTMPConfiguration(audioChannels: \(Swift.String(describing: audioChannels)), audioSampleRate: \(Swift.String(describing: audioSampleRate)), url: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The media pipeline's RTMP configuration object.
    public struct LiveConnectorRTMPConfiguration: Swift.Equatable {
        /// The audio channels set for the RTMP configuration
        public var audioChannels: ChimeSDKMediaPipelinesClientTypes.AudioChannelsOption?
        /// The audio sample rate set for the RTMP configuration. Default: 48000.
        public var audioSampleRate: Swift.String?
        /// The URL of the RTMP configuration.
        /// This member is required.
        public var url: Swift.String?

        public init (
            audioChannels: ChimeSDKMediaPipelinesClientTypes.AudioChannelsOption? = nil,
            audioSampleRate: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.audioChannels = audioChannels
            self.audioSampleRate = audioSampleRate
            self.url = url
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rtmpConfiguration = "RTMPConfiguration"
        case sinkType = "SinkType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rtmpConfiguration = self.rtmpConfiguration {
            try encodeContainer.encode(rtmpConfiguration, forKey: .rtmpConfiguration)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let rtmpConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration.self, forKey: .rtmpConfiguration)
        rtmpConfiguration = rtmpConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The media pipeline's sink configuration settings.
    public struct LiveConnectorSinkConfiguration: Swift.Equatable {
        /// The sink configuration's RTMP configuration setttings.
        /// This member is required.
        public var rtmpConfiguration: ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration?
        /// The sink configuration's sink type.
        /// This member is required.
        public var sinkType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkType?

        public init (
            rtmpConfiguration: ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration? = nil,
            sinkType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkType? = nil
        )
        {
            self.rtmpConfiguration = rtmpConfiguration
            self.sinkType = sinkType
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum LiveConnectorSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rtmp
        case sdkUnknown(Swift.String)

        public static var allCases: [LiveConnectorSinkType] {
            return [
                .rtmp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rtmp: return "RTMP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LiveConnectorSinkType(rawValue: rawValue) ?? LiveConnectorSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingLiveConnectorConfiguration = "ChimeSdkMeetingLiveConnectorConfiguration"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingLiveConnectorConfiguration = self.chimeSdkMeetingLiveConnectorConfiguration {
            try encodeContainer.encode(chimeSdkMeetingLiveConnectorConfiguration, forKey: .chimeSdkMeetingLiveConnectorConfiguration)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let chimeSdkMeetingLiveConnectorConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration.self, forKey: .chimeSdkMeetingLiveConnectorConfiguration)
        chimeSdkMeetingLiveConnectorConfiguration = chimeSdkMeetingLiveConnectorConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The data source configuration object of a streaming media pipeline.
    public struct LiveConnectorSourceConfiguration: Swift.Equatable {
        /// The configuration settings of the connector pipeline.
        /// This member is required.
        public var chimeSdkMeetingLiveConnectorConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration?
        /// The source configuration's media source type.
        /// This member is required.
        public var sourceType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceType?

        public init (
            chimeSdkMeetingLiveConnectorConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration? = nil,
            sourceType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceType? = nil
        )
        {
            self.chimeSdkMeetingLiveConnectorConfiguration = chimeSdkMeetingLiveConnectorConfiguration
            self.sourceType = sourceType
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum LiveConnectorSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [LiveConnectorSourceType] {
            return [
                .chimesdkmeeting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LiveConnectorSourceType(rawValue: rawValue) ?? LiveConnectorSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipeline(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), mediaPipelineArn: \(Swift.String(describing: mediaPipelineArn)), mediaPipelineId: \(Swift.String(describing: mediaPipelineId)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A media pipeline object consisting of an ID, source type, source ARN, a sink type, a sink ARN, and a configuration object.
    public struct MediaCapturePipeline: Swift.Equatable {
        /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
        public var chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
        /// The time at which the pipeline was created, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the media capture pipeline
        public var mediaPipelineArn: Swift.String?
        /// The ID of a media pipeline.
        public var mediaPipelineId: Swift.String?
        /// ARN of the destination to which the media artifacts are saved.
        public var sinkArn: Swift.String?
        /// Destination type to which the media artifacts are saved. You must use an S3 Bucket.
        public var sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType?
        /// ARN of the source from which the media artifacts are saved.
        public var sourceArn: Swift.String?
        /// Source type from which media artifacts are saved. You must use ChimeMeeting.
        public var sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?
        /// The status of the media pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the pipeline was updated, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinkArn: Swift.String? = nil,
            sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType? = nil,
            sourceArn: Swift.String? = nil,
            sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case mediaPipelineArn = "MediaPipelineArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipelineSourceConfiguration(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), mediaPipelineArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The source configuration object of a media capture pipeline.
    public struct MediaCapturePipelineSourceConfiguration: Swift.Equatable {
        /// The meeting configuration settings in a media capture pipeline configuration object.
        /// This member is required.
        public var chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration?
        /// The media pipeline ARN in the configuration object of a media capture pipeline.
        /// This member is required.
        public var mediaPipelineArn: Swift.String?

        public init (
            chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration? = nil,
            mediaPipelineArn: Swift.String? = nil
        )
        {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.mediaPipelineArn = mediaPipelineArn
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The summary data of a media capture pipeline.
    public struct MediaCapturePipelineSummary: Swift.Equatable {
        /// The ARN of the media pipeline in the summary.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media pipeline in the summary.
        public var mediaPipelineId: Swift.String?

        public init (
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil
        )
        {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
        case sinks = "Sinks"
        case sources = "Sources"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for concatenationsink0 in sinks {
                try sinksContainer.encode(concatenationsink0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for concatenationsource0 in sources {
                try sourcesContainer.encode(concatenationsource0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.ConcatenationSource?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.ConcatenationSink?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Concatenates audio and video data from one or more data streams.
    public struct MediaConcatenationPipeline: Swift.Equatable {
        /// The time at which the concatenation pipeline was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the media pipeline that you specify in the SourceConfiguration object.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media pipeline being concatenated.
        public var mediaPipelineId: Swift.String?
        /// The data sinks of the concatenation pipeline.
        public var sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]?
        /// The data sources being concatnated.
        public var sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]?
        /// The status of the concatenation pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the concatenation pipeline was last updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil,
            sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
        case sinks = "Sinks"
        case sources = "Sources"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for liveconnectorsinkconfiguration0 in sinks {
                try sinksContainer.encode(liveconnectorsinkconfiguration0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for liveconnectorsourceconfiguration0 in sources {
                try sourcesContainer.encode(liveconnectorsourceconfiguration0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The connector pipeline.
    public struct MediaLiveConnectorPipeline: Swift.Equatable {
        /// Thetime at which the connector pipeline was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The connector pipeline's ARN.
        public var mediaPipelineArn: Swift.String?
        /// The connector pipeline's ID.
        public var mediaPipelineId: Swift.String?
        /// The connector pipeline's data sinks.
        public var sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]?
        /// The connector pipeline's data sources.
        public var sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]?
        /// The connector pipeline's status.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the connector pipeline was last updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil,
            sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaPipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
        case mediaConcatenationPipeline = "MediaConcatenationPipeline"
        case mediaLiveConnectorPipeline = "MediaLiveConnectorPipeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaCapturePipeline = self.mediaCapturePipeline {
            try encodeContainer.encode(mediaCapturePipeline, forKey: .mediaCapturePipeline)
        }
        if let mediaConcatenationPipeline = self.mediaConcatenationPipeline {
            try encodeContainer.encode(mediaConcatenationPipeline, forKey: .mediaConcatenationPipeline)
        }
        if let mediaLiveConnectorPipeline = self.mediaLiveConnectorPipeline {
            try encodeContainer.encode(mediaLiveConnectorPipeline, forKey: .mediaLiveConnectorPipeline)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
        let mediaLiveConnectorPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline.self, forKey: .mediaLiveConnectorPipeline)
        mediaLiveConnectorPipeline = mediaLiveConnectorPipelineDecoded
        let mediaConcatenationPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline.self, forKey: .mediaConcatenationPipeline)
        mediaConcatenationPipeline = mediaConcatenationPipelineDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A pipeline consisting of a media capture, media concatenation, or live-streaming pipeline.
    public struct MediaPipeline: Swift.Equatable {
        /// A pipeline that enables users to capture audio and video.
        public var mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?
        /// The media concatenation pipeline in a media pipeline.
        public var mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline?
        /// The connector pipeline of the media pipeline.
        public var mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline?

        public init (
            mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline? = nil,
            mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline? = nil,
            mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline? = nil
        )
        {
            self.mediaCapturePipeline = mediaCapturePipeline
            self.mediaConcatenationPipeline = mediaConcatenationPipeline
            self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaPipelineSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSinkType] {
            return [
                .s3bucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSinkType(rawValue: rawValue) ?? MediaPipelineSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaPipelineSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSourceType] {
            return [
                .chimesdkmeeting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSourceType(rawValue: rawValue) ?? MediaPipelineSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaPipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineStatus(rawValue: rawValue) ?? MediaPipelineStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The summary of the media pipeline.
    public struct MediaPipelineSummary: Swift.Equatable {
        /// The ARN of the media pipeline in the summary.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media pipeline in the summary.
        public var mediaPipelineId: Swift.String?

        public init (
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil
        )
        {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object for an event concatenation pipeline.
    public struct MeetingEventsConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init (
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case presenterPosition = "PresenterPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let presenterPosition = self.presenterPosition {
            try encodeContainer.encode(presenterPosition.rawValue, forKey: .presenterPosition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presenterPositionDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.PresenterPosition.self, forKey: .presenterPosition)
        presenterPosition = presenterPositionDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Defines the configuration for a presenter only video tile.
    public struct PresenterOnlyConfiguration: Swift.Equatable {
        /// Defines the position of the presenter video tile. Default: TopRight.
        public var presenterPosition: ChimeSDKMediaPipelinesClientTypes.PresenterPosition?

        public init (
            presenterPosition: ChimeSDKMediaPipelinesClientTypes.PresenterPosition? = nil
        )
        {
            self.presenterPosition = presenterPosition
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum PresenterPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottomleft
        case bottomright
        case topleft
        case topright
        case sdkUnknown(Swift.String)

        public static var allCases: [PresenterPosition] {
            return [
                .bottomleft,
                .bottomright,
                .topleft,
                .topright,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottomleft: return "BottomLeft"
            case .bottomright: return "BottomRight"
            case .topleft: return "TopLeft"
            case .topright: return "TopRight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresenterPosition(rawValue: rawValue) ?? PresenterPosition.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ResolutionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fhd
        case hd
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionOption] {
            return [
                .fhd,
                .hd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fhd: return "FHD"
            case .hd: return "HD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolutionOption(rawValue: rawValue) ?? ResolutionOption.sdkUnknown(rawValue)
        }
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3BucketSinkConfiguration(destination: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration settings for the S3 bucket.
    public struct S3BucketSinkConfiguration: Swift.Equatable {
        /// The destination URL of the S3 bucket.
        /// This member is required.
        public var destination: Swift.String?

        public init (
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeIds = "AttendeeIds"
        case externalUserIds = "ExternalUserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeIds = attendeeIds {
            var attendeeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendeeIds)
            for guidstring0 in attendeeIds {
                try attendeeIdsContainer.encode(guidstring0)
            }
        }
        if let externalUserIds = externalUserIds {
            var externalUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalUserIds)
            for externaluseridtype0 in externalUserIds {
                try externalUserIdsContainer.encode(externaluseridtype0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attendeeIds)
        var attendeeIdsDecoded0:[Swift.String]? = nil
        if let attendeeIdsContainer = attendeeIdsContainer {
            attendeeIdsDecoded0 = [Swift.String]()
            for string0 in attendeeIdsContainer {
                if let string0 = string0 {
                    attendeeIdsDecoded0?.append(string0)
                }
            }
        }
        attendeeIds = attendeeIdsDecoded0
        let externalUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalUserIds)
        var externalUserIdsDecoded0:[Swift.String]? = nil
        if let externalUserIdsContainer = externalUserIdsContainer {
            externalUserIdsDecoded0 = [Swift.String]()
            for string0 in externalUserIdsContainer {
                if let string0 = string0 {
                    externalUserIdsDecoded0?.append(string0)
                }
            }
        }
        externalUserIds = externalUserIdsDecoded0
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The video streams for a specified media pipeline. The total number of video streams can't exceed 25.
    public struct SelectedVideoStreams: Swift.Equatable {
        /// The attendee IDs of the streams selected for a media pipeline.
        public var attendeeIds: [Swift.String]?
        /// The external user IDs of the streams selected for a media pipeline.
        public var externalUserIds: [Swift.String]?

        public init (
            attendeeIds: [Swift.String]? = nil,
            externalUserIds: [Swift.String]? = nil
        )
        {
            self.attendeeIds = attendeeIds
            self.externalUserIds = externalUserIds
        }
    }

}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectedVideoStreams = "SelectedVideoStreams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectedVideoStreams = self.selectedVideoStreams {
            try encodeContainer.encode(selectedVideoStreams, forKey: .selectedVideoStreams)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedVideoStreamsDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams.self, forKey: .selectedVideoStreams)
        selectedVideoStreams = selectedVideoStreamsDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Source configuration for a specified media pipeline.
    public struct SourceConfiguration: Swift.Equatable {
        /// The selected video streams for a specified media pipeline. The number of video streams can't exceed 25.
        public var selectedVideoStreams: ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams?

        public init (
            selectedVideoStreams: ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams? = nil
        )
        {
            self.selectedVideoStreams = selectedVideoStreams
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A key/value pair that grants users access to meeting resources.
    public struct Tag: Swift.Equatable {
        /// The key half of a tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value half of a tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's endpoint region, resource ID, and pipeline ID.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags associated with the specified media pipeline.
    /// This member is required.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottledClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object for concatenating transcription messages.
    public struct TranscriptionMessagesConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init (
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the pipeline that you want to untag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key/value pairs in the tag that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsState.self, forKey: .state)
        state = stateDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VideoMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The video artifact configuration object.
    public struct VideoArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the video artifact configuration object.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.VideoMuxType?
        /// Indicates whether the video artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState?

        public init (
            muxType: ChimeSDKMediaPipelinesClientTypes.VideoMuxType? = nil,
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object of a video contacatentation pipeline.
    public struct VideoConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init (
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum VideoMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case videoonly
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoMuxType] {
            return [
                .videoonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .videoonly: return "VideoOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VideoMuxType(rawValue: rawValue) ?? VideoMuxType.sdkUnknown(rawValue)
        }
    }
}
