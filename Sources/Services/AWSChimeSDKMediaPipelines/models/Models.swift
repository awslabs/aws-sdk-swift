// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeSpeakerPosition = "ActiveSpeakerPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeSpeakerPosition = self.activeSpeakerPosition {
            try encodeContainer.encode(activeSpeakerPosition.rawValue, forKey: .activeSpeakerPosition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeSpeakerPositionDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerPosition.self, forKey: .activeSpeakerPosition)
        activeSpeakerPosition = activeSpeakerPositionDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Defines the configuration for an ActiveSpeakerOnly video tile.
    public struct ActiveSpeakerOnlyConfiguration: Swift.Equatable {
        /// The position of the ActiveSpeakerOnly video tile.
        public var activeSpeakerPosition: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerPosition?

        public init(
            activeSpeakerPosition: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerPosition? = nil
        )
        {
            self.activeSpeakerPosition = activeSpeakerPosition
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ActiveSpeakerPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottomleft
        case bottomright
        case topleft
        case topright
        case sdkUnknown(Swift.String)

        public static var allCases: [ActiveSpeakerPosition] {
            return [
                .bottomleft,
                .bottomright,
                .topleft,
                .topright,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottomleft: return "BottomLeft"
            case .bottomright: return "BottomRight"
            case .topleft: return "TopLeft"
            case .topright: return "TopRight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActiveSpeakerPosition(rawValue: rawValue) ?? ActiveSpeakerPosition.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callAnalyticsStreamCategories = "CallAnalyticsStreamCategories"
        case contentIdentificationType = "ContentIdentificationType"
        case contentRedactionType = "ContentRedactionType"
        case enablePartialResultsStabilization = "EnablePartialResultsStabilization"
        case filterPartialResults = "FilterPartialResults"
        case languageCode = "LanguageCode"
        case languageModelName = "LanguageModelName"
        case partialResultsStability = "PartialResultsStability"
        case piiEntityTypes = "PiiEntityTypes"
        case postCallAnalyticsSettings = "PostCallAnalyticsSettings"
        case vocabularyFilterMethod = "VocabularyFilterMethod"
        case vocabularyFilterName = "VocabularyFilterName"
        case vocabularyName = "VocabularyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callAnalyticsStreamCategories = callAnalyticsStreamCategories {
            var callAnalyticsStreamCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callAnalyticsStreamCategories)
            for categoryname0 in callAnalyticsStreamCategories {
                try callAnalyticsStreamCategoriesContainer.encode(categoryname0)
            }
        }
        if let contentIdentificationType = self.contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let contentRedactionType = self.contentRedactionType {
            try encodeContainer.encode(contentRedactionType.rawValue, forKey: .contentRedactionType)
        }
        if enablePartialResultsStabilization != false {
            try encodeContainer.encode(enablePartialResultsStabilization, forKey: .enablePartialResultsStabilization)
        }
        if filterPartialResults != false {
            try encodeContainer.encode(filterPartialResults, forKey: .filterPartialResults)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageModelName = self.languageModelName {
            try encodeContainer.encode(languageModelName, forKey: .languageModelName)
        }
        if let partialResultsStability = self.partialResultsStability {
            try encodeContainer.encode(partialResultsStability.rawValue, forKey: .partialResultsStability)
        }
        if let piiEntityTypes = self.piiEntityTypes {
            try encodeContainer.encode(piiEntityTypes, forKey: .piiEntityTypes)
        }
        if let postCallAnalyticsSettings = self.postCallAnalyticsSettings {
            try encodeContainer.encode(postCallAnalyticsSettings, forKey: .postCallAnalyticsSettings)
        }
        if let vocabularyFilterMethod = self.vocabularyFilterMethod {
            try encodeContainer.encode(vocabularyFilterMethod.rawValue, forKey: .vocabularyFilterMethod)
        }
        if let vocabularyFilterName = self.vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let vocabularyFilterMethodDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod.self, forKey: .vocabularyFilterMethod)
        vocabularyFilterMethod = vocabularyFilterMethodDecoded
        let languageModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageModelName)
        languageModelName = languageModelNameDecoded
        let enablePartialResultsStabilizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePartialResultsStabilization) ?? false
        enablePartialResultsStabilization = enablePartialResultsStabilizationDecoded
        let partialResultsStabilityDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.PartialResultsStability.self, forKey: .partialResultsStability)
        partialResultsStability = partialResultsStabilityDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
        let contentRedactionTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentType.self, forKey: .contentRedactionType)
        contentRedactionType = contentRedactionTypeDecoded
        let piiEntityTypesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .piiEntityTypes)
        piiEntityTypes = piiEntityTypesDecoded
        let filterPartialResultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .filterPartialResults) ?? false
        filterPartialResults = filterPartialResultsDecoded
        let postCallAnalyticsSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings.self, forKey: .postCallAnalyticsSettings)
        postCallAnalyticsSettings = postCallAnalyticsSettingsDecoded
        let callAnalyticsStreamCategoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .callAnalyticsStreamCategories)
        var callAnalyticsStreamCategoriesDecoded0:[Swift.String]? = nil
        if let callAnalyticsStreamCategoriesContainer = callAnalyticsStreamCategoriesContainer {
            callAnalyticsStreamCategoriesDecoded0 = [Swift.String]()
            for string0 in callAnalyticsStreamCategoriesContainer {
                if let string0 = string0 {
                    callAnalyticsStreamCategoriesDecoded0?.append(string0)
                }
            }
        }
        callAnalyticsStreamCategories = callAnalyticsStreamCategoriesDecoded0
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the configuration settings for an Amazon Transcribe call analytics processor.
    public struct AmazonTranscribeCallAnalyticsProcessorConfiguration: Swift.Equatable {
        /// By default, all CategoryEvents are sent to the insights target. If this parameter is specified, only included categories are sent to the insights target.
        public var callAnalyticsStreamCategories: [Swift.String]?
        /// Labels all personally identifiable information (PII) identified in your transcript. Content identification is performed at the segment level; PII specified in PiiEntityTypes is flagged upon complete transcription of an audio segment. You can’t set ContentIdentificationType and ContentRedactionType in the same request. If you do, your request returns a BadRequestException. For more information, see [Redacting or identifying personally identifiable information](https://docs.aws.amazon.com/transcribe/latest/dg/pii-redaction.html) in the Amazon Transcribe Developer Guide.
        public var contentIdentificationType: ChimeSDKMediaPipelinesClientTypes.ContentType?
        /// Redacts all personally identifiable information (PII) identified in your transcript. Content redaction is performed at the segment level; PII specified in PiiEntityTypes is redacted upon complete transcription of an audio segment. You can’t set ContentRedactionType and ContentIdentificationType in the same request. If you do, your request returns a BadRequestException. For more information, see [Redacting or identifying personally identifiable information](https://docs.aws.amazon.com/transcribe/latest/dg/pii-redaction.html) in the Amazon Transcribe Developer Guide.
        public var contentRedactionType: ChimeSDKMediaPipelinesClientTypes.ContentType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy. For more information, see [Partial-result stabilization](https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html#streaming-partial-result-stabilization) in the Amazon Transcribe Developer Guide.
        public var enablePartialResultsStabilization: Swift.Bool
        /// If true, UtteranceEvents with IsPartial: true are filtered out of the insights target.
        public var filterPartialResults: Swift.Bool
        /// The language code in the configuration.
        /// This member is required.
        public var languageCode: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode?
        /// Specifies the name of the custom language model to use when processing a transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code specified in the transcription request. If the languages don't match, the custom language model isn't applied. Language mismatches don't generate errors or warnings. For more information, see [Custom language models](https://docs.aws.amazon.com/transcribe/latest/dg/custom-language-models.html) in the Amazon Transcribe Developer Guide.
        public var languageModelName: Swift.String?
        /// Specifies the level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy. For more information, see [Partial-result stabilization](https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html#streaming-partial-result-stabilization) in the Amazon Transcribe Developer Guide.
        public var partialResultsStability: ChimeSDKMediaPipelinesClientTypes.PartialResultsStability?
        /// Specifies the types of personally identifiable information (PII) to redact from a transcript. You can include as many types as you'd like, or you can select ALL. To include PiiEntityTypes in your Call Analytics request, you must also include ContentIdentificationType or ContentRedactionType, but you can't include both. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRY, CREDIT_DEBIT_NUMBER, EMAIL, NAME, PHONE, PIN, SSN, or ALL. Length Constraints: Minimum length of 1. Maximum length of 300.
        public var piiEntityTypes: Swift.String?
        /// The settings for a post-call analysis task in an analytics configuration.
        public var postCallAnalyticsSettings: ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings?
        /// Specifies how to apply a vocabulary filter to a transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod?
        /// Specifies the name of the custom vocabulary filter to use when processing a transcription. Note that vocabulary filter names are case sensitive. If the language of the specified custom vocabulary filter doesn't match the language identified in your media, the vocabulary filter is not applied to your transcription. For more information, see [Using vocabulary filtering with unwanted words](https://docs.aws.amazon.com/transcribe/latest/dg/vocabulary-filtering.html) in the Amazon Transcribe Developer Guide. Length Constraints: Minimum length of 1. Maximum length of 200.
        public var vocabularyFilterName: Swift.String?
        /// Specifies the name of the custom vocabulary to use when processing a transcription. Note that vocabulary names are case sensitive. If the language of the specified custom vocabulary doesn't match the language identified in your media, the custom vocabulary is not applied to your transcription. For more information, see [Custom vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html) in the Amazon Transcribe Developer Guide. Length Constraints: Minimum length of 1. Maximum length of 200.
        public var vocabularyName: Swift.String?

        public init(
            callAnalyticsStreamCategories: [Swift.String]? = nil,
            contentIdentificationType: ChimeSDKMediaPipelinesClientTypes.ContentType? = nil,
            contentRedactionType: ChimeSDKMediaPipelinesClientTypes.ContentType? = nil,
            enablePartialResultsStabilization: Swift.Bool = false,
            filterPartialResults: Swift.Bool = false,
            languageCode: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode? = nil,
            languageModelName: Swift.String? = nil,
            partialResultsStability: ChimeSDKMediaPipelinesClientTypes.PartialResultsStability? = nil,
            piiEntityTypes: Swift.String? = nil,
            postCallAnalyticsSettings: ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings? = nil,
            vocabularyFilterMethod: ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.callAnalyticsStreamCategories = callAnalyticsStreamCategories
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.filterPartialResults = filterPartialResults
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.postCallAnalyticsSettings = postCallAnalyticsSettings
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentIdentificationType = "ContentIdentificationType"
        case contentRedactionType = "ContentRedactionType"
        case enablePartialResultsStabilization = "EnablePartialResultsStabilization"
        case filterPartialResults = "FilterPartialResults"
        case identifyLanguage = "IdentifyLanguage"
        case languageCode = "LanguageCode"
        case languageModelName = "LanguageModelName"
        case languageOptions = "LanguageOptions"
        case partialResultsStability = "PartialResultsStability"
        case piiEntityTypes = "PiiEntityTypes"
        case preferredLanguage = "PreferredLanguage"
        case showSpeakerLabel = "ShowSpeakerLabel"
        case vocabularyFilterMethod = "VocabularyFilterMethod"
        case vocabularyFilterName = "VocabularyFilterName"
        case vocabularyFilterNames = "VocabularyFilterNames"
        case vocabularyName = "VocabularyName"
        case vocabularyNames = "VocabularyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentIdentificationType = self.contentIdentificationType {
            try encodeContainer.encode(contentIdentificationType.rawValue, forKey: .contentIdentificationType)
        }
        if let contentRedactionType = self.contentRedactionType {
            try encodeContainer.encode(contentRedactionType.rawValue, forKey: .contentRedactionType)
        }
        if enablePartialResultsStabilization != false {
            try encodeContainer.encode(enablePartialResultsStabilization, forKey: .enablePartialResultsStabilization)
        }
        if filterPartialResults != false {
            try encodeContainer.encode(filterPartialResults, forKey: .filterPartialResults)
        }
        if identifyLanguage != false {
            try encodeContainer.encode(identifyLanguage, forKey: .identifyLanguage)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let languageModelName = self.languageModelName {
            try encodeContainer.encode(languageModelName, forKey: .languageModelName)
        }
        if let languageOptions = self.languageOptions {
            try encodeContainer.encode(languageOptions, forKey: .languageOptions)
        }
        if let partialResultsStability = self.partialResultsStability {
            try encodeContainer.encode(partialResultsStability.rawValue, forKey: .partialResultsStability)
        }
        if let piiEntityTypes = self.piiEntityTypes {
            try encodeContainer.encode(piiEntityTypes, forKey: .piiEntityTypes)
        }
        if let preferredLanguage = self.preferredLanguage {
            try encodeContainer.encode(preferredLanguage.rawValue, forKey: .preferredLanguage)
        }
        if showSpeakerLabel != false {
            try encodeContainer.encode(showSpeakerLabel, forKey: .showSpeakerLabel)
        }
        if let vocabularyFilterMethod = self.vocabularyFilterMethod {
            try encodeContainer.encode(vocabularyFilterMethod.rawValue, forKey: .vocabularyFilterMethod)
        }
        if let vocabularyFilterName = self.vocabularyFilterName {
            try encodeContainer.encode(vocabularyFilterName, forKey: .vocabularyFilterName)
        }
        if let vocabularyFilterNames = self.vocabularyFilterNames {
            try encodeContainer.encode(vocabularyFilterNames, forKey: .vocabularyFilterNames)
        }
        if let vocabularyName = self.vocabularyName {
            try encodeContainer.encode(vocabularyName, forKey: .vocabularyName)
        }
        if let vocabularyNames = self.vocabularyNames {
            try encodeContainer.encode(vocabularyNames, forKey: .vocabularyNames)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let vocabularyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyName)
        vocabularyName = vocabularyNameDecoded
        let vocabularyFilterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterName)
        vocabularyFilterName = vocabularyFilterNameDecoded
        let vocabularyFilterMethodDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod.self, forKey: .vocabularyFilterMethod)
        vocabularyFilterMethod = vocabularyFilterMethodDecoded
        let showSpeakerLabelDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .showSpeakerLabel) ?? false
        showSpeakerLabel = showSpeakerLabelDecoded
        let enablePartialResultsStabilizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enablePartialResultsStabilization) ?? false
        enablePartialResultsStabilization = enablePartialResultsStabilizationDecoded
        let partialResultsStabilityDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.PartialResultsStability.self, forKey: .partialResultsStability)
        partialResultsStability = partialResultsStabilityDecoded
        let contentIdentificationTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentType.self, forKey: .contentIdentificationType)
        contentIdentificationType = contentIdentificationTypeDecoded
        let contentRedactionTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentType.self, forKey: .contentRedactionType)
        contentRedactionType = contentRedactionTypeDecoded
        let piiEntityTypesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .piiEntityTypes)
        piiEntityTypes = piiEntityTypesDecoded
        let languageModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageModelName)
        languageModelName = languageModelNameDecoded
        let filterPartialResultsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .filterPartialResults) ?? false
        filterPartialResults = filterPartialResultsDecoded
        let identifyLanguageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .identifyLanguage) ?? false
        identifyLanguage = identifyLanguageDecoded
        let languageOptionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageOptions)
        languageOptions = languageOptionsDecoded
        let preferredLanguageDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode.self, forKey: .preferredLanguage)
        preferredLanguage = preferredLanguageDecoded
        let vocabularyNamesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyNames)
        vocabularyNames = vocabularyNamesDecoded
        let vocabularyFilterNamesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vocabularyFilterNames)
        vocabularyFilterNames = vocabularyFilterNamesDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the configuration settings for an Amazon Transcribe processor.
    public struct AmazonTranscribeProcessorConfiguration: Swift.Equatable {
        /// Labels all personally identifiable information (PII) identified in your transcript. Content identification is performed at the segment level; PII specified in PiiEntityTypes is flagged upon complete transcription of an audio segment. You can’t set ContentIdentificationType and ContentRedactionType in the same request. If you set both, your request returns a BadRequestException. For more information, see [Redacting or identifying personally identifiable information](https://docs.aws.amazon.com/transcribe/latest/dg/pii-redaction.html) in the Amazon Transcribe Developer Guide.
        public var contentIdentificationType: ChimeSDKMediaPipelinesClientTypes.ContentType?
        /// Redacts all personally identifiable information (PII) identified in your transcript. Content redaction is performed at the segment level; PII specified in PiiEntityTypes is redacted upon complete transcription of an audio segment. You can’t set ContentRedactionType and ContentIdentificationType in the same request. If you set both, your request returns a BadRequestException. For more information, see [Redacting or identifying personally identifiable information](https://docs.aws.amazon.com/transcribe/latest/dg/pii-redaction.html) in the Amazon Transcribe Developer Guide.
        public var contentRedactionType: ChimeSDKMediaPipelinesClientTypes.ContentType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy. For more information, see [Partial-result stabilization](https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html#streaming-partial-result-stabilization) in the Amazon Transcribe Developer Guide.
        public var enablePartialResultsStabilization: Swift.Bool
        /// If true, TranscriptEvents with IsPartial: true are filtered out of the insights target.
        public var filterPartialResults: Swift.Bool
        /// Turns language identification on or off.
        public var identifyLanguage: Swift.Bool
        /// The language code that represents the language spoken in your audio. If you're unsure of the language spoken in your audio, consider using IdentifyLanguage to enable automatic language identification. For a list of languages that real-time Call Analytics supports, see the [Supported languages table](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) in the Amazon Transcribe Developer Guide.
        public var languageCode: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode?
        /// The name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code you specify in your transcription request. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch. For more information, see [Custom language models](https://docs.aws.amazon.com/transcribe/latest/dg/custom-language-models.html) in the Amazon Transcribe Developer Guide.
        public var languageModelName: Swift.String?
        /// The language options for the transcription, such as automatic language detection.
        public var languageOptions: Swift.String?
        /// The level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy. For more information, see [Partial-result stabilization](https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html#streaming-partial-result-stabilization) in the Amazon Transcribe Developer Guide.
        public var partialResultsStability: ChimeSDKMediaPipelinesClientTypes.PartialResultsStability?
        /// The types of personally identifiable information (PII) to redact from a transcript. You can include as many types as you'd like, or you can select ALL. To include PiiEntityTypes in your Call Analytics request, you must also include ContentIdentificationType or ContentRedactionType, but you can't include both. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRY, CREDIT_DEBIT_NUMBER, EMAIL, NAME, PHONE, PIN, SSN, or ALL. If you leave this parameter empty, the default behavior is equivalent to ALL.
        public var piiEntityTypes: Swift.String?
        /// The preferred language for the transcription.
        public var preferredLanguage: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode?
        /// Enables speaker partitioning (diarization) in your transcription output. Speaker partitioning labels the speech from individual speakers in your media file. For more information, see [Partitioning speakers (diarization)](https://docs.aws.amazon.com/transcribe/latest/dg/diarization.html) in the Amazon Transcribe Developer Guide.
        public var showSpeakerLabel: Swift.Bool
        /// The vocabulary filtering method used in your Call Analytics transcription.
        public var vocabularyFilterMethod: ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod?
        /// The name of the custom vocabulary filter that you specified in your Call Analytics request. Length Constraints: Minimum length of 1. Maximum length of 200.
        public var vocabularyFilterName: Swift.String?
        /// The names of the custom vocabulary filter or filters using during transcription.
        public var vocabularyFilterNames: Swift.String?
        /// The name of the custom vocabulary that you specified in your Call Analytics request. Length Constraints: Minimum length of 1. Maximum length of 200.
        public var vocabularyName: Swift.String?
        /// The names of the custom vocabulary or vocabularies used during transcription.
        public var vocabularyNames: Swift.String?

        public init(
            contentIdentificationType: ChimeSDKMediaPipelinesClientTypes.ContentType? = nil,
            contentRedactionType: ChimeSDKMediaPipelinesClientTypes.ContentType? = nil,
            enablePartialResultsStabilization: Swift.Bool = false,
            filterPartialResults: Swift.Bool = false,
            identifyLanguage: Swift.Bool = false,
            languageCode: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode? = nil,
            languageModelName: Swift.String? = nil,
            languageOptions: Swift.String? = nil,
            partialResultsStability: ChimeSDKMediaPipelinesClientTypes.PartialResultsStability? = nil,
            piiEntityTypes: Swift.String? = nil,
            preferredLanguage: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode? = nil,
            showSpeakerLabel: Swift.Bool = false,
            vocabularyFilterMethod: ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyFilterNames: Swift.String? = nil,
            vocabularyName: Swift.String? = nil,
            vocabularyNames: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.filterPartialResults = filterPartialResults
            self.identifyLanguage = identifyLanguage
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.preferredLanguage = preferredLanguage
            self.showSpeakerLabel = showSpeakerLabel
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyFilterNames = vocabularyFilterNames
            self.vocabularyName = vocabularyName
            self.vocabularyNames = vocabularyNames
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
        case compositedVideo = "CompositedVideo"
        case content = "Content"
        case dataChannel = "DataChannel"
        case meetingEvents = "MeetingEvents"
        case transcriptionMessages = "TranscriptionMessages"
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let compositedVideo = self.compositedVideo {
            try encodeContainer.encode(compositedVideo, forKey: .compositedVideo)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let dataChannel = self.dataChannel {
            try encodeContainer.encode(dataChannel, forKey: .dataChannel)
        }
        if let meetingEvents = self.meetingEvents {
            try encodeContainer.encode(meetingEvents, forKey: .meetingEvents)
        }
        if let transcriptionMessages = self.transcriptionMessages {
            try encodeContainer.encode(transcriptionMessages, forKey: .transcriptionMessages)
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration.self, forKey: .audio)
        audio = audioDecoded
        let videoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration.self, forKey: .video)
        video = videoDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration.self, forKey: .content)
        content = contentDecoded
        let dataChannelDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration.self, forKey: .dataChannel)
        dataChannel = dataChannelDecoded
        let transcriptionMessagesDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration.self, forKey: .transcriptionMessages)
        transcriptionMessages = transcriptionMessagesDecoded
        let meetingEventsDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration.self, forKey: .meetingEvents)
        meetingEvents = meetingEventsDecoded
        let compositedVideoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration.self, forKey: .compositedVideo)
        compositedVideo = compositedVideoDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration for the artifacts concatenation.
    public struct ArtifactsConcatenationConfiguration: Swift.Equatable {
        /// The configuration for the audio artifacts concatenation.
        /// This member is required.
        public var audio: ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration?
        /// The configuration for the composited video artifacts concatenation.
        /// This member is required.
        public var compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration?
        /// The configuration for the content artifacts concatenation.
        /// This member is required.
        public var content: ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration?
        /// The configuration for the data channel artifacts concatenation.
        /// This member is required.
        public var dataChannel: ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration?
        /// The configuration for the meeting events artifacts concatenation.
        /// This member is required.
        public var meetingEvents: ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration?
        /// The configuration for the transcription messages artifacts concatenation.
        /// This member is required.
        public var transcriptionMessages: ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration?
        /// The configuration for the video artifacts concatenation.
        /// This member is required.
        public var video: ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration?

        public init(
            audio: ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration? = nil,
            compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration? = nil,
            content: ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration? = nil,
            dataChannel: ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration? = nil,
            meetingEvents: ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration? = nil,
            transcriptionMessages: ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration? = nil,
            video: ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration? = nil
        )
        {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.dataChannel = dataChannel
            self.meetingEvents = meetingEvents
            self.transcriptionMessages = transcriptionMessages
            self.video = video
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ArtifactsConcatenationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsConcatenationState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactsConcatenationState(rawValue: rawValue) ?? ArtifactsConcatenationState.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
        case compositedVideo = "CompositedVideo"
        case content = "Content"
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let compositedVideo = self.compositedVideo {
            try encodeContainer.encode(compositedVideo, forKey: .compositedVideo)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration.self, forKey: .audio)
        audio = audioDecoded
        let videoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration.self, forKey: .video)
        video = videoDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration.self, forKey: .content)
        content = contentDecoded
        let compositedVideoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration.self, forKey: .compositedVideo)
        compositedVideo = compositedVideoDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration for the artifacts.
    public struct ArtifactsConfiguration: Swift.Equatable {
        /// The configuration for the audio artifacts.
        /// This member is required.
        public var audio: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration?
        /// Enables video compositing.
        public var compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration?
        /// The configuration for the content artifacts.
        /// This member is required.
        public var content: ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration?
        /// The configuration for the video artifacts.
        /// This member is required.
        public var video: ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration?

        public init(
            audio: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration? = nil,
            compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration? = nil,
            content: ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration? = nil,
            video: ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration? = nil
        )
        {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.video = video
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ArtifactsState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactsState(rawValue: rawValue) ?? ArtifactsState.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum AudioArtifactsConcatenationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioArtifactsConcatenationState] {
            return [
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudioArtifactsConcatenationState(rawValue: rawValue) ?? AudioArtifactsConcatenationState.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The audio artifact configuration object.
    public struct AudioArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the audio artifact configuration object.
        /// This member is required.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.AudioMuxType?

        public init(
            muxType: ChimeSDKMediaPipelinesClientTypes.AudioMuxType? = nil
        )
        {
            self.muxType = muxType
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum AudioChannelsOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mono
        case stereo
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioChannelsOption] {
            return [
                .mono,
                .stereo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mono: return "Mono"
            case .stereo: return "Stereo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudioChannelsOption(rawValue: rawValue) ?? AudioChannelsOption.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The audio artifact concatenation configuration object.
    public struct AudioConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum AudioMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audioonly
        case audiowithactivespeakervideo
        case audiowithcompositedvideo
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioMuxType] {
            return [
                .audioonly,
                .audiowithactivespeakervideo,
                .audiowithcompositedvideo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audioonly: return "AudioOnly"
            case .audiowithactivespeakervideo: return "AudioWithActiveSpeakerVideo"
            case .audiowithcompositedvideo: return "AudioWithCompositedVideo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudioMuxType(rawValue: rawValue) ?? AudioMuxType.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum BorderColor: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case black
        case blue
        case green
        case red
        case white
        case yellow
        case sdkUnknown(Swift.String)

        public static var allCases: [BorderColor] {
            return [
                .black,
                .blue,
                .green,
                .red,
                .white,
                .yellow,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .black: return "Black"
            case .blue: return "Blue"
            case .green: return "Green"
            case .red: return "Red"
            case .white: return "White"
            case .yellow: return "Yellow"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BorderColor(rawValue: rawValue) ?? BorderColor.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum CallAnalyticsLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case frCa
        case frFr
        case itIt
        case ptBr
        case sdkUnknown(Swift.String)

        public static var allCases: [CallAnalyticsLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .frCa,
                .frFr,
                .itIt,
                .ptBr,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .itIt: return "it-IT"
            case .ptBr: return "pt-BR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CallAnalyticsLanguageCode(rawValue: rawValue) ?? CallAnalyticsLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum CanvasOrientation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case landscape
        case portrait
        case sdkUnknown(Swift.String)

        public static var allCases: [CanvasOrientation] {
            return [
                .landscape,
                .portrait,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .landscape: return "Landscape"
            case .portrait: return "Portrait"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CanvasOrientation(rawValue: rawValue) ?? CanvasOrientation.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ChannelDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId = "ChannelId"
        case participantRole = "ParticipantRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if channelId != 0 {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .channelId) ?? 0
        channelId = channelIdDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Defines an audio channel in a Kinesis video stream.
    public struct ChannelDefinition: Swift.Equatable {
        /// The channel ID.
        /// This member is required.
        public var channelId: Swift.Int
        /// Specifies whether the audio in a channel belongs to the AGENT or CUSTOMER.
        public var participantRole: ChimeSDKMediaPipelinesClientTypes.ParticipantRole?

        public init(
            channelId: Swift.Int = 0,
            participantRole: ChimeSDKMediaPipelinesClientTypes.ParticipantRole? = nil
        )
        {
            self.channelId = channelId
            self.participantRole = participantRole
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsConfiguration = "ArtifactsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsConfiguration = self.artifactsConfiguration {
            try encodeContainer.encode(artifactsConfiguration, forKey: .artifactsConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration.self, forKey: .artifactsConfiguration)
        artifactsConfiguration = artifactsConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object of the Amazon Chime SDK meeting concatenation for a specified media pipeline.
    public struct ChimeSdkMeetingConcatenationConfiguration: Swift.Equatable {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting concatenation.
        /// This member is required.
        public var artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration?

        public init(
            artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration? = nil
        )
        {
            self.artifactsConfiguration = artifactsConfiguration
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsConfiguration = "ArtifactsConfiguration"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsConfiguration = self.artifactsConfiguration {
            try encodeContainer.encode(artifactsConfiguration, forKey: .artifactsConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let artifactsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration.self, forKey: .artifactsConfiguration)
        artifactsConfiguration = artifactsConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object of the Amazon Chime SDK meeting for a specified media pipeline. SourceType must be ChimeSdkMeeting.
    public struct ChimeSdkMeetingConfiguration: Swift.Equatable {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting.
        public var artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration?
        /// The source configuration for a specified media pipeline.
        public var sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration?

        public init(
            artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration? = nil,
            sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration? = nil
        )
        {
            self.artifactsConfiguration = artifactsConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case compositedVideo = "CompositedVideo"
        case muxType = "MuxType"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let compositedVideo = self.compositedVideo {
            try encodeContainer.encode(compositedVideo, forKey: .compositedVideo)
        }
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LiveConnectorMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
        let compositedVideoDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration.self, forKey: .compositedVideo)
        compositedVideo = compositedVideoDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChimeSdkMeetingLiveConnectorConfiguration(compositedVideo: \(Swift.String(describing: compositedVideo)), muxType: \(Swift.String(describing: muxType)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), arn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The media pipeline's configuration object.
    public struct ChimeSdkMeetingLiveConnectorConfiguration: Swift.Equatable {
        /// The configuration object's Chime SDK meeting ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// The media pipeline's composited video.
        public var compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration?
        /// The configuration object's multiplex type.
        /// This member is required.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorMuxType?
        /// The source configuration settings of the media pipeline's configuration object.
        public var sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration?

        public init(
            arn: Swift.String? = nil,
            compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration? = nil,
            muxType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorMuxType? = nil,
            sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration? = nil
        )
        {
            self.arn = arn
            self.compositedVideo = compositedVideo
            self.muxType = muxType
            self.sourceConfiguration = sourceConfiguration
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gridViewConfiguration = "GridViewConfiguration"
        case layout = "Layout"
        case resolution = "Resolution"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gridViewConfiguration = self.gridViewConfiguration {
            try encodeContainer.encode(gridViewConfiguration, forKey: .gridViewConfiguration)
        }
        if let layout = self.layout {
            try encodeContainer.encode(layout.rawValue, forKey: .layout)
        }
        if let resolution = self.resolution {
            try encodeContainer.encode(resolution.rawValue, forKey: .resolution)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layoutDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LayoutOption.self, forKey: .layout)
        layout = layoutDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ResolutionOption.self, forKey: .resolution)
        resolution = resolutionDecoded
        let gridViewConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration.self, forKey: .gridViewConfiguration)
        gridViewConfiguration = gridViewConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Specifies the configuration for compositing video artifacts.
    public struct CompositedVideoArtifactsConfiguration: Swift.Equatable {
        /// The GridView configuration setting.
        /// This member is required.
        public var gridViewConfiguration: ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration?
        /// The layout setting, such as GridView in the configuration object.
        public var layout: ChimeSDKMediaPipelinesClientTypes.LayoutOption?
        /// The video resolution setting in the configuration object. Default: HD at 1280 x 720. FHD resolution: 1920 x 1080.
        public var resolution: ChimeSDKMediaPipelinesClientTypes.ResolutionOption?

        public init(
            gridViewConfiguration: ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration? = nil,
            layout: ChimeSDKMediaPipelinesClientTypes.LayoutOption? = nil,
            resolution: ChimeSDKMediaPipelinesClientTypes.ResolutionOption? = nil
        )
        {
            self.gridViewConfiguration = gridViewConfiguration
            self.layout = layout
            self.resolution = resolution
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The composited video configuration object for a specified media pipeline. SourceType must be ChimeSdkMeeting.
    public struct CompositedVideoConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ConcatenationSink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketSinkConfiguration = "S3BucketSinkConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketSinkConfiguration = self.s3BucketSinkConfiguration {
            try encodeContainer.encode(s3BucketSinkConfiguration, forKey: .s3BucketSinkConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ConcatenationSinkType.self, forKey: .type)
        type = typeDecoded
        let s3BucketSinkConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration.self, forKey: .s3BucketSinkConfiguration)
        s3BucketSinkConfiguration = s3BucketSinkConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The data sink of the configuration object.
    public struct ConcatenationSink: Swift.Equatable {
        /// The configuration settings for an Amazon S3 bucket sink.
        /// This member is required.
        public var s3BucketSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration?
        /// The type of data sink in the configuration object.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSinkType?

        public init(
            s3BucketSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSinkType? = nil
        )
        {
            self.s3BucketSinkConfiguration = s3BucketSinkConfiguration
            self.type = type
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ConcatenationSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [ConcatenationSinkType] {
            return [
                .s3bucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConcatenationSinkType(rawValue: rawValue) ?? ConcatenationSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ConcatenationSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipelineSourceConfiguration = "MediaCapturePipelineSourceConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaCapturePipelineSourceConfiguration = self.mediaCapturePipelineSourceConfiguration {
            try encodeContainer.encode(mediaCapturePipelineSourceConfiguration, forKey: .mediaCapturePipelineSourceConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ConcatenationSourceType.self, forKey: .type)
        type = typeDecoded
        let mediaCapturePipelineSourceConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration.self, forKey: .mediaCapturePipelineSourceConfiguration)
        mediaCapturePipelineSourceConfiguration = mediaCapturePipelineSourceConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The source type and media pipeline configuration settings in a configuration object.
    public struct ConcatenationSource: Swift.Equatable {
        /// The concatenation settings for the media pipeline in a configuration object.
        /// This member is required.
        public var mediaCapturePipelineSourceConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration?
        /// The type of concatenation source in a configuration object.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSourceType?

        public init(
            mediaCapturePipelineSourceConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSourceType? = nil
        )
        {
            self.mediaCapturePipelineSourceConfiguration = mediaCapturePipelineSourceConfiguration
            self.type = type
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ConcatenationSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mediacapturepipeline
        case sdkUnknown(Swift.String)

        public static var allCases: [ConcatenationSourceType] {
            return [
                .mediacapturepipeline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mediacapturepipeline: return "MediaCapturePipeline"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConcatenationSourceType(rawValue: rawValue) ?? ConcatenationSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsState.self, forKey: .state)
        state = stateDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The content artifact object.
    public struct ContentArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the artifact configuration.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.ContentMuxType?
        /// Indicates whether the content artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState?

        public init(
            muxType: ChimeSDKMediaPipelinesClientTypes.ContentMuxType? = nil,
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The composited content configuration object for a specified media pipeline.
    public struct ContentConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ContentMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contentonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentMuxType] {
            return [
                .contentonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contentonly: return "ContentOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentMuxType(rawValue: rawValue) ?? ContentMuxType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ContentRedactionOutput: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case redacted
        case redactedAndUnredacted
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentRedactionOutput] {
            return [
                .redacted,
                .redactedAndUnredacted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .redacted: return "redacted"
            case .redactedAndUnredacted: return "redacted_and_unredacted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentRedactionOutput(rawValue: rawValue) ?? ContentRedactionOutput.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ContentShareLayoutOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activespeakeronly
        case horizontal
        case presenteronly
        case vertical
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentShareLayoutOption] {
            return [
                .activespeakeronly,
                .horizontal,
                .presenteronly,
                .vertical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activespeakeronly: return "ActiveSpeakerOnly"
            case .horizontal: return "Horizontal"
            case .presenteronly: return "PresenterOnly"
            case .vertical: return "Vertical"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentShareLayoutOption(rawValue: rawValue) ?? ContentShareLayoutOption.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentType] {
            return [
                .pii,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentType(rawValue: rawValue) ?? ContentType.sdkUnknown(rawValue)
        }
    }
}

extension CreateMediaCapturePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaCapturePipelineInput(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension CreateMediaCapturePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-capture-pipelines"
    }
}

public struct CreateMediaCapturePipelineInput: Swift.Equatable {
    /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
    public var chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
    /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.
    public var clientRequestToken: Swift.String?
    /// The ARN of the sink type.
    /// This member is required.
    public var sinkArn: Swift.String?
    /// Destination type to which the media artifacts are saved. You must use an S3 bucket.
    /// This member is required.
    public var sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType?
    /// ARN of the source from which the media artifacts are captured.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.
    /// This member is required.
    public var sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?
    /// The tag key-value pairs.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration? = nil,
        clientRequestToken: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType? = nil,
        sourceArn: Swift.String? = nil,
        sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
        self.clientRequestToken = clientRequestToken
        self.sinkArn = sinkArn
        self.sinkType = sinkType
        self.sourceArn = sourceArn
        self.sourceType = sourceType
        self.tags = tags
    }
}

struct CreateMediaCapturePipelineInputBody: Swift.Equatable {
    let sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?
    let sourceArn: Swift.String?
    let sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType?
    let sinkArn: Swift.String?
    let clientRequestToken: Swift.String?
    let chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension CreateMediaCapturePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMediaCapturePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMediaCapturePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct CreateMediaCapturePipelineOutput: Swift.Equatable {
    /// A media pipeline object, the ID, source type, source ARN, sink type, and sink ARN of a media pipeline object.
    public var mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?

    public init(
        mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct CreateMediaCapturePipelineOutputBody: Swift.Equatable {
    let mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?
}

extension CreateMediaCapturePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

enum CreateMediaCapturePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMediaConcatenationPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaConcatenationPipelineInput(sinks: \(Swift.String(describing: sinks)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension CreateMediaConcatenationPipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for concatenationsink0 in sinks {
                try sinksContainer.encode(concatenationsink0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for concatenationsource0 in sources {
                try sourcesContainer.encode(concatenationsource0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaConcatenationPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-concatenation-pipelines"
    }
}

public struct CreateMediaConcatenationPipelineInput: Swift.Equatable {
    /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media concatenation pipeline request.
    public var clientRequestToken: Swift.String?
    /// An object that specifies the data sinks for the media concatenation pipeline.
    /// This member is required.
    public var sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]?
    /// An object that specifies the sources for the media concatenation pipeline.
    /// This member is required.
    public var sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]?
    /// The tags associated with the media concatenation pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil,
        sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sinks = sinks
        self.sources = sources
        self.tags = tags
    }
}

struct CreateMediaConcatenationPipelineInputBody: Swift.Equatable {
    let sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]?
    let sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension CreateMediaConcatenationPipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.ConcatenationSource?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.ConcatenationSink?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMediaConcatenationPipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMediaConcatenationPipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaConcatenationPipeline = output.mediaConcatenationPipeline
        } else {
            self.mediaConcatenationPipeline = nil
        }
    }
}

public struct CreateMediaConcatenationPipelineOutput: Swift.Equatable {
    /// A media concatenation pipeline object, the ID, source type, MediaPipelineARN, and sink of a media concatenation pipeline object.
    public var mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline?

    public init(
        mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline? = nil
    )
    {
        self.mediaConcatenationPipeline = mediaConcatenationPipeline
    }
}

struct CreateMediaConcatenationPipelineOutputBody: Swift.Equatable {
    let mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline?
}

extension CreateMediaConcatenationPipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaConcatenationPipeline = "MediaConcatenationPipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaConcatenationPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline.self, forKey: .mediaConcatenationPipeline)
        mediaConcatenationPipeline = mediaConcatenationPipelineDecoded
    }
}

enum CreateMediaConcatenationPipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMediaInsightsPipelineConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaInsightsPipelineConfigurationInput(elements: \(Swift.String(describing: elements)), mediaInsightsPipelineConfigurationName: \(Swift.String(describing: mediaInsightsPipelineConfigurationName)), realTimeAlertConfiguration: \(Swift.String(describing: realTimeAlertConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", resourceAccessRoleArn: \"CONTENT_REDACTED\")"}
}

extension CreateMediaInsightsPipelineConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case elements = "Elements"
        case mediaInsightsPipelineConfigurationName = "MediaInsightsPipelineConfigurationName"
        case realTimeAlertConfiguration = "RealTimeAlertConfiguration"
        case resourceAccessRoleArn = "ResourceAccessRoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let elements = elements {
            var elementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elements)
            for mediainsightspipelineconfigurationelement0 in elements {
                try elementsContainer.encode(mediainsightspipelineconfigurationelement0)
            }
        }
        if let mediaInsightsPipelineConfigurationName = self.mediaInsightsPipelineConfigurationName {
            try encodeContainer.encode(mediaInsightsPipelineConfigurationName, forKey: .mediaInsightsPipelineConfigurationName)
        }
        if let realTimeAlertConfiguration = self.realTimeAlertConfiguration {
            try encodeContainer.encode(realTimeAlertConfiguration, forKey: .realTimeAlertConfiguration)
        }
        if let resourceAccessRoleArn = self.resourceAccessRoleArn {
            try encodeContainer.encode(resourceAccessRoleArn, forKey: .resourceAccessRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaInsightsPipelineConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/media-insights-pipeline-configurations"
    }
}

public struct CreateMediaInsightsPipelineConfigurationInput: Swift.Equatable {
    /// The unique identifier for the media insights pipeline configuration request.
    public var clientRequestToken: Swift.String?
    /// The elements in the request, such as a processor for Amazon Transcribe or a sink for a Kinesis Data Stream.
    /// This member is required.
    public var elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]?
    /// The name of the media insights pipeline configuration.
    /// This member is required.
    public var mediaInsightsPipelineConfigurationName: Swift.String?
    /// The configuration settings for the real-time alerts in a media insights pipeline configuration.
    public var realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration?
    /// The ARN of the role used by the service to access Amazon Web Services resources, including Transcribe and Transcribe Call Analytics, on the caller’s behalf.
    /// This member is required.
    public var resourceAccessRoleArn: Swift.String?
    /// The tags assigned to the media insights pipeline configuration.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]? = nil,
        mediaInsightsPipelineConfigurationName: Swift.String? = nil,
        realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration? = nil,
        resourceAccessRoleArn: Swift.String? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.elements = elements
        self.mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationName
        self.realTimeAlertConfiguration = realTimeAlertConfiguration
        self.resourceAccessRoleArn = resourceAccessRoleArn
        self.tags = tags
    }
}

struct CreateMediaInsightsPipelineConfigurationInputBody: Swift.Equatable {
    let mediaInsightsPipelineConfigurationName: Swift.String?
    let resourceAccessRoleArn: Swift.String?
    let realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration?
    let elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateMediaInsightsPipelineConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case elements = "Elements"
        case mediaInsightsPipelineConfigurationName = "MediaInsightsPipelineConfigurationName"
        case realTimeAlertConfiguration = "RealTimeAlertConfiguration"
        case resourceAccessRoleArn = "ResourceAccessRoleArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaInsightsPipelineConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaInsightsPipelineConfigurationName)
        mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationNameDecoded
        let resourceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceAccessRoleArn)
        resourceAccessRoleArn = resourceAccessRoleArnDecoded
        let realTimeAlertConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration.self, forKey: .realTimeAlertConfiguration)
        realTimeAlertConfiguration = realTimeAlertConfigurationDecoded
        let elementsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement?].self, forKey: .elements)
        var elementsDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]? = nil
        if let elementsContainer = elementsContainer {
            elementsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]()
            for structure0 in elementsContainer {
                if let structure0 = structure0 {
                    elementsDecoded0?.append(structure0)
                }
            }
        }
        elements = elementsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateMediaInsightsPipelineConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMediaInsightsPipelineConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaInsightsPipelineConfiguration = output.mediaInsightsPipelineConfiguration
        } else {
            self.mediaInsightsPipelineConfiguration = nil
        }
    }
}

public struct CreateMediaInsightsPipelineConfigurationOutput: Swift.Equatable {
    /// The configuration settings for the media insights pipeline.
    public var mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration?

    public init(
        mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration? = nil
    )
    {
        self.mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfiguration
    }
}

struct CreateMediaInsightsPipelineConfigurationOutputBody: Swift.Equatable {
    let mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration?
}

extension CreateMediaInsightsPipelineConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaInsightsPipelineConfiguration = "MediaInsightsPipelineConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaInsightsPipelineConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration.self, forKey: .mediaInsightsPipelineConfiguration)
        mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfigurationDecoded
    }
}

enum CreateMediaInsightsPipelineConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMediaInsightsPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaInsightsPipelineInput(kinesisVideoStreamRecordingSourceRuntimeConfiguration: \(Swift.String(describing: kinesisVideoStreamRecordingSourceRuntimeConfiguration)), kinesisVideoStreamSourceRuntimeConfiguration: \(Swift.String(describing: kinesisVideoStreamSourceRuntimeConfiguration)), s3RecordingSinkRuntimeConfiguration: \(Swift.String(describing: s3RecordingSinkRuntimeConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", mediaInsightsPipelineConfigurationArn: \"CONTENT_REDACTED\", mediaInsightsRuntimeMetadata: \"CONTENT_REDACTED\")"}
}

extension CreateMediaInsightsPipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kinesisVideoStreamRecordingSourceRuntimeConfiguration = "KinesisVideoStreamRecordingSourceRuntimeConfiguration"
        case kinesisVideoStreamSourceRuntimeConfiguration = "KinesisVideoStreamSourceRuntimeConfiguration"
        case mediaInsightsPipelineConfigurationArn = "MediaInsightsPipelineConfigurationArn"
        case mediaInsightsRuntimeMetadata = "MediaInsightsRuntimeMetadata"
        case s3RecordingSinkRuntimeConfiguration = "S3RecordingSinkRuntimeConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let kinesisVideoStreamRecordingSourceRuntimeConfiguration = self.kinesisVideoStreamRecordingSourceRuntimeConfiguration {
            try encodeContainer.encode(kinesisVideoStreamRecordingSourceRuntimeConfiguration, forKey: .kinesisVideoStreamRecordingSourceRuntimeConfiguration)
        }
        if let kinesisVideoStreamSourceRuntimeConfiguration = self.kinesisVideoStreamSourceRuntimeConfiguration {
            try encodeContainer.encode(kinesisVideoStreamSourceRuntimeConfiguration, forKey: .kinesisVideoStreamSourceRuntimeConfiguration)
        }
        if let mediaInsightsPipelineConfigurationArn = self.mediaInsightsPipelineConfigurationArn {
            try encodeContainer.encode(mediaInsightsPipelineConfigurationArn, forKey: .mediaInsightsPipelineConfigurationArn)
        }
        if let mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadata {
            var mediaInsightsRuntimeMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .mediaInsightsRuntimeMetadata)
            for (dictKey0, mediaInsightsRuntimeMetadata0) in mediaInsightsRuntimeMetadata {
                try mediaInsightsRuntimeMetadataContainer.encode(mediaInsightsRuntimeMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let s3RecordingSinkRuntimeConfiguration = self.s3RecordingSinkRuntimeConfiguration {
            try encodeContainer.encode(s3RecordingSinkRuntimeConfiguration, forKey: .s3RecordingSinkRuntimeConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaInsightsPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/media-insights-pipelines"
    }
}

public struct CreateMediaInsightsPipelineInput: Swift.Equatable {
    /// The unique identifier for the media insights pipeline request.
    public var clientRequestToken: Swift.String?
    /// The runtime configuration for the Kinesis video recording stream source.
    public var kinesisVideoStreamRecordingSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration?
    /// The runtime configuration for the Kinesis video stream source of the media insights pipeline.
    public var kinesisVideoStreamSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration?
    /// The ARN of the pipeline's configuration.
    /// This member is required.
    public var mediaInsightsPipelineConfigurationArn: Swift.String?
    /// The runtime metadata for the media insights pipeline. Consists of a key-value map of strings.
    public var mediaInsightsRuntimeMetadata: [Swift.String:Swift.String]?
    /// The runtime configuration for the S3 recording sink. If specified, the settings in this structure override any settings in S3RecordingSinkConfiguration.
    public var s3RecordingSinkRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration?
    /// The tags assigned to the media insights pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        kinesisVideoStreamRecordingSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration? = nil,
        kinesisVideoStreamSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration? = nil,
        mediaInsightsPipelineConfigurationArn: Swift.String? = nil,
        mediaInsightsRuntimeMetadata: [Swift.String:Swift.String]? = nil,
        s3RecordingSinkRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.kinesisVideoStreamRecordingSourceRuntimeConfiguration = kinesisVideoStreamRecordingSourceRuntimeConfiguration
        self.kinesisVideoStreamSourceRuntimeConfiguration = kinesisVideoStreamSourceRuntimeConfiguration
        self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
        self.mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadata
        self.s3RecordingSinkRuntimeConfiguration = s3RecordingSinkRuntimeConfiguration
        self.tags = tags
    }
}

struct CreateMediaInsightsPipelineInputBody: Swift.Equatable {
    let mediaInsightsPipelineConfigurationArn: Swift.String?
    let kinesisVideoStreamSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration?
    let mediaInsightsRuntimeMetadata: [Swift.String:Swift.String]?
    let kinesisVideoStreamRecordingSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration?
    let s3RecordingSinkRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateMediaInsightsPipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kinesisVideoStreamRecordingSourceRuntimeConfiguration = "KinesisVideoStreamRecordingSourceRuntimeConfiguration"
        case kinesisVideoStreamSourceRuntimeConfiguration = "KinesisVideoStreamSourceRuntimeConfiguration"
        case mediaInsightsPipelineConfigurationArn = "MediaInsightsPipelineConfigurationArn"
        case mediaInsightsRuntimeMetadata = "MediaInsightsRuntimeMetadata"
        case s3RecordingSinkRuntimeConfiguration = "S3RecordingSinkRuntimeConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaInsightsPipelineConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaInsightsPipelineConfigurationArn)
        mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArnDecoded
        let kinesisVideoStreamSourceRuntimeConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration.self, forKey: .kinesisVideoStreamSourceRuntimeConfiguration)
        kinesisVideoStreamSourceRuntimeConfiguration = kinesisVideoStreamSourceRuntimeConfigurationDecoded
        let mediaInsightsRuntimeMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .mediaInsightsRuntimeMetadata)
        var mediaInsightsRuntimeMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let mediaInsightsRuntimeMetadataContainer = mediaInsightsRuntimeMetadataContainer {
            mediaInsightsRuntimeMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in mediaInsightsRuntimeMetadataContainer {
                if let string0 = string0 {
                    mediaInsightsRuntimeMetadataDecoded0?[key0] = string0
                }
            }
        }
        mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadataDecoded0
        let kinesisVideoStreamRecordingSourceRuntimeConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration.self, forKey: .kinesisVideoStreamRecordingSourceRuntimeConfiguration)
        kinesisVideoStreamRecordingSourceRuntimeConfiguration = kinesisVideoStreamRecordingSourceRuntimeConfigurationDecoded
        let s3RecordingSinkRuntimeConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration.self, forKey: .s3RecordingSinkRuntimeConfiguration)
        s3RecordingSinkRuntimeConfiguration = s3RecordingSinkRuntimeConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateMediaInsightsPipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMediaInsightsPipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaInsightsPipeline = output.mediaInsightsPipeline
        } else {
            self.mediaInsightsPipeline = nil
        }
    }
}

public struct CreateMediaInsightsPipelineOutput: Swift.Equatable {
    /// The media insights pipeline object.
    /// This member is required.
    public var mediaInsightsPipeline: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline?

    public init(
        mediaInsightsPipeline: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline? = nil
    )
    {
        self.mediaInsightsPipeline = mediaInsightsPipeline
    }
}

struct CreateMediaInsightsPipelineOutputBody: Swift.Equatable {
    let mediaInsightsPipeline: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline?
}

extension CreateMediaInsightsPipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaInsightsPipeline = "MediaInsightsPipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaInsightsPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline.self, forKey: .mediaInsightsPipeline)
        mediaInsightsPipeline = mediaInsightsPipelineDecoded
    }
}

enum CreateMediaInsightsPipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMediaLiveConnectorPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaLiveConnectorPipelineInput(sinks: \(Swift.String(describing: sinks)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension CreateMediaLiveConnectorPipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for liveconnectorsinkconfiguration0 in sinks {
                try sinksContainer.encode(liveconnectorsinkconfiguration0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for liveconnectorsourceconfiguration0 in sources {
                try sourcesContainer.encode(liveconnectorsourceconfiguration0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaLiveConnectorPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-live-connector-pipelines"
    }
}

public struct CreateMediaLiveConnectorPipelineInput: Swift.Equatable {
    /// The token assigned to the client making the request.
    public var clientRequestToken: Swift.String?
    /// The media live connector pipeline's data sinks.
    /// This member is required.
    public var sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]?
    /// The media live connector pipeline's data sources.
    /// This member is required.
    public var sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]?
    /// The tags associated with the media live connector pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil,
        sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sinks = sinks
        self.sources = sources
        self.tags = tags
    }
}

struct CreateMediaLiveConnectorPipelineInputBody: Swift.Equatable {
    let sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]?
    let sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension CreateMediaLiveConnectorPipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMediaLiveConnectorPipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMediaLiveConnectorPipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaLiveConnectorPipeline = output.mediaLiveConnectorPipeline
        } else {
            self.mediaLiveConnectorPipeline = nil
        }
    }
}

public struct CreateMediaLiveConnectorPipelineOutput: Swift.Equatable {
    /// The new media live connector pipeline.
    public var mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline?

    public init(
        mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline? = nil
    )
    {
        self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
    }
}

struct CreateMediaLiveConnectorPipelineOutputBody: Swift.Equatable {
    let mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline?
}

extension CreateMediaLiveConnectorPipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaLiveConnectorPipeline = "MediaLiveConnectorPipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaLiveConnectorPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline.self, forKey: .mediaLiveConnectorPipeline)
        mediaLiveConnectorPipeline = mediaLiveConnectorPipelineDecoded
    }
}

enum CreateMediaLiveConnectorPipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMediaPipelineKinesisVideoStreamPoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaPipelineKinesisVideoStreamPoolInput(poolName: \(Swift.String(describing: poolName)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension CreateMediaPipelineKinesisVideoStreamPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case poolName = "PoolName"
        case streamConfiguration = "StreamConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let poolName = self.poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let streamConfiguration = self.streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaPipelineKinesisVideoStreamPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/media-pipeline-kinesis-video-stream-pools"
    }
}

public struct CreateMediaPipelineKinesisVideoStreamPoolInput: Swift.Equatable {
    /// The token assigned to the client making the request.
    public var clientRequestToken: Swift.String?
    /// The name of the video stream pool.
    /// This member is required.
    public var poolName: Swift.String?
    /// The configuration settings for the video stream.
    /// This member is required.
    public var streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration?
    /// The tags assigned to the video stream pool.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        poolName: Swift.String? = nil,
        streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.poolName = poolName
        self.streamConfiguration = streamConfiguration
        self.tags = tags
    }
}

struct CreateMediaPipelineKinesisVideoStreamPoolInputBody: Swift.Equatable {
    let streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration?
    let poolName: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension CreateMediaPipelineKinesisVideoStreamPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case poolName = "PoolName"
        case streamConfiguration = "StreamConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let poolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMediaPipelineKinesisVideoStreamPoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMediaPipelineKinesisVideoStreamPoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.kinesisVideoStreamPoolConfiguration = output.kinesisVideoStreamPoolConfiguration
        } else {
            self.kinesisVideoStreamPoolConfiguration = nil
        }
    }
}

public struct CreateMediaPipelineKinesisVideoStreamPoolOutput: Swift.Equatable {
    /// The configuration for the Kinesis video stream pool.
    public var kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration?

    public init(
        kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration? = nil
    )
    {
        self.kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfiguration
    }
}

struct CreateMediaPipelineKinesisVideoStreamPoolOutputBody: Swift.Equatable {
    let kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration?
}

extension CreateMediaPipelineKinesisVideoStreamPoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisVideoStreamPoolConfiguration = "KinesisVideoStreamPoolConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisVideoStreamPoolConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration.self, forKey: .kinesisVideoStreamPoolConfiguration)
        kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfigurationDecoded
    }
}

enum CreateMediaPipelineKinesisVideoStreamPoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMediaStreamPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaStreamPipelineInput(sinks: \(Swift.String(describing: sinks)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension CreateMediaStreamPipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for mediastreamsink0 in sinks {
                try sinksContainer.encode(mediastreamsink0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for mediastreamsource0 in sources {
                try sourcesContainer.encode(mediastreamsource0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateMediaStreamPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-stream-pipelines"
    }
}

public struct CreateMediaStreamPipelineInput: Swift.Equatable {
    /// The token assigned to the client making the request.
    public var clientRequestToken: Swift.String?
    /// The data sink for the media pipeline.
    /// This member is required.
    public var sinks: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]?
    /// The data sources for the media pipeline.
    /// This member is required.
    public var sources: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]?
    /// The tags assigned to the media pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        sinks: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]? = nil,
        sources: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sinks = sinks
        self.sources = sources
        self.tags = tags
    }
}

struct CreateMediaStreamPipelineInputBody: Swift.Equatable {
    let sources: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]?
    let sinks: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension CreateMediaStreamPipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sinks = "Sinks"
        case sources = "Sources"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaStreamSource?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaStreamSink?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMediaStreamPipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMediaStreamPipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaStreamPipeline = output.mediaStreamPipeline
        } else {
            self.mediaStreamPipeline = nil
        }
    }
}

public struct CreateMediaStreamPipelineOutput: Swift.Equatable {
    /// The requested media pipeline.
    public var mediaStreamPipeline: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline?

    public init(
        mediaStreamPipeline: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline? = nil
    )
    {
        self.mediaStreamPipeline = mediaStreamPipeline
    }
}

struct CreateMediaStreamPipelineOutputBody: Swift.Equatable {
    let mediaStreamPipeline: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline?
}

extension CreateMediaStreamPipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaStreamPipeline = "MediaStreamPipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaStreamPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline.self, forKey: .mediaStreamPipeline)
        mediaStreamPipeline = mediaStreamPipelineDecoded
    }
}

enum CreateMediaStreamPipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The content configuration object's data channel.
    public struct DataChannelConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension DeleteMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct DeleteMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the media pipeline being deleted.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct DeleteMediaCapturePipelineInputBody: Swift.Equatable {
}

extension DeleteMediaCapturePipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaCapturePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMediaCapturePipelineOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMediaCapturePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMediaInsightsPipelineConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/media-insights-pipeline-configurations/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteMediaInsightsPipelineConfigurationInput: Swift.Equatable {
    /// The unique identifier of the resource to be deleted. Valid values include the name and ARN of the media insights pipeline configuration.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteMediaInsightsPipelineConfigurationInputBody: Swift.Equatable {
}

extension DeleteMediaInsightsPipelineConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaInsightsPipelineConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMediaInsightsPipelineConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMediaInsightsPipelineConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMediaPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct DeleteMediaPipelineInput: Swift.Equatable {
    /// The ID of the media pipeline to delete.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct DeleteMediaPipelineInputBody: Swift.Equatable {
}

extension DeleteMediaPipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaPipelineKinesisVideoStreamPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/media-pipeline-kinesis-video-stream-pools/\(identifier.urlPercentEncoding())"
    }
}

public struct DeleteMediaPipelineKinesisVideoStreamPoolInput: Swift.Equatable {
    /// The ID of the pool being deleted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct DeleteMediaPipelineKinesisVideoStreamPoolInputBody: Swift.Equatable {
}

extension DeleteMediaPipelineKinesisVideoStreamPoolInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaPipelineKinesisVideoStreamPoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMediaPipelineKinesisVideoStreamPoolOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMediaPipelineKinesisVideoStreamPoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMediaPipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMediaPipelineOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMediaPipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badrequest
        case forbidden
        case notfound
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttling
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .badrequest,
                .forbidden,
                .notfound,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badrequest: return "BadRequest"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttling: return "Throttling"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.FragmentSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fragmentSelectorType = "FragmentSelectorType"
        case timestampRange = "TimestampRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragmentSelectorType = self.fragmentSelectorType {
            try encodeContainer.encode(fragmentSelectorType.rawValue, forKey: .fragmentSelectorType)
        }
        if let timestampRange = self.timestampRange {
            try encodeContainer.encode(timestampRange, forKey: .timestampRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fragmentSelectorTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.FragmentSelectorType.self, forKey: .fragmentSelectorType)
        fragmentSelectorType = fragmentSelectorTypeDecoded
        let timestampRangeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.TimestampRange.self, forKey: .timestampRange)
        timestampRange = timestampRangeDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Describes the timestamp range and timestamp origin of a range of fragments. Only fragments with a start timestamp greater than or equal to the given start time and less than or equal to the end time are returned. For example, say a stream contains fragments with the following start timestamps:
    ///
    /// * 00:00:00
    ///
    /// * 00:00:02
    ///
    /// * 00:00:04
    ///
    /// * 00:00:06
    ///
    ///
    /// A fragment selector range with a start time of 00:00:01 and end time of 00:00:04 would return the fragments with start times of 00:00:02 and 00:00:04.
    public struct FragmentSelector: Swift.Equatable {
        /// The origin of the timestamps to use, Server or Producer. For more information, see [StartSelectorType](https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_dataplane_StartSelector.html) in the Amazon Kinesis Video Streams Developer Guide.
        /// This member is required.
        public var fragmentSelectorType: ChimeSDKMediaPipelinesClientTypes.FragmentSelectorType?
        /// The range of timestamps to return.
        /// This member is required.
        public var timestampRange: ChimeSDKMediaPipelinesClientTypes.TimestampRange?

        public init(
            fragmentSelectorType: ChimeSDKMediaPipelinesClientTypes.FragmentSelectorType? = nil,
            timestampRange: ChimeSDKMediaPipelinesClientTypes.TimestampRange? = nil
        )
        {
            self.fragmentSelectorType = fragmentSelectorType
            self.timestampRange = timestampRange
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum FragmentSelectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case producertimestamp
        case servertimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [FragmentSelectorType] {
            return [
                .producertimestamp,
                .servertimestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .producertimestamp: return "ProducerTimestamp"
            case .servertimestamp: return "ServerTimestamp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FragmentSelectorType(rawValue: rawValue) ?? FragmentSelectorType.sdkUnknown(rawValue)
        }
    }
}

extension GetMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct GetMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct GetMediaCapturePipelineInputBody: Swift.Equatable {
}

extension GetMediaCapturePipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMediaCapturePipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMediaCapturePipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct GetMediaCapturePipelineOutput: Swift.Equatable {
    /// The media pipeline object.
    public var mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?

    public init(
        mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct GetMediaCapturePipelineOutputBody: Swift.Equatable {
    let mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?
}

extension GetMediaCapturePipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

enum GetMediaCapturePipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMediaInsightsPipelineConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/media-insights-pipeline-configurations/\(identifier.urlPercentEncoding())"
    }
}

public struct GetMediaInsightsPipelineConfigurationInput: Swift.Equatable {
    /// The unique identifier of the requested resource. Valid values include the name and ARN of the media insights pipeline configuration.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetMediaInsightsPipelineConfigurationInputBody: Swift.Equatable {
}

extension GetMediaInsightsPipelineConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMediaInsightsPipelineConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMediaInsightsPipelineConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaInsightsPipelineConfiguration = output.mediaInsightsPipelineConfiguration
        } else {
            self.mediaInsightsPipelineConfiguration = nil
        }
    }
}

public struct GetMediaInsightsPipelineConfigurationOutput: Swift.Equatable {
    /// The requested media insights pipeline configuration.
    public var mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration?

    public init(
        mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration? = nil
    )
    {
        self.mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfiguration
    }
}

struct GetMediaInsightsPipelineConfigurationOutputBody: Swift.Equatable {
    let mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration?
}

extension GetMediaInsightsPipelineConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaInsightsPipelineConfiguration = "MediaInsightsPipelineConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaInsightsPipelineConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration.self, forKey: .mediaInsightsPipelineConfiguration)
        mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfigurationDecoded
    }
}

enum GetMediaInsightsPipelineConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMediaPipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct GetMediaPipelineInput: Swift.Equatable {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct GetMediaPipelineInputBody: Swift.Equatable {
}

extension GetMediaPipelineInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMediaPipelineKinesisVideoStreamPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/media-pipeline-kinesis-video-stream-pools/\(identifier.urlPercentEncoding())"
    }
}

public struct GetMediaPipelineKinesisVideoStreamPoolInput: Swift.Equatable {
    /// The ID of the video stream pool.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

struct GetMediaPipelineKinesisVideoStreamPoolInputBody: Swift.Equatable {
}

extension GetMediaPipelineKinesisVideoStreamPoolInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMediaPipelineKinesisVideoStreamPoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMediaPipelineKinesisVideoStreamPoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.kinesisVideoStreamPoolConfiguration = output.kinesisVideoStreamPoolConfiguration
        } else {
            self.kinesisVideoStreamPoolConfiguration = nil
        }
    }
}

public struct GetMediaPipelineKinesisVideoStreamPoolOutput: Swift.Equatable {
    /// The video stream pool configuration object.
    public var kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration?

    public init(
        kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration? = nil
    )
    {
        self.kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfiguration
    }
}

struct GetMediaPipelineKinesisVideoStreamPoolOutputBody: Swift.Equatable {
    let kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration?
}

extension GetMediaPipelineKinesisVideoStreamPoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisVideoStreamPoolConfiguration = "KinesisVideoStreamPoolConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisVideoStreamPoolConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration.self, forKey: .kinesisVideoStreamPoolConfiguration)
        kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfigurationDecoded
    }
}

enum GetMediaPipelineKinesisVideoStreamPoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMediaPipelineOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMediaPipelineOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaPipeline = output.mediaPipeline
        } else {
            self.mediaPipeline = nil
        }
    }
}

public struct GetMediaPipelineOutput: Swift.Equatable {
    /// The media pipeline object.
    public var mediaPipeline: ChimeSDKMediaPipelinesClientTypes.MediaPipeline?

    public init(
        mediaPipeline: ChimeSDKMediaPipelinesClientTypes.MediaPipeline? = nil
    )
    {
        self.mediaPipeline = mediaPipeline
    }
}

struct GetMediaPipelineOutputBody: Swift.Equatable {
    let mediaPipeline: ChimeSDKMediaPipelinesClientTypes.MediaPipeline?
}

extension GetMediaPipelineOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPipeline = "MediaPipeline"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipeline.self, forKey: .mediaPipeline)
        mediaPipeline = mediaPipelineDecoded
    }
}

enum GetMediaPipelineOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSpeakerSearchTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        guard let speakerSearchTaskId = speakerSearchTaskId else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/speaker-search-tasks/\(speakerSearchTaskId.urlPercentEncoding())"
    }
}

public struct GetSpeakerSearchTaskInput: Swift.Equatable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The ID of the speaker search task.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        speakerSearchTaskId: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.speakerSearchTaskId = speakerSearchTaskId
    }
}

struct GetSpeakerSearchTaskInputBody: Swift.Equatable {
}

extension GetSpeakerSearchTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSpeakerSearchTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSpeakerSearchTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.speakerSearchTask = output.speakerSearchTask
        } else {
            self.speakerSearchTask = nil
        }
    }
}

public struct GetSpeakerSearchTaskOutput: Swift.Equatable {
    /// The details of the speaker search task.
    public var speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask?

    public init(
        speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask? = nil
    )
    {
        self.speakerSearchTask = speakerSearchTask
    }
}

struct GetSpeakerSearchTaskOutputBody: Swift.Equatable {
    let speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask?
}

extension GetSpeakerSearchTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTask = "SpeakerSearchTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask.self, forKey: .speakerSearchTask)
        speakerSearchTask = speakerSearchTaskDecoded
    }
}

enum GetSpeakerSearchTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceToneAnalysisTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        guard let voiceToneAnalysisTaskId = voiceToneAnalysisTaskId else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/voice-tone-analysis-tasks/\(voiceToneAnalysisTaskId.urlPercentEncoding())"
    }
}

public struct GetVoiceToneAnalysisTaskInput: Swift.Equatable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The ID of the voice tone analysis task.
    /// This member is required.
    public var voiceToneAnalysisTaskId: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        voiceToneAnalysisTaskId: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
    }
}

struct GetVoiceToneAnalysisTaskInputBody: Swift.Equatable {
}

extension GetVoiceToneAnalysisTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceToneAnalysisTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceToneAnalysisTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceToneAnalysisTask = output.voiceToneAnalysisTask
        } else {
            self.voiceToneAnalysisTask = nil
        }
    }
}

public struct GetVoiceToneAnalysisTaskOutput: Swift.Equatable {
    /// The details of the voice tone analysis task.
    public var voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask?

    public init(
        voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask? = nil
    )
    {
        self.voiceToneAnalysisTask = voiceToneAnalysisTask
    }
}

struct GetVoiceToneAnalysisTaskOutputBody: Swift.Equatable {
    let voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask?
}

extension GetVoiceToneAnalysisTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceToneAnalysisTask = "VoiceToneAnalysisTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceToneAnalysisTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask.self, forKey: .voiceToneAnalysisTask)
        voiceToneAnalysisTask = voiceToneAnalysisTaskDecoded
    }
}

enum GetVoiceToneAnalysisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeSpeakerOnlyConfiguration = "ActiveSpeakerOnlyConfiguration"
        case canvasOrientation = "CanvasOrientation"
        case contentShareLayout = "ContentShareLayout"
        case horizontalLayoutConfiguration = "HorizontalLayoutConfiguration"
        case presenterOnlyConfiguration = "PresenterOnlyConfiguration"
        case verticalLayoutConfiguration = "VerticalLayoutConfiguration"
        case videoAttribute = "VideoAttribute"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeSpeakerOnlyConfiguration = self.activeSpeakerOnlyConfiguration {
            try encodeContainer.encode(activeSpeakerOnlyConfiguration, forKey: .activeSpeakerOnlyConfiguration)
        }
        if let canvasOrientation = self.canvasOrientation {
            try encodeContainer.encode(canvasOrientation.rawValue, forKey: .canvasOrientation)
        }
        if let contentShareLayout = self.contentShareLayout {
            try encodeContainer.encode(contentShareLayout.rawValue, forKey: .contentShareLayout)
        }
        if let horizontalLayoutConfiguration = self.horizontalLayoutConfiguration {
            try encodeContainer.encode(horizontalLayoutConfiguration, forKey: .horizontalLayoutConfiguration)
        }
        if let presenterOnlyConfiguration = self.presenterOnlyConfiguration {
            try encodeContainer.encode(presenterOnlyConfiguration, forKey: .presenterOnlyConfiguration)
        }
        if let verticalLayoutConfiguration = self.verticalLayoutConfiguration {
            try encodeContainer.encode(verticalLayoutConfiguration, forKey: .verticalLayoutConfiguration)
        }
        if let videoAttribute = self.videoAttribute {
            try encodeContainer.encode(videoAttribute, forKey: .videoAttribute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentShareLayoutDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentShareLayoutOption.self, forKey: .contentShareLayout)
        contentShareLayout = contentShareLayoutDecoded
        let presenterOnlyConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration.self, forKey: .presenterOnlyConfiguration)
        presenterOnlyConfiguration = presenterOnlyConfigurationDecoded
        let activeSpeakerOnlyConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration.self, forKey: .activeSpeakerOnlyConfiguration)
        activeSpeakerOnlyConfiguration = activeSpeakerOnlyConfigurationDecoded
        let horizontalLayoutConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration.self, forKey: .horizontalLayoutConfiguration)
        horizontalLayoutConfiguration = horizontalLayoutConfigurationDecoded
        let verticalLayoutConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration.self, forKey: .verticalLayoutConfiguration)
        verticalLayoutConfiguration = verticalLayoutConfigurationDecoded
        let videoAttributeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VideoAttribute.self, forKey: .videoAttribute)
        videoAttribute = videoAttributeDecoded
        let canvasOrientationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.CanvasOrientation.self, forKey: .canvasOrientation)
        canvasOrientation = canvasOrientationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Specifies the type of grid layout.
    public struct GridViewConfiguration: Swift.Equatable {
        /// The configuration settings for an ActiveSpeakerOnly video tile.
        public var activeSpeakerOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration?
        /// The orientation setting, horizontal or vertical.
        public var canvasOrientation: ChimeSDKMediaPipelinesClientTypes.CanvasOrientation?
        /// Defines the layout of the video tiles when content sharing is enabled.
        /// This member is required.
        public var contentShareLayout: ChimeSDKMediaPipelinesClientTypes.ContentShareLayoutOption?
        /// The configuration settings for a horizontal layout.
        public var horizontalLayoutConfiguration: ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration?
        /// Defines the configuration options for a presenter only video tile.
        public var presenterOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration?
        /// The configuration settings for a vertical layout.
        public var verticalLayoutConfiguration: ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration?
        /// The attribute settings for the video tiles.
        public var videoAttribute: ChimeSDKMediaPipelinesClientTypes.VideoAttribute?

        public init(
            activeSpeakerOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration? = nil,
            canvasOrientation: ChimeSDKMediaPipelinesClientTypes.CanvasOrientation? = nil,
            contentShareLayout: ChimeSDKMediaPipelinesClientTypes.ContentShareLayoutOption? = nil,
            horizontalLayoutConfiguration: ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration? = nil,
            presenterOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration? = nil,
            verticalLayoutConfiguration: ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration? = nil,
            videoAttribute: ChimeSDKMediaPipelinesClientTypes.VideoAttribute? = nil
        )
        {
            self.activeSpeakerOnlyConfiguration = activeSpeakerOnlyConfiguration
            self.canvasOrientation = canvasOrientation
            self.contentShareLayout = contentShareLayout
            self.horizontalLayoutConfiguration = horizontalLayoutConfiguration
            self.presenterOnlyConfiguration = presenterOnlyConfiguration
            self.verticalLayoutConfiguration = verticalLayoutConfiguration
            self.videoAttribute = videoAttribute
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum HighlightColor: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case black
        case blue
        case green
        case red
        case white
        case yellow
        case sdkUnknown(Swift.String)

        public static var allCases: [HighlightColor] {
            return [
                .black,
                .blue,
                .green,
                .red,
                .white,
                .yellow,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .black: return "Black"
            case .blue: return "Blue"
            case .green: return "Green"
            case .red: return "Red"
            case .white: return "White"
            case .yellow: return "Yellow"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HighlightColor(rawValue: rawValue) ?? HighlightColor.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tileAspectRatio = "TileAspectRatio"
        case tileCount = "TileCount"
        case tileOrder = "TileOrder"
        case tilePosition = "TilePosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tileAspectRatio = self.tileAspectRatio {
            try encodeContainer.encode(tileAspectRatio, forKey: .tileAspectRatio)
        }
        if let tileCount = self.tileCount {
            try encodeContainer.encode(tileCount, forKey: .tileCount)
        }
        if let tileOrder = self.tileOrder {
            try encodeContainer.encode(tileOrder.rawValue, forKey: .tileOrder)
        }
        if let tilePosition = self.tilePosition {
            try encodeContainer.encode(tilePosition.rawValue, forKey: .tilePosition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tileOrderDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.TileOrder.self, forKey: .tileOrder)
        tileOrder = tileOrderDecoded
        let tilePositionDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.HorizontalTilePosition.self, forKey: .tilePosition)
        tilePosition = tilePositionDecoded
        let tileCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tileCount)
        tileCount = tileCountDecoded
        let tileAspectRatioDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tileAspectRatio)
        tileAspectRatio = tileAspectRatioDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Defines the configuration settings for the horizontal layout.
    public struct HorizontalLayoutConfiguration: Swift.Equatable {
        /// Specifies the aspect ratio of all video tiles.
        public var tileAspectRatio: Swift.String?
        /// The maximum number of video tiles to display.
        public var tileCount: Swift.Int?
        /// Sets the automatic ordering of the video tiles.
        public var tileOrder: ChimeSDKMediaPipelinesClientTypes.TileOrder?
        /// Sets the position of horizontal tiles.
        public var tilePosition: ChimeSDKMediaPipelinesClientTypes.HorizontalTilePosition?

        public init(
            tileAspectRatio: Swift.String? = nil,
            tileCount: Swift.Int? = nil,
            tileOrder: ChimeSDKMediaPipelinesClientTypes.TileOrder? = nil,
            tilePosition: ChimeSDKMediaPipelinesClientTypes.HorizontalTilePosition? = nil
        )
        {
            self.tileAspectRatio = tileAspectRatio
            self.tileCount = tileCount
            self.tileOrder = tileOrder
            self.tilePosition = tilePosition
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum HorizontalTilePosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottom
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [HorizontalTilePosition] {
            return [
                .bottom,
                .top,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottom: return "Bottom"
            case .top: return "Top"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HorizontalTilePosition(rawValue: rawValue) ?? HorizontalTilePosition.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleName = "RuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the configuration settings for an issue detection task.
    public struct IssueDetectionConfiguration: Swift.Equatable {
        /// The name of the issue detection rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init(
            ruleName: Swift.String? = nil
        )
        {
            self.ruleName = ruleName
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keywords = "Keywords"
        case negate = "Negate"
        case ruleName = "RuleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keywords = keywords {
            var keywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keywords)
            for keyword0 in keywords {
                try keywordsContainer.encode(keyword0)
            }
        }
        if negate != false {
            try encodeContainer.encode(negate, forKey: .negate)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let keywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keywords)
        var keywordsDecoded0:[Swift.String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [Swift.String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let negateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negate) ?? false
        negate = negateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the settings for a keyword match task.
    public struct KeywordMatchConfiguration: Swift.Equatable {
        /// The keywords or phrases that you want to match.
        /// This member is required.
        public var keywords: [Swift.String]?
        /// Matches keywords or phrases on their presence or absence. If set to TRUE, the rule matches when all the specified keywords or phrases are absent. Default: FALSE.
        public var negate: Swift.Bool
        /// The name of the keyword match rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init(
            keywords: [Swift.String]? = nil,
            negate: Swift.Bool = false,
            ruleName: Swift.String? = nil
        )
        {
            self.keywords = keywords
            self.negate = negate
            self.ruleName = ruleName
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightsTarget = "InsightsTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightsTarget = self.insightsTarget {
            try encodeContainer.encode(insightsTarget, forKey: .insightsTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightsTarget)
        insightsTarget = insightsTargetDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisDataStreamSinkConfiguration(insightsTarget: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the configuration settings for a Kinesis Data Stream sink.
    public struct KinesisDataStreamSinkConfiguration: Swift.Equatable {
        /// The ARN of the sink.
        public var insightsTarget: Swift.String?

        public init(
            insightsTarget: Swift.String? = nil
        )
        {
            self.insightsTarget = insightsTarget
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration of an Kinesis video stream.
    public struct KinesisVideoStreamConfiguration: Swift.Equatable {
        /// The amount of time that data is retained.
        public var dataRetentionInHours: Swift.Int?
        /// The Amazon Web Services Region of the video stream.
        /// This member is required.
        public var region: Swift.String?

        public init(
            dataRetentionInHours: Swift.Int? = nil,
            region: Swift.String? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
            self.region = region
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The updated Kinesis video stream configuration object.
    public struct KinesisVideoStreamConfigurationUpdate: Swift.Equatable {
        /// The updated time that data is retained.
        public var dataRetentionInHours: Swift.Int?

        public init(
            dataRetentionInHours: Swift.Int? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case poolName = "PoolName"
        case poolSize = "PoolSize"
        case poolStatus = "PoolStatus"
        case streamConfiguration = "StreamConfiguration"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let poolArn = self.poolArn {
            try encodeContainer.encode(poolArn, forKey: .poolArn)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let poolName = self.poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
        if let poolSize = self.poolSize {
            try encodeContainer.encode(poolSize, forKey: .poolSize)
        }
        if let poolStatus = self.poolStatus {
            try encodeContainer.encode(poolStatus.rawValue, forKey: .poolStatus)
        }
        if let streamConfiguration = self.streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
        let poolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let poolStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolStatus.self, forKey: .poolStatus)
        poolStatus = poolStatusDecoded
        let poolSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .poolSize)
        poolSize = poolSizeDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisVideoStreamPoolConfiguration(createdTimestamp: \(Swift.String(describing: createdTimestamp)), poolId: \(Swift.String(describing: poolId)), poolName: \(Swift.String(describing: poolName)), poolSize: \(Swift.String(describing: poolSize)), poolStatus: \(Swift.String(describing: poolStatus)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), poolArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The video stream pool configuration object.
    public struct KinesisVideoStreamPoolConfiguration: Swift.Equatable {
        /// The time at which the configuration was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the video stream pool configuration.
        public var poolArn: Swift.String?
        /// The ID of the video stream pool in the configuration.
        public var poolId: Swift.String?
        /// The name of the video stream pool configuration.
        public var poolName: Swift.String?
        /// The size of the video stream pool in the configuration.
        public var poolSize: Swift.Int?
        /// The status of the video stream pool in the configuration.
        public var poolStatus: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolStatus?
        /// The Kinesis video stream pool configuration object.
        public var streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration?
        /// The time at which the configuration was updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            poolArn: Swift.String? = nil,
            poolId: Swift.String? = nil,
            poolName: Swift.String? = nil,
            poolSize: Swift.Int? = nil,
            poolStatus: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolStatus? = nil,
            streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.poolArn = poolArn
            self.poolId = poolId
            self.poolName = poolName
            self.poolSize = poolSize
            self.poolStatus = poolStatus
            self.streamConfiguration = streamConfiguration
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum KinesisVideoStreamPoolStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KinesisVideoStreamPoolStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KinesisVideoStreamPoolStatus(rawValue: rawValue) ?? KinesisVideoStreamPoolStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case poolArn = "PoolArn"
        case poolId = "PoolId"
        case poolName = "PoolName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let poolArn = self.poolArn {
            try encodeContainer.encode(poolArn, forKey: .poolArn)
        }
        if let poolId = self.poolId {
            try encodeContainer.encode(poolId, forKey: .poolId)
        }
        if let poolName = self.poolName {
            try encodeContainer.encode(poolName, forKey: .poolName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let poolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolName)
        poolName = poolNameDecoded
        let poolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolId)
        poolId = poolIdDecoded
        let poolArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .poolArn)
        poolArn = poolArnDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisVideoStreamPoolSummary(poolId: \(Swift.String(describing: poolId)), poolName: \(Swift.String(describing: poolName)), poolArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A summary of the Kinesis video stream pool.
    public struct KinesisVideoStreamPoolSummary: Swift.Equatable {
        /// The ARN of the video stream pool.
        public var poolArn: Swift.String?
        /// The ID of the video stream pool.
        public var poolId: Swift.String?
        /// The name of the video stream pool.
        public var poolName: Swift.String?

        public init(
            poolArn: Swift.String? = nil,
            poolId: Swift.String? = nil,
            poolName: Swift.String? = nil
        )
        {
            self.poolArn = poolArn
            self.poolId = poolId
            self.poolName = poolName
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fragmentSelector = "FragmentSelector"
        case streams = "Streams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragmentSelector = self.fragmentSelector {
            try encodeContainer.encode(fragmentSelector, forKey: .fragmentSelector)
        }
        if let streams = streams {
            var streamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streams)
            for recordingstreamconfiguration0 in streams {
                try streamsContainer.encode(recordingstreamconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration?].self, forKey: .streams)
        var streamsDecoded0:[ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let fragmentSelectorDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.FragmentSelector.self, forKey: .fragmentSelector)
        fragmentSelector = fragmentSelectorDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the runtime settings for recording a Kinesis video stream.
    public struct KinesisVideoStreamRecordingSourceRuntimeConfiguration: Swift.Equatable {
        /// Describes the timestamp range and timestamp origin of a range of fragments in the Kinesis video stream.
        /// This member is required.
        public var fragmentSelector: ChimeSDKMediaPipelinesClientTypes.FragmentSelector?
        /// The stream or streams to be recorded.
        /// This member is required.
        public var streams: [ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration]?

        public init(
            fragmentSelector: ChimeSDKMediaPipelinesClientTypes.FragmentSelector? = nil,
            streams: [ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration]? = nil
        )
        {
            self.fragmentSelector = fragmentSelector
            self.streams = streams
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaEncoding = "MediaEncoding"
        case mediaSampleRate = "MediaSampleRate"
        case streams = "Streams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaEncoding = self.mediaEncoding {
            try encodeContainer.encode(mediaEncoding.rawValue, forKey: .mediaEncoding)
        }
        if let mediaSampleRate = self.mediaSampleRate {
            try encodeContainer.encode(mediaSampleRate, forKey: .mediaSampleRate)
        }
        if let streams = streams {
            var streamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streams)
            for streamconfiguration0 in streams {
                try streamsContainer.encode(streamconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.StreamConfiguration?].self, forKey: .streams)
        var streamsDecoded0:[ChimeSDKMediaPipelinesClientTypes.StreamConfiguration]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.StreamConfiguration]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let mediaEncodingDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaEncoding.self, forKey: .mediaEncoding)
        mediaEncoding = mediaEncodingDecoded
        let mediaSampleRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaSampleRate)
        mediaSampleRate = mediaSampleRateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The runtime configuration settings for the Kinesis video stream source.
    public struct KinesisVideoStreamSourceRuntimeConfiguration: Swift.Equatable {
        /// Specifies the encoding of your input audio. Supported format: PCM (only signed 16-bit little-endian audio formats, which does not include WAV) For more information, see [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) in the Amazon Transcribe Developer Guide.
        /// This member is required.
        public var mediaEncoding: ChimeSDKMediaPipelinesClientTypes.MediaEncoding?
        /// The sample rate of the input audio (in hertz). Low-quality audio, such as telephone audio, is typically around 8,000 Hz. High-quality audio typically ranges from 16,000 Hz to 48,000 Hz. Note that the sample rate you specify must match that of your audio. Valid Range: Minimum value of 8000. Maximum value of 48000.
        /// This member is required.
        public var mediaSampleRate: Swift.Int?
        /// The streams in the source runtime configuration of a Kinesis video stream.
        /// This member is required.
        public var streams: [ChimeSDKMediaPipelinesClientTypes.StreamConfiguration]?

        public init(
            mediaEncoding: ChimeSDKMediaPipelinesClientTypes.MediaEncoding? = nil,
            mediaSampleRate: Swift.Int? = nil,
            streams: [ChimeSDKMediaPipelinesClientTypes.StreamConfiguration]? = nil
        )
        {
            self.mediaEncoding = mediaEncoding
            self.mediaSampleRate = mediaSampleRate
            self.streams = streams
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId = "ChannelId"
        case fragmentNumber = "FragmentNumber"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if channelId != 0 {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let fragmentNumber = self.fragmentNumber {
            try encodeContainer.encode(fragmentNumber, forKey: .fragmentNumber)
        }
        if let streamArn = self.streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .channelId) ?? 0
        channelId = channelIdDecoded
        let fragmentNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fragmentNumber)
        fragmentNumber = fragmentNumberDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The task configuration settings for the Kinesis video stream source.
    public struct KinesisVideoStreamSourceTaskConfiguration: Swift.Equatable {
        /// The channel ID.
        /// This member is required.
        public var channelId: Swift.Int
        /// The unique identifier of the fragment to begin processing.
        public var fragmentNumber: Swift.String?
        /// The ARN of the stream.
        /// This member is required.
        public var streamArn: Swift.String?

        public init(
            channelId: Swift.Int = 0,
            fragmentNumber: Swift.String? = nil,
            streamArn: Swift.String? = nil
        )
        {
            self.channelId = channelId
            self.fragmentNumber = fragmentNumber
            self.streamArn = streamArn
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightsTarget = "InsightsTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightsTarget = self.insightsTarget {
            try encodeContainer.encode(insightsTarget, forKey: .insightsTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightsTarget)
        insightsTarget = insightsTargetDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionSinkConfiguration(insightsTarget: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the configuration settings for an AWS Lambda function's data sink.
    public struct LambdaFunctionSinkConfiguration: Swift.Equatable {
        /// The ARN of the sink.
        public var insightsTarget: Swift.String?

        public init(
            insightsTarget: Swift.String? = nil
        )
        {
            self.insightsTarget = insightsTarget
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum LayoutOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gridview
        case sdkUnknown(Swift.String)

        public static var allCases: [LayoutOption] {
            return [
                .gridview,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gridview: return "GridView"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayoutOption(rawValue: rawValue) ?? LayoutOption.sdkUnknown(rawValue)
        }
    }
}

extension ListMediaCapturePipelinesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMediaCapturePipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-capture-pipelines"
    }
}

public struct ListMediaCapturePipelinesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesInputBody: Swift.Equatable {
}

extension ListMediaCapturePipelinesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMediaCapturePipelinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMediaCapturePipelinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipelines = output.mediaCapturePipelines
            self.nextToken = output.nextToken
        } else {
            self.mediaCapturePipelines = nil
            self.nextToken = nil
        }
    }
}

public struct ListMediaCapturePipelinesOutput: Swift.Equatable {
    /// The media pipeline objects in the list.
    public var mediaCapturePipelines: [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        mediaCapturePipelines: [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaCapturePipelines = mediaCapturePipelines
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesOutputBody: Swift.Equatable {
    let mediaCapturePipelines: [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]?
    let nextToken: Swift.String?
}

extension ListMediaCapturePipelinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipelines = "MediaCapturePipelines"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelinesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary?].self, forKey: .mediaCapturePipelines)
        var mediaCapturePipelinesDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]? = nil
        if let mediaCapturePipelinesContainer = mediaCapturePipelinesContainer {
            mediaCapturePipelinesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]()
            for structure0 in mediaCapturePipelinesContainer {
                if let structure0 = structure0 {
                    mediaCapturePipelinesDecoded0?.append(structure0)
                }
            }
        }
        mediaCapturePipelines = mediaCapturePipelinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMediaCapturePipelinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMediaInsightsPipelineConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMediaInsightsPipelineConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/media-insights-pipeline-configurations"
    }
}

public struct ListMediaInsightsPipelineConfigurationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMediaInsightsPipelineConfigurationsInputBody: Swift.Equatable {
}

extension ListMediaInsightsPipelineConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMediaInsightsPipelineConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMediaInsightsPipelineConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaInsightsPipelineConfigurations = output.mediaInsightsPipelineConfigurations
            self.nextToken = output.nextToken
        } else {
            self.mediaInsightsPipelineConfigurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListMediaInsightsPipelineConfigurationsOutput: Swift.Equatable {
    /// The requested list of media insights pipeline configurations.
    public var mediaInsightsPipelineConfigurations: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary]?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        mediaInsightsPipelineConfigurations: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaInsightsPipelineConfigurations = mediaInsightsPipelineConfigurations
        self.nextToken = nextToken
    }
}

struct ListMediaInsightsPipelineConfigurationsOutputBody: Swift.Equatable {
    let mediaInsightsPipelineConfigurations: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListMediaInsightsPipelineConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaInsightsPipelineConfigurations = "MediaInsightsPipelineConfigurations"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaInsightsPipelineConfigurationsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary?].self, forKey: .mediaInsightsPipelineConfigurations)
        var mediaInsightsPipelineConfigurationsDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary]? = nil
        if let mediaInsightsPipelineConfigurationsContainer = mediaInsightsPipelineConfigurationsContainer {
            mediaInsightsPipelineConfigurationsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary]()
            for structure0 in mediaInsightsPipelineConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaInsightsPipelineConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaInsightsPipelineConfigurations = mediaInsightsPipelineConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMediaInsightsPipelineConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMediaPipelineKinesisVideoStreamPoolsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMediaPipelineKinesisVideoStreamPoolsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/media-pipeline-kinesis-video-stream-pools"
    }
}

public struct ListMediaPipelineKinesisVideoStreamPoolsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMediaPipelineKinesisVideoStreamPoolsInputBody: Swift.Equatable {
}

extension ListMediaPipelineKinesisVideoStreamPoolsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMediaPipelineKinesisVideoStreamPoolsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMediaPipelineKinesisVideoStreamPoolsOutputBody = try responseDecoder.decode(responseBody: data)
            self.kinesisVideoStreamPools = output.kinesisVideoStreamPools
            self.nextToken = output.nextToken
        } else {
            self.kinesisVideoStreamPools = nil
            self.nextToken = nil
        }
    }
}

public struct ListMediaPipelineKinesisVideoStreamPoolsOutput: Swift.Equatable {
    /// The list of video stream pools.
    public var kinesisVideoStreamPools: [ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary]?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        kinesisVideoStreamPools: [ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kinesisVideoStreamPools = kinesisVideoStreamPools
        self.nextToken = nextToken
    }
}

struct ListMediaPipelineKinesisVideoStreamPoolsOutputBody: Swift.Equatable {
    let kinesisVideoStreamPools: [ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary]?
    let nextToken: Swift.String?
}

extension ListMediaPipelineKinesisVideoStreamPoolsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisVideoStreamPools = "KinesisVideoStreamPools"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisVideoStreamPoolsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary?].self, forKey: .kinesisVideoStreamPools)
        var kinesisVideoStreamPoolsDecoded0:[ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary]? = nil
        if let kinesisVideoStreamPoolsContainer = kinesisVideoStreamPoolsContainer {
            kinesisVideoStreamPoolsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary]()
            for structure0 in kinesisVideoStreamPoolsContainer {
                if let structure0 = structure0 {
                    kinesisVideoStreamPoolsDecoded0?.append(structure0)
                }
            }
        }
        kinesisVideoStreamPools = kinesisVideoStreamPoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMediaPipelineKinesisVideoStreamPoolsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMediaPipelinesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMediaPipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-pipelines"
    }
}

public struct ListMediaPipelinesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMediaPipelinesInputBody: Swift.Equatable {
}

extension ListMediaPipelinesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMediaPipelinesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMediaPipelinesOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaPipelines = output.mediaPipelines
            self.nextToken = output.nextToken
        } else {
            self.mediaPipelines = nil
            self.nextToken = nil
        }
    }
}

public struct ListMediaPipelinesOutput: Swift.Equatable {
    /// The media pipeline objects in the list.
    public var mediaPipelines: [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        mediaPipelines: [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaPipelines = mediaPipelines
        self.nextToken = nextToken
    }
}

struct ListMediaPipelinesOutputBody: Swift.Equatable {
    let mediaPipelines: [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]?
    let nextToken: Swift.String?
}

extension ListMediaPipelinesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPipelines = "MediaPipelines"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelinesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary?].self, forKey: .mediaPipelines)
        var mediaPipelinesDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]? = nil
        if let mediaPipelinesContainer = mediaPipelinesContainer {
            mediaPipelinesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]()
            for structure0 in mediaPipelinesContainer {
                if let structure0 = structure0 {
                    mediaPipelinesDecoded0?.append(structure0)
                }
            }
        }
        mediaPipelines = mediaPipelinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMediaPipelinesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceARN = resourceARN else {
                let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's region, resource ID, and pipeline ID.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags associated with the specified media pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum LiveConnectorMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audiowithactivespeakervideo
        case audiowithcompositedvideo
        case sdkUnknown(Swift.String)

        public static var allCases: [LiveConnectorMuxType] {
            return [
                .audiowithactivespeakervideo,
                .audiowithcompositedvideo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audiowithactivespeakervideo: return "AudioWithActiveSpeakerVideo"
            case .audiowithcompositedvideo: return "AudioWithCompositedVideo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LiveConnectorMuxType(rawValue: rawValue) ?? LiveConnectorMuxType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioChannels = "AudioChannels"
        case audioSampleRate = "AudioSampleRate"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioChannels = self.audioChannels {
            try encodeContainer.encode(audioChannels.rawValue, forKey: .audioChannels)
        }
        if let audioSampleRate = self.audioSampleRate {
            try encodeContainer.encode(audioSampleRate, forKey: .audioSampleRate)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let audioChannelsDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AudioChannelsOption.self, forKey: .audioChannels)
        audioChannels = audioChannelsDecoded
        let audioSampleRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioSampleRate)
        audioSampleRate = audioSampleRateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LiveConnectorRTMPConfiguration(audioChannels: \(Swift.String(describing: audioChannels)), audioSampleRate: \(Swift.String(describing: audioSampleRate)), url: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The media pipeline's RTMP configuration object.
    public struct LiveConnectorRTMPConfiguration: Swift.Equatable {
        /// The audio channels set for the RTMP configuration
        public var audioChannels: ChimeSDKMediaPipelinesClientTypes.AudioChannelsOption?
        /// The audio sample rate set for the RTMP configuration. Default: 48000.
        public var audioSampleRate: Swift.String?
        /// The URL of the RTMP configuration.
        /// This member is required.
        public var url: Swift.String?

        public init(
            audioChannels: ChimeSDKMediaPipelinesClientTypes.AudioChannelsOption? = nil,
            audioSampleRate: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.audioChannels = audioChannels
            self.audioSampleRate = audioSampleRate
            self.url = url
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rtmpConfiguration = "RTMPConfiguration"
        case sinkType = "SinkType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rtmpConfiguration = self.rtmpConfiguration {
            try encodeContainer.encode(rtmpConfiguration, forKey: .rtmpConfiguration)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let rtmpConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration.self, forKey: .rtmpConfiguration)
        rtmpConfiguration = rtmpConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The media pipeline's sink configuration settings.
    public struct LiveConnectorSinkConfiguration: Swift.Equatable {
        /// The sink configuration's RTMP configuration settings.
        /// This member is required.
        public var rtmpConfiguration: ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration?
        /// The sink configuration's sink type.
        /// This member is required.
        public var sinkType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkType?

        public init(
            rtmpConfiguration: ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration? = nil,
            sinkType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkType? = nil
        )
        {
            self.rtmpConfiguration = rtmpConfiguration
            self.sinkType = sinkType
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum LiveConnectorSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rtmp
        case sdkUnknown(Swift.String)

        public static var allCases: [LiveConnectorSinkType] {
            return [
                .rtmp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rtmp: return "RTMP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LiveConnectorSinkType(rawValue: rawValue) ?? LiveConnectorSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingLiveConnectorConfiguration = "ChimeSdkMeetingLiveConnectorConfiguration"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingLiveConnectorConfiguration = self.chimeSdkMeetingLiveConnectorConfiguration {
            try encodeContainer.encode(chimeSdkMeetingLiveConnectorConfiguration, forKey: .chimeSdkMeetingLiveConnectorConfiguration)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let chimeSdkMeetingLiveConnectorConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration.self, forKey: .chimeSdkMeetingLiveConnectorConfiguration)
        chimeSdkMeetingLiveConnectorConfiguration = chimeSdkMeetingLiveConnectorConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The data source configuration object of a streaming media pipeline.
    public struct LiveConnectorSourceConfiguration: Swift.Equatable {
        /// The configuration settings of the connector pipeline.
        /// This member is required.
        public var chimeSdkMeetingLiveConnectorConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration?
        /// The source configuration's media source type.
        /// This member is required.
        public var sourceType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceType?

        public init(
            chimeSdkMeetingLiveConnectorConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration? = nil,
            sourceType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceType? = nil
        )
        {
            self.chimeSdkMeetingLiveConnectorConfiguration = chimeSdkMeetingLiveConnectorConfiguration
            self.sourceType = sourceType
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum LiveConnectorSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [LiveConnectorSourceType] {
            return [
                .chimesdkmeeting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LiveConnectorSourceType(rawValue: rawValue) ?? LiveConnectorSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipeline(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), mediaPipelineArn: \(Swift.String(describing: mediaPipelineArn)), mediaPipelineId: \(Swift.String(describing: mediaPipelineId)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A media pipeline object consisting of an ID, source type, source ARN, a sink type, a sink ARN, and a configuration object.
    public struct MediaCapturePipeline: Swift.Equatable {
        /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
        public var chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
        /// The time at which the pipeline was created, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the media capture pipeline
        public var mediaPipelineArn: Swift.String?
        /// The ID of a media pipeline.
        public var mediaPipelineId: Swift.String?
        /// ARN of the destination to which the media artifacts are saved.
        public var sinkArn: Swift.String?
        /// Destination type to which the media artifacts are saved. You must use an S3 Bucket.
        public var sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType?
        /// ARN of the source from which the media artifacts are saved.
        public var sourceArn: Swift.String?
        /// Source type from which media artifacts are saved. You must use ChimeMeeting.
        public var sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?
        /// The status of the media pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the pipeline was updated, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinkArn: Swift.String? = nil,
            sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType? = nil,
            sourceArn: Swift.String? = nil,
            sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case mediaPipelineArn = "MediaPipelineArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipelineSourceConfiguration(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), mediaPipelineArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The source configuration object of a media capture pipeline.
    public struct MediaCapturePipelineSourceConfiguration: Swift.Equatable {
        /// The meeting configuration settings in a media capture pipeline configuration object.
        /// This member is required.
        public var chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration?
        /// The media pipeline ARN in the configuration object of a media capture pipeline.
        /// This member is required.
        public var mediaPipelineArn: Swift.String?

        public init(
            chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration? = nil,
            mediaPipelineArn: Swift.String? = nil
        )
        {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.mediaPipelineArn = mediaPipelineArn
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The summary data of a media capture pipeline.
    public struct MediaCapturePipelineSummary: Swift.Equatable {
        /// The ARN of the media pipeline in the summary.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media pipeline in the summary.
        public var mediaPipelineId: Swift.String?

        public init(
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil
        )
        {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
        case sinks = "Sinks"
        case sources = "Sources"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for concatenationsink0 in sinks {
                try sinksContainer.encode(concatenationsink0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for concatenationsource0 in sources {
                try sourcesContainer.encode(concatenationsource0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.ConcatenationSource?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.ConcatenationSink?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Concatenates audio and video data from one or more data streams.
    public struct MediaConcatenationPipeline: Swift.Equatable {
        /// The time at which the concatenation pipeline was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the media pipeline that you specify in the SourceConfiguration object.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media pipeline being concatenated.
        public var mediaPipelineId: Swift.String?
        /// The data sinks of the concatenation pipeline.
        public var sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]?
        /// The data sources being concatenated.
        public var sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]?
        /// The status of the concatenation pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the concatenation pipeline was last updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil,
            sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaEncoding: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pcm
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaEncoding] {
            return [
                .pcm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pcm: return "pcm"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaEncoding(rawValue: rawValue) ?? MediaEncoding.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case elementStatuses = "ElementStatuses"
        case kinesisVideoStreamRecordingSourceRuntimeConfiguration = "KinesisVideoStreamRecordingSourceRuntimeConfiguration"
        case kinesisVideoStreamSourceRuntimeConfiguration = "KinesisVideoStreamSourceRuntimeConfiguration"
        case mediaInsightsPipelineConfigurationArn = "MediaInsightsPipelineConfigurationArn"
        case mediaInsightsRuntimeMetadata = "MediaInsightsRuntimeMetadata"
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
        case s3RecordingSinkRuntimeConfiguration = "S3RecordingSinkRuntimeConfiguration"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let elementStatuses = elementStatuses {
            var elementStatusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elementStatuses)
            for mediainsightspipelineelementstatus0 in elementStatuses {
                try elementStatusesContainer.encode(mediainsightspipelineelementstatus0)
            }
        }
        if let kinesisVideoStreamRecordingSourceRuntimeConfiguration = self.kinesisVideoStreamRecordingSourceRuntimeConfiguration {
            try encodeContainer.encode(kinesisVideoStreamRecordingSourceRuntimeConfiguration, forKey: .kinesisVideoStreamRecordingSourceRuntimeConfiguration)
        }
        if let kinesisVideoStreamSourceRuntimeConfiguration = self.kinesisVideoStreamSourceRuntimeConfiguration {
            try encodeContainer.encode(kinesisVideoStreamSourceRuntimeConfiguration, forKey: .kinesisVideoStreamSourceRuntimeConfiguration)
        }
        if let mediaInsightsPipelineConfigurationArn = self.mediaInsightsPipelineConfigurationArn {
            try encodeContainer.encode(mediaInsightsPipelineConfigurationArn, forKey: .mediaInsightsPipelineConfigurationArn)
        }
        if let mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadata {
            var mediaInsightsRuntimeMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .mediaInsightsRuntimeMetadata)
            for (dictKey0, mediaInsightsRuntimeMetadata0) in mediaInsightsRuntimeMetadata {
                try mediaInsightsRuntimeMetadataContainer.encode(mediaInsightsRuntimeMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let s3RecordingSinkRuntimeConfiguration = self.s3RecordingSinkRuntimeConfiguration {
            try encodeContainer.encode(s3RecordingSinkRuntimeConfiguration, forKey: .s3RecordingSinkRuntimeConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let mediaInsightsPipelineConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaInsightsPipelineConfigurationArn)
        mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let kinesisVideoStreamSourceRuntimeConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration.self, forKey: .kinesisVideoStreamSourceRuntimeConfiguration)
        kinesisVideoStreamSourceRuntimeConfiguration = kinesisVideoStreamSourceRuntimeConfigurationDecoded
        let mediaInsightsRuntimeMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .mediaInsightsRuntimeMetadata)
        var mediaInsightsRuntimeMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let mediaInsightsRuntimeMetadataContainer = mediaInsightsRuntimeMetadataContainer {
            mediaInsightsRuntimeMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in mediaInsightsRuntimeMetadataContainer {
                if let string0 = string0 {
                    mediaInsightsRuntimeMetadataDecoded0?[key0] = string0
                }
            }
        }
        mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadataDecoded0
        let kinesisVideoStreamRecordingSourceRuntimeConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration.self, forKey: .kinesisVideoStreamRecordingSourceRuntimeConfiguration)
        kinesisVideoStreamRecordingSourceRuntimeConfiguration = kinesisVideoStreamRecordingSourceRuntimeConfigurationDecoded
        let s3RecordingSinkRuntimeConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration.self, forKey: .s3RecordingSinkRuntimeConfiguration)
        s3RecordingSinkRuntimeConfiguration = s3RecordingSinkRuntimeConfigurationDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let elementStatusesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus?].self, forKey: .elementStatuses)
        var elementStatusesDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus]? = nil
        if let elementStatusesContainer = elementStatusesContainer {
            elementStatusesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus]()
            for structure0 in elementStatusesContainer {
                if let structure0 = structure0 {
                    elementStatusesDecoded0?.append(structure0)
                }
            }
        }
        elementStatuses = elementStatusesDecoded0
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaInsightsPipeline(createdTimestamp: \(Swift.String(describing: createdTimestamp)), elementStatuses: \(Swift.String(describing: elementStatuses)), kinesisVideoStreamRecordingSourceRuntimeConfiguration: \(Swift.String(describing: kinesisVideoStreamRecordingSourceRuntimeConfiguration)), kinesisVideoStreamSourceRuntimeConfiguration: \(Swift.String(describing: kinesisVideoStreamSourceRuntimeConfiguration)), mediaPipelineId: \(Swift.String(describing: mediaPipelineId)), s3RecordingSinkRuntimeConfiguration: \(Swift.String(describing: s3RecordingSinkRuntimeConfiguration)), status: \(Swift.String(describing: status)), mediaInsightsPipelineConfigurationArn: \"CONTENT_REDACTED\", mediaInsightsRuntimeMetadata: \"CONTENT_REDACTED\", mediaPipelineArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A media pipeline that streams call analytics data.
    public struct MediaInsightsPipeline: Swift.Equatable {
        /// The time at which the media insights pipeline was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The statuses that the elements in a media insights pipeline can have during data processing.
        public var elementStatuses: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus]?
        /// The runtime configuration settings for a Kinesis recording video stream in a media insights pipeline.
        public var kinesisVideoStreamRecordingSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration?
        /// The configuration settings for a Kinesis runtime video stream in a media insights pipeline.
        public var kinesisVideoStreamSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration?
        /// The ARN of a media insight pipeline's configuration settings.
        public var mediaInsightsPipelineConfigurationArn: Swift.String?
        /// The runtime metadata of a media insights pipeline.
        public var mediaInsightsRuntimeMetadata: [Swift.String:Swift.String]?
        /// The ARN of a media insights pipeline.
        public var mediaPipelineArn: Swift.String?
        /// The ID of a media insights pipeline.
        public var mediaPipelineId: Swift.String?
        /// The runtime configuration of the Amazon S3 bucket that stores recordings in a media insights pipeline.
        public var s3RecordingSinkRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration?
        /// The status of a media insights pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            elementStatuses: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus]? = nil,
            kinesisVideoStreamRecordingSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration? = nil,
            kinesisVideoStreamSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration? = nil,
            mediaInsightsPipelineConfigurationArn: Swift.String? = nil,
            mediaInsightsRuntimeMetadata: [Swift.String:Swift.String]? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            s3RecordingSinkRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.elementStatuses = elementStatuses
            self.kinesisVideoStreamRecordingSourceRuntimeConfiguration = kinesisVideoStreamRecordingSourceRuntimeConfiguration
            self.kinesisVideoStreamSourceRuntimeConfiguration = kinesisVideoStreamSourceRuntimeConfiguration
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadata
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.s3RecordingSinkRuntimeConfiguration = s3RecordingSinkRuntimeConfiguration
            self.status = status
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case elements = "Elements"
        case mediaInsightsPipelineConfigurationArn = "MediaInsightsPipelineConfigurationArn"
        case mediaInsightsPipelineConfigurationId = "MediaInsightsPipelineConfigurationId"
        case mediaInsightsPipelineConfigurationName = "MediaInsightsPipelineConfigurationName"
        case realTimeAlertConfiguration = "RealTimeAlertConfiguration"
        case resourceAccessRoleArn = "ResourceAccessRoleArn"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let elements = elements {
            var elementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elements)
            for mediainsightspipelineconfigurationelement0 in elements {
                try elementsContainer.encode(mediainsightspipelineconfigurationelement0)
            }
        }
        if let mediaInsightsPipelineConfigurationArn = self.mediaInsightsPipelineConfigurationArn {
            try encodeContainer.encode(mediaInsightsPipelineConfigurationArn, forKey: .mediaInsightsPipelineConfigurationArn)
        }
        if let mediaInsightsPipelineConfigurationId = self.mediaInsightsPipelineConfigurationId {
            try encodeContainer.encode(mediaInsightsPipelineConfigurationId, forKey: .mediaInsightsPipelineConfigurationId)
        }
        if let mediaInsightsPipelineConfigurationName = self.mediaInsightsPipelineConfigurationName {
            try encodeContainer.encode(mediaInsightsPipelineConfigurationName, forKey: .mediaInsightsPipelineConfigurationName)
        }
        if let realTimeAlertConfiguration = self.realTimeAlertConfiguration {
            try encodeContainer.encode(realTimeAlertConfiguration, forKey: .realTimeAlertConfiguration)
        }
        if let resourceAccessRoleArn = self.resourceAccessRoleArn {
            try encodeContainer.encode(resourceAccessRoleArn, forKey: .resourceAccessRoleArn)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaInsightsPipelineConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaInsightsPipelineConfigurationName)
        mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationNameDecoded
        let mediaInsightsPipelineConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaInsightsPipelineConfigurationArn)
        mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArnDecoded
        let resourceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceAccessRoleArn)
        resourceAccessRoleArn = resourceAccessRoleArnDecoded
        let realTimeAlertConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration.self, forKey: .realTimeAlertConfiguration)
        realTimeAlertConfiguration = realTimeAlertConfigurationDecoded
        let elementsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement?].self, forKey: .elements)
        var elementsDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]? = nil
        if let elementsContainer = elementsContainer {
            elementsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]()
            for structure0 in elementsContainer {
                if let structure0 = structure0 {
                    elementsDecoded0?.append(structure0)
                }
            }
        }
        elements = elementsDecoded0
        let mediaInsightsPipelineConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaInsightsPipelineConfigurationId)
        mediaInsightsPipelineConfigurationId = mediaInsightsPipelineConfigurationIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaInsightsPipelineConfiguration(createdTimestamp: \(Swift.String(describing: createdTimestamp)), elements: \(Swift.String(describing: elements)), mediaInsightsPipelineConfigurationId: \(Swift.String(describing: mediaInsightsPipelineConfigurationId)), mediaInsightsPipelineConfigurationName: \(Swift.String(describing: mediaInsightsPipelineConfigurationName)), realTimeAlertConfiguration: \(Swift.String(describing: realTimeAlertConfiguration)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), mediaInsightsPipelineConfigurationArn: \"CONTENT_REDACTED\", resourceAccessRoleArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the configuration settings for a media insights pipeline.
    public struct MediaInsightsPipelineConfiguration: Swift.Equatable {
        /// The time at which the configuration was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The elements in the configuration.
        public var elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]?
        /// The ARN of the configuration.
        public var mediaInsightsPipelineConfigurationArn: Swift.String?
        /// The ID of the configuration.
        public var mediaInsightsPipelineConfigurationId: Swift.String?
        /// The name of the configuration.
        public var mediaInsightsPipelineConfigurationName: Swift.String?
        /// Lists the rules that trigger a real-time alert.
        public var realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration?
        /// The ARN of the role used by the service to access Amazon Web Services resources.
        public var resourceAccessRoleArn: Swift.String?
        /// The time at which the configuration was last updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]? = nil,
            mediaInsightsPipelineConfigurationArn: Swift.String? = nil,
            mediaInsightsPipelineConfigurationId: Swift.String? = nil,
            mediaInsightsPipelineConfigurationName: Swift.String? = nil,
            realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration? = nil,
            resourceAccessRoleArn: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.elements = elements
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsPipelineConfigurationId = mediaInsightsPipelineConfigurationId
            self.mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationName
            self.realTimeAlertConfiguration = realTimeAlertConfiguration
            self.resourceAccessRoleArn = resourceAccessRoleArn
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonTranscribeCallAnalyticsProcessorConfiguration = "AmazonTranscribeCallAnalyticsProcessorConfiguration"
        case amazonTranscribeProcessorConfiguration = "AmazonTranscribeProcessorConfiguration"
        case kinesisDataStreamSinkConfiguration = "KinesisDataStreamSinkConfiguration"
        case lambdaFunctionSinkConfiguration = "LambdaFunctionSinkConfiguration"
        case s3RecordingSinkConfiguration = "S3RecordingSinkConfiguration"
        case snsTopicSinkConfiguration = "SnsTopicSinkConfiguration"
        case sqsQueueSinkConfiguration = "SqsQueueSinkConfiguration"
        case type = "Type"
        case voiceAnalyticsProcessorConfiguration = "VoiceAnalyticsProcessorConfiguration"
        case voiceEnhancementSinkConfiguration = "VoiceEnhancementSinkConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonTranscribeCallAnalyticsProcessorConfiguration = self.amazonTranscribeCallAnalyticsProcessorConfiguration {
            try encodeContainer.encode(amazonTranscribeCallAnalyticsProcessorConfiguration, forKey: .amazonTranscribeCallAnalyticsProcessorConfiguration)
        }
        if let amazonTranscribeProcessorConfiguration = self.amazonTranscribeProcessorConfiguration {
            try encodeContainer.encode(amazonTranscribeProcessorConfiguration, forKey: .amazonTranscribeProcessorConfiguration)
        }
        if let kinesisDataStreamSinkConfiguration = self.kinesisDataStreamSinkConfiguration {
            try encodeContainer.encode(kinesisDataStreamSinkConfiguration, forKey: .kinesisDataStreamSinkConfiguration)
        }
        if let lambdaFunctionSinkConfiguration = self.lambdaFunctionSinkConfiguration {
            try encodeContainer.encode(lambdaFunctionSinkConfiguration, forKey: .lambdaFunctionSinkConfiguration)
        }
        if let s3RecordingSinkConfiguration = self.s3RecordingSinkConfiguration {
            try encodeContainer.encode(s3RecordingSinkConfiguration, forKey: .s3RecordingSinkConfiguration)
        }
        if let snsTopicSinkConfiguration = self.snsTopicSinkConfiguration {
            try encodeContainer.encode(snsTopicSinkConfiguration, forKey: .snsTopicSinkConfiguration)
        }
        if let sqsQueueSinkConfiguration = self.sqsQueueSinkConfiguration {
            try encodeContainer.encode(sqsQueueSinkConfiguration, forKey: .sqsQueueSinkConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let voiceAnalyticsProcessorConfiguration = self.voiceAnalyticsProcessorConfiguration {
            try encodeContainer.encode(voiceAnalyticsProcessorConfiguration, forKey: .voiceAnalyticsProcessorConfiguration)
        }
        if let voiceEnhancementSinkConfiguration = self.voiceEnhancementSinkConfiguration {
            try encodeContainer.encode(voiceEnhancementSinkConfiguration, forKey: .voiceEnhancementSinkConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType.self, forKey: .type)
        type = typeDecoded
        let amazonTranscribeCallAnalyticsProcessorConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration.self, forKey: .amazonTranscribeCallAnalyticsProcessorConfiguration)
        amazonTranscribeCallAnalyticsProcessorConfiguration = amazonTranscribeCallAnalyticsProcessorConfigurationDecoded
        let amazonTranscribeProcessorConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration.self, forKey: .amazonTranscribeProcessorConfiguration)
        amazonTranscribeProcessorConfiguration = amazonTranscribeProcessorConfigurationDecoded
        let kinesisDataStreamSinkConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration.self, forKey: .kinesisDataStreamSinkConfiguration)
        kinesisDataStreamSinkConfiguration = kinesisDataStreamSinkConfigurationDecoded
        let s3RecordingSinkConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration.self, forKey: .s3RecordingSinkConfiguration)
        s3RecordingSinkConfiguration = s3RecordingSinkConfigurationDecoded
        let voiceAnalyticsProcessorConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration.self, forKey: .voiceAnalyticsProcessorConfiguration)
        voiceAnalyticsProcessorConfiguration = voiceAnalyticsProcessorConfigurationDecoded
        let lambdaFunctionSinkConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration.self, forKey: .lambdaFunctionSinkConfiguration)
        lambdaFunctionSinkConfiguration = lambdaFunctionSinkConfigurationDecoded
        let sqsQueueSinkConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration.self, forKey: .sqsQueueSinkConfiguration)
        sqsQueueSinkConfiguration = sqsQueueSinkConfigurationDecoded
        let snsTopicSinkConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration.self, forKey: .snsTopicSinkConfiguration)
        snsTopicSinkConfiguration = snsTopicSinkConfigurationDecoded
        let voiceEnhancementSinkConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration.self, forKey: .voiceEnhancementSinkConfiguration)
        voiceEnhancementSinkConfiguration = voiceEnhancementSinkConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// An element in a media insights pipeline configuration.
    public struct MediaInsightsPipelineConfigurationElement: Swift.Equatable {
        /// The analytics configuration settings for transcribing audio in a media insights pipeline configuration element.
        public var amazonTranscribeCallAnalyticsProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration?
        /// The transcription processor configuration settings in a media insights pipeline configuration element.
        public var amazonTranscribeProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration?
        /// The configuration settings for the Kinesis Data Stream Sink in a media insights pipeline configuration element.
        public var kinesisDataStreamSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration?
        /// The configuration settings for the Amazon Web Services Lambda sink in a media insights pipeline configuration element.
        public var lambdaFunctionSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration?
        /// The configuration settings for the Amazon S3 recording bucket in a media insights pipeline configuration element.
        public var s3RecordingSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration?
        /// The configuration settings for an SNS topic sink in a media insights pipeline configuration element.
        public var snsTopicSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration?
        /// The configuration settings for an SQS queue sink in a media insights pipeline configuration element.
        public var sqsQueueSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration?
        /// The element type.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType?
        /// The voice analytics configuration settings in a media insights pipeline configuration element.
        public var voiceAnalyticsProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration?
        /// The configuration settings for voice enhancement sink in a media insights pipeline configuration element.
        public var voiceEnhancementSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration?

        public init(
            amazonTranscribeCallAnalyticsProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration? = nil,
            amazonTranscribeProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration? = nil,
            kinesisDataStreamSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration? = nil,
            lambdaFunctionSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration? = nil,
            s3RecordingSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration? = nil,
            snsTopicSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration? = nil,
            sqsQueueSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType? = nil,
            voiceAnalyticsProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration? = nil,
            voiceEnhancementSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration? = nil
        )
        {
            self.amazonTranscribeCallAnalyticsProcessorConfiguration = amazonTranscribeCallAnalyticsProcessorConfiguration
            self.amazonTranscribeProcessorConfiguration = amazonTranscribeProcessorConfiguration
            self.kinesisDataStreamSinkConfiguration = kinesisDataStreamSinkConfiguration
            self.lambdaFunctionSinkConfiguration = lambdaFunctionSinkConfiguration
            self.s3RecordingSinkConfiguration = s3RecordingSinkConfiguration
            self.snsTopicSinkConfiguration = snsTopicSinkConfiguration
            self.sqsQueueSinkConfiguration = sqsQueueSinkConfiguration
            self.type = type
            self.voiceAnalyticsProcessorConfiguration = voiceAnalyticsProcessorConfiguration
            self.voiceEnhancementSinkConfiguration = voiceEnhancementSinkConfiguration
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaInsightsPipelineConfigurationElementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonTranscribeCallAnalyticsProcessor
        case amazonTranscribeProcessor
        case kinesisDataStreamSink
        case lambdaFunctionSink
        case s3RecordingSink
        case snsTopicSink
        case sqsQueueSink
        case voiceAnalyticsProcessor
        case voiceEnhancementSink
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaInsightsPipelineConfigurationElementType] {
            return [
                .amazonTranscribeCallAnalyticsProcessor,
                .amazonTranscribeProcessor,
                .kinesisDataStreamSink,
                .lambdaFunctionSink,
                .s3RecordingSink,
                .snsTopicSink,
                .sqsQueueSink,
                .voiceAnalyticsProcessor,
                .voiceEnhancementSink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonTranscribeCallAnalyticsProcessor: return "AmazonTranscribeCallAnalyticsProcessor"
            case .amazonTranscribeProcessor: return "AmazonTranscribeProcessor"
            case .kinesisDataStreamSink: return "KinesisDataStreamSink"
            case .lambdaFunctionSink: return "LambdaFunctionSink"
            case .s3RecordingSink: return "S3RecordingSink"
            case .snsTopicSink: return "SnsTopicSink"
            case .sqsQueueSink: return "SqsQueueSink"
            case .voiceAnalyticsProcessor: return "VoiceAnalyticsProcessor"
            case .voiceEnhancementSink: return "VoiceEnhancementSink"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaInsightsPipelineConfigurationElementType(rawValue: rawValue) ?? MediaInsightsPipelineConfigurationElementType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaInsightsPipelineConfigurationArn = "MediaInsightsPipelineConfigurationArn"
        case mediaInsightsPipelineConfigurationId = "MediaInsightsPipelineConfigurationId"
        case mediaInsightsPipelineConfigurationName = "MediaInsightsPipelineConfigurationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaInsightsPipelineConfigurationArn = self.mediaInsightsPipelineConfigurationArn {
            try encodeContainer.encode(mediaInsightsPipelineConfigurationArn, forKey: .mediaInsightsPipelineConfigurationArn)
        }
        if let mediaInsightsPipelineConfigurationId = self.mediaInsightsPipelineConfigurationId {
            try encodeContainer.encode(mediaInsightsPipelineConfigurationId, forKey: .mediaInsightsPipelineConfigurationId)
        }
        if let mediaInsightsPipelineConfigurationName = self.mediaInsightsPipelineConfigurationName {
            try encodeContainer.encode(mediaInsightsPipelineConfigurationName, forKey: .mediaInsightsPipelineConfigurationName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaInsightsPipelineConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaInsightsPipelineConfigurationName)
        mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationNameDecoded
        let mediaInsightsPipelineConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaInsightsPipelineConfigurationId)
        mediaInsightsPipelineConfigurationId = mediaInsightsPipelineConfigurationIdDecoded
        let mediaInsightsPipelineConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaInsightsPipelineConfigurationArn)
        mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArnDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaInsightsPipelineConfigurationSummary(mediaInsightsPipelineConfigurationId: \(Swift.String(describing: mediaInsightsPipelineConfigurationId)), mediaInsightsPipelineConfigurationName: \(Swift.String(describing: mediaInsightsPipelineConfigurationName)), mediaInsightsPipelineConfigurationArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A summary of the media insights pipeline configuration.
    public struct MediaInsightsPipelineConfigurationSummary: Swift.Equatable {
        /// The ARN of the media insights pipeline configuration.
        public var mediaInsightsPipelineConfigurationArn: Swift.String?
        /// The ID of the media insights pipeline configuration.
        public var mediaInsightsPipelineConfigurationId: Swift.String?
        /// The name of the media insights pipeline configuration.
        public var mediaInsightsPipelineConfigurationName: Swift.String?

        public init(
            mediaInsightsPipelineConfigurationArn: Swift.String? = nil,
            mediaInsightsPipelineConfigurationId: Swift.String? = nil,
            mediaInsightsPipelineConfigurationName: Swift.String? = nil
        )
        {
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsPipelineConfigurationId = mediaInsightsPipelineConfigurationId
            self.mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationName
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineElementStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The status of the pipeline element.
    public struct MediaInsightsPipelineElementStatus: Swift.Equatable {
        /// The element's status.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineElementStatus?
        /// The type of status.
        public var type: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType?

        public init(
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineElementStatus? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType? = nil
        )
        {
            self.status = status
            self.type = type
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
        case sinks = "Sinks"
        case sources = "Sources"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for liveconnectorsinkconfiguration0 in sinks {
                try sinksContainer.encode(liveconnectorsinkconfiguration0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for liveconnectorsourceconfiguration0 in sources {
                try sourcesContainer.encode(liveconnectorsourceconfiguration0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The connector pipeline.
    public struct MediaLiveConnectorPipeline: Swift.Equatable {
        /// The time at which the connector pipeline was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The connector pipeline's ARN.
        public var mediaPipelineArn: Swift.String?
        /// The connector pipeline's ID.
        public var mediaPipelineId: Swift.String?
        /// The connector pipeline's data sinks.
        public var sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]?
        /// The connector pipeline's data sources.
        public var sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]?
        /// The connector pipeline's status.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the connector pipeline was last updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil,
            sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaPipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
        case mediaConcatenationPipeline = "MediaConcatenationPipeline"
        case mediaInsightsPipeline = "MediaInsightsPipeline"
        case mediaLiveConnectorPipeline = "MediaLiveConnectorPipeline"
        case mediaStreamPipeline = "MediaStreamPipeline"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaCapturePipeline = self.mediaCapturePipeline {
            try encodeContainer.encode(mediaCapturePipeline, forKey: .mediaCapturePipeline)
        }
        if let mediaConcatenationPipeline = self.mediaConcatenationPipeline {
            try encodeContainer.encode(mediaConcatenationPipeline, forKey: .mediaConcatenationPipeline)
        }
        if let mediaInsightsPipeline = self.mediaInsightsPipeline {
            try encodeContainer.encode(mediaInsightsPipeline, forKey: .mediaInsightsPipeline)
        }
        if let mediaLiveConnectorPipeline = self.mediaLiveConnectorPipeline {
            try encodeContainer.encode(mediaLiveConnectorPipeline, forKey: .mediaLiveConnectorPipeline)
        }
        if let mediaStreamPipeline = self.mediaStreamPipeline {
            try encodeContainer.encode(mediaStreamPipeline, forKey: .mediaStreamPipeline)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
        let mediaLiveConnectorPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline.self, forKey: .mediaLiveConnectorPipeline)
        mediaLiveConnectorPipeline = mediaLiveConnectorPipelineDecoded
        let mediaConcatenationPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline.self, forKey: .mediaConcatenationPipeline)
        mediaConcatenationPipeline = mediaConcatenationPipelineDecoded
        let mediaInsightsPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline.self, forKey: .mediaInsightsPipeline)
        mediaInsightsPipeline = mediaInsightsPipelineDecoded
        let mediaStreamPipelineDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline.self, forKey: .mediaStreamPipeline)
        mediaStreamPipeline = mediaStreamPipelineDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A pipeline consisting of a media capture, media concatenation, or live-streaming pipeline.
    public struct MediaPipeline: Swift.Equatable {
        /// A pipeline that enables users to capture audio and video.
        public var mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?
        /// The media concatenation pipeline in a media pipeline.
        public var mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline?
        /// The media insights pipeline of a media pipeline.
        public var mediaInsightsPipeline: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline?
        /// The connector pipeline of the media pipeline.
        public var mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline?
        /// Designates a media pipeline as a media stream pipeline.
        public var mediaStreamPipeline: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline?

        public init(
            mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline? = nil,
            mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline? = nil,
            mediaInsightsPipeline: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline? = nil,
            mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline? = nil,
            mediaStreamPipeline: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline? = nil
        )
        {
            self.mediaCapturePipeline = mediaCapturePipeline
            self.mediaConcatenationPipeline = mediaConcatenationPipeline
            self.mediaInsightsPipeline = mediaInsightsPipeline
            self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
            self.mediaStreamPipeline = mediaStreamPipeline
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaPipelineElementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case notstarted
        case notsupported
        case paused
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineElementStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .notstarted,
                .notsupported,
                .paused,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .notstarted: return "NotStarted"
            case .notsupported: return "NotSupported"
            case .paused: return "Paused"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineElementStatus(rawValue: rawValue) ?? MediaPipelineElementStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaPipelineSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSinkType] {
            return [
                .s3bucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSinkType(rawValue: rawValue) ?? MediaPipelineSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaPipelineSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSourceType] {
            return [
                .chimesdkmeeting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSourceType(rawValue: rawValue) ?? MediaPipelineSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaPipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case notstarted
        case paused
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .notstarted,
                .paused,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .notstarted: return "NotStarted"
            case .paused: return "Paused"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineStatus(rawValue: rawValue) ?? MediaPipelineStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaPipelineStatusUpdate: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pause
        case resume
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineStatusUpdate] {
            return [
                .pause,
                .resume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pause: return "Pause"
            case .resume: return "Resume"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineStatusUpdate(rawValue: rawValue) ?? MediaPipelineStatusUpdate.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The summary of the media pipeline.
    public struct MediaPipelineSummary: Swift.Equatable {
        /// The ARN of the media pipeline in the summary.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media pipeline in the summary.
        public var mediaPipelineId: Swift.String?

        public init(
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil
        )
        {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaPipelineTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case notstarted
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineTaskStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .notstarted,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .notstarted: return "NotStarted"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineTaskStatus(rawValue: rawValue) ?? MediaPipelineTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
        case sinks = "Sinks"
        case sources = "Sources"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinks = sinks {
            var sinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sinks)
            for mediastreamsink0 in sinks {
                try sinksContainer.encode(mediastreamsink0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for mediastreamsource0 in sources {
                try sourcesContainer.encode(mediastreamsource0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaStreamSource?].self, forKey: .sources)
        var sourcesDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let sinksContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaStreamSink?].self, forKey: .sinks)
        var sinksDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]? = nil
        if let sinksContainer = sinksContainer {
            sinksDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]()
            for structure0 in sinksContainer {
                if let structure0 = structure0 {
                    sinksDecoded0?.append(structure0)
                }
            }
        }
        sinks = sinksDecoded0
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Structure that contains the settings for a media stream pipeline.
    public struct MediaStreamPipeline: Swift.Equatable {
        /// The time at which the media stream pipeline was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the media stream pipeline.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media stream pipeline
        public var mediaPipelineId: Swift.String?
        /// The media stream pipeline's data sinks.
        public var sinks: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]?
        /// The media stream pipeline's data sources.
        public var sources: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]?
        /// The status of the media stream pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the media stream pipeline was updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinks: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]? = nil,
            sources: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaStreamPipelineSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kinesisvideostreampool
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStreamPipelineSinkType] {
            return [
                .kinesisvideostreampool,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kinesisvideostreampool: return "KinesisVideoStreamPool"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaStreamPipelineSinkType(rawValue: rawValue) ?? MediaStreamPipelineSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamSink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaStreamType = "MediaStreamType"
        case reservedStreamCapacity = "ReservedStreamCapacity"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaStreamType = self.mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let reservedStreamCapacity = self.reservedStreamCapacity {
            try encodeContainer.encode(reservedStreamCapacity, forKey: .reservedStreamCapacity)
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaStreamPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let reservedStreamCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedStreamCapacity)
        reservedStreamCapacity = reservedStreamCapacityDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamSink: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaStreamSink(mediaStreamType: \(Swift.String(describing: mediaStreamType)), reservedStreamCapacity: \(Swift.String(describing: reservedStreamCapacity)), sinkType: \(Swift.String(describing: sinkType)), sinkArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Structure that contains the settings for a media stream sink.
    public struct MediaStreamSink: Swift.Equatable {
        /// The media stream sink's media stream type.
        /// This member is required.
        public var mediaStreamType: ChimeSDKMediaPipelinesClientTypes.MediaStreamType?
        /// Specifies the number of streams that the sink can accept.
        /// This member is required.
        public var reservedStreamCapacity: Swift.Int?
        /// The ARN of the media stream sink.
        /// This member is required.
        public var sinkArn: Swift.String?
        /// The media stream sink's type.
        /// This member is required.
        public var sinkType: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipelineSinkType?

        public init(
            mediaStreamType: ChimeSDKMediaPipelinesClientTypes.MediaStreamType? = nil,
            reservedStreamCapacity: Swift.Int? = nil,
            sinkArn: Swift.String? = nil,
            sinkType: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipelineSinkType? = nil
        )
        {
            self.mediaStreamType = mediaStreamType
            self.reservedStreamCapacity = reservedStreamCapacity
            self.sinkArn = sinkArn
            self.sinkType = sinkType
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaStreamSource(sourceType: \(Swift.String(describing: sourceType)), sourceArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Structure that contains the settings for media stream sources.
    public struct MediaStreamSource: Swift.Equatable {
        /// The ARN of the media stream source.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// The type of media stream source.
        /// This member is required.
        public var sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?

        public init(
            sourceArn: Swift.String? = nil,
            sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType? = nil
        )
        {
            self.sourceArn = sourceArn
            self.sourceType = sourceType
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum MediaStreamType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case individualaudio
        case mixedaudio
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStreamType] {
            return [
                .individualaudio,
                .mixedaudio,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .individualaudio: return "IndividualAudio"
            case .mixedaudio: return "MixedAudio"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaStreamType(rawValue: rawValue) ?? MediaStreamType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object for an event concatenation pipeline.
    public struct MeetingEventsConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum PartialResultsStability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [PartialResultsStability] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .medium: return "medium"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PartialResultsStability(rawValue: rawValue) ?? PartialResultsStability.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ParticipantRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRole] {
            return [
                .agent,
                .customer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantRole(rawValue: rawValue) ?? ParticipantRole.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentRedactionOutput = "ContentRedactionOutput"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case outputEncryptionKMSKeyId = "OutputEncryptionKMSKeyId"
        case outputLocation = "OutputLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentRedactionOutput = self.contentRedactionOutput {
            try encodeContainer.encode(contentRedactionOutput.rawValue, forKey: .contentRedactionOutput)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let outputEncryptionKMSKeyId = self.outputEncryptionKMSKeyId {
            try encodeContainer.encode(outputEncryptionKMSKeyId, forKey: .outputEncryptionKMSKeyId)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let contentRedactionOutputDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ContentRedactionOutput.self, forKey: .contentRedactionOutput)
        contentRedactionOutput = contentRedactionOutputDecoded
        let outputEncryptionKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputEncryptionKMSKeyId)
        outputEncryptionKMSKeyId = outputEncryptionKMSKeyIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Allows you to specify additional settings for your Call Analytics post-call request, including output locations for your redacted transcript, which IAM role to use, and which encryption key to use. DataAccessRoleArn and OutputLocation are required fields. PostCallAnalyticsSettings provides the same insights as a Call Analytics post-call transcription. For more information, refer to [Post-call analytics with real-time transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-post-call.html) in the Amazon Transcribe Developer Guide.
    public struct PostCallAnalyticsSettings: Swift.Equatable {
        /// The content redaction output settings for a post-call analysis task.
        public var contentRedactionOutput: ChimeSDKMediaPipelinesClientTypes.ContentRedactionOutput?
        /// The ARN of the role used by Amazon Web Services Transcribe to upload your post call analysis. For more information, see [Post-call analytics with real-time transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-post-call.html) in the Amazon Transcribe Developer Guide.
        /// This member is required.
        public var dataAccessRoleArn: Swift.String?
        /// The ID of the KMS (Key Management Service) key used to encrypt the output.
        public var outputEncryptionKMSKeyId: Swift.String?
        /// The URL of the Amazon S3 bucket that contains the post-call data.
        /// This member is required.
        public var outputLocation: Swift.String?

        public init(
            contentRedactionOutput: ChimeSDKMediaPipelinesClientTypes.ContentRedactionOutput? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            outputEncryptionKMSKeyId: Swift.String? = nil,
            outputLocation: Swift.String? = nil
        )
        {
            self.contentRedactionOutput = contentRedactionOutput
            self.dataAccessRoleArn = dataAccessRoleArn
            self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
            self.outputLocation = outputLocation
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case presenterPosition = "PresenterPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let presenterPosition = self.presenterPosition {
            try encodeContainer.encode(presenterPosition.rawValue, forKey: .presenterPosition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presenterPositionDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.PresenterPosition.self, forKey: .presenterPosition)
        presenterPosition = presenterPositionDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Defines the configuration for a presenter-only video tile.
    public struct PresenterOnlyConfiguration: Swift.Equatable {
        /// Defines the position of the presenter video tile. Default: TopRight.
        public var presenterPosition: ChimeSDKMediaPipelinesClientTypes.PresenterPosition?

        public init(
            presenterPosition: ChimeSDKMediaPipelinesClientTypes.PresenterPosition? = nil
        )
        {
            self.presenterPosition = presenterPosition
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum PresenterPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottomleft
        case bottomright
        case topleft
        case topright
        case sdkUnknown(Swift.String)

        public static var allCases: [PresenterPosition] {
            return [
                .bottomleft,
                .bottomright,
                .topleft,
                .topright,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottomleft: return "BottomLeft"
            case .bottomright: return "BottomRight"
            case .topleft: return "TopLeft"
            case .topright: return "TopRight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PresenterPosition(rawValue: rawValue) ?? PresenterPosition.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disabled != false {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for realtimealertrule0 in rules {
                try rulesContainer.encode(realtimealertrule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled) ?? false
        disabled = disabledDecoded
        let rulesContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule?].self, forKey: .rules)
        var rulesDecoded0:[ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the configuration settings for real-time alerts.
    public struct RealTimeAlertConfiguration: Swift.Equatable {
        /// Turns off real-time alerts.
        public var disabled: Swift.Bool
        /// The rules in the alert. Rules specify the words or phrases that you want to be notified about.
        public var rules: [ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule]?

        public init(
            disabled: Swift.Bool = false,
            rules: [ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule]? = nil
        )
        {
            self.disabled = disabled
            self.rules = rules
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issueDetectionConfiguration = "IssueDetectionConfiguration"
        case keywordMatchConfiguration = "KeywordMatchConfiguration"
        case sentimentConfiguration = "SentimentConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issueDetectionConfiguration = self.issueDetectionConfiguration {
            try encodeContainer.encode(issueDetectionConfiguration, forKey: .issueDetectionConfiguration)
        }
        if let keywordMatchConfiguration = self.keywordMatchConfiguration {
            try encodeContainer.encode(keywordMatchConfiguration, forKey: .keywordMatchConfiguration)
        }
        if let sentimentConfiguration = self.sentimentConfiguration {
            try encodeContainer.encode(sentimentConfiguration, forKey: .sentimentConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRuleType.self, forKey: .type)
        type = typeDecoded
        let keywordMatchConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration.self, forKey: .keywordMatchConfiguration)
        keywordMatchConfiguration = keywordMatchConfigurationDecoded
        let sentimentConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration.self, forKey: .sentimentConfiguration)
        sentimentConfiguration = sentimentConfigurationDecoded
        let issueDetectionConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration.self, forKey: .issueDetectionConfiguration)
        issueDetectionConfiguration = issueDetectionConfigurationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Specifies the words or phrases that trigger an alert.
    public struct RealTimeAlertRule: Swift.Equatable {
        /// Specifies the issue detection settings for a real-time alert rule.
        public var issueDetectionConfiguration: ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration?
        /// Specifies the settings for matching the keywords in a real-time alert rule.
        public var keywordMatchConfiguration: ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration?
        /// Specifies the settings for predicting sentiment in a real-time alert rule.
        public var sentimentConfiguration: ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration?
        /// The type of alert rule.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRuleType?

        public init(
            issueDetectionConfiguration: ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration? = nil,
            keywordMatchConfiguration: ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration? = nil,
            sentimentConfiguration: ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRuleType? = nil
        )
        {
            self.issueDetectionConfiguration = issueDetectionConfiguration
            self.keywordMatchConfiguration = keywordMatchConfiguration
            self.sentimentConfiguration = sentimentConfiguration
            self.type = type
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum RealTimeAlertRuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case issuedetection
        case keywordmatch
        case sentiment
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeAlertRuleType] {
            return [
                .issuedetection,
                .keywordmatch,
                .sentiment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .issuedetection: return "IssueDetection"
            case .keywordmatch: return "KeywordMatch"
            case .sentiment: return "Sentiment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RealTimeAlertRuleType(rawValue: rawValue) ?? RealTimeAlertRuleType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum RecordingFileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case opus
        case wav
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingFileFormat] {
            return [
                .opus,
                .wav,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .opus: return "Opus"
            case .wav: return "Wav"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordingFileFormat(rawValue: rawValue) ?? RecordingFileFormat.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamArn = self.streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that holds the settings for recording media.
    public struct RecordingStreamConfiguration: Swift.Equatable {
        /// The ARN of the recording stream.
        public var streamArn: Swift.String?

        public init(
            streamArn: Swift.String? = nil
        )
        {
            self.streamArn = streamArn
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum ResolutionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fhd
        case hd
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionOption] {
            return [
                .fhd,
                .hd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fhd: return "FHD"
            case .hd: return "HD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolutionOption(rawValue: rawValue) ?? ResolutionOption.sdkUnknown(rawValue)
        }
    }
}

extension ResourceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3BucketSinkConfiguration(destination: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration settings for the S3 bucket.
    public struct S3BucketSinkConfiguration: Swift.Equatable {
        /// The destination URL of the S3 bucket.
        /// This member is required.
        public var destination: Swift.String?

        public init(
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case recordingFileFormat = "RecordingFileFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let recordingFileFormat = self.recordingFileFormat {
            try encodeContainer.encode(recordingFileFormat.rawValue, forKey: .recordingFileFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let recordingFileFormatDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat.self, forKey: .recordingFileFormat)
        recordingFileFormat = recordingFileFormatDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3RecordingSinkConfiguration(recordingFileFormat: \(Swift.String(describing: recordingFileFormat)), destination: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The structure that holds the settings for transmitting media to the Amazon S3 bucket. These values are used as defaults if S3RecordingSinkRuntimeConfiguration is not specified.
    public struct S3RecordingSinkConfiguration: Swift.Equatable {
        /// The default URI of the Amazon S3 bucket used as the recording sink.
        public var destination: Swift.String?
        /// The default file format for the media files sent to the Amazon S3 bucket.
        public var recordingFileFormat: ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat?

        public init(
            destination: Swift.String? = nil,
            recordingFileFormat: ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat? = nil
        )
        {
            self.destination = destination
            self.recordingFileFormat = recordingFileFormat
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case recordingFileFormat = "RecordingFileFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let recordingFileFormat = self.recordingFileFormat {
            try encodeContainer.encode(recordingFileFormat.rawValue, forKey: .recordingFileFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let recordingFileFormatDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat.self, forKey: .recordingFileFormat)
        recordingFileFormat = recordingFileFormatDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3RecordingSinkRuntimeConfiguration(recordingFileFormat: \(Swift.String(describing: recordingFileFormat)), destination: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that holds the settings for transmitting media files to the Amazon S3 bucket. If specified, the settings in this structure override any settings in S3RecordingSinkConfiguration.
    public struct S3RecordingSinkRuntimeConfiguration: Swift.Equatable {
        /// The URI of the S3 bucket used as the sink.
        /// This member is required.
        public var destination: Swift.String?
        /// The file format for the media files sent to the Amazon S3 bucket.
        /// This member is required.
        public var recordingFileFormat: ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat?

        public init(
            destination: Swift.String? = nil,
            recordingFileFormat: ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat? = nil
        )
        {
            self.destination = destination
            self.recordingFileFormat = recordingFileFormat
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeIds = "AttendeeIds"
        case externalUserIds = "ExternalUserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeIds = attendeeIds {
            var attendeeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendeeIds)
            for guidstring0 in attendeeIds {
                try attendeeIdsContainer.encode(guidstring0)
            }
        }
        if let externalUserIds = externalUserIds {
            var externalUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalUserIds)
            for externaluseridtype0 in externalUserIds {
                try externalUserIdsContainer.encode(externaluseridtype0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attendeeIds)
        var attendeeIdsDecoded0:[Swift.String]? = nil
        if let attendeeIdsContainer = attendeeIdsContainer {
            attendeeIdsDecoded0 = [Swift.String]()
            for string0 in attendeeIdsContainer {
                if let string0 = string0 {
                    attendeeIdsDecoded0?.append(string0)
                }
            }
        }
        attendeeIds = attendeeIdsDecoded0
        let externalUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalUserIds)
        var externalUserIdsDecoded0:[Swift.String]? = nil
        if let externalUserIdsContainer = externalUserIdsContainer {
            externalUserIdsDecoded0 = [Swift.String]()
            for string0 in externalUserIdsContainer {
                if let string0 = string0 {
                    externalUserIdsDecoded0?.append(string0)
                }
            }
        }
        externalUserIds = externalUserIdsDecoded0
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The video streams for a specified media pipeline. The total number of video streams can't exceed 25.
    public struct SelectedVideoStreams: Swift.Equatable {
        /// The attendee IDs of the streams selected for a media pipeline.
        public var attendeeIds: [Swift.String]?
        /// The external user IDs of the streams selected for a media pipeline.
        public var externalUserIds: [Swift.String]?

        public init(
            attendeeIds: [Swift.String]? = nil,
            externalUserIds: [Swift.String]? = nil
        )
        {
            self.attendeeIds = attendeeIds
            self.externalUserIds = externalUserIds
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleName = "RuleName"
        case sentimentType = "SentimentType"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let sentimentType = self.sentimentType {
            try encodeContainer.encode(sentimentType.rawValue, forKey: .sentimentType)
        }
        if timePeriod != 0 {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let sentimentTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SentimentType.self, forKey: .sentimentType)
        sentimentType = sentimentTypeDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timePeriod) ?? 0
        timePeriod = timePeriodDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A structure that contains the configuration settings for a sentiment analysis task.
    public struct SentimentConfiguration: Swift.Equatable {
        /// The name of the rule in the sentiment configuration.
        /// This member is required.
        public var ruleName: Swift.String?
        /// The type of sentiment, POSITIVE, NEGATIVE, or NEUTRAL.
        /// This member is required.
        public var sentimentType: ChimeSDKMediaPipelinesClientTypes.SentimentType?
        /// Specifies the analysis interval.
        /// This member is required.
        public var timePeriod: Swift.Int

        public init(
            ruleName: Swift.String? = nil,
            sentimentType: ChimeSDKMediaPipelinesClientTypes.SentimentType? = nil,
            timePeriod: Swift.Int = 0
        )
        {
            self.ruleName = ruleName
            self.sentimentType = sentimentType
            self.timePeriod = timePeriod
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum SentimentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case negative
        case sdkUnknown(Swift.String)

        public static var allCases: [SentimentType] {
            return [
                .negative,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .negative: return "NEGATIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SentimentType(rawValue: rawValue) ?? SentimentType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightsTarget = "InsightsTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightsTarget = self.insightsTarget {
            try encodeContainer.encode(insightsTarget, forKey: .insightsTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightsTarget)
        insightsTarget = insightsTargetDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnsTopicSinkConfiguration(insightsTarget: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration settings for the SNS topic sink.
    public struct SnsTopicSinkConfiguration: Swift.Equatable {
        /// The ARN of the SNS sink.
        public var insightsTarget: Swift.String?

        public init(
            insightsTarget: Swift.String? = nil
        )
        {
            self.insightsTarget = insightsTarget
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.SourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectedVideoStreams = "SelectedVideoStreams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectedVideoStreams = self.selectedVideoStreams {
            try encodeContainer.encode(selectedVideoStreams, forKey: .selectedVideoStreams)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedVideoStreamsDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams.self, forKey: .selectedVideoStreams)
        selectedVideoStreams = selectedVideoStreamsDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Source configuration for a specified media pipeline.
    public struct SourceConfiguration: Swift.Equatable {
        /// The selected video streams for a specified media pipeline. The number of video streams can't exceed 25.
        public var selectedVideoStreams: ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams?

        public init(
            selectedVideoStreams: ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams? = nil
        )
        {
            self.selectedVideoStreams = selectedVideoStreams
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case speakerSearchTaskId = "SpeakerSearchTaskId"
        case speakerSearchTaskStatus = "SpeakerSearchTaskStatus"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let speakerSearchTaskId = self.speakerSearchTaskId {
            try encodeContainer.encode(speakerSearchTaskId, forKey: .speakerSearchTaskId)
        }
        if let speakerSearchTaskStatus = self.speakerSearchTaskStatus {
            try encodeContainer.encode(speakerSearchTaskStatus.rawValue, forKey: .speakerSearchTaskStatus)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerSearchTaskId)
        speakerSearchTaskId = speakerSearchTaskIdDecoded
        let speakerSearchTaskStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus.self, forKey: .speakerSearchTaskStatus)
        speakerSearchTaskStatus = speakerSearchTaskStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A representation of an asynchronous request to perform speaker search analysis on a media insights pipeline.
    public struct SpeakerSearchTask: Swift.Equatable {
        /// The time at which a speaker search task was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The speaker search task ID.
        public var speakerSearchTaskId: Swift.String?
        /// The status of the speaker search task.
        public var speakerSearchTaskStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus?
        /// The time at which a speaker search task was updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            speakerSearchTaskId: Swift.String? = nil,
            speakerSearchTaskStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.speakerSearchTaskId = speakerSearchTaskId
            self.speakerSearchTaskStatus = speakerSearchTaskStatus
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightsTarget = "InsightsTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightsTarget = self.insightsTarget {
            try encodeContainer.encode(insightsTarget, forKey: .insightsTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightsTarget)
        insightsTarget = insightsTargetDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SqsQueueSinkConfiguration(insightsTarget: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration settings for the SQS sink.
    public struct SqsQueueSinkConfiguration: Swift.Equatable {
        /// The ARN of the SQS sink.
        public var insightsTarget: Swift.String?

        public init(
            insightsTarget: Swift.String? = nil
        )
        {
            self.insightsTarget = insightsTarget
        }
    }

}

extension StartSpeakerSearchTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSpeakerSearchTaskInput(identifier: \(Swift.String(describing: identifier)), kinesisVideoStreamSourceTaskConfiguration: \(Swift.String(describing: kinesisVideoStreamSourceTaskConfiguration)), clientRequestToken: \"CONTENT_REDACTED\", voiceProfileDomainArn: \"CONTENT_REDACTED\")"}
}

extension StartSpeakerSearchTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kinesisVideoStreamSourceTaskConfiguration = "KinesisVideoStreamSourceTaskConfiguration"
        case voiceProfileDomainArn = "VoiceProfileDomainArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let kinesisVideoStreamSourceTaskConfiguration = self.kinesisVideoStreamSourceTaskConfiguration {
            try encodeContainer.encode(kinesisVideoStreamSourceTaskConfiguration, forKey: .kinesisVideoStreamSourceTaskConfiguration)
        }
        if let voiceProfileDomainArn = self.voiceProfileDomainArn {
            try encodeContainer.encode(voiceProfileDomainArn, forKey: .voiceProfileDomainArn)
        }
    }
}

extension StartSpeakerSearchTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "start"))
            return items
        }
    }
}

extension StartSpeakerSearchTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/speaker-search-tasks"
    }
}

public struct StartSpeakerSearchTaskInput: Swift.Equatable {
    /// The unique identifier for the client request. Use a different token for different speaker search tasks.
    public var clientRequestToken: Swift.String?
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The task configuration for the Kinesis video stream source of the media insights pipeline.
    public var kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration?
    /// The ARN of the voice profile domain that will store the voice profile.
    /// This member is required.
    public var voiceProfileDomainArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration? = nil,
        voiceProfileDomainArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.identifier = identifier
        self.kinesisVideoStreamSourceTaskConfiguration = kinesisVideoStreamSourceTaskConfiguration
        self.voiceProfileDomainArn = voiceProfileDomainArn
    }
}

struct StartSpeakerSearchTaskInputBody: Swift.Equatable {
    let voiceProfileDomainArn: Swift.String?
    let kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration?
    let clientRequestToken: Swift.String?
}

extension StartSpeakerSearchTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kinesisVideoStreamSourceTaskConfiguration = "KinesisVideoStreamSourceTaskConfiguration"
        case voiceProfileDomainArn = "VoiceProfileDomainArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainArn)
        voiceProfileDomainArn = voiceProfileDomainArnDecoded
        let kinesisVideoStreamSourceTaskConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration.self, forKey: .kinesisVideoStreamSourceTaskConfiguration)
        kinesisVideoStreamSourceTaskConfiguration = kinesisVideoStreamSourceTaskConfigurationDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartSpeakerSearchTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSpeakerSearchTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.speakerSearchTask = output.speakerSearchTask
        } else {
            self.speakerSearchTask = nil
        }
    }
}

public struct StartSpeakerSearchTaskOutput: Swift.Equatable {
    /// The details of the speaker search task.
    public var speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask?

    public init(
        speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask? = nil
    )
    {
        self.speakerSearchTask = speakerSearchTask
    }
}

struct StartSpeakerSearchTaskOutputBody: Swift.Equatable {
    let speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask?
}

extension StartSpeakerSearchTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTask = "SpeakerSearchTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask.self, forKey: .speakerSearchTask)
        speakerSearchTask = speakerSearchTaskDecoded
    }
}

enum StartSpeakerSearchTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartVoiceToneAnalysisTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartVoiceToneAnalysisTaskInput(identifier: \(Swift.String(describing: identifier)), kinesisVideoStreamSourceTaskConfiguration: \(Swift.String(describing: kinesisVideoStreamSourceTaskConfiguration)), languageCode: \(Swift.String(describing: languageCode)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension StartVoiceToneAnalysisTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kinesisVideoStreamSourceTaskConfiguration = "KinesisVideoStreamSourceTaskConfiguration"
        case languageCode = "LanguageCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let kinesisVideoStreamSourceTaskConfiguration = self.kinesisVideoStreamSourceTaskConfiguration {
            try encodeContainer.encode(kinesisVideoStreamSourceTaskConfiguration, forKey: .kinesisVideoStreamSourceTaskConfiguration)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
    }
}

extension StartVoiceToneAnalysisTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "start"))
            return items
        }
    }
}

extension StartVoiceToneAnalysisTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/voice-tone-analysis-tasks"
    }
}

public struct StartVoiceToneAnalysisTaskInput: Swift.Equatable {
    /// The unique identifier for the client request. Use a different token for different voice tone analysis tasks.
    public var clientRequestToken: Swift.String?
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The task configuration for the Kinesis video stream source of the media insights pipeline.
    public var kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration?
    /// The language code.
    /// This member is required.
    public var languageCode: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsLanguageCode?

    public init(
        clientRequestToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration? = nil,
        languageCode: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsLanguageCode? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.identifier = identifier
        self.kinesisVideoStreamSourceTaskConfiguration = kinesisVideoStreamSourceTaskConfiguration
        self.languageCode = languageCode
    }
}

struct StartVoiceToneAnalysisTaskInputBody: Swift.Equatable {
    let languageCode: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsLanguageCode?
    let kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration?
    let clientRequestToken: Swift.String?
}

extension StartVoiceToneAnalysisTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kinesisVideoStreamSourceTaskConfiguration = "KinesisVideoStreamSourceTaskConfiguration"
        case languageCode = "LanguageCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsLanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let kinesisVideoStreamSourceTaskConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration.self, forKey: .kinesisVideoStreamSourceTaskConfiguration)
        kinesisVideoStreamSourceTaskConfiguration = kinesisVideoStreamSourceTaskConfigurationDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartVoiceToneAnalysisTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartVoiceToneAnalysisTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceToneAnalysisTask = output.voiceToneAnalysisTask
        } else {
            self.voiceToneAnalysisTask = nil
        }
    }
}

public struct StartVoiceToneAnalysisTaskOutput: Swift.Equatable {
    /// The details of the voice tone analysis task.
    public var voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask?

    public init(
        voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask? = nil
    )
    {
        self.voiceToneAnalysisTask = voiceToneAnalysisTask
    }
}

struct StartVoiceToneAnalysisTaskOutputBody: Swift.Equatable {
    let voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask?
}

extension StartVoiceToneAnalysisTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceToneAnalysisTask = "VoiceToneAnalysisTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceToneAnalysisTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask.self, forKey: .voiceToneAnalysisTask)
        voiceToneAnalysisTask = voiceToneAnalysisTaskDecoded
    }
}

enum StartVoiceToneAnalysisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopSpeakerSearchTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "stop"))
            return items
        }
    }
}

extension StopSpeakerSearchTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        guard let speakerSearchTaskId = speakerSearchTaskId else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/speaker-search-tasks/\(speakerSearchTaskId.urlPercentEncoding())"
    }
}

public struct StopSpeakerSearchTaskInput: Swift.Equatable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The speaker search task ID.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        speakerSearchTaskId: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.speakerSearchTaskId = speakerSearchTaskId
    }
}

struct StopSpeakerSearchTaskInputBody: Swift.Equatable {
}

extension StopSpeakerSearchTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopSpeakerSearchTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopSpeakerSearchTaskOutput: Swift.Equatable {

    public init() { }
}

enum StopSpeakerSearchTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopVoiceToneAnalysisTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "stop"))
            return items
        }
    }
}

extension StopVoiceToneAnalysisTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        guard let voiceToneAnalysisTaskId = voiceToneAnalysisTaskId else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/voice-tone-analysis-tasks/\(voiceToneAnalysisTaskId.urlPercentEncoding())"
    }
}

public struct StopVoiceToneAnalysisTaskInput: Swift.Equatable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The ID of the voice tone analysis task.
    /// This member is required.
    public var voiceToneAnalysisTaskId: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        voiceToneAnalysisTaskId: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
    }
}

struct StopVoiceToneAnalysisTaskInputBody: Swift.Equatable {
}

extension StopVoiceToneAnalysisTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopVoiceToneAnalysisTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopVoiceToneAnalysisTaskOutput: Swift.Equatable {

    public init() { }
}

enum StopVoiceToneAnalysisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelDefinitions = "ChannelDefinitions"
        case numberOfChannels = "NumberOfChannels"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelDefinitions = channelDefinitions {
            var channelDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channelDefinitions)
            for channeldefinition0 in channelDefinitions {
                try channelDefinitionsContainer.encode(channeldefinition0)
            }
        }
        if let numberOfChannels = self.numberOfChannels {
            try encodeContainer.encode(numberOfChannels, forKey: .numberOfChannels)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfChannelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfChannels)
        numberOfChannels = numberOfChannelsDecoded
        let channelDefinitionsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.ChannelDefinition?].self, forKey: .channelDefinitions)
        var channelDefinitionsDecoded0:[ChimeSDKMediaPipelinesClientTypes.ChannelDefinition]? = nil
        if let channelDefinitionsContainer = channelDefinitionsContainer {
            channelDefinitionsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.ChannelDefinition]()
            for structure0 in channelDefinitionsContainer {
                if let structure0 = structure0 {
                    channelDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        channelDefinitions = channelDefinitionsDecoded0
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Defines a streaming channel.
    public struct StreamChannelDefinition: Swift.Equatable {
        /// The definitions of the channels in a streaming channel.
        public var channelDefinitions: [ChimeSDKMediaPipelinesClientTypes.ChannelDefinition]?
        /// The number of channels in a streaming channel.
        /// This member is required.
        public var numberOfChannels: Swift.Int?

        public init(
            channelDefinitions: [ChimeSDKMediaPipelinesClientTypes.ChannelDefinition]? = nil,
            numberOfChannels: Swift.Int? = nil
        )
        {
            self.channelDefinitions = channelDefinitions
            self.numberOfChannels = numberOfChannels
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.StreamConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fragmentNumber = "FragmentNumber"
        case streamArn = "StreamArn"
        case streamChannelDefinition = "StreamChannelDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragmentNumber = self.fragmentNumber {
            try encodeContainer.encode(fragmentNumber, forKey: .fragmentNumber)
        }
        if let streamArn = self.streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
        if let streamChannelDefinition = self.streamChannelDefinition {
            try encodeContainer.encode(streamChannelDefinition, forKey: .streamChannelDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let fragmentNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fragmentNumber)
        fragmentNumber = fragmentNumberDecoded
        let streamChannelDefinitionDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition.self, forKey: .streamChannelDefinition)
        streamChannelDefinition = streamChannelDefinitionDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration settings for a stream.
    public struct StreamConfiguration: Swift.Equatable {
        /// The unique identifier of the fragment to begin processing.
        public var fragmentNumber: Swift.String?
        /// The ARN of the stream.
        /// This member is required.
        public var streamArn: Swift.String?
        /// The streaming channel definition in the stream configuration.
        /// This member is required.
        public var streamChannelDefinition: ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition?

        public init(
            fragmentNumber: Swift.String? = nil,
            streamArn: Swift.String? = nil,
            streamChannelDefinition: ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition? = nil
        )
        {
            self.fragmentNumber = fragmentNumber
            self.streamArn = streamArn
            self.streamChannelDefinition = streamChannelDefinition
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A key/value pair that grants users access to meeting resources.
    public struct Tag: Swift.Equatable {
        /// The key half of a tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value half of a tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's endpoint region, resource ID, and pipeline ID.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags associated with the specified media pipeline.
    /// This member is required.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottledClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum TileOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case joinsequence
        case speakersequence
        case sdkUnknown(Swift.String)

        public static var allCases: [TileOrder] {
            return [
                .joinsequence,
                .speakersequence,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .joinsequence: return "JoinSequence"
            case .speakersequence: return "SpeakerSequence"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TileOrder(rawValue: rawValue) ?? TileOrder.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.TimestampRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTimestamp = "EndTimestamp"
        case startTimestamp = "StartTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimestamp = self.endTimestamp {
            try encodeContainer.encodeTimestamp(endTimestamp, format: .epochSeconds, forKey: .endTimestamp)
        }
        if let startTimestamp = self.startTimestamp {
            try encodeContainer.encodeTimestamp(startTimestamp, format: .epochSeconds, forKey: .startTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let endTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTimestamp)
        endTimestamp = endTimestampDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The range of timestamps to return.
    public struct TimestampRange: Swift.Equatable {
        /// The ending timestamp for the specified range.
        /// This member is required.
        public var endTimestamp: ClientRuntime.Date?
        /// The starting timestamp for the specified range.
        /// This member is required.
        public var startTimestamp: ClientRuntime.Date?

        public init(
            endTimestamp: ClientRuntime.Date? = nil,
            startTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.endTimestamp = endTimestamp
            self.startTimestamp = startTimestamp
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object for concatenating transcription messages.
    public struct TranscriptionMessagesConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension UnauthorizedClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the pipeline that you want to untag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key/value pairs in the tag that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMediaInsightsPipelineConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMediaInsightsPipelineConfigurationInput(elements: \(Swift.String(describing: elements)), identifier: \(Swift.String(describing: identifier)), realTimeAlertConfiguration: \(Swift.String(describing: realTimeAlertConfiguration)), resourceAccessRoleArn: \"CONTENT_REDACTED\")"}
}

extension UpdateMediaInsightsPipelineConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elements = "Elements"
        case realTimeAlertConfiguration = "RealTimeAlertConfiguration"
        case resourceAccessRoleArn = "ResourceAccessRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elements = elements {
            var elementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elements)
            for mediainsightspipelineconfigurationelement0 in elements {
                try elementsContainer.encode(mediainsightspipelineconfigurationelement0)
            }
        }
        if let realTimeAlertConfiguration = self.realTimeAlertConfiguration {
            try encodeContainer.encode(realTimeAlertConfiguration, forKey: .realTimeAlertConfiguration)
        }
        if let resourceAccessRoleArn = self.resourceAccessRoleArn {
            try encodeContainer.encode(resourceAccessRoleArn, forKey: .resourceAccessRoleArn)
        }
    }
}

extension UpdateMediaInsightsPipelineConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/media-insights-pipeline-configurations/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateMediaInsightsPipelineConfigurationInput: Swift.Equatable {
    /// The elements in the request, such as a processor for Amazon Transcribe or a sink for a Kinesis Data Stream..
    /// This member is required.
    public var elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]?
    /// The unique identifier for the resource to be updated. Valid values include the name and ARN of the media insights pipeline configuration.
    /// This member is required.
    public var identifier: Swift.String?
    /// The configuration settings for real-time alerts for the media insights pipeline.
    public var realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration?
    /// The ARN of the role used by the service to access Amazon Web Services resources.
    /// This member is required.
    public var resourceAccessRoleArn: Swift.String?

    public init(
        elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]? = nil,
        identifier: Swift.String? = nil,
        realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration? = nil,
        resourceAccessRoleArn: Swift.String? = nil
    )
    {
        self.elements = elements
        self.identifier = identifier
        self.realTimeAlertConfiguration = realTimeAlertConfiguration
        self.resourceAccessRoleArn = resourceAccessRoleArn
    }
}

struct UpdateMediaInsightsPipelineConfigurationInputBody: Swift.Equatable {
    let resourceAccessRoleArn: Swift.String?
    let realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration?
    let elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]?
}

extension UpdateMediaInsightsPipelineConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elements = "Elements"
        case realTimeAlertConfiguration = "RealTimeAlertConfiguration"
        case resourceAccessRoleArn = "ResourceAccessRoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceAccessRoleArn)
        resourceAccessRoleArn = resourceAccessRoleArnDecoded
        let realTimeAlertConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration.self, forKey: .realTimeAlertConfiguration)
        realTimeAlertConfiguration = realTimeAlertConfigurationDecoded
        let elementsContainer = try containerValues.decodeIfPresent([ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement?].self, forKey: .elements)
        var elementsDecoded0:[ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]? = nil
        if let elementsContainer = elementsContainer {
            elementsDecoded0 = [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]()
            for structure0 in elementsContainer {
                if let structure0 = structure0 {
                    elementsDecoded0?.append(structure0)
                }
            }
        }
        elements = elementsDecoded0
    }
}

extension UpdateMediaInsightsPipelineConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMediaInsightsPipelineConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaInsightsPipelineConfiguration = output.mediaInsightsPipelineConfiguration
        } else {
            self.mediaInsightsPipelineConfiguration = nil
        }
    }
}

public struct UpdateMediaInsightsPipelineConfigurationOutput: Swift.Equatable {
    /// The updated configuration settings.
    public var mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration?

    public init(
        mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration? = nil
    )
    {
        self.mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfiguration
    }
}

struct UpdateMediaInsightsPipelineConfigurationOutputBody: Swift.Equatable {
    let mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration?
}

extension UpdateMediaInsightsPipelineConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaInsightsPipelineConfiguration = "MediaInsightsPipelineConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaInsightsPipelineConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration.self, forKey: .mediaInsightsPipelineConfiguration)
        mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfigurationDecoded
    }
}

enum UpdateMediaInsightsPipelineConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMediaInsightsPipelineStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateStatus = "UpdateStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus.rawValue, forKey: .updateStatus)
        }
    }
}

extension UpdateMediaInsightsPipelineStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/media-insights-pipeline-status/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateMediaInsightsPipelineStatusInput: Swift.Equatable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The requested status of the media insights pipeline.
    /// This member is required.
    public var updateStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatusUpdate?

    public init(
        identifier: Swift.String? = nil,
        updateStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatusUpdate? = nil
    )
    {
        self.identifier = identifier
        self.updateStatus = updateStatus
    }
}

struct UpdateMediaInsightsPipelineStatusInputBody: Swift.Equatable {
    let updateStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatusUpdate?
}

extension UpdateMediaInsightsPipelineStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateStatus = "UpdateStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatusUpdate.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
    }
}

extension UpdateMediaInsightsPipelineStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMediaInsightsPipelineStatusOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMediaInsightsPipelineStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMediaPipelineKinesisVideoStreamPoolInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamConfiguration = "StreamConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamConfiguration = self.streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
    }
}

extension UpdateMediaPipelineKinesisVideoStreamPoolInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let identifier = identifier else {
            return nil
        }
        return "/media-pipeline-kinesis-video-stream-pools/\(identifier.urlPercentEncoding())"
    }
}

public struct UpdateMediaPipelineKinesisVideoStreamPoolInput: Swift.Equatable {
    /// The ID of the video stream pool.
    /// This member is required.
    public var identifier: Swift.String?
    /// The configuration settings for the video stream.
    public var streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate?

    public init(
        identifier: Swift.String? = nil,
        streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate? = nil
    )
    {
        self.identifier = identifier
        self.streamConfiguration = streamConfiguration
    }
}

struct UpdateMediaPipelineKinesisVideoStreamPoolInputBody: Swift.Equatable {
    let streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate?
}

extension UpdateMediaPipelineKinesisVideoStreamPoolInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamConfiguration = "StreamConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
    }
}

extension UpdateMediaPipelineKinesisVideoStreamPoolOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMediaPipelineKinesisVideoStreamPoolOutputBody = try responseDecoder.decode(responseBody: data)
            self.kinesisVideoStreamPoolConfiguration = output.kinesisVideoStreamPoolConfiguration
        } else {
            self.kinesisVideoStreamPoolConfiguration = nil
        }
    }
}

public struct UpdateMediaPipelineKinesisVideoStreamPoolOutput: Swift.Equatable {
    /// The video stream pool configuration object.
    public var kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration?

    public init(
        kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration? = nil
    )
    {
        self.kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfiguration
    }
}

struct UpdateMediaPipelineKinesisVideoStreamPoolOutputBody: Swift.Equatable {
    let kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration?
}

extension UpdateMediaPipelineKinesisVideoStreamPoolOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kinesisVideoStreamPoolConfiguration = "KinesisVideoStreamPoolConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kinesisVideoStreamPoolConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration.self, forKey: .kinesisVideoStreamPoolConfiguration)
        kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfigurationDecoded
    }
}

enum UpdateMediaPipelineKinesisVideoStreamPoolOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tileAspectRatio = "TileAspectRatio"
        case tileCount = "TileCount"
        case tileOrder = "TileOrder"
        case tilePosition = "TilePosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tileAspectRatio = self.tileAspectRatio {
            try encodeContainer.encode(tileAspectRatio, forKey: .tileAspectRatio)
        }
        if let tileCount = self.tileCount {
            try encodeContainer.encode(tileCount, forKey: .tileCount)
        }
        if let tileOrder = self.tileOrder {
            try encodeContainer.encode(tileOrder.rawValue, forKey: .tileOrder)
        }
        if let tilePosition = self.tilePosition {
            try encodeContainer.encode(tilePosition.rawValue, forKey: .tilePosition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tileOrderDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.TileOrder.self, forKey: .tileOrder)
        tileOrder = tileOrderDecoded
        let tilePositionDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VerticalTilePosition.self, forKey: .tilePosition)
        tilePosition = tilePositionDecoded
        let tileCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tileCount)
        tileCount = tileCountDecoded
        let tileAspectRatioDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tileAspectRatio)
        tileAspectRatio = tileAspectRatioDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Defines the configuration settings for a vertical layout.
    public struct VerticalLayoutConfiguration: Swift.Equatable {
        /// Sets the aspect ratio of the video tiles, such as 16:9.
        public var tileAspectRatio: Swift.String?
        /// The maximum number of tiles to display.
        public var tileCount: Swift.Int?
        /// Sets the automatic ordering of the video tiles.
        public var tileOrder: ChimeSDKMediaPipelinesClientTypes.TileOrder?
        /// Sets the position of vertical tiles.
        public var tilePosition: ChimeSDKMediaPipelinesClientTypes.VerticalTilePosition?

        public init(
            tileAspectRatio: Swift.String? = nil,
            tileCount: Swift.Int? = nil,
            tileOrder: ChimeSDKMediaPipelinesClientTypes.TileOrder? = nil,
            tilePosition: ChimeSDKMediaPipelinesClientTypes.VerticalTilePosition? = nil
        )
        {
            self.tileAspectRatio = tileAspectRatio
            self.tileCount = tileCount
            self.tileOrder = tileOrder
            self.tilePosition = tilePosition
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum VerticalTilePosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `left`
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [VerticalTilePosition] {
            return [
                .left,
                .right,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .left: return "Left"
            case .right: return "Right"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VerticalTilePosition(rawValue: rawValue) ?? VerticalTilePosition.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsState.self, forKey: .state)
        state = stateDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VideoMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The video artifact configuration object.
    public struct VideoArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the video artifact configuration object.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.VideoMuxType?
        /// Indicates whether the video artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState?

        public init(
            muxType: ChimeSDKMediaPipelinesClientTypes.VideoMuxType? = nil,
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.VideoAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case borderColor = "BorderColor"
        case borderThickness = "BorderThickness"
        case cornerRadius = "CornerRadius"
        case highlightColor = "HighlightColor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let borderColor = self.borderColor {
            try encodeContainer.encode(borderColor.rawValue, forKey: .borderColor)
        }
        if let borderThickness = self.borderThickness {
            try encodeContainer.encode(borderThickness, forKey: .borderThickness)
        }
        if let cornerRadius = self.cornerRadius {
            try encodeContainer.encode(cornerRadius, forKey: .cornerRadius)
        }
        if let highlightColor = self.highlightColor {
            try encodeContainer.encode(highlightColor.rawValue, forKey: .highlightColor)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cornerRadiusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cornerRadius)
        cornerRadius = cornerRadiusDecoded
        let borderColorDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.BorderColor.self, forKey: .borderColor)
        borderColor = borderColorDecoded
        let highlightColorDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.HighlightColor.self, forKey: .highlightColor)
        highlightColor = highlightColorDecoded
        let borderThicknessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .borderThickness)
        borderThickness = borderThicknessDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// Defines the settings for a video tile.
    public struct VideoAttribute: Swift.Equatable {
        /// Defines the border color of all video tiles.
        public var borderColor: ChimeSDKMediaPipelinesClientTypes.BorderColor?
        /// Defines the border thickness for all video tiles.
        public var borderThickness: Swift.Int?
        /// Sets the corner radius of all video tiles.
        public var cornerRadius: Swift.Int?
        /// Defines the highlight color for the active video tile.
        public var highlightColor: ChimeSDKMediaPipelinesClientTypes.HighlightColor?

        public init(
            borderColor: ChimeSDKMediaPipelinesClientTypes.BorderColor? = nil,
            borderThickness: Swift.Int? = nil,
            cornerRadius: Swift.Int? = nil,
            highlightColor: ChimeSDKMediaPipelinesClientTypes.HighlightColor? = nil
        )
        {
            self.borderColor = borderColor
            self.borderThickness = borderThickness
            self.cornerRadius = cornerRadius
            self.highlightColor = highlightColor
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration object of a video concatenation pipeline.
    public struct VideoConcatenationConfiguration: Swift.Equatable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum VideoMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case videoonly
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoMuxType] {
            return [
                .videoonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .videoonly: return "VideoOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VideoMuxType(rawValue: rawValue) ?? VideoMuxType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum VocabularyFilterMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VocabularyFilterMethod(rawValue: rawValue) ?? VocabularyFilterMethod.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum VoiceAnalyticsConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceAnalyticsConfigurationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceAnalyticsConfigurationStatus(rawValue: rawValue) ?? VoiceAnalyticsConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    public enum VoiceAnalyticsLanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceAnalyticsLanguageCode] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceAnalyticsLanguageCode(rawValue: rawValue) ?? VoiceAnalyticsLanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchStatus = "SpeakerSearchStatus"
        case voiceToneAnalysisStatus = "VoiceToneAnalysisStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let speakerSearchStatus = self.speakerSearchStatus {
            try encodeContainer.encode(speakerSearchStatus.rawValue, forKey: .speakerSearchStatus)
        }
        if let voiceToneAnalysisStatus = self.voiceToneAnalysisStatus {
            try encodeContainer.encode(voiceToneAnalysisStatus.rawValue, forKey: .voiceToneAnalysisStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus.self, forKey: .speakerSearchStatus)
        speakerSearchStatus = speakerSearchStatusDecoded
        let voiceToneAnalysisStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus.self, forKey: .voiceToneAnalysisStatus)
        voiceToneAnalysisStatus = voiceToneAnalysisStatusDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// The configuration settings for a voice analytics processor.
    public struct VoiceAnalyticsProcessorConfiguration: Swift.Equatable {
        /// The status of the speaker search task.
        public var speakerSearchStatus: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus?
        /// The status of the voice tone analysis task.
        public var voiceToneAnalysisStatus: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus?

        public init(
            speakerSearchStatus: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus? = nil,
            voiceToneAnalysisStatus: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus? = nil
        )
        {
            self.speakerSearchStatus = speakerSearchStatus
            self.voiceToneAnalysisStatus = voiceToneAnalysisStatus
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if disabled != false {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled) ?? false
        disabled = disabledDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A static structure that contains the configuration data for a VoiceEnhancementSinkConfiguration element.
    public struct VoiceEnhancementSinkConfiguration: Swift.Equatable {
        /// Disables the VoiceEnhancementSinkConfiguration element.
        public var disabled: Swift.Bool

        public init(
            disabled: Swift.Bool = false
        )
        {
            self.disabled = disabled
        }
    }

}

extension ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceToneAnalysisTaskId = "VoiceToneAnalysisTaskId"
        case voiceToneAnalysisTaskStatus = "VoiceToneAnalysisTaskStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceToneAnalysisTaskId = self.voiceToneAnalysisTaskId {
            try encodeContainer.encode(voiceToneAnalysisTaskId, forKey: .voiceToneAnalysisTaskId)
        }
        if let voiceToneAnalysisTaskStatus = self.voiceToneAnalysisTaskStatus {
            try encodeContainer.encode(voiceToneAnalysisTaskStatus.rawValue, forKey: .voiceToneAnalysisTaskStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceToneAnalysisTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceToneAnalysisTaskId)
        voiceToneAnalysisTaskId = voiceToneAnalysisTaskIdDecoded
        let voiceToneAnalysisTaskStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus.self, forKey: .voiceToneAnalysisTaskStatus)
        voiceToneAnalysisTaskStatus = voiceToneAnalysisTaskStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKMediaPipelinesClientTypes {
    /// A representation of an asynchronous request to perform voice tone analysis on a media insights pipeline.
    public struct VoiceToneAnalysisTask: Swift.Equatable {
        /// The time at which a voice tone analysis task was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a voice tone analysis task was updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ID of the voice tone analysis task.
        public var voiceToneAnalysisTaskId: Swift.String?
        /// The status of a voice tone analysis task.
        public var voiceToneAnalysisTaskStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceToneAnalysisTaskId: Swift.String? = nil,
            voiceToneAnalysisTaskStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.updatedTimestamp = updatedTimestamp
            self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
            self.voiceToneAnalysisTaskStatus = voiceToneAnalysisTaskStatus
        }
    }

}
