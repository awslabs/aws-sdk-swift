// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListCidrBlocksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCidrBlocksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCidrBlocksOutputResponse`
extension Route53Client {
    public func listCidrBlocksPaginated(input: ListCidrBlocksInput) -> ClientRuntime.PaginatorSequence<ListCidrBlocksInput, ListCidrBlocksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCidrBlocksInput, ListCidrBlocksOutputResponse>(input: input, inputKey: \ListCidrBlocksInput.nextToken, outputKey: \ListCidrBlocksOutputResponse.nextToken, paginationFunction: self.listCidrBlocks(input:))
    }
}

extension ListCidrBlocksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCidrBlocksInput {
        return ListCidrBlocksInput(
            collectionId: self.collectionId,
            locationName: self.locationName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCidrBlocksPaginated`
/// to access the nested member `[Route53ClientTypes.CidrBlockSummary]`
/// - Returns: `[Route53ClientTypes.CidrBlockSummary]`
extension PaginatorSequence where Input == ListCidrBlocksInput, Output == ListCidrBlocksOutputResponse {
    public func cidrBlocks() async throws -> [Route53ClientTypes.CidrBlockSummary] {
        return try await self.asyncCompactMap { item in item.cidrBlocks }
    }
}

/// Paginate over `[ListCidrCollectionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCidrCollectionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCidrCollectionsOutputResponse`
extension Route53Client {
    public func listCidrCollectionsPaginated(input: ListCidrCollectionsInput) -> ClientRuntime.PaginatorSequence<ListCidrCollectionsInput, ListCidrCollectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCidrCollectionsInput, ListCidrCollectionsOutputResponse>(input: input, inputKey: \ListCidrCollectionsInput.nextToken, outputKey: \ListCidrCollectionsOutputResponse.nextToken, paginationFunction: self.listCidrCollections(input:))
    }
}

extension ListCidrCollectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCidrCollectionsInput {
        return ListCidrCollectionsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCidrCollectionsPaginated`
/// to access the nested member `[Route53ClientTypes.CollectionSummary]`
/// - Returns: `[Route53ClientTypes.CollectionSummary]`
extension PaginatorSequence where Input == ListCidrCollectionsInput, Output == ListCidrCollectionsOutputResponse {
    public func cidrCollections() async throws -> [Route53ClientTypes.CollectionSummary] {
        return try await self.asyncCompactMap { item in item.cidrCollections }
    }
}

/// Paginate over `[ListCidrLocationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCidrLocationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCidrLocationsOutputResponse`
extension Route53Client {
    public func listCidrLocationsPaginated(input: ListCidrLocationsInput) -> ClientRuntime.PaginatorSequence<ListCidrLocationsInput, ListCidrLocationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCidrLocationsInput, ListCidrLocationsOutputResponse>(input: input, inputKey: \ListCidrLocationsInput.nextToken, outputKey: \ListCidrLocationsOutputResponse.nextToken, paginationFunction: self.listCidrLocations(input:))
    }
}

extension ListCidrLocationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCidrLocationsInput {
        return ListCidrLocationsInput(
            collectionId: self.collectionId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCidrLocationsPaginated`
/// to access the nested member `[Route53ClientTypes.LocationSummary]`
/// - Returns: `[Route53ClientTypes.LocationSummary]`
extension PaginatorSequence where Input == ListCidrLocationsInput, Output == ListCidrLocationsOutputResponse {
    public func cidrLocations() async throws -> [Route53ClientTypes.LocationSummary] {
        return try await self.asyncCompactMap { item in item.cidrLocations }
    }
}

/// Paginate over `[ListHealthChecksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHealthChecksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHealthChecksOutputResponse`
extension Route53Client {
    public func listHealthChecksPaginated(input: ListHealthChecksInput) -> ClientRuntime.PaginatorSequence<ListHealthChecksInput, ListHealthChecksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHealthChecksInput, ListHealthChecksOutputResponse>(input: input, inputKey: \ListHealthChecksInput.marker, outputKey: \ListHealthChecksOutputResponse.nextMarker, paginationFunction: self.listHealthChecks(input:))
    }
}

extension ListHealthChecksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHealthChecksInput {
        return ListHealthChecksInput(
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listHealthChecksPaginated`
/// to access the nested member `[Route53ClientTypes.HealthCheck]`
/// - Returns: `[Route53ClientTypes.HealthCheck]`
extension PaginatorSequence where Input == ListHealthChecksInput, Output == ListHealthChecksOutputResponse {
    public func healthChecks() async throws -> [Route53ClientTypes.HealthCheck] {
        return try await self.asyncCompactMap { item in item.healthChecks }
    }
}

/// Paginate over `[ListHostedZonesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHostedZonesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHostedZonesOutputResponse`
extension Route53Client {
    public func listHostedZonesPaginated(input: ListHostedZonesInput) -> ClientRuntime.PaginatorSequence<ListHostedZonesInput, ListHostedZonesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHostedZonesInput, ListHostedZonesOutputResponse>(input: input, inputKey: \ListHostedZonesInput.marker, outputKey: \ListHostedZonesOutputResponse.nextMarker, paginationFunction: self.listHostedZones(input:))
    }
}

extension ListHostedZonesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHostedZonesInput {
        return ListHostedZonesInput(
            delegationSetId: self.delegationSetId,
            marker: token,
            maxItems: self.maxItems
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listHostedZonesPaginated`
/// to access the nested member `[Route53ClientTypes.HostedZone]`
/// - Returns: `[Route53ClientTypes.HostedZone]`
extension PaginatorSequence where Input == ListHostedZonesInput, Output == ListHostedZonesOutputResponse {
    public func hostedZones() async throws -> [Route53ClientTypes.HostedZone] {
        return try await self.asyncCompactMap { item in item.hostedZones }
    }
}

/// Paginate over `[ListQueryLoggingConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListQueryLoggingConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListQueryLoggingConfigsOutputResponse`
extension Route53Client {
    public func listQueryLoggingConfigsPaginated(input: ListQueryLoggingConfigsInput) -> ClientRuntime.PaginatorSequence<ListQueryLoggingConfigsInput, ListQueryLoggingConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListQueryLoggingConfigsInput, ListQueryLoggingConfigsOutputResponse>(input: input, inputKey: \ListQueryLoggingConfigsInput.nextToken, outputKey: \ListQueryLoggingConfigsOutputResponse.nextToken, paginationFunction: self.listQueryLoggingConfigs(input:))
    }
}

extension ListQueryLoggingConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQueryLoggingConfigsInput {
        return ListQueryLoggingConfigsInput(
            hostedZoneId: self.hostedZoneId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listQueryLoggingConfigsPaginated`
/// to access the nested member `[Route53ClientTypes.QueryLoggingConfig]`
/// - Returns: `[Route53ClientTypes.QueryLoggingConfig]`
extension PaginatorSequence where Input == ListQueryLoggingConfigsInput, Output == ListQueryLoggingConfigsOutputResponse {
    public func queryLoggingConfigs() async throws -> [Route53ClientTypes.QueryLoggingConfig] {
        return try await self.asyncCompactMap { item in item.queryLoggingConfigs }
    }
}
