// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Smithy
import SmithyEventStreams
import SmithyEventStreamsAPI
import SmithyHTTPAPI
import SmithyJSON
import SmithyReadWrite
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request failed due to an error while processing the model.
public struct ModelErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The original status code.
        public internal(set) var originalStatusCode: Swift.Int? = nil
        /// The resource name.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelErrorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        originalStatusCode: Swift.Int? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.originalStatusCode = originalStatusCode
        self.properties.resourceName = resourceName
    }
}

/// The model specified in the request is not ready to serve inference requests.
public struct ModelNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelNotReadyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request took too long to process. Processing time exceeded the model timeout length.
public struct ModelTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource ARN was not found. Check the ARN and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockRuntimeClientTypes {
    /// Base inference parameters to pass to a model in a call to [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html) or [ConverseStream](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html). For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). If you need to pass additional parameters that the model supports, use the additionalModelRequestFields request field in the call to Converse or ConverseStream. For more information, see [Model parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public struct InferenceConfiguration {
        /// The maximum number of tokens to allow in the generated response. The default value is the maximum allowed value for the model that you are using. For more information, see [Inference parameters for foundatio{ "messages": [ { "role": "user", "content": [ { "text": "what's the weather in Queens, NY and Austin, TX?" } ] }, { "role": "assistant", "content": [ { "toolUse": { "toolUseId": "1", "name": "get_weather", "input": { "city": "Queens", "state": "NY" } } }, { "toolUse": { "toolUseId": "2", "name": "get_weather", "input": { "city": "Austin", "state": "TX" } } } ] }, { "role": "user", "content": [ { "toolResult": { "toolUseId": "2", "content": [ { "json": { "weather": "40" } } ] } }, { "text": "..." }, { "toolResult": { "toolUseId": "1", "content": [ { "text": "result text" } ] } } ] } ], "toolConfig": { "tools": [ { "name": "get_weather", "description": "Get weather", "inputSchema": { "type": "object", "properties": { "city": { "type": "string", "description": "City of location" }, "state": { "type": "string", "description": "State of location" } }, "required": ["city", "state"] } } ] } } n models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var maxTokens: Swift.Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public var stopSequences: [Swift.String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options. The default value is the default value for the model that you are using. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var temperature: Swift.Float?
        /// The percentage of most-likely candidates that the model considers for the next token. For example, if you choose a value of 0.8 for topP, the model selects from the top 80% of the probability distribution of tokens that could be next in the sequence. The default value is the default value for the model that you are using. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var topp: Swift.Float?

        public init(
            maxTokens: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topp = topp
        }
    }

}

extension BedrockRuntimeClientTypes {

    public enum ImageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gif
        case jpeg
        case png
        case webp
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFormat] {
            return [
                .gif,
                .jpeg,
                .png,
                .webp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gif: return "gif"
            case .jpeg: return "jpeg"
            case .png: return "png"
            case .webp: return "webp"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {
    /// The source for an image.
    public enum ImageSource {
        /// The raw image bytes for the image. If you use an AWS SDK, you don't need to base64 encode the image bytes.
        case bytes(Foundation.Data)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {
    /// Image content for a message.
    public struct ImageBlock {
        /// The format of the image.
        /// This member is required.
        public var format: BedrockRuntimeClientTypes.ImageFormat?
        /// The source for the image.
        /// This member is required.
        public var source: BedrockRuntimeClientTypes.ImageSource?

        public init(
            format: BedrockRuntimeClientTypes.ImageFormat? = nil,
            source: BedrockRuntimeClientTypes.ImageSource? = nil
        )
        {
            self.format = format
            self.source = source
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// The tool result content block.
    public enum ToolResultContentBlock {
        /// A tool result that is JSON format data.
        case json(SmithyReadWrite.Document)
        /// A tool result that is text.
        case text(Swift.String)
        /// A tool result that is an image. This field is only supported by Anthropic Claude 3 models.
        case image(BedrockRuntimeClientTypes.ImageBlock)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {

    public enum ToolResultStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ToolResultStatus] {
            return [
                .error,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "error"
            case .success: return "success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {
    /// A tool result block that contains the results for a tool request that the model previously made.
    public struct ToolResultBlock {
        /// The content for tool result content block.
        /// This member is required.
        public var content: [BedrockRuntimeClientTypes.ToolResultContentBlock]?
        /// The status for the tool result content block. This field is only supported Anthropic Claude 3 models.
        public var status: BedrockRuntimeClientTypes.ToolResultStatus?
        /// The ID of the tool request that this is the result for.
        /// This member is required.
        public var toolUseId: Swift.String?

        public init(
            content: [BedrockRuntimeClientTypes.ToolResultContentBlock]? = nil,
            status: BedrockRuntimeClientTypes.ToolResultStatus? = nil,
            toolUseId: Swift.String? = nil
        )
        {
            self.content = content
            self.status = status
            self.toolUseId = toolUseId
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// A tool use content block. Contains information about a tool that the model is requesting be run., The model uses the result from the tool to generate a response.
    public struct ToolUseBlock {
        /// The input to pass to the tool.
        /// This member is required.
        public var input: SmithyReadWrite.Document?
        /// The name of the tool that the model wants to use.
        /// This member is required.
        public var name: Swift.String?
        /// The ID for the tool request.
        /// This member is required.
        public var toolUseId: Swift.String?

        public init(
            input: SmithyReadWrite.Document? = nil,
            name: Swift.String? = nil,
            toolUseId: Swift.String? = nil
        )
        {
            self.input = input
            self.name = name
            self.toolUseId = toolUseId
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// A block of content for a message.
    public enum ContentBlock {
        /// Text to include in the message.
        case text(Swift.String)
        /// Image to include in the message. This field is only supported by Anthropic Claude 3 models.
        case image(BedrockRuntimeClientTypes.ImageBlock)
        /// Information about a tool use request from a model.
        case tooluse(BedrockRuntimeClientTypes.ToolUseBlock)
        /// The result for a tool request that a model makes.
        case toolresult(BedrockRuntimeClientTypes.ToolResultBlock)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {

    public enum ConversationRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assistant
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationRole] {
            return [
                .assistant,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assistant: return "assistant"
            case .user: return "user"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {
    /// A message in the [Message](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Message.html) field. Use to send a message in a call to [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html).
    public struct Message {
        /// The message content.
        /// This member is required.
        public var content: [BedrockRuntimeClientTypes.ContentBlock]?
        /// The role that the message plays in the message.
        /// This member is required.
        public var role: BedrockRuntimeClientTypes.ConversationRole?

        public init(
            content: [BedrockRuntimeClientTypes.ContentBlock]? = nil,
            role: BedrockRuntimeClientTypes.ConversationRole? = nil
        )
        {
            self.content = content
            self.role = role
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// A system content block
    public enum SystemContentBlock {
        /// A system prompt for the model.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {
    /// The model must request at least one tool (no text is generated).
    public struct AnyToolChoice {

        public init() { }
    }

}

extension BedrockRuntimeClientTypes {
    /// The Model automatically decides if a tool should be called or to whether to generate text instead.
    public struct AutoToolChoice {

        public init() { }
    }

}

extension BedrockRuntimeClientTypes {
    /// The model must request a specific tool. This field is only supported by Anthropic Claude 3 models.
    public struct SpecificToolChoice {
        /// The name of the tool that the model must request.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// Forces a model to use a tool.
    public enum ToolChoice {
        /// The Model automatically decides if a tool should be called or to whether to generate text instead.
        case auto(BedrockRuntimeClientTypes.AutoToolChoice)
        /// The model must request at least one tool (no text is generated).
        case any(BedrockRuntimeClientTypes.AnyToolChoice)
        /// The Model must request the specified tool.
        case tool(BedrockRuntimeClientTypes.SpecificToolChoice)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {
    /// The schema for the tool. The top level schema type must be object.
    public enum ToolInputSchema {
        /// The JSON schema for the tool. For more information, see [JSON Schema Reference](https://json-schema.org/understanding-json-schema/reference).
        case json(SmithyReadWrite.Document)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {
    /// The specification for the tool.
    public struct ToolSpecification {
        /// The description for the tool.
        public var description: Swift.String?
        /// The input schema for the tool in JSON format.
        /// This member is required.
        public var inputSchema: BedrockRuntimeClientTypes.ToolInputSchema?
        /// The name for the tool.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            inputSchema: BedrockRuntimeClientTypes.ToolInputSchema? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// Information about a tool that you can use with the Converse API.
    public enum Tool {
        /// The specfication for the tool.
        case toolspec(BedrockRuntimeClientTypes.ToolSpecification)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {
    /// Configuration information for the tools that you pass to a model. This field is only supported by Anthropic Claude 3, Cohere Command R, Cohere Command R+, and Mistral Large models.
    public struct ToolConfiguration {
        /// If supported by model, forces the model to request a tool.
        public var toolChoice: BedrockRuntimeClientTypes.ToolChoice?
        /// An array of tools that you want to pass to a model.
        /// This member is required.
        public var tools: [BedrockRuntimeClientTypes.Tool]?

        public init(
            toolChoice: BedrockRuntimeClientTypes.ToolChoice? = nil,
            tools: [BedrockRuntimeClientTypes.Tool]? = nil
        )
        {
            self.toolChoice = toolChoice
            self.tools = tools
        }
    }

}

public struct ConverseInput {
    /// Additional inference parameters that the model supports, beyond the base set of inference parameters that Converse supports in the inferenceConfig field. For more information, see [Model parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public var additionalModelRequestFields: SmithyReadWrite.Document?
    /// Additional model parameters field paths to return in the response. Converse returns the requested fields as a JSON Pointer object in the additionalModelResultFields field. The following is example JSON for additionalModelResponseFieldPaths. [ "/stop_sequence" ] For information about the JSON Pointer syntax, see the [Internet Engineering Task Force (IETF)](https://datatracker.ietf.org/doc/html/rfc6901) documentation. Converse rejects an empty JSON Pointer or incorrectly structured JSON Pointer with a 400 error code. if the JSON Pointer is valid, but the requested field is not in the model response, it is ignored by Converse.
    public var additionalModelResponseFieldPaths: [Swift.String]?
    /// Inference parameters to pass to the model. Converse supports a base set of inference parameters. If you need to pass additional parameters that the model supports, use the additionalModelRequestFields request field.
    public var inferenceConfig: BedrockRuntimeClientTypes.InferenceConfiguration?
    /// The messages that you want to send to the model.
    /// This member is required.
    public var messages: [BedrockRuntimeClientTypes.Message]?
    /// The identifier for the model that you want to call. The modelId to provide depends on the type of model that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var modelId: Swift.String?
    /// A system prompt to pass to the model.
    public var system: [BedrockRuntimeClientTypes.SystemContentBlock]?
    /// Configuration information for the tools that the model can use when generating a response. This field is only supported by Anthropic Claude 3, Cohere Command R, Cohere Command R+, and Mistral Large models.
    public var toolConfig: BedrockRuntimeClientTypes.ToolConfiguration?

    public init(
        additionalModelRequestFields: SmithyReadWrite.Document? = nil,
        additionalModelResponseFieldPaths: [Swift.String]? = nil,
        inferenceConfig: BedrockRuntimeClientTypes.InferenceConfiguration? = nil,
        messages: [BedrockRuntimeClientTypes.Message]? = nil,
        modelId: Swift.String? = nil,
        system: [BedrockRuntimeClientTypes.SystemContentBlock]? = nil,
        toolConfig: BedrockRuntimeClientTypes.ToolConfiguration? = nil
    )
    {
        self.additionalModelRequestFields = additionalModelRequestFields
        self.additionalModelResponseFieldPaths = additionalModelResponseFieldPaths
        self.inferenceConfig = inferenceConfig
        self.messages = messages
        self.modelId = modelId
        self.system = system
        self.toolConfig = toolConfig
    }
}

extension BedrockRuntimeClientTypes {
    /// Metrics for a call to [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html).
    public struct ConverseMetrics {
        /// The latency of the call to Converse, in milliseconds.
        /// This member is required.
        public var latencyMs: Swift.Int?

        public init(
            latencyMs: Swift.Int? = nil
        )
        {
            self.latencyMs = latencyMs
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// The output from a call to [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html).
    public enum ConverseOutput {
        /// The message that the model generates.
        case message(BedrockRuntimeClientTypes.Message)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {

    public enum StopReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contentFiltered
        case endTurn
        case maxTokens
        case stopSequence
        case toolUse
        case sdkUnknown(Swift.String)

        public static var allCases: [StopReason] {
            return [
                .contentFiltered,
                .endTurn,
                .maxTokens,
                .stopSequence,
                .toolUse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contentFiltered: return "content_filtered"
            case .endTurn: return "end_turn"
            case .maxTokens: return "max_tokens"
            case .stopSequence: return "stop_sequence"
            case .toolUse: return "tool_use"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {
    /// The tokens used in a message API inference call.
    public struct TokenUsage {
        /// The number of tokens sent in the request to the model.
        /// This member is required.
        public var inputTokens: Swift.Int?
        /// The number of tokens that the model generated for the request.
        /// This member is required.
        public var outputTokens: Swift.Int?
        /// The total of input tokens and tokens generated by the model.
        /// This member is required.
        public var totalTokens: Swift.Int?

        public init(
            inputTokens: Swift.Int? = nil,
            outputTokens: Swift.Int? = nil,
            totalTokens: Swift.Int? = nil
        )
        {
            self.inputTokens = inputTokens
            self.outputTokens = outputTokens
            self.totalTokens = totalTokens
        }
    }

}

public struct ConverseOutput {
    /// Additional fields in the response that are unique to the model.
    public var additionalModelResponseFields: SmithyReadWrite.Document?
    /// Metrics for the call to Converse.
    /// This member is required.
    public var metrics: BedrockRuntimeClientTypes.ConverseMetrics?
    /// The result from the call to Converse.
    /// This member is required.
    public var output: BedrockRuntimeClientTypes.ConverseOutput?
    /// The reason why the model stopped generating output.
    /// This member is required.
    public var stopReason: BedrockRuntimeClientTypes.StopReason?
    /// The total number of tokens used in the call to Converse. The total includes the tokens input to the model and the tokens generated by the model.
    /// This member is required.
    public var usage: BedrockRuntimeClientTypes.TokenUsage?

    public init(
        additionalModelResponseFields: SmithyReadWrite.Document? = nil,
        metrics: BedrockRuntimeClientTypes.ConverseMetrics? = nil,
        output: BedrockRuntimeClientTypes.ConverseOutput? = nil,
        stopReason: BedrockRuntimeClientTypes.StopReason? = nil,
        usage: BedrockRuntimeClientTypes.TokenUsage? = nil
    )
    {
        self.additionalModelResponseFields = additionalModelResponseFields
        self.metrics = metrics
        self.output = output
        self.stopReason = stopReason
        self.usage = usage
    }
}

public struct ConverseStreamInput {
    /// Additional inference parameters that the model supports, beyond the base set of inference parameters that ConverseStream supports in the inferenceConfig field.
    public var additionalModelRequestFields: SmithyReadWrite.Document?
    /// Additional model parameters field paths to return in the response. ConverseStream returns the requested fields as a JSON Pointer object in the additionalModelResultFields field. The following is example JSON for additionalModelResponseFieldPaths. [ "/stop_sequence" ] For information about the JSON Pointer syntax, see the [Internet Engineering Task Force (IETF)](https://datatracker.ietf.org/doc/html/rfc6901) documentation. ConverseStream rejects an empty JSON Pointer or incorrectly structured JSON Pointer with a 400 error code. if the JSON Pointer is valid, but the requested field is not in the model response, it is ignored by ConverseStream.
    public var additionalModelResponseFieldPaths: [Swift.String]?
    /// Inference parameters to pass to the model. ConverseStream supports a base set of inference parameters. If you need to pass additional parameters that the model supports, use the additionalModelRequestFields request field.
    public var inferenceConfig: BedrockRuntimeClientTypes.InferenceConfiguration?
    /// The messages that you want to send to the model.
    /// This member is required.
    public var messages: [BedrockRuntimeClientTypes.Message]?
    /// The ID for the model. The modelId to provide depends on the type of model that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var modelId: Swift.String?
    /// A system prompt to send to the model.
    public var system: [BedrockRuntimeClientTypes.SystemContentBlock]?
    /// Configuration information for the tools that the model can use when generating a response. This field is only supported by Anthropic Claude 3 models.
    public var toolConfig: BedrockRuntimeClientTypes.ToolConfiguration?

    public init(
        additionalModelRequestFields: SmithyReadWrite.Document? = nil,
        additionalModelResponseFieldPaths: [Swift.String]? = nil,
        inferenceConfig: BedrockRuntimeClientTypes.InferenceConfiguration? = nil,
        messages: [BedrockRuntimeClientTypes.Message]? = nil,
        modelId: Swift.String? = nil,
        system: [BedrockRuntimeClientTypes.SystemContentBlock]? = nil,
        toolConfig: BedrockRuntimeClientTypes.ToolConfiguration? = nil
    )
    {
        self.additionalModelRequestFields = additionalModelRequestFields
        self.additionalModelResponseFieldPaths = additionalModelResponseFieldPaths
        self.inferenceConfig = inferenceConfig
        self.messages = messages
        self.modelId = modelId
        self.system = system
        self.toolConfig = toolConfig
    }
}

extension BedrockRuntimeClientTypes {
    /// The delta for a tool use block.
    public struct ToolUseBlockDelta {
        /// The input for a requested tool.
        /// This member is required.
        public var input: Swift.String?

        public init(
            input: Swift.String? = nil
        )
        {
            self.input = input
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// A bock of content in a streaming response.
    public enum ContentBlockDelta {
        /// The content text.
        case text(Swift.String)
        /// Information about a tool that the model is requesting to use.
        case tooluse(BedrockRuntimeClientTypes.ToolUseBlockDelta)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {
    /// The content block delta event.
    public struct ContentBlockDeltaEvent {
        /// The block index for a content block delta event.
        /// This member is required.
        public var contentBlockIndex: Swift.Int?
        /// The delta for a content block delta event.
        /// This member is required.
        public var delta: BedrockRuntimeClientTypes.ContentBlockDelta?

        public init(
            contentBlockIndex: Swift.Int? = nil,
            delta: BedrockRuntimeClientTypes.ContentBlockDelta? = nil
        )
        {
            self.contentBlockIndex = contentBlockIndex
            self.delta = delta
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// The start of a tool use block.
    public struct ToolUseBlockStart {
        /// The name of the tool that the model is requesting to use.
        /// This member is required.
        public var name: Swift.String?
        /// The ID for the tool request.
        /// This member is required.
        public var toolUseId: Swift.String?

        public init(
            name: Swift.String? = nil,
            toolUseId: Swift.String? = nil
        )
        {
            self.name = name
            self.toolUseId = toolUseId
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// Content block start information.
    public enum ContentBlockStart {
        /// Information about a tool that the model is requesting to use.
        case tooluse(BedrockRuntimeClientTypes.ToolUseBlockStart)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockRuntimeClientTypes {
    /// Content block start event.
    public struct ContentBlockStartEvent {
        /// The index for a content block start event.
        /// This member is required.
        public var contentBlockIndex: Swift.Int?
        /// Start information about a content block start event.
        /// This member is required.
        public var start: BedrockRuntimeClientTypes.ContentBlockStart?

        public init(
            contentBlockIndex: Swift.Int? = nil,
            start: BedrockRuntimeClientTypes.ContentBlockStart? = nil
        )
        {
            self.contentBlockIndex = contentBlockIndex
            self.start = start
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// A content block stop event.
    public struct ContentBlockStopEvent {
        /// The index for a content block.
        /// This member is required.
        public var contentBlockIndex: Swift.Int?

        public init(
            contentBlockIndex: Swift.Int? = nil
        )
        {
            self.contentBlockIndex = contentBlockIndex
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// The start of a message.
    public struct MessageStartEvent {
        /// The role for the message.
        /// This member is required.
        public var role: BedrockRuntimeClientTypes.ConversationRole?

        public init(
            role: BedrockRuntimeClientTypes.ConversationRole? = nil
        )
        {
            self.role = role
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// The stop event for a message.
    public struct MessageStopEvent {
        /// The additional model response fields.
        public var additionalModelResponseFields: SmithyReadWrite.Document?
        /// The reason why the model stopped generating output.
        /// This member is required.
        public var stopReason: BedrockRuntimeClientTypes.StopReason?

        public init(
            additionalModelResponseFields: SmithyReadWrite.Document? = nil,
            stopReason: BedrockRuntimeClientTypes.StopReason? = nil
        )
        {
            self.additionalModelResponseFields = additionalModelResponseFields
            self.stopReason = stopReason
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// Metrics for the stream.
    public struct ConverseStreamMetrics {
        /// The latency for the streaming request, in milliseconds.
        /// This member is required.
        public var latencyMs: Swift.Int?

        public init(
            latencyMs: Swift.Int? = nil
        )
        {
            self.latencyMs = latencyMs
        }
    }

}

extension BedrockRuntimeClientTypes {
    /// A conversation stream metadata event.
    public struct ConverseStreamMetadataEvent {
        /// The metrics for the conversation stream metadata event.
        /// This member is required.
        public var metrics: BedrockRuntimeClientTypes.ConverseStreamMetrics?
        /// Usage information for the conversation stream event.
        /// This member is required.
        public var usage: BedrockRuntimeClientTypes.TokenUsage?

        public init(
            metrics: BedrockRuntimeClientTypes.ConverseStreamMetrics? = nil,
            usage: BedrockRuntimeClientTypes.TokenUsage? = nil
        )
        {
            self.metrics = metrics
            self.usage = usage
        }
    }

}

/// An error occurred while streaming the response. Retry your request.
public struct ModelStreamErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The original message.
        public internal(set) var originalMessage: Swift.String? = nil
        /// The original status code.
        public internal(set) var originalStatusCode: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelStreamErrorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        originalMessage: Swift.String? = nil,
        originalStatusCode: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.originalMessage = originalMessage
        self.properties.originalStatusCode = originalStatusCode
    }
}

extension BedrockRuntimeClientTypes {
    /// The messages output stream
    public enum ConverseStreamOutput {
        /// Message start information.
        case messagestart(BedrockRuntimeClientTypes.MessageStartEvent)
        /// Start information for a content block.
        case contentblockstart(BedrockRuntimeClientTypes.ContentBlockStartEvent)
        /// The messages output content block delta.
        case contentblockdelta(BedrockRuntimeClientTypes.ContentBlockDeltaEvent)
        /// Stop information for a content block.
        case contentblockstop(BedrockRuntimeClientTypes.ContentBlockStopEvent)
        /// Message stop information.
        case messagestop(BedrockRuntimeClientTypes.MessageStopEvent)
        /// Metadata for the converse output stream.
        case metadata(BedrockRuntimeClientTypes.ConverseStreamMetadataEvent)
        case sdkUnknown(Swift.String)
    }

}

public struct ConverseStreamOutput {
    /// The output stream that the model generated.
    public var stream: AsyncThrowingStream<BedrockRuntimeClientTypes.ConverseStreamOutput, Swift.Error>?

    public init(
        stream: AsyncThrowingStream<BedrockRuntimeClientTypes.ConverseStreamOutput, Swift.Error>? = nil
    )
    {
        self.stream = stream
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockRuntimeClientTypes {

    public enum Trace: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Trace] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct InvokeModelInput {
    /// The desired MIME type of the inference body in the response. The default value is application/json.
    public var accept: Swift.String?
    /// The prompt and inference parameters in the format specified in the contentType in the header. To see the format and content of the request and response bodies for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). For more information, see [Run inference](https://docs.aws.amazon.com/bedrock/latest/userguide/api-methods-run.html) in the Bedrock User Guide.
    /// This member is required.
    public var body: Foundation.Data?
    /// The MIME type of the input data in the request. The default value is application/json.
    public var contentType: Swift.String?
    /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error will be thrown in the following situations.
    ///
    /// * You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.
    ///
    /// * You enable the guardrail but the contentType isn't application/json.
    ///
    /// * You provide a guardrail identifier, but guardrailVersion isn't specified.
    public var guardrailIdentifier: Swift.String?
    /// The version number for the guardrail. The value can also be DRAFT.
    public var guardrailVersion: Swift.String?
    /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var modelId: Swift.String?
    /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
    public var trace: BedrockRuntimeClientTypes.Trace?

    public init(
        accept: Swift.String? = nil,
        body: Foundation.Data? = nil,
        contentType: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil,
        modelId: Swift.String? = nil,
        trace: BedrockRuntimeClientTypes.Trace? = nil
    )
    {
        self.accept = accept
        self.body = body
        self.contentType = contentType
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
        self.modelId = modelId
        self.trace = trace
    }
}

extension InvokeModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeModelInput(accept: \(Swift.String(describing: accept)), contentType: \(Swift.String(describing: contentType)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), guardrailVersion: \(Swift.String(describing: guardrailVersion)), modelId: \(Swift.String(describing: modelId)), trace: \(Swift.String(describing: trace)), body: \"CONTENT_REDACTED\")"}
}

public struct InvokeModelOutput {
    /// Inference response from the model in the format specified in the contentType header. To see the format and content of the request and response bodies for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    /// This member is required.
    public var body: Foundation.Data?
    /// The MIME type of the inference result.
    /// This member is required.
    public var contentType: Swift.String?

    public init(
        body: Foundation.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
    }
}

extension InvokeModelOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeModelOutput(contentType: \(Swift.String(describing: contentType)), body: \"CONTENT_REDACTED\")"}
}

public struct InvokeModelWithResponseStreamInput {
    /// The desired MIME type of the inference body in the response. The default value is application/json.
    public var accept: Swift.String?
    /// The prompt and inference parameters in the format specified in the contentType in the header. To see the format and content of the request and response bodies for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). For more information, see [Run inference](https://docs.aws.amazon.com/bedrock/latest/userguide/api-methods-run.html) in the Bedrock User Guide.
    /// This member is required.
    public var body: Foundation.Data?
    /// The MIME type of the input data in the request. The default value is application/json.
    public var contentType: Swift.String?
    /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error is thrown in the following situations.
    ///
    /// * You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.
    ///
    /// * You enable the guardrail but the contentType isn't application/json.
    ///
    /// * You provide a guardrail identifier, but guardrailVersion isn't specified.
    public var guardrailIdentifier: Swift.String?
    /// The version number for the guardrail. The value can also be DRAFT.
    public var guardrailVersion: Swift.String?
    /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var modelId: Swift.String?
    /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
    public var trace: BedrockRuntimeClientTypes.Trace?

    public init(
        accept: Swift.String? = nil,
        body: Foundation.Data? = nil,
        contentType: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil,
        modelId: Swift.String? = nil,
        trace: BedrockRuntimeClientTypes.Trace? = nil
    )
    {
        self.accept = accept
        self.body = body
        self.contentType = contentType
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
        self.modelId = modelId
        self.trace = trace
    }
}

extension InvokeModelWithResponseStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeModelWithResponseStreamInput(accept: \(Swift.String(describing: accept)), contentType: \(Swift.String(describing: contentType)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), guardrailVersion: \(Swift.String(describing: guardrailVersion)), modelId: \(Swift.String(describing: modelId)), trace: \(Swift.String(describing: trace)), body: \"CONTENT_REDACTED\")"}
}

extension BedrockRuntimeClientTypes {
    /// Payload content included in the response.
    public struct PayloadPart {
        /// Base64-encoded bytes of payload data.
        public var bytes: Foundation.Data?

        public init(
            bytes: Foundation.Data? = nil
        )
        {
            self.bytes = bytes
        }
    }

}

extension BedrockRuntimeClientTypes.PayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockRuntimeClientTypes {
    /// Definition of content in the response stream.
    public enum ResponseStream {
        /// Content included in the response.
        case chunk(BedrockRuntimeClientTypes.PayloadPart)
        case sdkUnknown(Swift.String)
    }

}

public struct InvokeModelWithResponseStreamOutput {
    /// Inference response from the model in the format specified by the contentType header. To see the format and content of this field for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    /// This member is required.
    public var body: AsyncThrowingStream<BedrockRuntimeClientTypes.ResponseStream, Swift.Error>?
    /// The MIME type of the inference result.
    /// This member is required.
    public var contentType: Swift.String?

    public init(
        body: AsyncThrowingStream<BedrockRuntimeClientTypes.ResponseStream, Swift.Error>? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
    }
}

extension ConverseInput {

    static func urlPathProvider(_ value: ConverseInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/converse"
    }
}

extension ConverseStreamInput {

    static func urlPathProvider(_ value: ConverseStreamInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/converse-stream"
    }
}

extension InvokeModelInput {

    static func urlPathProvider(_ value: InvokeModelInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/invoke"
    }
}

extension InvokeModelInput {

    static func headerProvider(_ value: InvokeModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(Header(name: "Accept", value: Swift.String(accept)))
        }
        if let contentType = value.contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            items.add(Header(name: "X-Amzn-Bedrock-GuardrailIdentifier", value: Swift.String(guardrailIdentifier)))
        }
        if let guardrailVersion = value.guardrailVersion {
            items.add(Header(name: "X-Amzn-Bedrock-GuardrailVersion", value: Swift.String(guardrailVersion)))
        }
        if let trace = value.trace {
            items.add(Header(name: "X-Amzn-Bedrock-Trace", value: Swift.String(trace.rawValue)))
        }
        return items
    }
}

extension InvokeModelWithResponseStreamInput {

    static func urlPathProvider(_ value: InvokeModelWithResponseStreamInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/invoke-with-response-stream"
    }
}

extension InvokeModelWithResponseStreamInput {

    static func headerProvider(_ value: InvokeModelWithResponseStreamInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(Header(name: "X-Amzn-Bedrock-Accept", value: Swift.String(accept)))
        }
        if let contentType = value.contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            items.add(Header(name: "X-Amzn-Bedrock-GuardrailIdentifier", value: Swift.String(guardrailIdentifier)))
        }
        if let guardrailVersion = value.guardrailVersion {
            items.add(Header(name: "X-Amzn-Bedrock-GuardrailVersion", value: Swift.String(guardrailVersion)))
        }
        if let trace = value.trace {
            items.add(Header(name: "X-Amzn-Bedrock-Trace", value: Swift.String(trace.rawValue)))
        }
        return items
    }
}

extension ConverseInput {

    static func write(value: ConverseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].write(value.additionalModelRequestFields)
        try writer["additionalModelResponseFieldPaths"].writeList(value.additionalModelResponseFieldPaths, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockRuntimeClientTypes.InferenceConfiguration.write(value:to:))
        try writer["messages"].writeList(value.messages, memberWritingClosure: BedrockRuntimeClientTypes.Message.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["system"].writeList(value.system, memberWritingClosure: BedrockRuntimeClientTypes.SystemContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["toolConfig"].write(value.toolConfig, with: BedrockRuntimeClientTypes.ToolConfiguration.write(value:to:))
    }
}

extension ConverseStreamInput {

    static func write(value: ConverseStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].write(value.additionalModelRequestFields)
        try writer["additionalModelResponseFieldPaths"].writeList(value.additionalModelResponseFieldPaths, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockRuntimeClientTypes.InferenceConfiguration.write(value:to:))
        try writer["messages"].writeList(value.messages, memberWritingClosure: BedrockRuntimeClientTypes.Message.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["system"].writeList(value.system, memberWritingClosure: BedrockRuntimeClientTypes.SystemContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["toolConfig"].write(value.toolConfig, with: BedrockRuntimeClientTypes.ToolConfiguration.write(value:to:))
    }
}

extension InvokeModelInput {

    static func write(value: InvokeModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension InvokeModelWithResponseStreamInput {

    static func write(value: InvokeModelWithResponseStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension ConverseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ConverseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConverseOutput()
        value.additionalModelResponseFields = try reader["additionalModelResponseFields"].readIfPresent()
        value.metrics = try reader["metrics"].readIfPresent(with: BedrockRuntimeClientTypes.ConverseMetrics.read(from:))
        value.output = try reader["output"].readIfPresent(with: BedrockRuntimeClientTypes.ConverseOutput.read(from:))
        value.stopReason = try reader["stopReason"].readIfPresent()
        value.usage = try reader["usage"].readIfPresent(with: BedrockRuntimeClientTypes.TokenUsage.read(from:))
        return value
    }
}

extension ConverseStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ConverseStreamOutput {
        var value = ConverseStreamOutput()
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockRuntimeClientTypes.ConverseStreamOutput.unmarshal)
            value.stream = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension InvokeModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> InvokeModelOutput {
        var value = InvokeModelOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.body = data
        case .stream(let stream):
            value.body = try stream.readToEnd()
        case .noStream:
            value.body = nil
        }
        return value
    }
}

extension InvokeModelWithResponseStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> InvokeModelWithResponseStreamOutput {
        var value = InvokeModelWithResponseStreamOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "X-Amzn-Bedrock-Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockRuntimeClientTypes.ResponseStream.unmarshal)
            value.body = decoderStream.toAsyncStream()
        }
        return value
    }
}

enum ConverseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConverseStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeModelWithResponseStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelStreamErrorException": return try ModelStreamErrorException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ModelTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelTimeoutException {
        let reader = baseError.errorBodyReader
        var value = ModelTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelNotReadyException {
        let reader = baseError.errorBodyReader
        var value = ModelNotReadyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelErrorException {
        let reader = baseError.errorBodyReader
        var value = ModelErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.originalStatusCode = try reader["originalStatusCode"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelStreamErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelStreamErrorException {
        let reader = baseError.errorBodyReader
        var value = ModelStreamErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.originalMessage = try reader["originalMessage"].readIfPresent()
        value.properties.originalStatusCode = try reader["originalStatusCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseStreamOutput {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockRuntimeClientTypes.ConverseStreamOutput> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "messageStart":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.MessageStartEvent.read(from:))
                    return .messagestart(value)
                case "contentBlockStart":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.ContentBlockStartEvent.read(from:))
                    return .contentblockstart(value)
                case "contentBlockDelta":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.ContentBlockDeltaEvent.read(from:))
                    return .contentblockdelta(value)
                case "contentBlockStop":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.ContentBlockStopEvent.read(from:))
                    return .contentblockstop(value)
                case "messageStop":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.MessageStopEvent.read(from:))
                    return .messagestop(value)
                case "metadata":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.ConverseStreamMetadataEvent.read(from:))
                    return .metadata(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "modelStreamErrorException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelStreamErrorException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HttpResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HttpResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockRuntimeClientTypes.ResponseStream {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockRuntimeClientTypes.ResponseStream> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "chunk":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.PayloadPart.read(from:))
                    return .chunk(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "modelStreamErrorException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelStreamErrorException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "modelTimeoutException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelTimeoutException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HttpResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HttpResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockRuntimeClientTypes.ConverseOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "message":
                return .message(try reader["message"].read(with: BedrockRuntimeClientTypes.Message.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.Message {

    static func write(value: BedrockRuntimeClientTypes.Message?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].writeList(value.content, memberWritingClosure: BedrockRuntimeClientTypes.ContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["role"].write(value.role)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.Message {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.Message()
        value.role = try reader["role"].readIfPresent()
        value.content = try reader["content"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.ContentBlock.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlock {

    static func write(value: BedrockRuntimeClientTypes.ContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .image(image):
                try writer["image"].write(image, with: BedrockRuntimeClientTypes.ImageBlock.write(value:to:))
            case let .text(text):
                try writer["text"].write(text)
            case let .toolresult(toolresult):
                try writer["toolResult"].write(toolresult, with: BedrockRuntimeClientTypes.ToolResultBlock.write(value:to:))
            case let .tooluse(tooluse):
                try writer["toolUse"].write(tooluse, with: BedrockRuntimeClientTypes.ToolUseBlock.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            case "image":
                return .image(try reader["image"].read(with: BedrockRuntimeClientTypes.ImageBlock.read(from:)))
            case "toolUse":
                return .tooluse(try reader["toolUse"].read(with: BedrockRuntimeClientTypes.ToolUseBlock.read(from:)))
            case "toolResult":
                return .toolresult(try reader["toolResult"].read(with: BedrockRuntimeClientTypes.ToolResultBlock.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.ToolResultBlock {

    static func write(value: BedrockRuntimeClientTypes.ToolResultBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].writeList(value.content, memberWritingClosure: BedrockRuntimeClientTypes.ToolResultContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["status"].write(value.status)
        try writer["toolUseId"].write(value.toolUseId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolResultBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ToolResultBlock()
        value.toolUseId = try reader["toolUseId"].readIfPresent()
        value.content = try reader["content"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.ToolResultContentBlock.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ToolResultContentBlock {

    static func write(value: BedrockRuntimeClientTypes.ToolResultContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .image(image):
                try writer["image"].write(image, with: BedrockRuntimeClientTypes.ImageBlock.write(value:to:))
            case let .json(json):
                try writer["json"].write(json)
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolResultContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "json":
                return .json(try reader["json"].read())
            case "text":
                return .text(try reader["text"].read())
            case "image":
                return .image(try reader["image"].read(with: BedrockRuntimeClientTypes.ImageBlock.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.ImageBlock {

    static func write(value: BedrockRuntimeClientTypes.ImageBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
        try writer["source"].write(value.source, with: BedrockRuntimeClientTypes.ImageSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ImageBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ImageBlock()
        value.format = try reader["format"].readIfPresent()
        value.source = try reader["source"].readIfPresent(with: BedrockRuntimeClientTypes.ImageSource.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.ImageSource {

    static func write(value: BedrockRuntimeClientTypes.ImageSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bytes(bytes):
                try writer["bytes"].write(bytes)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ImageSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bytes":
                return .bytes(try reader["bytes"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.ToolUseBlock {

    static func write(value: BedrockRuntimeClientTypes.ToolUseBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["input"].write(value.input)
        try writer["name"].write(value.name)
        try writer["toolUseId"].write(value.toolUseId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolUseBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ToolUseBlock()
        value.toolUseId = try reader["toolUseId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.input = try reader["input"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.TokenUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.TokenUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.TokenUsage()
        value.inputTokens = try reader["inputTokens"].readIfPresent()
        value.outputTokens = try reader["outputTokens"].readIfPresent()
        value.totalTokens = try reader["totalTokens"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ConverseMetrics()
        value.latencyMs = try reader["latencyMs"].readIfPresent()
        return value
    }
}

extension ThrottlingException {

    static func read(from reader: SmithyJSON.Reader) throws -> ThrottlingException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ValidationException {

    static func read(from reader: SmithyJSON.Reader) throws -> ValidationException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ModelStreamErrorException {

    static func read(from reader: SmithyJSON.Reader) throws -> ModelStreamErrorException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ModelStreamErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.originalStatusCode = try reader["originalStatusCode"].readIfPresent()
        value.properties.originalMessage = try reader["originalMessage"].readIfPresent()
        return value
    }
}

extension InternalServerException {

    static func read(from reader: SmithyJSON.Reader) throws -> InternalServerException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseStreamMetadataEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseStreamMetadataEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ConverseStreamMetadataEvent()
        value.usage = try reader["usage"].readIfPresent(with: BedrockRuntimeClientTypes.TokenUsage.read(from:))
        value.metrics = try reader["metrics"].readIfPresent(with: BedrockRuntimeClientTypes.ConverseStreamMetrics.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseStreamMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseStreamMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ConverseStreamMetrics()
        value.latencyMs = try reader["latencyMs"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.MessageStopEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.MessageStopEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.MessageStopEvent()
        value.stopReason = try reader["stopReason"].readIfPresent()
        value.additionalModelResponseFields = try reader["additionalModelResponseFields"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockStopEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockStopEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ContentBlockStopEvent()
        value.contentBlockIndex = try reader["contentBlockIndex"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockDeltaEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockDeltaEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ContentBlockDeltaEvent()
        value.delta = try reader["delta"].readIfPresent(with: BedrockRuntimeClientTypes.ContentBlockDelta.read(from:))
        value.contentBlockIndex = try reader["contentBlockIndex"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockDelta {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockDelta {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            case "toolUse":
                return .tooluse(try reader["toolUse"].read(with: BedrockRuntimeClientTypes.ToolUseBlockDelta.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.ToolUseBlockDelta {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolUseBlockDelta {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ToolUseBlockDelta()
        value.input = try reader["input"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockStartEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockStartEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ContentBlockStartEvent()
        value.start = try reader["start"].readIfPresent(with: BedrockRuntimeClientTypes.ContentBlockStart.read(from:))
        value.contentBlockIndex = try reader["contentBlockIndex"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockStart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockStart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "toolUse":
                return .tooluse(try reader["toolUse"].read(with: BedrockRuntimeClientTypes.ToolUseBlockStart.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.ToolUseBlockStart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolUseBlockStart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ToolUseBlockStart()
        value.toolUseId = try reader["toolUseId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.MessageStartEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.MessageStartEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.MessageStartEvent()
        value.role = try reader["role"].readIfPresent()
        return value
    }
}

extension ModelTimeoutException {

    static func read(from reader: SmithyJSON.Reader) throws -> ModelTimeoutException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ModelTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.PayloadPart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.PayloadPart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.PayloadPart()
        value.bytes = try reader["bytes"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.SystemContentBlock {

    static func write(value: BedrockRuntimeClientTypes.SystemContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockRuntimeClientTypes.InferenceConfiguration {

    static func write(value: BedrockRuntimeClientTypes.InferenceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topP"].write(value.topp)
    }
}

extension BedrockRuntimeClientTypes.ToolConfiguration {

    static func write(value: BedrockRuntimeClientTypes.ToolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["toolChoice"].write(value.toolChoice, with: BedrockRuntimeClientTypes.ToolChoice.write(value:to:))
        try writer["tools"].writeList(value.tools, memberWritingClosure: BedrockRuntimeClientTypes.Tool.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockRuntimeClientTypes.ToolChoice {

    static func write(value: BedrockRuntimeClientTypes.ToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .any(any):
                try writer["any"].write(any, with: BedrockRuntimeClientTypes.AnyToolChoice.write(value:to:))
            case let .auto(auto):
                try writer["auto"].write(auto, with: BedrockRuntimeClientTypes.AutoToolChoice.write(value:to:))
            case let .tool(tool):
                try writer["tool"].write(tool, with: BedrockRuntimeClientTypes.SpecificToolChoice.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockRuntimeClientTypes.SpecificToolChoice {

    static func write(value: BedrockRuntimeClientTypes.SpecificToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension BedrockRuntimeClientTypes.AnyToolChoice {

    static func write(value: BedrockRuntimeClientTypes.AnyToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension BedrockRuntimeClientTypes.AutoToolChoice {

    static func write(value: BedrockRuntimeClientTypes.AutoToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension BedrockRuntimeClientTypes.Tool {

    static func write(value: BedrockRuntimeClientTypes.Tool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .toolspec(toolspec):
                try writer["toolSpec"].write(toolspec, with: BedrockRuntimeClientTypes.ToolSpecification.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockRuntimeClientTypes.ToolSpecification {

    static func write(value: BedrockRuntimeClientTypes.ToolSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["inputSchema"].write(value.inputSchema, with: BedrockRuntimeClientTypes.ToolInputSchema.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension BedrockRuntimeClientTypes.ToolInputSchema {

    static func write(value: BedrockRuntimeClientTypes.ToolInputSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .json(json):
                try writer["json"].write(json)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

public enum BedrockRuntimeClientTypes {}
