// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum BedrockRuntimeClientTypes {}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func read(from reader: SmithyJSON.Reader) throws -> InternalServerException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvokeModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeModelInput(accept: \(Swift.String(describing: accept)), contentType: \(Swift.String(describing: contentType)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), guardrailVersion: \(Swift.String(describing: guardrailVersion)), modelId: \(Swift.String(describing: modelId)), trace: \(Swift.String(describing: trace)), body: \"CONTENT_REDACTED\")"}
}

extension InvokeModelInput {

    static func headerProvider(_ value: InvokeModelInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = value.accept {
            items.add(Header(name: "Accept", value: Swift.String(accept)))
        }
        if let contentType = value.contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            items.add(Header(name: "X-Amzn-Bedrock-GuardrailIdentifier", value: Swift.String(guardrailIdentifier)))
        }
        if let guardrailVersion = value.guardrailVersion {
            items.add(Header(name: "X-Amzn-Bedrock-GuardrailVersion", value: Swift.String(guardrailVersion)))
        }
        if let trace = value.trace {
            items.add(Header(name: "X-Amzn-Bedrock-Trace", value: Swift.String(trace.rawValue)))
        }
        return items
    }
}

extension InvokeModelInput {

    static func urlPathProvider(_ value: InvokeModelInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/invoke"
    }
}

extension InvokeModelInput {

    static func write(value: InvokeModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

public struct InvokeModelInput {
    /// The desired MIME type of the inference body in the response. The default value is application/json.
    public var accept: Swift.String?
    /// The prompt and inference parameters in the format specified in the contentType in the header. To see the format and content of the request and response bodies for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). For more information, see [Run inference](https://docs.aws.amazon.com/bedrock/latest/userguide/api-methods-run.html) in the Bedrock User Guide.
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// The MIME type of the input data in the request. The default value is application/json.
    public var contentType: Swift.String?
    /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error will be thrown in the following situations.
    ///
    /// * You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.
    ///
    /// * You enable the guardrail but the contentType isn't application/json.
    ///
    /// * You provide a guardrail identifier, but guardrailVersion isn't specified.
    public var guardrailIdentifier: Swift.String?
    /// The version number for the guardrail. The value can also be DRAFT.
    public var guardrailVersion: Swift.String?
    /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var modelId: Swift.String?
    /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
    public var trace: BedrockRuntimeClientTypes.Trace?

    public init(
        accept: Swift.String? = nil,
        body: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil,
        modelId: Swift.String? = nil,
        trace: BedrockRuntimeClientTypes.Trace? = nil
    )
    {
        self.accept = accept
        self.body = body
        self.contentType = contentType
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
        self.modelId = modelId
        self.trace = trace
    }
}

extension InvokeModelOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeModelOutput(contentType: \(Swift.String(describing: contentType)), body: \"CONTENT_REDACTED\")"}
}

extension InvokeModelOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> InvokeModelOutput {
        var value = InvokeModelOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.body = data
        case .stream(let stream):
            value.body = try stream.readToEnd()
        case .noStream:
            value.body = nil
        }
        return value
    }
}

public struct InvokeModelOutput {
    /// Inference response from the model in the format specified in the contentType header. To see the format and content of the request and response bodies for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// The MIME type of the inference result.
    /// This member is required.
    public var contentType: Swift.String?

    public init(
        body: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
    }
}

enum InvokeModelOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvokeModelWithResponseStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeModelWithResponseStreamInput(accept: \(Swift.String(describing: accept)), contentType: \(Swift.String(describing: contentType)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), guardrailVersion: \(Swift.String(describing: guardrailVersion)), modelId: \(Swift.String(describing: modelId)), trace: \(Swift.String(describing: trace)), body: \"CONTENT_REDACTED\")"}
}

extension InvokeModelWithResponseStreamInput {

    static func headerProvider(_ value: InvokeModelWithResponseStreamInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = value.accept {
            items.add(Header(name: "X-Amzn-Bedrock-Accept", value: Swift.String(accept)))
        }
        if let contentType = value.contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            items.add(Header(name: "X-Amzn-Bedrock-GuardrailIdentifier", value: Swift.String(guardrailIdentifier)))
        }
        if let guardrailVersion = value.guardrailVersion {
            items.add(Header(name: "X-Amzn-Bedrock-GuardrailVersion", value: Swift.String(guardrailVersion)))
        }
        if let trace = value.trace {
            items.add(Header(name: "X-Amzn-Bedrock-Trace", value: Swift.String(trace.rawValue)))
        }
        return items
    }
}

extension InvokeModelWithResponseStreamInput {

    static func urlPathProvider(_ value: InvokeModelWithResponseStreamInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/invoke-with-response-stream"
    }
}

extension InvokeModelWithResponseStreamInput {

    static func write(value: InvokeModelWithResponseStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

public struct InvokeModelWithResponseStreamInput {
    /// The desired MIME type of the inference body in the response. The default value is application/json.
    public var accept: Swift.String?
    /// The prompt and inference parameters in the format specified in the contentType in the header. To see the format and content of the request and response bodies for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). For more information, see [Run inference](https://docs.aws.amazon.com/bedrock/latest/userguide/api-methods-run.html) in the Bedrock User Guide.
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// The MIME type of the input data in the request. The default value is application/json.
    public var contentType: Swift.String?
    /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error is thrown in the following situations.
    ///
    /// * You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.
    ///
    /// * You enable the guardrail but the contentType isn't application/json.
    ///
    /// * You provide a guardrail identifier, but guardrailVersion isn't specified.
    public var guardrailIdentifier: Swift.String?
    /// The version number for the guardrail. The value can also be DRAFT.
    public var guardrailVersion: Swift.String?
    /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var modelId: Swift.String?
    /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
    public var trace: BedrockRuntimeClientTypes.Trace?

    public init(
        accept: Swift.String? = nil,
        body: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil,
        modelId: Swift.String? = nil,
        trace: BedrockRuntimeClientTypes.Trace? = nil
    )
    {
        self.accept = accept
        self.body = body
        self.contentType = contentType
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
        self.modelId = modelId
        self.trace = trace
    }
}

extension InvokeModelWithResponseStreamOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> InvokeModelWithResponseStreamOutput {
        var value = InvokeModelWithResponseStreamOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "X-Amzn-Bedrock-Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = AWSClientRuntime.AWSEventStream.AWSMessageDecoder()
            let decoderStream = ClientRuntime.EventStream.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockRuntimeClientTypes.ResponseStream.unmarshal)
            value.body = decoderStream.toAsyncStream()
        }
        return value
    }
}

public struct InvokeModelWithResponseStreamOutput {
    /// Inference response from the model in the format specified by the contentType header. To see the format and content of this field for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    /// This member is required.
    public var body: AsyncThrowingStream<BedrockRuntimeClientTypes.ResponseStream, Swift.Error>?
    /// The MIME type of the inference result.
    /// This member is required.
    public var contentType: Swift.String?

    public init(
        body: AsyncThrowingStream<BedrockRuntimeClientTypes.ResponseStream, Swift.Error>? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
    }
}

enum InvokeModelWithResponseStreamOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelStreamErrorException": return try ModelStreamErrorException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ModelErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelErrorException {
        let reader = baseError.errorBodyReader
        var value = ModelErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.originalStatusCode = try reader["originalStatusCode"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request failed due to an error while processing the model.
public struct ModelErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The original status code.
        public internal(set) var originalStatusCode: Swift.Int? = nil
        /// The resource name.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelErrorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        originalStatusCode: Swift.Int? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.originalStatusCode = originalStatusCode
        self.properties.resourceName = resourceName
    }
}

extension ModelNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelNotReadyException {
        let reader = baseError.errorBodyReader
        var value = ModelNotReadyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The model specified in the request is not ready to serve inference requests.
public struct ModelNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelNotReadyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ModelStreamErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelStreamErrorException {
        let reader = baseError.errorBodyReader
        var value = ModelStreamErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.originalMessage = try reader["originalMessage"].readIfPresent()
        value.properties.originalStatusCode = try reader["originalStatusCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelStreamErrorException {

    static func read(from reader: SmithyJSON.Reader) throws -> ModelStreamErrorException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ModelStreamErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.originalStatusCode = try reader["originalStatusCode"].readIfPresent()
        value.properties.originalMessage = try reader["originalMessage"].readIfPresent()
        return value
    }
}

/// An error occurred while streaming the response. Retry your request.
public struct ModelStreamErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The original message.
        public internal(set) var originalMessage: Swift.String? = nil
        /// The original status code.
        public internal(set) var originalStatusCode: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelStreamErrorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        originalMessage: Swift.String? = nil,
        originalStatusCode: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.originalMessage = originalMessage
        self.properties.originalStatusCode = originalStatusCode
    }
}

extension ModelTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelTimeoutException {
        let reader = baseError.errorBodyReader
        var value = ModelTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelTimeoutException {

    static func read(from reader: SmithyJSON.Reader) throws -> ModelTimeoutException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ModelTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// The request took too long to process. Processing time exceeded the model timeout length.
public struct ModelTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelTimeoutException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockRuntimeClientTypes.PayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockRuntimeClientTypes.PayloadPart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.PayloadPart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.PayloadPart()
        value.bytes = try reader["bytes"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes {
    /// Payload content included in the response.
    public struct PayloadPart {
        /// Base64-encoded bytes of payload data.
        public var bytes: ClientRuntime.Data?

        public init(
            bytes: ClientRuntime.Data? = nil
        )
        {
            self.bytes = bytes
        }
    }

}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified resource ARN was not found. Check the ARN and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockRuntimeClientTypes.ResponseStream {
    static var unmarshal: ClientRuntime.UnmarshalClosure<BedrockRuntimeClientTypes.ResponseStream> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "chunk":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.PayloadPart.read(from:))
                    return .chunk(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (ClientRuntime.EventStream.Message, ClientRuntime.EventStream.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "modelStreamErrorException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelStreamErrorException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "modelTimeoutException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelTimeoutException.read(from:))
                        return value
                    default:
                        let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = HttpResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw ClientRuntime.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockRuntimeClientTypes {
    /// Definition of content in the response stream.
    public enum ResponseStream {
        /// Content included in the response.
        case chunk(BedrockRuntimeClientTypes.PayloadPart)
        case sdkUnknown(Swift.String)
    }

}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func read(from reader: SmithyJSON.Reader) throws -> ThrottlingException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockRuntimeClientTypes {

    public enum Trace: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Trace] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func read(from reader: SmithyJSON.Reader) throws -> ValidationException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
