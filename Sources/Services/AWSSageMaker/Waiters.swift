// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SageMakerClientProtocol {

    static func endpointDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeEndpointInput, DescribeEndpointOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeEndpointInput, DescribeEndpointOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeEndpointInput, result: Result<DescribeEndpointOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
            .init(state: .failure, matcher: { (input: DescribeEndpointInput, result: Result<DescribeEndpointOutputResponse, Error>) -> Bool in
                // JMESPath expression: "EndpointStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let endpointStatus = output.endpointStatus
                return JMESUtils.compare(endpointStatus, ==, "Failed")
            }),
        ]
        return try WaiterConfiguration<DescribeEndpointInput, DescribeEndpointOutputResponse>(acceptors: acceptors, minDelay: 30.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the EndpointDeleted event on the describeEndpoint operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeEndpointInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilEndpointDeleted(options: WaiterOptions, input: DescribeEndpointInput) async throws -> WaiterOutcome<DescribeEndpointOutputResponse> {
        let waiter = Waiter(config: try Self.endpointDeletedWaiterConfig(), operation: self.describeEndpoint(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func endpointInServiceWaiterConfig() throws -> WaiterConfiguration<DescribeEndpointInput, DescribeEndpointOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeEndpointInput, DescribeEndpointOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeEndpointInput, result: Result<DescribeEndpointOutputResponse, Error>) -> Bool in
                // JMESPath expression: "EndpointStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "InService"
                guard case .success(let output) = result else { return false }
                let endpointStatus = output.endpointStatus
                return JMESUtils.compare(endpointStatus, ==, "InService")
            }),
            .init(state: .failure, matcher: { (input: DescribeEndpointInput, result: Result<DescribeEndpointOutputResponse, Error>) -> Bool in
                // JMESPath expression: "EndpointStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let endpointStatus = output.endpointStatus
                return JMESUtils.compare(endpointStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeEndpointInput, result: Result<DescribeEndpointOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
        ]
        return try WaiterConfiguration<DescribeEndpointInput, DescribeEndpointOutputResponse>(acceptors: acceptors, minDelay: 30.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the EndpointInService event on the describeEndpoint operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeEndpointInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilEndpointInService(options: WaiterOptions, input: DescribeEndpointInput) async throws -> WaiterOutcome<DescribeEndpointOutputResponse> {
        let waiter = Waiter(config: try Self.endpointInServiceWaiterConfig(), operation: self.describeEndpoint(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func imageCreatedWaiterConfig() throws -> WaiterConfiguration<DescribeImageInput, DescribeImageOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeImageInput, DescribeImageOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImageInput, result: Result<DescribeImageOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImageStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATED"
                guard case .success(let output) = result else { return false }
                let imageStatus = output.imageStatus
                return JMESUtils.compare(imageStatus, ==, "CREATED")
            }),
            .init(state: .failure, matcher: { (input: DescribeImageInput, result: Result<DescribeImageOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImageStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_FAILED"
                guard case .success(let output) = result else { return false }
                let imageStatus = output.imageStatus
                return JMESUtils.compare(imageStatus, ==, "CREATE_FAILED")
            }),
            .init(state: .failure, matcher: { (input: DescribeImageInput, result: Result<DescribeImageOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
        ]
        return try WaiterConfiguration<DescribeImageInput, DescribeImageOutputResponse>(acceptors: acceptors, minDelay: 60.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ImageCreated event on the describeImage operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImageInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilImageCreated(options: WaiterOptions, input: DescribeImageInput) async throws -> WaiterOutcome<DescribeImageOutputResponse> {
        let waiter = Waiter(config: try Self.imageCreatedWaiterConfig(), operation: self.describeImage(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func imageDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeImageInput, DescribeImageOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeImageInput, DescribeImageOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImageInput, result: Result<DescribeImageOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ResourceNotFoundException"
            }),
            .init(state: .failure, matcher: { (input: DescribeImageInput, result: Result<DescribeImageOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImageStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETE_FAILED"
                guard case .success(let output) = result else { return false }
                let imageStatus = output.imageStatus
                return JMESUtils.compare(imageStatus, ==, "DELETE_FAILED")
            }),
            .init(state: .failure, matcher: { (input: DescribeImageInput, result: Result<DescribeImageOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
        ]
        return try WaiterConfiguration<DescribeImageInput, DescribeImageOutputResponse>(acceptors: acceptors, minDelay: 60.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ImageDeleted event on the describeImage operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImageInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilImageDeleted(options: WaiterOptions, input: DescribeImageInput) async throws -> WaiterOutcome<DescribeImageOutputResponse> {
        let waiter = Waiter(config: try Self.imageDeletedWaiterConfig(), operation: self.describeImage(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func imageUpdatedWaiterConfig() throws -> WaiterConfiguration<DescribeImageInput, DescribeImageOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeImageInput, DescribeImageOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImageInput, result: Result<DescribeImageOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImageStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATED"
                guard case .success(let output) = result else { return false }
                let imageStatus = output.imageStatus
                return JMESUtils.compare(imageStatus, ==, "CREATED")
            }),
            .init(state: .failure, matcher: { (input: DescribeImageInput, result: Result<DescribeImageOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImageStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "UPDATE_FAILED"
                guard case .success(let output) = result else { return false }
                let imageStatus = output.imageStatus
                return JMESUtils.compare(imageStatus, ==, "UPDATE_FAILED")
            }),
            .init(state: .failure, matcher: { (input: DescribeImageInput, result: Result<DescribeImageOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
        ]
        return try WaiterConfiguration<DescribeImageInput, DescribeImageOutputResponse>(acceptors: acceptors, minDelay: 60.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ImageUpdated event on the describeImage operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImageInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilImageUpdated(options: WaiterOptions, input: DescribeImageInput) async throws -> WaiterOutcome<DescribeImageOutputResponse> {
        let waiter = Waiter(config: try Self.imageUpdatedWaiterConfig(), operation: self.describeImage(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func imageVersionCreatedWaiterConfig() throws -> WaiterConfiguration<DescribeImageVersionInput, DescribeImageVersionOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeImageVersionInput, DescribeImageVersionOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImageVersionInput, result: Result<DescribeImageVersionOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImageVersionStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATED"
                guard case .success(let output) = result else { return false }
                let imageVersionStatus = output.imageVersionStatus
                return JMESUtils.compare(imageVersionStatus, ==, "CREATED")
            }),
            .init(state: .failure, matcher: { (input: DescribeImageVersionInput, result: Result<DescribeImageVersionOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImageVersionStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "CREATE_FAILED"
                guard case .success(let output) = result else { return false }
                let imageVersionStatus = output.imageVersionStatus
                return JMESUtils.compare(imageVersionStatus, ==, "CREATE_FAILED")
            }),
            .init(state: .failure, matcher: { (input: DescribeImageVersionInput, result: Result<DescribeImageVersionOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
        ]
        return try WaiterConfiguration<DescribeImageVersionInput, DescribeImageVersionOutputResponse>(acceptors: acceptors, minDelay: 60.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ImageVersionCreated event on the describeImageVersion operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImageVersionInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilImageVersionCreated(options: WaiterOptions, input: DescribeImageVersionInput) async throws -> WaiterOutcome<DescribeImageVersionOutputResponse> {
        let waiter = Waiter(config: try Self.imageVersionCreatedWaiterConfig(), operation: self.describeImageVersion(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func imageVersionDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeImageVersionInput, DescribeImageVersionOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeImageVersionInput, DescribeImageVersionOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeImageVersionInput, result: Result<DescribeImageVersionOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ResourceNotFoundException"
            }),
            .init(state: .failure, matcher: { (input: DescribeImageVersionInput, result: Result<DescribeImageVersionOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ImageVersionStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "DELETE_FAILED"
                guard case .success(let output) = result else { return false }
                let imageVersionStatus = output.imageVersionStatus
                return JMESUtils.compare(imageVersionStatus, ==, "DELETE_FAILED")
            }),
            .init(state: .failure, matcher: { (input: DescribeImageVersionInput, result: Result<DescribeImageVersionOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
        ]
        return try WaiterConfiguration<DescribeImageVersionInput, DescribeImageVersionOutputResponse>(acceptors: acceptors, minDelay: 60.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ImageVersionDeleted event on the describeImageVersion operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeImageVersionInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilImageVersionDeleted(options: WaiterOptions, input: DescribeImageVersionInput) async throws -> WaiterOutcome<DescribeImageVersionOutputResponse> {
        let waiter = Waiter(config: try Self.imageVersionDeletedWaiterConfig(), operation: self.describeImageVersion(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func notebookInstanceDeletedWaiterConfig() throws -> WaiterConfiguration<DescribeNotebookInstanceInput, DescribeNotebookInstanceOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeNotebookInstanceInput, DescribeNotebookInstanceOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNotebookInstanceInput, result: Result<DescribeNotebookInstanceOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
            .init(state: .failure, matcher: { (input: DescribeNotebookInstanceInput, result: Result<DescribeNotebookInstanceOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NotebookInstanceStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let notebookInstanceStatus = output.notebookInstanceStatus
                return JMESUtils.compare(notebookInstanceStatus, ==, "Failed")
            }),
        ]
        return try WaiterConfiguration<DescribeNotebookInstanceInput, DescribeNotebookInstanceOutputResponse>(acceptors: acceptors, minDelay: 30.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NotebookInstanceDeleted event on the describeNotebookInstance operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNotebookInstanceInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNotebookInstanceDeleted(options: WaiterOptions, input: DescribeNotebookInstanceInput) async throws -> WaiterOutcome<DescribeNotebookInstanceOutputResponse> {
        let waiter = Waiter(config: try Self.notebookInstanceDeletedWaiterConfig(), operation: self.describeNotebookInstance(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func notebookInstanceInServiceWaiterConfig() throws -> WaiterConfiguration<DescribeNotebookInstanceInput, DescribeNotebookInstanceOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeNotebookInstanceInput, DescribeNotebookInstanceOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNotebookInstanceInput, result: Result<DescribeNotebookInstanceOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NotebookInstanceStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "InService"
                guard case .success(let output) = result else { return false }
                let notebookInstanceStatus = output.notebookInstanceStatus
                return JMESUtils.compare(notebookInstanceStatus, ==, "InService")
            }),
            .init(state: .failure, matcher: { (input: DescribeNotebookInstanceInput, result: Result<DescribeNotebookInstanceOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NotebookInstanceStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let notebookInstanceStatus = output.notebookInstanceStatus
                return JMESUtils.compare(notebookInstanceStatus, ==, "Failed")
            }),
        ]
        return try WaiterConfiguration<DescribeNotebookInstanceInput, DescribeNotebookInstanceOutputResponse>(acceptors: acceptors, minDelay: 30.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NotebookInstanceInService event on the describeNotebookInstance operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNotebookInstanceInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNotebookInstanceInService(options: WaiterOptions, input: DescribeNotebookInstanceInput) async throws -> WaiterOutcome<DescribeNotebookInstanceOutputResponse> {
        let waiter = Waiter(config: try Self.notebookInstanceInServiceWaiterConfig(), operation: self.describeNotebookInstance(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func notebookInstanceStoppedWaiterConfig() throws -> WaiterConfiguration<DescribeNotebookInstanceInput, DescribeNotebookInstanceOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeNotebookInstanceInput, DescribeNotebookInstanceOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeNotebookInstanceInput, result: Result<DescribeNotebookInstanceOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NotebookInstanceStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Stopped"
                guard case .success(let output) = result else { return false }
                let notebookInstanceStatus = output.notebookInstanceStatus
                return JMESUtils.compare(notebookInstanceStatus, ==, "Stopped")
            }),
            .init(state: .failure, matcher: { (input: DescribeNotebookInstanceInput, result: Result<DescribeNotebookInstanceOutputResponse, Error>) -> Bool in
                // JMESPath expression: "NotebookInstanceStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let notebookInstanceStatus = output.notebookInstanceStatus
                return JMESUtils.compare(notebookInstanceStatus, ==, "Failed")
            }),
        ]
        return try WaiterConfiguration<DescribeNotebookInstanceInput, DescribeNotebookInstanceOutputResponse>(acceptors: acceptors, minDelay: 30.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the NotebookInstanceStopped event on the describeNotebookInstance operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeNotebookInstanceInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilNotebookInstanceStopped(options: WaiterOptions, input: DescribeNotebookInstanceInput) async throws -> WaiterOutcome<DescribeNotebookInstanceOutputResponse> {
        let waiter = Waiter(config: try Self.notebookInstanceStoppedWaiterConfig(), operation: self.describeNotebookInstance(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func processingJobCompletedOrStoppedWaiterConfig() throws -> WaiterConfiguration<DescribeProcessingJobInput, DescribeProcessingJobOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeProcessingJobInput, DescribeProcessingJobOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeProcessingJobInput, result: Result<DescribeProcessingJobOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ProcessingJobStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Completed"
                guard case .success(let output) = result else { return false }
                let processingJobStatus = output.processingJobStatus
                return JMESUtils.compare(processingJobStatus, ==, "Completed")
            }),
            .init(state: .success, matcher: { (input: DescribeProcessingJobInput, result: Result<DescribeProcessingJobOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ProcessingJobStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Stopped"
                guard case .success(let output) = result else { return false }
                let processingJobStatus = output.processingJobStatus
                return JMESUtils.compare(processingJobStatus, ==, "Stopped")
            }),
            .init(state: .failure, matcher: { (input: DescribeProcessingJobInput, result: Result<DescribeProcessingJobOutputResponse, Error>) -> Bool in
                // JMESPath expression: "ProcessingJobStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let processingJobStatus = output.processingJobStatus
                return JMESUtils.compare(processingJobStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeProcessingJobInput, result: Result<DescribeProcessingJobOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
        ]
        return try WaiterConfiguration<DescribeProcessingJobInput, DescribeProcessingJobOutputResponse>(acceptors: acceptors, minDelay: 60.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ProcessingJobCompletedOrStopped event on the describeProcessingJob operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeProcessingJobInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilProcessingJobCompletedOrStopped(options: WaiterOptions, input: DescribeProcessingJobInput) async throws -> WaiterOutcome<DescribeProcessingJobOutputResponse> {
        let waiter = Waiter(config: try Self.processingJobCompletedOrStoppedWaiterConfig(), operation: self.describeProcessingJob(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func trainingJobCompletedOrStoppedWaiterConfig() throws -> WaiterConfiguration<DescribeTrainingJobInput, DescribeTrainingJobOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeTrainingJobInput, DescribeTrainingJobOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeTrainingJobInput, result: Result<DescribeTrainingJobOutputResponse, Error>) -> Bool in
                // JMESPath expression: "TrainingJobStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Completed"
                guard case .success(let output) = result else { return false }
                let trainingJobStatus = output.trainingJobStatus
                return JMESUtils.compare(trainingJobStatus, ==, "Completed")
            }),
            .init(state: .success, matcher: { (input: DescribeTrainingJobInput, result: Result<DescribeTrainingJobOutputResponse, Error>) -> Bool in
                // JMESPath expression: "TrainingJobStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Stopped"
                guard case .success(let output) = result else { return false }
                let trainingJobStatus = output.trainingJobStatus
                return JMESUtils.compare(trainingJobStatus, ==, "Stopped")
            }),
            .init(state: .failure, matcher: { (input: DescribeTrainingJobInput, result: Result<DescribeTrainingJobOutputResponse, Error>) -> Bool in
                // JMESPath expression: "TrainingJobStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let trainingJobStatus = output.trainingJobStatus
                return JMESUtils.compare(trainingJobStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeTrainingJobInput, result: Result<DescribeTrainingJobOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
        ]
        return try WaiterConfiguration<DescribeTrainingJobInput, DescribeTrainingJobOutputResponse>(acceptors: acceptors, minDelay: 120.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the TrainingJobCompletedOrStopped event on the describeTrainingJob operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeTrainingJobInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilTrainingJobCompletedOrStopped(options: WaiterOptions, input: DescribeTrainingJobInput) async throws -> WaiterOutcome<DescribeTrainingJobOutputResponse> {
        let waiter = Waiter(config: try Self.trainingJobCompletedOrStoppedWaiterConfig(), operation: self.describeTrainingJob(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func transformJobCompletedOrStoppedWaiterConfig() throws -> WaiterConfiguration<DescribeTransformJobInput, DescribeTransformJobOutputResponse> {
        let acceptors: [WaiterConfiguration<DescribeTransformJobInput, DescribeTransformJobOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: DescribeTransformJobInput, result: Result<DescribeTransformJobOutputResponse, Error>) -> Bool in
                // JMESPath expression: "TransformJobStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Completed"
                guard case .success(let output) = result else { return false }
                let transformJobStatus = output.transformJobStatus
                return JMESUtils.compare(transformJobStatus, ==, "Completed")
            }),
            .init(state: .success, matcher: { (input: DescribeTransformJobInput, result: Result<DescribeTransformJobOutputResponse, Error>) -> Bool in
                // JMESPath expression: "TransformJobStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Stopped"
                guard case .success(let output) = result else { return false }
                let transformJobStatus = output.transformJobStatus
                return JMESUtils.compare(transformJobStatus, ==, "Stopped")
            }),
            .init(state: .failure, matcher: { (input: DescribeTransformJobInput, result: Result<DescribeTransformJobOutputResponse, Error>) -> Bool in
                // JMESPath expression: "TransformJobStatus"
                // JMESPath comparator: "stringEquals"
                // JMESPath expected value: "Failed"
                guard case .success(let output) = result else { return false }
                let transformJobStatus = output.transformJobStatus
                return JMESUtils.compare(transformJobStatus, ==, "Failed")
            }),
            .init(state: .failure, matcher: { (input: DescribeTransformJobInput, result: Result<DescribeTransformJobOutputResponse, Error>) -> Bool in
                guard case .failure(let error) = result else { return false }
                return (error as? WaiterTypedError)?.waiterErrorType == "ValidationException"
            }),
        ]
        return try WaiterConfiguration<DescribeTransformJobInput, DescribeTransformJobOutputResponse>(acceptors: acceptors, minDelay: 60.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the TransformJobCompletedOrStopped event on the describeTransformJob operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `DescribeTransformJobInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilTransformJobCompletedOrStopped(options: WaiterOptions, input: DescribeTransformJobInput) async throws -> WaiterOutcome<DescribeTransformJobOutputResponse> {
        let waiter = Waiter(config: try Self.transformJobCompletedOrStoppedWaiterConfig(), operation: self.describeTransformJob(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }
}
