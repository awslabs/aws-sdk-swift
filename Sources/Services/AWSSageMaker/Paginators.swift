// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListActionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListActionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListActionsOutputResponse`
extension SageMakerClient {
    public func listActionsPaginated(input: ListActionsInput) -> ClientRuntime.PaginatorSequence<ListActionsInput, ListActionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListActionsInput, ListActionsOutputResponse>(input: input, inputKey: \ListActionsInput.nextToken, outputKey: \ListActionsOutputResponse.nextToken, paginationFunction: self.listActions(input:))
    }
}

extension ListActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListActionsInput {
        return ListActionsInput(
            actionType: self.actionType,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceUri: self.sourceUri
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listActionsPaginated`
/// to access the nested member `[SageMakerClientTypes.ActionSummary]`
/// - Returns: `[SageMakerClientTypes.ActionSummary]`
extension PaginatorSequence where Input == ListActionsInput, Output == ListActionsOutputResponse {
    public func actionSummaries() async throws -> [SageMakerClientTypes.ActionSummary] {
        return try await self.asyncCompactMap { item in item.actionSummaries }
    }
}

/// Paginate over `[ListAlgorithmsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAlgorithmsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAlgorithmsOutputResponse`
extension SageMakerClient {
    public func listAlgorithmsPaginated(input: ListAlgorithmsInput) -> ClientRuntime.PaginatorSequence<ListAlgorithmsInput, ListAlgorithmsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAlgorithmsInput, ListAlgorithmsOutputResponse>(input: input, inputKey: \ListAlgorithmsInput.nextToken, outputKey: \ListAlgorithmsOutputResponse.nextToken, paginationFunction: self.listAlgorithms(input:))
    }
}

extension ListAlgorithmsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAlgorithmsInput {
        return ListAlgorithmsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAlgorithmsPaginated`
/// to access the nested member `[SageMakerClientTypes.AlgorithmSummary]`
/// - Returns: `[SageMakerClientTypes.AlgorithmSummary]`
extension PaginatorSequence where Input == ListAlgorithmsInput, Output == ListAlgorithmsOutputResponse {
    public func algorithmSummaryList() async throws -> [SageMakerClientTypes.AlgorithmSummary] {
        return try await self.asyncCompactMap { item in item.algorithmSummaryList }
    }
}

/// Paginate over `[ListAliasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAliasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAliasesOutputResponse`
extension SageMakerClient {
    public func listAliasesPaginated(input: ListAliasesInput) -> ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutputResponse>(input: input, inputKey: \ListAliasesInput.nextToken, outputKey: \ListAliasesOutputResponse.nextToken, paginationFunction: self.listAliases(input:))
    }
}

extension ListAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAliasesInput {
        return ListAliasesInput(
            alias: self.alias,
            imageName: self.imageName,
            maxResults: self.maxResults,
            nextToken: token,
            version: self.version
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAliasesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListAliasesInput, Output == ListAliasesOutputResponse {
    public func sageMakerImageVersionAliases() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.sageMakerImageVersionAliases }
    }
}

/// Paginate over `[ListAppImageConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAppImageConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAppImageConfigsOutputResponse`
extension SageMakerClient {
    public func listAppImageConfigsPaginated(input: ListAppImageConfigsInput) -> ClientRuntime.PaginatorSequence<ListAppImageConfigsInput, ListAppImageConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAppImageConfigsInput, ListAppImageConfigsOutputResponse>(input: input, inputKey: \ListAppImageConfigsInput.nextToken, outputKey: \ListAppImageConfigsOutputResponse.nextToken, paginationFunction: self.listAppImageConfigs(input:))
    }
}

extension ListAppImageConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppImageConfigsInput {
        return ListAppImageConfigsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modifiedTimeAfter: self.modifiedTimeAfter,
            modifiedTimeBefore: self.modifiedTimeBefore,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAppImageConfigsPaginated`
/// to access the nested member `[SageMakerClientTypes.AppImageConfigDetails]`
/// - Returns: `[SageMakerClientTypes.AppImageConfigDetails]`
extension PaginatorSequence where Input == ListAppImageConfigsInput, Output == ListAppImageConfigsOutputResponse {
    public func appImageConfigs() async throws -> [SageMakerClientTypes.AppImageConfigDetails] {
        return try await self.asyncCompactMap { item in item.appImageConfigs }
    }
}

/// Paginate over `[ListAppsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAppsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAppsOutputResponse`
extension SageMakerClient {
    public func listAppsPaginated(input: ListAppsInput) -> ClientRuntime.PaginatorSequence<ListAppsInput, ListAppsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAppsInput, ListAppsOutputResponse>(input: input, inputKey: \ListAppsInput.nextToken, outputKey: \ListAppsOutputResponse.nextToken, paginationFunction: self.listApps(input:))
    }
}

extension ListAppsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppsInput {
        return ListAppsInput(
            domainIdEquals: self.domainIdEquals,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            spaceNameEquals: self.spaceNameEquals,
            userProfileNameEquals: self.userProfileNameEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAppsPaginated`
/// to access the nested member `[SageMakerClientTypes.AppDetails]`
/// - Returns: `[SageMakerClientTypes.AppDetails]`
extension PaginatorSequence where Input == ListAppsInput, Output == ListAppsOutputResponse {
    public func apps() async throws -> [SageMakerClientTypes.AppDetails] {
        return try await self.asyncCompactMap { item in item.apps }
    }
}

/// Paginate over `[ListArtifactsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListArtifactsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListArtifactsOutputResponse`
extension SageMakerClient {
    public func listArtifactsPaginated(input: ListArtifactsInput) -> ClientRuntime.PaginatorSequence<ListArtifactsInput, ListArtifactsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListArtifactsInput, ListArtifactsOutputResponse>(input: input, inputKey: \ListArtifactsInput.nextToken, outputKey: \ListArtifactsOutputResponse.nextToken, paginationFunction: self.listArtifacts(input:))
    }
}

extension ListArtifactsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListArtifactsInput {
        return ListArtifactsInput(
            artifactType: self.artifactType,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceUri: self.sourceUri
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listArtifactsPaginated`
/// to access the nested member `[SageMakerClientTypes.ArtifactSummary]`
/// - Returns: `[SageMakerClientTypes.ArtifactSummary]`
extension PaginatorSequence where Input == ListArtifactsInput, Output == ListArtifactsOutputResponse {
    public func artifactSummaries() async throws -> [SageMakerClientTypes.ArtifactSummary] {
        return try await self.asyncCompactMap { item in item.artifactSummaries }
    }
}

/// Paginate over `[ListAssociationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAssociationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAssociationsOutputResponse`
extension SageMakerClient {
    public func listAssociationsPaginated(input: ListAssociationsInput) -> ClientRuntime.PaginatorSequence<ListAssociationsInput, ListAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAssociationsInput, ListAssociationsOutputResponse>(input: input, inputKey: \ListAssociationsInput.nextToken, outputKey: \ListAssociationsOutputResponse.nextToken, paginationFunction: self.listAssociations(input:))
    }
}

extension ListAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssociationsInput {
        return ListAssociationsInput(
            associationType: self.associationType,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            destinationArn: self.destinationArn,
            destinationType: self.destinationType,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceArn: self.sourceArn,
            sourceType: self.sourceType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAssociationsPaginated`
/// to access the nested member `[SageMakerClientTypes.AssociationSummary]`
/// - Returns: `[SageMakerClientTypes.AssociationSummary]`
extension PaginatorSequence where Input == ListAssociationsInput, Output == ListAssociationsOutputResponse {
    public func associationSummaries() async throws -> [SageMakerClientTypes.AssociationSummary] {
        return try await self.asyncCompactMap { item in item.associationSummaries }
    }
}

/// Paginate over `[ListAutoMLJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAutoMLJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAutoMLJobsOutputResponse`
extension SageMakerClient {
    public func listAutoMLJobsPaginated(input: ListAutoMLJobsInput) -> ClientRuntime.PaginatorSequence<ListAutoMLJobsInput, ListAutoMLJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAutoMLJobsInput, ListAutoMLJobsOutputResponse>(input: input, inputKey: \ListAutoMLJobsInput.nextToken, outputKey: \ListAutoMLJobsOutputResponse.nextToken, paginationFunction: self.listAutoMLJobs(input:))
    }
}

extension ListAutoMLJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAutoMLJobsInput {
        return ListAutoMLJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAutoMLJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.AutoMLJobSummary]`
/// - Returns: `[SageMakerClientTypes.AutoMLJobSummary]`
extension PaginatorSequence where Input == ListAutoMLJobsInput, Output == ListAutoMLJobsOutputResponse {
    public func autoMLJobSummaries() async throws -> [SageMakerClientTypes.AutoMLJobSummary] {
        return try await self.asyncCompactMap { item in item.autoMLJobSummaries }
    }
}

/// Paginate over `[ListCandidatesForAutoMLJobOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCandidatesForAutoMLJobInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCandidatesForAutoMLJobOutputResponse`
extension SageMakerClient {
    public func listCandidatesForAutoMLJobPaginated(input: ListCandidatesForAutoMLJobInput) -> ClientRuntime.PaginatorSequence<ListCandidatesForAutoMLJobInput, ListCandidatesForAutoMLJobOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCandidatesForAutoMLJobInput, ListCandidatesForAutoMLJobOutputResponse>(input: input, inputKey: \ListCandidatesForAutoMLJobInput.nextToken, outputKey: \ListCandidatesForAutoMLJobOutputResponse.nextToken, paginationFunction: self.listCandidatesForAutoMLJob(input:))
    }
}

extension ListCandidatesForAutoMLJobInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCandidatesForAutoMLJobInput {
        return ListCandidatesForAutoMLJobInput(
            autoMLJobName: self.autoMLJobName,
            candidateNameEquals: self.candidateNameEquals,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCandidatesForAutoMLJobPaginated`
/// to access the nested member `[SageMakerClientTypes.AutoMLCandidate]`
/// - Returns: `[SageMakerClientTypes.AutoMLCandidate]`
extension PaginatorSequence where Input == ListCandidatesForAutoMLJobInput, Output == ListCandidatesForAutoMLJobOutputResponse {
    public func candidates() async throws -> [SageMakerClientTypes.AutoMLCandidate] {
        return try await self.asyncCompactMap { item in item.candidates }
    }
}

/// Paginate over `[ListCodeRepositoriesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCodeRepositoriesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCodeRepositoriesOutputResponse`
extension SageMakerClient {
    public func listCodeRepositoriesPaginated(input: ListCodeRepositoriesInput) -> ClientRuntime.PaginatorSequence<ListCodeRepositoriesInput, ListCodeRepositoriesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCodeRepositoriesInput, ListCodeRepositoriesOutputResponse>(input: input, inputKey: \ListCodeRepositoriesInput.nextToken, outputKey: \ListCodeRepositoriesOutputResponse.nextToken, paginationFunction: self.listCodeRepositories(input:))
    }
}

extension ListCodeRepositoriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCodeRepositoriesInput {
        return ListCodeRepositoriesInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCodeRepositoriesPaginated`
/// to access the nested member `[SageMakerClientTypes.CodeRepositorySummary]`
/// - Returns: `[SageMakerClientTypes.CodeRepositorySummary]`
extension PaginatorSequence where Input == ListCodeRepositoriesInput, Output == ListCodeRepositoriesOutputResponse {
    public func codeRepositorySummaryList() async throws -> [SageMakerClientTypes.CodeRepositorySummary] {
        return try await self.asyncCompactMap { item in item.codeRepositorySummaryList }
    }
}

/// Paginate over `[ListCompilationJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListCompilationJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListCompilationJobsOutputResponse`
extension SageMakerClient {
    public func listCompilationJobsPaginated(input: ListCompilationJobsInput) -> ClientRuntime.PaginatorSequence<ListCompilationJobsInput, ListCompilationJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListCompilationJobsInput, ListCompilationJobsOutputResponse>(input: input, inputKey: \ListCompilationJobsInput.nextToken, outputKey: \ListCompilationJobsOutputResponse.nextToken, paginationFunction: self.listCompilationJobs(input:))
    }
}

extension ListCompilationJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCompilationJobsInput {
        return ListCompilationJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listCompilationJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.CompilationJobSummary]`
/// - Returns: `[SageMakerClientTypes.CompilationJobSummary]`
extension PaginatorSequence where Input == ListCompilationJobsInput, Output == ListCompilationJobsOutputResponse {
    public func compilationJobSummaries() async throws -> [SageMakerClientTypes.CompilationJobSummary] {
        return try await self.asyncCompactMap { item in item.compilationJobSummaries }
    }
}

/// Paginate over `[ListContextsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListContextsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListContextsOutputResponse`
extension SageMakerClient {
    public func listContextsPaginated(input: ListContextsInput) -> ClientRuntime.PaginatorSequence<ListContextsInput, ListContextsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListContextsInput, ListContextsOutputResponse>(input: input, inputKey: \ListContextsInput.nextToken, outputKey: \ListContextsOutputResponse.nextToken, paginationFunction: self.listContexts(input:))
    }
}

extension ListContextsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContextsInput {
        return ListContextsInput(
            contextType: self.contextType,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceUri: self.sourceUri
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listContextsPaginated`
/// to access the nested member `[SageMakerClientTypes.ContextSummary]`
/// - Returns: `[SageMakerClientTypes.ContextSummary]`
extension PaginatorSequence where Input == ListContextsInput, Output == ListContextsOutputResponse {
    public func contextSummaries() async throws -> [SageMakerClientTypes.ContextSummary] {
        return try await self.asyncCompactMap { item in item.contextSummaries }
    }
}

/// Paginate over `[ListDataQualityJobDefinitionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDataQualityJobDefinitionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityJobDefinitionsOutputResponse`
extension SageMakerClient {
    public func listDataQualityJobDefinitionsPaginated(input: ListDataQualityJobDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityJobDefinitionsInput, ListDataQualityJobDefinitionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDataQualityJobDefinitionsInput, ListDataQualityJobDefinitionsOutputResponse>(input: input, inputKey: \ListDataQualityJobDefinitionsInput.nextToken, outputKey: \ListDataQualityJobDefinitionsOutputResponse.nextToken, paginationFunction: self.listDataQualityJobDefinitions(input:))
    }
}

extension ListDataQualityJobDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityJobDefinitionsInput {
        return ListDataQualityJobDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDataQualityJobDefinitionsPaginated`
/// to access the nested member `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
/// - Returns: `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
extension PaginatorSequence where Input == ListDataQualityJobDefinitionsInput, Output == ListDataQualityJobDefinitionsOutputResponse {
    public func jobDefinitionSummaries() async throws -> [SageMakerClientTypes.MonitoringJobDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.jobDefinitionSummaries }
    }
}

/// Paginate over `[ListDeviceFleetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDeviceFleetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDeviceFleetsOutputResponse`
extension SageMakerClient {
    public func listDeviceFleetsPaginated(input: ListDeviceFleetsInput) -> ClientRuntime.PaginatorSequence<ListDeviceFleetsInput, ListDeviceFleetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDeviceFleetsInput, ListDeviceFleetsOutputResponse>(input: input, inputKey: \ListDeviceFleetsInput.nextToken, outputKey: \ListDeviceFleetsOutputResponse.nextToken, paginationFunction: self.listDeviceFleets(input:))
    }
}

extension ListDeviceFleetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeviceFleetsInput {
        return ListDeviceFleetsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDeviceFleetsPaginated`
/// to access the nested member `[SageMakerClientTypes.DeviceFleetSummary]`
/// - Returns: `[SageMakerClientTypes.DeviceFleetSummary]`
extension PaginatorSequence where Input == ListDeviceFleetsInput, Output == ListDeviceFleetsOutputResponse {
    public func deviceFleetSummaries() async throws -> [SageMakerClientTypes.DeviceFleetSummary] {
        return try await self.asyncCompactMap { item in item.deviceFleetSummaries }
    }
}

/// Paginate over `[ListDevicesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDevicesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDevicesOutputResponse`
extension SageMakerClient {
    public func listDevicesPaginated(input: ListDevicesInput) -> ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutputResponse>(input: input, inputKey: \ListDevicesInput.nextToken, outputKey: \ListDevicesOutputResponse.nextToken, paginationFunction: self.listDevices(input:))
    }
}

extension ListDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicesInput {
        return ListDevicesInput(
            deviceFleetName: self.deviceFleetName,
            latestHeartbeatAfter: self.latestHeartbeatAfter,
            maxResults: self.maxResults,
            modelName: self.modelName,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDevicesPaginated`
/// to access the nested member `[SageMakerClientTypes.DeviceSummary]`
/// - Returns: `[SageMakerClientTypes.DeviceSummary]`
extension PaginatorSequence where Input == ListDevicesInput, Output == ListDevicesOutputResponse {
    public func deviceSummaries() async throws -> [SageMakerClientTypes.DeviceSummary] {
        return try await self.asyncCompactMap { item in item.deviceSummaries }
    }
}

/// Paginate over `[ListDomainsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDomainsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDomainsOutputResponse`
extension SageMakerClient {
    public func listDomainsPaginated(input: ListDomainsInput) -> ClientRuntime.PaginatorSequence<ListDomainsInput, ListDomainsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDomainsInput, ListDomainsOutputResponse>(input: input, inputKey: \ListDomainsInput.nextToken, outputKey: \ListDomainsOutputResponse.nextToken, paginationFunction: self.listDomains(input:))
    }
}

extension ListDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDomainsInput {
        return ListDomainsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDomainsPaginated`
/// to access the nested member `[SageMakerClientTypes.DomainDetails]`
/// - Returns: `[SageMakerClientTypes.DomainDetails]`
extension PaginatorSequence where Input == ListDomainsInput, Output == ListDomainsOutputResponse {
    public func domains() async throws -> [SageMakerClientTypes.DomainDetails] {
        return try await self.asyncCompactMap { item in item.domains }
    }
}

/// Paginate over `[ListEdgeDeploymentPlansOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEdgeDeploymentPlansInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEdgeDeploymentPlansOutputResponse`
extension SageMakerClient {
    public func listEdgeDeploymentPlansPaginated(input: ListEdgeDeploymentPlansInput) -> ClientRuntime.PaginatorSequence<ListEdgeDeploymentPlansInput, ListEdgeDeploymentPlansOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEdgeDeploymentPlansInput, ListEdgeDeploymentPlansOutputResponse>(input: input, inputKey: \ListEdgeDeploymentPlansInput.nextToken, outputKey: \ListEdgeDeploymentPlansOutputResponse.nextToken, paginationFunction: self.listEdgeDeploymentPlans(input:))
    }
}

extension ListEdgeDeploymentPlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEdgeDeploymentPlansInput {
        return ListEdgeDeploymentPlansInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            deviceFleetNameContains: self.deviceFleetNameContains,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listEdgeDeploymentPlansPaginated`
/// to access the nested member `[SageMakerClientTypes.EdgeDeploymentPlanSummary]`
/// - Returns: `[SageMakerClientTypes.EdgeDeploymentPlanSummary]`
extension PaginatorSequence where Input == ListEdgeDeploymentPlansInput, Output == ListEdgeDeploymentPlansOutputResponse {
    public func edgeDeploymentPlanSummaries() async throws -> [SageMakerClientTypes.EdgeDeploymentPlanSummary] {
        return try await self.asyncCompactMap { item in item.edgeDeploymentPlanSummaries }
    }
}

/// Paginate over `[ListEdgePackagingJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEdgePackagingJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEdgePackagingJobsOutputResponse`
extension SageMakerClient {
    public func listEdgePackagingJobsPaginated(input: ListEdgePackagingJobsInput) -> ClientRuntime.PaginatorSequence<ListEdgePackagingJobsInput, ListEdgePackagingJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEdgePackagingJobsInput, ListEdgePackagingJobsOutputResponse>(input: input, inputKey: \ListEdgePackagingJobsInput.nextToken, outputKey: \ListEdgePackagingJobsOutputResponse.nextToken, paginationFunction: self.listEdgePackagingJobs(input:))
    }
}

extension ListEdgePackagingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEdgePackagingJobsInput {
        return ListEdgePackagingJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            modelNameContains: self.modelNameContains,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listEdgePackagingJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.EdgePackagingJobSummary]`
/// - Returns: `[SageMakerClientTypes.EdgePackagingJobSummary]`
extension PaginatorSequence where Input == ListEdgePackagingJobsInput, Output == ListEdgePackagingJobsOutputResponse {
    public func edgePackagingJobSummaries() async throws -> [SageMakerClientTypes.EdgePackagingJobSummary] {
        return try await self.asyncCompactMap { item in item.edgePackagingJobSummaries }
    }
}

/// Paginate over `[ListEndpointConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEndpointConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEndpointConfigsOutputResponse`
extension SageMakerClient {
    public func listEndpointConfigsPaginated(input: ListEndpointConfigsInput) -> ClientRuntime.PaginatorSequence<ListEndpointConfigsInput, ListEndpointConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEndpointConfigsInput, ListEndpointConfigsOutputResponse>(input: input, inputKey: \ListEndpointConfigsInput.nextToken, outputKey: \ListEndpointConfigsOutputResponse.nextToken, paginationFunction: self.listEndpointConfigs(input:))
    }
}

extension ListEndpointConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEndpointConfigsInput {
        return ListEndpointConfigsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listEndpointConfigsPaginated`
/// to access the nested member `[SageMakerClientTypes.EndpointConfigSummary]`
/// - Returns: `[SageMakerClientTypes.EndpointConfigSummary]`
extension PaginatorSequence where Input == ListEndpointConfigsInput, Output == ListEndpointConfigsOutputResponse {
    public func endpointConfigs() async throws -> [SageMakerClientTypes.EndpointConfigSummary] {
        return try await self.asyncCompactMap { item in item.endpointConfigs }
    }
}

/// Paginate over `[ListEndpointsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListEndpointsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListEndpointsOutputResponse`
extension SageMakerClient {
    public func listEndpointsPaginated(input: ListEndpointsInput) -> ClientRuntime.PaginatorSequence<ListEndpointsInput, ListEndpointsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEndpointsInput, ListEndpointsOutputResponse>(input: input, inputKey: \ListEndpointsInput.nextToken, outputKey: \ListEndpointsOutputResponse.nextToken, paginationFunction: self.listEndpoints(input:))
    }
}

extension ListEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEndpointsInput {
        return ListEndpointsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listEndpointsPaginated`
/// to access the nested member `[SageMakerClientTypes.EndpointSummary]`
/// - Returns: `[SageMakerClientTypes.EndpointSummary]`
extension PaginatorSequence where Input == ListEndpointsInput, Output == ListEndpointsOutputResponse {
    public func endpoints() async throws -> [SageMakerClientTypes.EndpointSummary] {
        return try await self.asyncCompactMap { item in item.endpoints }
    }
}

/// Paginate over `[ListExperimentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListExperimentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListExperimentsOutputResponse`
extension SageMakerClient {
    public func listExperimentsPaginated(input: ListExperimentsInput) -> ClientRuntime.PaginatorSequence<ListExperimentsInput, ListExperimentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListExperimentsInput, ListExperimentsOutputResponse>(input: input, inputKey: \ListExperimentsInput.nextToken, outputKey: \ListExperimentsOutputResponse.nextToken, paginationFunction: self.listExperiments(input:))
    }
}

extension ListExperimentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExperimentsInput {
        return ListExperimentsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listExperimentsPaginated`
/// to access the nested member `[SageMakerClientTypes.ExperimentSummary]`
/// - Returns: `[SageMakerClientTypes.ExperimentSummary]`
extension PaginatorSequence where Input == ListExperimentsInput, Output == ListExperimentsOutputResponse {
    public func experimentSummaries() async throws -> [SageMakerClientTypes.ExperimentSummary] {
        return try await self.asyncCompactMap { item in item.experimentSummaries }
    }
}

/// Paginate over `[ListFlowDefinitionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFlowDefinitionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFlowDefinitionsOutputResponse`
extension SageMakerClient {
    public func listFlowDefinitionsPaginated(input: ListFlowDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListFlowDefinitionsInput, ListFlowDefinitionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFlowDefinitionsInput, ListFlowDefinitionsOutputResponse>(input: input, inputKey: \ListFlowDefinitionsInput.nextToken, outputKey: \ListFlowDefinitionsOutputResponse.nextToken, paginationFunction: self.listFlowDefinitions(input:))
    }
}

extension ListFlowDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFlowDefinitionsInput {
        return ListFlowDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFlowDefinitionsPaginated`
/// to access the nested member `[SageMakerClientTypes.FlowDefinitionSummary]`
/// - Returns: `[SageMakerClientTypes.FlowDefinitionSummary]`
extension PaginatorSequence where Input == ListFlowDefinitionsInput, Output == ListFlowDefinitionsOutputResponse {
    public func flowDefinitionSummaries() async throws -> [SageMakerClientTypes.FlowDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.flowDefinitionSummaries }
    }
}

/// Paginate over `[ListHumanTaskUisOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHumanTaskUisInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHumanTaskUisOutputResponse`
extension SageMakerClient {
    public func listHumanTaskUisPaginated(input: ListHumanTaskUisInput) -> ClientRuntime.PaginatorSequence<ListHumanTaskUisInput, ListHumanTaskUisOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHumanTaskUisInput, ListHumanTaskUisOutputResponse>(input: input, inputKey: \ListHumanTaskUisInput.nextToken, outputKey: \ListHumanTaskUisOutputResponse.nextToken, paginationFunction: self.listHumanTaskUis(input:))
    }
}

extension ListHumanTaskUisInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHumanTaskUisInput {
        return ListHumanTaskUisInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listHumanTaskUisPaginated`
/// to access the nested member `[SageMakerClientTypes.HumanTaskUiSummary]`
/// - Returns: `[SageMakerClientTypes.HumanTaskUiSummary]`
extension PaginatorSequence where Input == ListHumanTaskUisInput, Output == ListHumanTaskUisOutputResponse {
    public func humanTaskUiSummaries() async throws -> [SageMakerClientTypes.HumanTaskUiSummary] {
        return try await self.asyncCompactMap { item in item.humanTaskUiSummaries }
    }
}

/// Paginate over `[ListHyperParameterTuningJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListHyperParameterTuningJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListHyperParameterTuningJobsOutputResponse`
extension SageMakerClient {
    public func listHyperParameterTuningJobsPaginated(input: ListHyperParameterTuningJobsInput) -> ClientRuntime.PaginatorSequence<ListHyperParameterTuningJobsInput, ListHyperParameterTuningJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHyperParameterTuningJobsInput, ListHyperParameterTuningJobsOutputResponse>(input: input, inputKey: \ListHyperParameterTuningJobsInput.nextToken, outputKey: \ListHyperParameterTuningJobsOutputResponse.nextToken, paginationFunction: self.listHyperParameterTuningJobs(input:))
    }
}

extension ListHyperParameterTuningJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHyperParameterTuningJobsInput {
        return ListHyperParameterTuningJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listHyperParameterTuningJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.HyperParameterTuningJobSummary]`
/// - Returns: `[SageMakerClientTypes.HyperParameterTuningJobSummary]`
extension PaginatorSequence where Input == ListHyperParameterTuningJobsInput, Output == ListHyperParameterTuningJobsOutputResponse {
    public func hyperParameterTuningJobSummaries() async throws -> [SageMakerClientTypes.HyperParameterTuningJobSummary] {
        return try await self.asyncCompactMap { item in item.hyperParameterTuningJobSummaries }
    }
}

/// Paginate over `[ListImagesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListImagesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListImagesOutputResponse`
extension SageMakerClient {
    public func listImagesPaginated(input: ListImagesInput) -> ClientRuntime.PaginatorSequence<ListImagesInput, ListImagesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListImagesInput, ListImagesOutputResponse>(input: input, inputKey: \ListImagesInput.nextToken, outputKey: \ListImagesOutputResponse.nextToken, paginationFunction: self.listImages(input:))
    }
}

extension ListImagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagesInput {
        return ListImagesInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listImagesPaginated`
/// to access the nested member `[SageMakerClientTypes.Image]`
/// - Returns: `[SageMakerClientTypes.Image]`
extension PaginatorSequence where Input == ListImagesInput, Output == ListImagesOutputResponse {
    public func images() async throws -> [SageMakerClientTypes.Image] {
        return try await self.asyncCompactMap { item in item.images }
    }
}

/// Paginate over `[ListImageVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListImageVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListImageVersionsOutputResponse`
extension SageMakerClient {
    public func listImageVersionsPaginated(input: ListImageVersionsInput) -> ClientRuntime.PaginatorSequence<ListImageVersionsInput, ListImageVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListImageVersionsInput, ListImageVersionsOutputResponse>(input: input, inputKey: \ListImageVersionsInput.nextToken, outputKey: \ListImageVersionsOutputResponse.nextToken, paginationFunction: self.listImageVersions(input:))
    }
}

extension ListImageVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageVersionsInput {
        return ListImageVersionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            imageName: self.imageName,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listImageVersionsPaginated`
/// to access the nested member `[SageMakerClientTypes.ImageVersion]`
/// - Returns: `[SageMakerClientTypes.ImageVersion]`
extension PaginatorSequence where Input == ListImageVersionsInput, Output == ListImageVersionsOutputResponse {
    public func imageVersions() async throws -> [SageMakerClientTypes.ImageVersion] {
        return try await self.asyncCompactMap { item in item.imageVersions }
    }
}

/// Paginate over `[ListInferenceExperimentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInferenceExperimentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInferenceExperimentsOutputResponse`
extension SageMakerClient {
    public func listInferenceExperimentsPaginated(input: ListInferenceExperimentsInput) -> ClientRuntime.PaginatorSequence<ListInferenceExperimentsInput, ListInferenceExperimentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInferenceExperimentsInput, ListInferenceExperimentsOutputResponse>(input: input, inputKey: \ListInferenceExperimentsInput.nextToken, outputKey: \ListInferenceExperimentsOutputResponse.nextToken, paginationFunction: self.listInferenceExperiments(input:))
    }
}

extension ListInferenceExperimentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceExperimentsInput {
        return ListInferenceExperimentsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals,
            type: self.type
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInferenceExperimentsPaginated`
/// to access the nested member `[SageMakerClientTypes.InferenceExperimentSummary]`
/// - Returns: `[SageMakerClientTypes.InferenceExperimentSummary]`
extension PaginatorSequence where Input == ListInferenceExperimentsInput, Output == ListInferenceExperimentsOutputResponse {
    public func inferenceExperiments() async throws -> [SageMakerClientTypes.InferenceExperimentSummary] {
        return try await self.asyncCompactMap { item in item.inferenceExperiments }
    }
}

/// Paginate over `[ListInferenceRecommendationsJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInferenceRecommendationsJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInferenceRecommendationsJobsOutputResponse`
extension SageMakerClient {
    public func listInferenceRecommendationsJobsPaginated(input: ListInferenceRecommendationsJobsInput) -> ClientRuntime.PaginatorSequence<ListInferenceRecommendationsJobsInput, ListInferenceRecommendationsJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInferenceRecommendationsJobsInput, ListInferenceRecommendationsJobsOutputResponse>(input: input, inputKey: \ListInferenceRecommendationsJobsInput.nextToken, outputKey: \ListInferenceRecommendationsJobsOutputResponse.nextToken, paginationFunction: self.listInferenceRecommendationsJobs(input:))
    }
}

extension ListInferenceRecommendationsJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceRecommendationsJobsInput {
        return ListInferenceRecommendationsJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInferenceRecommendationsJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.InferenceRecommendationsJob]`
/// - Returns: `[SageMakerClientTypes.InferenceRecommendationsJob]`
extension PaginatorSequence where Input == ListInferenceRecommendationsJobsInput, Output == ListInferenceRecommendationsJobsOutputResponse {
    public func inferenceRecommendationsJobs() async throws -> [SageMakerClientTypes.InferenceRecommendationsJob] {
        return try await self.asyncCompactMap { item in item.inferenceRecommendationsJobs }
    }
}

/// Paginate over `[ListInferenceRecommendationsJobStepsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListInferenceRecommendationsJobStepsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListInferenceRecommendationsJobStepsOutputResponse`
extension SageMakerClient {
    public func listInferenceRecommendationsJobStepsPaginated(input: ListInferenceRecommendationsJobStepsInput) -> ClientRuntime.PaginatorSequence<ListInferenceRecommendationsJobStepsInput, ListInferenceRecommendationsJobStepsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListInferenceRecommendationsJobStepsInput, ListInferenceRecommendationsJobStepsOutputResponse>(input: input, inputKey: \ListInferenceRecommendationsJobStepsInput.nextToken, outputKey: \ListInferenceRecommendationsJobStepsOutputResponse.nextToken, paginationFunction: self.listInferenceRecommendationsJobSteps(input:))
    }
}

extension ListInferenceRecommendationsJobStepsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceRecommendationsJobStepsInput {
        return ListInferenceRecommendationsJobStepsInput(
            jobName: self.jobName,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status,
            stepType: self.stepType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listInferenceRecommendationsJobStepsPaginated`
/// to access the nested member `[SageMakerClientTypes.InferenceRecommendationsJobStep]`
/// - Returns: `[SageMakerClientTypes.InferenceRecommendationsJobStep]`
extension PaginatorSequence where Input == ListInferenceRecommendationsJobStepsInput, Output == ListInferenceRecommendationsJobStepsOutputResponse {
    public func steps() async throws -> [SageMakerClientTypes.InferenceRecommendationsJobStep] {
        return try await self.asyncCompactMap { item in item.steps }
    }
}

/// Paginate over `[ListLabelingJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLabelingJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLabelingJobsOutputResponse`
extension SageMakerClient {
    public func listLabelingJobsPaginated(input: ListLabelingJobsInput) -> ClientRuntime.PaginatorSequence<ListLabelingJobsInput, ListLabelingJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLabelingJobsInput, ListLabelingJobsOutputResponse>(input: input, inputKey: \ListLabelingJobsInput.nextToken, outputKey: \ListLabelingJobsOutputResponse.nextToken, paginationFunction: self.listLabelingJobs(input:))
    }
}

extension ListLabelingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLabelingJobsInput {
        return ListLabelingJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listLabelingJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.LabelingJobSummary]`
/// - Returns: `[SageMakerClientTypes.LabelingJobSummary]`
extension PaginatorSequence where Input == ListLabelingJobsInput, Output == ListLabelingJobsOutputResponse {
    public func labelingJobSummaryList() async throws -> [SageMakerClientTypes.LabelingJobSummary] {
        return try await self.asyncCompactMap { item in item.labelingJobSummaryList }
    }
}

/// Paginate over `[ListLabelingJobsForWorkteamOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLabelingJobsForWorkteamInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLabelingJobsForWorkteamOutputResponse`
extension SageMakerClient {
    public func listLabelingJobsForWorkteamPaginated(input: ListLabelingJobsForWorkteamInput) -> ClientRuntime.PaginatorSequence<ListLabelingJobsForWorkteamInput, ListLabelingJobsForWorkteamOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLabelingJobsForWorkteamInput, ListLabelingJobsForWorkteamOutputResponse>(input: input, inputKey: \ListLabelingJobsForWorkteamInput.nextToken, outputKey: \ListLabelingJobsForWorkteamOutputResponse.nextToken, paginationFunction: self.listLabelingJobsForWorkteam(input:))
    }
}

extension ListLabelingJobsForWorkteamInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLabelingJobsForWorkteamInput {
        return ListLabelingJobsForWorkteamInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            jobReferenceCodeContains: self.jobReferenceCodeContains,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            workteamArn: self.workteamArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listLabelingJobsForWorkteamPaginated`
/// to access the nested member `[SageMakerClientTypes.LabelingJobForWorkteamSummary]`
/// - Returns: `[SageMakerClientTypes.LabelingJobForWorkteamSummary]`
extension PaginatorSequence where Input == ListLabelingJobsForWorkteamInput, Output == ListLabelingJobsForWorkteamOutputResponse {
    public func labelingJobSummaryList() async throws -> [SageMakerClientTypes.LabelingJobForWorkteamSummary] {
        return try await self.asyncCompactMap { item in item.labelingJobSummaryList }
    }
}

/// Paginate over `[ListLineageGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListLineageGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListLineageGroupsOutputResponse`
extension SageMakerClient {
    public func listLineageGroupsPaginated(input: ListLineageGroupsInput) -> ClientRuntime.PaginatorSequence<ListLineageGroupsInput, ListLineageGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListLineageGroupsInput, ListLineageGroupsOutputResponse>(input: input, inputKey: \ListLineageGroupsInput.nextToken, outputKey: \ListLineageGroupsOutputResponse.nextToken, paginationFunction: self.listLineageGroups(input:))
    }
}

extension ListLineageGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLineageGroupsInput {
        return ListLineageGroupsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listLineageGroupsPaginated`
/// to access the nested member `[SageMakerClientTypes.LineageGroupSummary]`
/// - Returns: `[SageMakerClientTypes.LineageGroupSummary]`
extension PaginatorSequence where Input == ListLineageGroupsInput, Output == ListLineageGroupsOutputResponse {
    public func lineageGroupSummaries() async throws -> [SageMakerClientTypes.LineageGroupSummary] {
        return try await self.asyncCompactMap { item in item.lineageGroupSummaries }
    }
}

/// Paginate over `[ListModelBiasJobDefinitionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelBiasJobDefinitionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelBiasJobDefinitionsOutputResponse`
extension SageMakerClient {
    public func listModelBiasJobDefinitionsPaginated(input: ListModelBiasJobDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListModelBiasJobDefinitionsInput, ListModelBiasJobDefinitionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelBiasJobDefinitionsInput, ListModelBiasJobDefinitionsOutputResponse>(input: input, inputKey: \ListModelBiasJobDefinitionsInput.nextToken, outputKey: \ListModelBiasJobDefinitionsOutputResponse.nextToken, paginationFunction: self.listModelBiasJobDefinitions(input:))
    }
}

extension ListModelBiasJobDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelBiasJobDefinitionsInput {
        return ListModelBiasJobDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelBiasJobDefinitionsPaginated`
/// to access the nested member `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
/// - Returns: `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
extension PaginatorSequence where Input == ListModelBiasJobDefinitionsInput, Output == ListModelBiasJobDefinitionsOutputResponse {
    public func jobDefinitionSummaries() async throws -> [SageMakerClientTypes.MonitoringJobDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.jobDefinitionSummaries }
    }
}

/// Paginate over `[ListModelCardExportJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelCardExportJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelCardExportJobsOutputResponse`
extension SageMakerClient {
    public func listModelCardExportJobsPaginated(input: ListModelCardExportJobsInput) -> ClientRuntime.PaginatorSequence<ListModelCardExportJobsInput, ListModelCardExportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelCardExportJobsInput, ListModelCardExportJobsOutputResponse>(input: input, inputKey: \ListModelCardExportJobsInput.nextToken, outputKey: \ListModelCardExportJobsOutputResponse.nextToken, paginationFunction: self.listModelCardExportJobs(input:))
    }
}

extension ListModelCardExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelCardExportJobsInput {
        return ListModelCardExportJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modelCardExportJobNameContains: self.modelCardExportJobNameContains,
            modelCardName: self.modelCardName,
            modelCardVersion: self.modelCardVersion,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelCardExportJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.ModelCardExportJobSummary]`
/// - Returns: `[SageMakerClientTypes.ModelCardExportJobSummary]`
extension PaginatorSequence where Input == ListModelCardExportJobsInput, Output == ListModelCardExportJobsOutputResponse {
    public func modelCardExportJobSummaries() async throws -> [SageMakerClientTypes.ModelCardExportJobSummary] {
        return try await self.asyncCompactMap { item in item.modelCardExportJobSummaries }
    }
}

/// Paginate over `[ListModelCardsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelCardsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelCardsOutputResponse`
extension SageMakerClient {
    public func listModelCardsPaginated(input: ListModelCardsInput) -> ClientRuntime.PaginatorSequence<ListModelCardsInput, ListModelCardsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelCardsInput, ListModelCardsOutputResponse>(input: input, inputKey: \ListModelCardsInput.nextToken, outputKey: \ListModelCardsOutputResponse.nextToken, paginationFunction: self.listModelCards(input:))
    }
}

extension ListModelCardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelCardsInput {
        return ListModelCardsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modelCardStatus: self.modelCardStatus,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelCardsPaginated`
/// to access the nested member `[SageMakerClientTypes.ModelCardSummary]`
/// - Returns: `[SageMakerClientTypes.ModelCardSummary]`
extension PaginatorSequence where Input == ListModelCardsInput, Output == ListModelCardsOutputResponse {
    public func modelCardSummaries() async throws -> [SageMakerClientTypes.ModelCardSummary] {
        return try await self.asyncCompactMap { item in item.modelCardSummaries }
    }
}

/// Paginate over `[ListModelCardVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelCardVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelCardVersionsOutputResponse`
extension SageMakerClient {
    public func listModelCardVersionsPaginated(input: ListModelCardVersionsInput) -> ClientRuntime.PaginatorSequence<ListModelCardVersionsInput, ListModelCardVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelCardVersionsInput, ListModelCardVersionsOutputResponse>(input: input, inputKey: \ListModelCardVersionsInput.nextToken, outputKey: \ListModelCardVersionsOutputResponse.nextToken, paginationFunction: self.listModelCardVersions(input:))
    }
}

extension ListModelCardVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelCardVersionsInput {
        return ListModelCardVersionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modelCardName: self.modelCardName,
            modelCardStatus: self.modelCardStatus,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelCardVersionsPaginated`
/// to access the nested member `[SageMakerClientTypes.ModelCardVersionSummary]`
/// - Returns: `[SageMakerClientTypes.ModelCardVersionSummary]`
extension PaginatorSequence where Input == ListModelCardVersionsInput, Output == ListModelCardVersionsOutputResponse {
    public func modelCardVersionSummaryList() async throws -> [SageMakerClientTypes.ModelCardVersionSummary] {
        return try await self.asyncCompactMap { item in item.modelCardVersionSummaryList }
    }
}

/// Paginate over `[ListModelExplainabilityJobDefinitionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelExplainabilityJobDefinitionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelExplainabilityJobDefinitionsOutputResponse`
extension SageMakerClient {
    public func listModelExplainabilityJobDefinitionsPaginated(input: ListModelExplainabilityJobDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListModelExplainabilityJobDefinitionsInput, ListModelExplainabilityJobDefinitionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelExplainabilityJobDefinitionsInput, ListModelExplainabilityJobDefinitionsOutputResponse>(input: input, inputKey: \ListModelExplainabilityJobDefinitionsInput.nextToken, outputKey: \ListModelExplainabilityJobDefinitionsOutputResponse.nextToken, paginationFunction: self.listModelExplainabilityJobDefinitions(input:))
    }
}

extension ListModelExplainabilityJobDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelExplainabilityJobDefinitionsInput {
        return ListModelExplainabilityJobDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelExplainabilityJobDefinitionsPaginated`
/// to access the nested member `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
/// - Returns: `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
extension PaginatorSequence where Input == ListModelExplainabilityJobDefinitionsInput, Output == ListModelExplainabilityJobDefinitionsOutputResponse {
    public func jobDefinitionSummaries() async throws -> [SageMakerClientTypes.MonitoringJobDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.jobDefinitionSummaries }
    }
}

/// Paginate over `[ListModelMetadataOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelMetadataInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelMetadataOutputResponse`
extension SageMakerClient {
    public func listModelMetadataPaginated(input: ListModelMetadataInput) -> ClientRuntime.PaginatorSequence<ListModelMetadataInput, ListModelMetadataOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelMetadataInput, ListModelMetadataOutputResponse>(input: input, inputKey: \ListModelMetadataInput.nextToken, outputKey: \ListModelMetadataOutputResponse.nextToken, paginationFunction: self.listModelMetadata(input:))
    }
}

extension ListModelMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelMetadataInput {
        return ListModelMetadataInput(
            maxResults: self.maxResults,
            nextToken: token,
            searchExpression: self.searchExpression
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelMetadataPaginated`
/// to access the nested member `[SageMakerClientTypes.ModelMetadataSummary]`
/// - Returns: `[SageMakerClientTypes.ModelMetadataSummary]`
extension PaginatorSequence where Input == ListModelMetadataInput, Output == ListModelMetadataOutputResponse {
    public func modelMetadataSummaries() async throws -> [SageMakerClientTypes.ModelMetadataSummary] {
        return try await self.asyncCompactMap { item in item.modelMetadataSummaries }
    }
}

/// Paginate over `[ListModelPackageGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelPackageGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelPackageGroupsOutputResponse`
extension SageMakerClient {
    public func listModelPackageGroupsPaginated(input: ListModelPackageGroupsInput) -> ClientRuntime.PaginatorSequence<ListModelPackageGroupsInput, ListModelPackageGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelPackageGroupsInput, ListModelPackageGroupsOutputResponse>(input: input, inputKey: \ListModelPackageGroupsInput.nextToken, outputKey: \ListModelPackageGroupsOutputResponse.nextToken, paginationFunction: self.listModelPackageGroups(input:))
    }
}

extension ListModelPackageGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelPackageGroupsInput {
        return ListModelPackageGroupsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelPackageGroupsPaginated`
/// to access the nested member `[SageMakerClientTypes.ModelPackageGroupSummary]`
/// - Returns: `[SageMakerClientTypes.ModelPackageGroupSummary]`
extension PaginatorSequence where Input == ListModelPackageGroupsInput, Output == ListModelPackageGroupsOutputResponse {
    public func modelPackageGroupSummaryList() async throws -> [SageMakerClientTypes.ModelPackageGroupSummary] {
        return try await self.asyncCompactMap { item in item.modelPackageGroupSummaryList }
    }
}

/// Paginate over `[ListModelPackagesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelPackagesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelPackagesOutputResponse`
extension SageMakerClient {
    public func listModelPackagesPaginated(input: ListModelPackagesInput) -> ClientRuntime.PaginatorSequence<ListModelPackagesInput, ListModelPackagesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelPackagesInput, ListModelPackagesOutputResponse>(input: input, inputKey: \ListModelPackagesInput.nextToken, outputKey: \ListModelPackagesOutputResponse.nextToken, paginationFunction: self.listModelPackages(input:))
    }
}

extension ListModelPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelPackagesInput {
        return ListModelPackagesInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modelApprovalStatus: self.modelApprovalStatus,
            modelPackageGroupName: self.modelPackageGroupName,
            modelPackageType: self.modelPackageType,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelPackagesPaginated`
/// to access the nested member `[SageMakerClientTypes.ModelPackageSummary]`
/// - Returns: `[SageMakerClientTypes.ModelPackageSummary]`
extension PaginatorSequence where Input == ListModelPackagesInput, Output == ListModelPackagesOutputResponse {
    public func modelPackageSummaryList() async throws -> [SageMakerClientTypes.ModelPackageSummary] {
        return try await self.asyncCompactMap { item in item.modelPackageSummaryList }
    }
}

/// Paginate over `[ListModelQualityJobDefinitionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelQualityJobDefinitionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelQualityJobDefinitionsOutputResponse`
extension SageMakerClient {
    public func listModelQualityJobDefinitionsPaginated(input: ListModelQualityJobDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListModelQualityJobDefinitionsInput, ListModelQualityJobDefinitionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelQualityJobDefinitionsInput, ListModelQualityJobDefinitionsOutputResponse>(input: input, inputKey: \ListModelQualityJobDefinitionsInput.nextToken, outputKey: \ListModelQualityJobDefinitionsOutputResponse.nextToken, paginationFunction: self.listModelQualityJobDefinitions(input:))
    }
}

extension ListModelQualityJobDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelQualityJobDefinitionsInput {
        return ListModelQualityJobDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelQualityJobDefinitionsPaginated`
/// to access the nested member `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
/// - Returns: `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
extension PaginatorSequence where Input == ListModelQualityJobDefinitionsInput, Output == ListModelQualityJobDefinitionsOutputResponse {
    public func jobDefinitionSummaries() async throws -> [SageMakerClientTypes.MonitoringJobDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.jobDefinitionSummaries }
    }
}

/// Paginate over `[ListModelsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListModelsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListModelsOutputResponse`
extension SageMakerClient {
    public func listModelsPaginated(input: ListModelsInput) -> ClientRuntime.PaginatorSequence<ListModelsInput, ListModelsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListModelsInput, ListModelsOutputResponse>(input: input, inputKey: \ListModelsInput.nextToken, outputKey: \ListModelsOutputResponse.nextToken, paginationFunction: self.listModels(input:))
    }
}

extension ListModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelsInput {
        return ListModelsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listModelsPaginated`
/// to access the nested member `[SageMakerClientTypes.ModelSummary]`
/// - Returns: `[SageMakerClientTypes.ModelSummary]`
extension PaginatorSequence where Input == ListModelsInput, Output == ListModelsOutputResponse {
    public func models() async throws -> [SageMakerClientTypes.ModelSummary] {
        return try await self.asyncCompactMap { item in item.models }
    }
}

/// Paginate over `[ListMonitoringAlertHistoryOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMonitoringAlertHistoryInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMonitoringAlertHistoryOutputResponse`
extension SageMakerClient {
    public func listMonitoringAlertHistoryPaginated(input: ListMonitoringAlertHistoryInput) -> ClientRuntime.PaginatorSequence<ListMonitoringAlertHistoryInput, ListMonitoringAlertHistoryOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMonitoringAlertHistoryInput, ListMonitoringAlertHistoryOutputResponse>(input: input, inputKey: \ListMonitoringAlertHistoryInput.nextToken, outputKey: \ListMonitoringAlertHistoryOutputResponse.nextToken, paginationFunction: self.listMonitoringAlertHistory(input:))
    }
}

extension ListMonitoringAlertHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitoringAlertHistoryInput {
        return ListMonitoringAlertHistoryInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            monitoringAlertName: self.monitoringAlertName,
            monitoringScheduleName: self.monitoringScheduleName,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMonitoringAlertHistoryPaginated`
/// to access the nested member `[SageMakerClientTypes.MonitoringAlertHistorySummary]`
/// - Returns: `[SageMakerClientTypes.MonitoringAlertHistorySummary]`
extension PaginatorSequence where Input == ListMonitoringAlertHistoryInput, Output == ListMonitoringAlertHistoryOutputResponse {
    public func monitoringAlertHistory() async throws -> [SageMakerClientTypes.MonitoringAlertHistorySummary] {
        return try await self.asyncCompactMap { item in item.monitoringAlertHistory }
    }
}

/// Paginate over `[ListMonitoringAlertsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMonitoringAlertsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMonitoringAlertsOutputResponse`
extension SageMakerClient {
    public func listMonitoringAlertsPaginated(input: ListMonitoringAlertsInput) -> ClientRuntime.PaginatorSequence<ListMonitoringAlertsInput, ListMonitoringAlertsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMonitoringAlertsInput, ListMonitoringAlertsOutputResponse>(input: input, inputKey: \ListMonitoringAlertsInput.nextToken, outputKey: \ListMonitoringAlertsOutputResponse.nextToken, paginationFunction: self.listMonitoringAlerts(input:))
    }
}

extension ListMonitoringAlertsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitoringAlertsInput {
        return ListMonitoringAlertsInput(
            maxResults: self.maxResults,
            monitoringScheduleName: self.monitoringScheduleName,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMonitoringAlertsPaginated`
/// to access the nested member `[SageMakerClientTypes.MonitoringAlertSummary]`
/// - Returns: `[SageMakerClientTypes.MonitoringAlertSummary]`
extension PaginatorSequence where Input == ListMonitoringAlertsInput, Output == ListMonitoringAlertsOutputResponse {
    public func monitoringAlertSummaries() async throws -> [SageMakerClientTypes.MonitoringAlertSummary] {
        return try await self.asyncCompactMap { item in item.monitoringAlertSummaries }
    }
}

/// Paginate over `[ListMonitoringExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMonitoringExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMonitoringExecutionsOutputResponse`
extension SageMakerClient {
    public func listMonitoringExecutionsPaginated(input: ListMonitoringExecutionsInput) -> ClientRuntime.PaginatorSequence<ListMonitoringExecutionsInput, ListMonitoringExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMonitoringExecutionsInput, ListMonitoringExecutionsOutputResponse>(input: input, inputKey: \ListMonitoringExecutionsInput.nextToken, outputKey: \ListMonitoringExecutionsOutputResponse.nextToken, paginationFunction: self.listMonitoringExecutions(input:))
    }
}

extension ListMonitoringExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitoringExecutionsInput {
        return ListMonitoringExecutionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            monitoringJobDefinitionName: self.monitoringJobDefinitionName,
            monitoringScheduleName: self.monitoringScheduleName,
            monitoringTypeEquals: self.monitoringTypeEquals,
            nextToken: token,
            scheduledTimeAfter: self.scheduledTimeAfter,
            scheduledTimeBefore: self.scheduledTimeBefore,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMonitoringExecutionsPaginated`
/// to access the nested member `[SageMakerClientTypes.MonitoringExecutionSummary]`
/// - Returns: `[SageMakerClientTypes.MonitoringExecutionSummary]`
extension PaginatorSequence where Input == ListMonitoringExecutionsInput, Output == ListMonitoringExecutionsOutputResponse {
    public func monitoringExecutionSummaries() async throws -> [SageMakerClientTypes.MonitoringExecutionSummary] {
        return try await self.asyncCompactMap { item in item.monitoringExecutionSummaries }
    }
}

/// Paginate over `[ListMonitoringSchedulesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMonitoringSchedulesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMonitoringSchedulesOutputResponse`
extension SageMakerClient {
    public func listMonitoringSchedulesPaginated(input: ListMonitoringSchedulesInput) -> ClientRuntime.PaginatorSequence<ListMonitoringSchedulesInput, ListMonitoringSchedulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMonitoringSchedulesInput, ListMonitoringSchedulesOutputResponse>(input: input, inputKey: \ListMonitoringSchedulesInput.nextToken, outputKey: \ListMonitoringSchedulesOutputResponse.nextToken, paginationFunction: self.listMonitoringSchedules(input:))
    }
}

extension ListMonitoringSchedulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitoringSchedulesInput {
        return ListMonitoringSchedulesInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            monitoringJobDefinitionName: self.monitoringJobDefinitionName,
            monitoringTypeEquals: self.monitoringTypeEquals,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMonitoringSchedulesPaginated`
/// to access the nested member `[SageMakerClientTypes.MonitoringScheduleSummary]`
/// - Returns: `[SageMakerClientTypes.MonitoringScheduleSummary]`
extension PaginatorSequence where Input == ListMonitoringSchedulesInput, Output == ListMonitoringSchedulesOutputResponse {
    public func monitoringScheduleSummaries() async throws -> [SageMakerClientTypes.MonitoringScheduleSummary] {
        return try await self.asyncCompactMap { item in item.monitoringScheduleSummaries }
    }
}

/// Paginate over `[ListNotebookInstanceLifecycleConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListNotebookInstanceLifecycleConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListNotebookInstanceLifecycleConfigsOutputResponse`
extension SageMakerClient {
    public func listNotebookInstanceLifecycleConfigsPaginated(input: ListNotebookInstanceLifecycleConfigsInput) -> ClientRuntime.PaginatorSequence<ListNotebookInstanceLifecycleConfigsInput, ListNotebookInstanceLifecycleConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNotebookInstanceLifecycleConfigsInput, ListNotebookInstanceLifecycleConfigsOutputResponse>(input: input, inputKey: \ListNotebookInstanceLifecycleConfigsInput.nextToken, outputKey: \ListNotebookInstanceLifecycleConfigsOutputResponse.nextToken, paginationFunction: self.listNotebookInstanceLifecycleConfigs(input:))
    }
}

extension ListNotebookInstanceLifecycleConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNotebookInstanceLifecycleConfigsInput {
        return ListNotebookInstanceLifecycleConfigsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listNotebookInstanceLifecycleConfigsPaginated`
/// to access the nested member `[SageMakerClientTypes.NotebookInstanceLifecycleConfigSummary]`
/// - Returns: `[SageMakerClientTypes.NotebookInstanceLifecycleConfigSummary]`
extension PaginatorSequence where Input == ListNotebookInstanceLifecycleConfigsInput, Output == ListNotebookInstanceLifecycleConfigsOutputResponse {
    public func notebookInstanceLifecycleConfigs() async throws -> [SageMakerClientTypes.NotebookInstanceLifecycleConfigSummary] {
        return try await self.asyncCompactMap { item in item.notebookInstanceLifecycleConfigs }
    }
}

/// Paginate over `[ListNotebookInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListNotebookInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListNotebookInstancesOutputResponse`
extension SageMakerClient {
    public func listNotebookInstancesPaginated(input: ListNotebookInstancesInput) -> ClientRuntime.PaginatorSequence<ListNotebookInstancesInput, ListNotebookInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNotebookInstancesInput, ListNotebookInstancesOutputResponse>(input: input, inputKey: \ListNotebookInstancesInput.nextToken, outputKey: \ListNotebookInstancesOutputResponse.nextToken, paginationFunction: self.listNotebookInstances(input:))
    }
}

extension ListNotebookInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNotebookInstancesInput {
        return ListNotebookInstancesInput(
            additionalCodeRepositoryEquals: self.additionalCodeRepositoryEquals,
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            defaultCodeRepositoryContains: self.defaultCodeRepositoryContains,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            notebookInstanceLifecycleConfigNameContains: self.notebookInstanceLifecycleConfigNameContains,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listNotebookInstancesPaginated`
/// to access the nested member `[SageMakerClientTypes.NotebookInstanceSummary]`
/// - Returns: `[SageMakerClientTypes.NotebookInstanceSummary]`
extension PaginatorSequence where Input == ListNotebookInstancesInput, Output == ListNotebookInstancesOutputResponse {
    public func notebookInstances() async throws -> [SageMakerClientTypes.NotebookInstanceSummary] {
        return try await self.asyncCompactMap { item in item.notebookInstances }
    }
}

/// Paginate over `[ListPipelineExecutionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPipelineExecutionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPipelineExecutionsOutputResponse`
extension SageMakerClient {
    public func listPipelineExecutionsPaginated(input: ListPipelineExecutionsInput) -> ClientRuntime.PaginatorSequence<ListPipelineExecutionsInput, ListPipelineExecutionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPipelineExecutionsInput, ListPipelineExecutionsOutputResponse>(input: input, inputKey: \ListPipelineExecutionsInput.nextToken, outputKey: \ListPipelineExecutionsOutputResponse.nextToken, paginationFunction: self.listPipelineExecutions(input:))
    }
}

extension ListPipelineExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPipelineExecutionsInput {
        return ListPipelineExecutionsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            pipelineName: self.pipelineName,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPipelineExecutionsPaginated`
/// to access the nested member `[SageMakerClientTypes.PipelineExecutionSummary]`
/// - Returns: `[SageMakerClientTypes.PipelineExecutionSummary]`
extension PaginatorSequence where Input == ListPipelineExecutionsInput, Output == ListPipelineExecutionsOutputResponse {
    public func pipelineExecutionSummaries() async throws -> [SageMakerClientTypes.PipelineExecutionSummary] {
        return try await self.asyncCompactMap { item in item.pipelineExecutionSummaries }
    }
}

/// Paginate over `[ListPipelineExecutionStepsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPipelineExecutionStepsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPipelineExecutionStepsOutputResponse`
extension SageMakerClient {
    public func listPipelineExecutionStepsPaginated(input: ListPipelineExecutionStepsInput) -> ClientRuntime.PaginatorSequence<ListPipelineExecutionStepsInput, ListPipelineExecutionStepsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPipelineExecutionStepsInput, ListPipelineExecutionStepsOutputResponse>(input: input, inputKey: \ListPipelineExecutionStepsInput.nextToken, outputKey: \ListPipelineExecutionStepsOutputResponse.nextToken, paginationFunction: self.listPipelineExecutionSteps(input:))
    }
}

extension ListPipelineExecutionStepsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPipelineExecutionStepsInput {
        return ListPipelineExecutionStepsInput(
            maxResults: self.maxResults,
            nextToken: token,
            pipelineExecutionArn: self.pipelineExecutionArn,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPipelineExecutionStepsPaginated`
/// to access the nested member `[SageMakerClientTypes.PipelineExecutionStep]`
/// - Returns: `[SageMakerClientTypes.PipelineExecutionStep]`
extension PaginatorSequence where Input == ListPipelineExecutionStepsInput, Output == ListPipelineExecutionStepsOutputResponse {
    public func pipelineExecutionSteps() async throws -> [SageMakerClientTypes.PipelineExecutionStep] {
        return try await self.asyncCompactMap { item in item.pipelineExecutionSteps }
    }
}

/// Paginate over `[ListPipelineParametersForExecutionOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPipelineParametersForExecutionInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPipelineParametersForExecutionOutputResponse`
extension SageMakerClient {
    public func listPipelineParametersForExecutionPaginated(input: ListPipelineParametersForExecutionInput) -> ClientRuntime.PaginatorSequence<ListPipelineParametersForExecutionInput, ListPipelineParametersForExecutionOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPipelineParametersForExecutionInput, ListPipelineParametersForExecutionOutputResponse>(input: input, inputKey: \ListPipelineParametersForExecutionInput.nextToken, outputKey: \ListPipelineParametersForExecutionOutputResponse.nextToken, paginationFunction: self.listPipelineParametersForExecution(input:))
    }
}

extension ListPipelineParametersForExecutionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPipelineParametersForExecutionInput {
        return ListPipelineParametersForExecutionInput(
            maxResults: self.maxResults,
            nextToken: token,
            pipelineExecutionArn: self.pipelineExecutionArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPipelineParametersForExecutionPaginated`
/// to access the nested member `[SageMakerClientTypes.Parameter]`
/// - Returns: `[SageMakerClientTypes.Parameter]`
extension PaginatorSequence where Input == ListPipelineParametersForExecutionInput, Output == ListPipelineParametersForExecutionOutputResponse {
    public func pipelineParameters() async throws -> [SageMakerClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.pipelineParameters }
    }
}

/// Paginate over `[ListPipelinesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPipelinesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPipelinesOutputResponse`
extension SageMakerClient {
    public func listPipelinesPaginated(input: ListPipelinesInput) -> ClientRuntime.PaginatorSequence<ListPipelinesInput, ListPipelinesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPipelinesInput, ListPipelinesOutputResponse>(input: input, inputKey: \ListPipelinesInput.nextToken, outputKey: \ListPipelinesOutputResponse.nextToken, paginationFunction: self.listPipelines(input:))
    }
}

extension ListPipelinesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPipelinesInput {
        return ListPipelinesInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            pipelineNamePrefix: self.pipelineNamePrefix,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPipelinesPaginated`
/// to access the nested member `[SageMakerClientTypes.PipelineSummary]`
/// - Returns: `[SageMakerClientTypes.PipelineSummary]`
extension PaginatorSequence where Input == ListPipelinesInput, Output == ListPipelinesOutputResponse {
    public func pipelineSummaries() async throws -> [SageMakerClientTypes.PipelineSummary] {
        return try await self.asyncCompactMap { item in item.pipelineSummaries }
    }
}

/// Paginate over `[ListProcessingJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProcessingJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProcessingJobsOutputResponse`
extension SageMakerClient {
    public func listProcessingJobsPaginated(input: ListProcessingJobsInput) -> ClientRuntime.PaginatorSequence<ListProcessingJobsInput, ListProcessingJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProcessingJobsInput, ListProcessingJobsOutputResponse>(input: input, inputKey: \ListProcessingJobsInput.nextToken, outputKey: \ListProcessingJobsOutputResponse.nextToken, paginationFunction: self.listProcessingJobs(input:))
    }
}

extension ListProcessingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProcessingJobsInput {
        return ListProcessingJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listProcessingJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.ProcessingJobSummary]`
/// - Returns: `[SageMakerClientTypes.ProcessingJobSummary]`
extension PaginatorSequence where Input == ListProcessingJobsInput, Output == ListProcessingJobsOutputResponse {
    public func processingJobSummaries() async throws -> [SageMakerClientTypes.ProcessingJobSummary] {
        return try await self.asyncCompactMap { item in item.processingJobSummaries }
    }
}

/// Paginate over `[ListProjectsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProjectsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProjectsOutputResponse`
extension SageMakerClient {
    public func listProjectsPaginated(input: ListProjectsInput) -> ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutputResponse>(input: input, inputKey: \ListProjectsInput.nextToken, outputKey: \ListProjectsOutputResponse.nextToken, paginationFunction: self.listProjects(input:))
    }
}

extension ListProjectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProjectsInput {
        return ListProjectsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// Paginate over `[ListSpacesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSpacesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSpacesOutputResponse`
extension SageMakerClient {
    public func listSpacesPaginated(input: ListSpacesInput) -> ClientRuntime.PaginatorSequence<ListSpacesInput, ListSpacesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSpacesInput, ListSpacesOutputResponse>(input: input, inputKey: \ListSpacesInput.nextToken, outputKey: \ListSpacesOutputResponse.nextToken, paginationFunction: self.listSpaces(input:))
    }
}

extension ListSpacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSpacesInput {
        return ListSpacesInput(
            domainIdEquals: self.domainIdEquals,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            spaceNameContains: self.spaceNameContains
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSpacesPaginated`
/// to access the nested member `[SageMakerClientTypes.SpaceDetails]`
/// - Returns: `[SageMakerClientTypes.SpaceDetails]`
extension PaginatorSequence where Input == ListSpacesInput, Output == ListSpacesOutputResponse {
    public func spaces() async throws -> [SageMakerClientTypes.SpaceDetails] {
        return try await self.asyncCompactMap { item in item.spaces }
    }
}

/// Paginate over `[ListStageDevicesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListStageDevicesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListStageDevicesOutputResponse`
extension SageMakerClient {
    public func listStageDevicesPaginated(input: ListStageDevicesInput) -> ClientRuntime.PaginatorSequence<ListStageDevicesInput, ListStageDevicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListStageDevicesInput, ListStageDevicesOutputResponse>(input: input, inputKey: \ListStageDevicesInput.nextToken, outputKey: \ListStageDevicesOutputResponse.nextToken, paginationFunction: self.listStageDevices(input:))
    }
}

extension ListStageDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStageDevicesInput {
        return ListStageDevicesInput(
            edgeDeploymentPlanName: self.edgeDeploymentPlanName,
            excludeDevicesDeployedInOtherStage: self.excludeDevicesDeployedInOtherStage,
            maxResults: self.maxResults,
            nextToken: token,
            stageName: self.stageName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listStageDevicesPaginated`
/// to access the nested member `[SageMakerClientTypes.DeviceDeploymentSummary]`
/// - Returns: `[SageMakerClientTypes.DeviceDeploymentSummary]`
extension PaginatorSequence where Input == ListStageDevicesInput, Output == ListStageDevicesOutputResponse {
    public func deviceDeploymentSummaries() async throws -> [SageMakerClientTypes.DeviceDeploymentSummary] {
        return try await self.asyncCompactMap { item in item.deviceDeploymentSummaries }
    }
}

/// Paginate over `[ListStudioLifecycleConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListStudioLifecycleConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListStudioLifecycleConfigsOutputResponse`
extension SageMakerClient {
    public func listStudioLifecycleConfigsPaginated(input: ListStudioLifecycleConfigsInput) -> ClientRuntime.PaginatorSequence<ListStudioLifecycleConfigsInput, ListStudioLifecycleConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListStudioLifecycleConfigsInput, ListStudioLifecycleConfigsOutputResponse>(input: input, inputKey: \ListStudioLifecycleConfigsInput.nextToken, outputKey: \ListStudioLifecycleConfigsOutputResponse.nextToken, paginationFunction: self.listStudioLifecycleConfigs(input:))
    }
}

extension ListStudioLifecycleConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStudioLifecycleConfigsInput {
        return ListStudioLifecycleConfigsInput(
            appTypeEquals: self.appTypeEquals,
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modifiedTimeAfter: self.modifiedTimeAfter,
            modifiedTimeBefore: self.modifiedTimeBefore,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listStudioLifecycleConfigsPaginated`
/// to access the nested member `[SageMakerClientTypes.StudioLifecycleConfigDetails]`
/// - Returns: `[SageMakerClientTypes.StudioLifecycleConfigDetails]`
extension PaginatorSequence where Input == ListStudioLifecycleConfigsInput, Output == ListStudioLifecycleConfigsOutputResponse {
    public func studioLifecycleConfigs() async throws -> [SageMakerClientTypes.StudioLifecycleConfigDetails] {
        return try await self.asyncCompactMap { item in item.studioLifecycleConfigs }
    }
}

/// Paginate over `[ListSubscribedWorkteamsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListSubscribedWorkteamsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListSubscribedWorkteamsOutputResponse`
extension SageMakerClient {
    public func listSubscribedWorkteamsPaginated(input: ListSubscribedWorkteamsInput) -> ClientRuntime.PaginatorSequence<ListSubscribedWorkteamsInput, ListSubscribedWorkteamsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListSubscribedWorkteamsInput, ListSubscribedWorkteamsOutputResponse>(input: input, inputKey: \ListSubscribedWorkteamsInput.nextToken, outputKey: \ListSubscribedWorkteamsOutputResponse.nextToken, paginationFunction: self.listSubscribedWorkteams(input:))
    }
}

extension ListSubscribedWorkteamsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSubscribedWorkteamsInput {
        return ListSubscribedWorkteamsInput(
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listSubscribedWorkteamsPaginated`
/// to access the nested member `[SageMakerClientTypes.SubscribedWorkteam]`
/// - Returns: `[SageMakerClientTypes.SubscribedWorkteam]`
extension PaginatorSequence where Input == ListSubscribedWorkteamsInput, Output == ListSubscribedWorkteamsOutputResponse {
    public func subscribedWorkteams() async throws -> [SageMakerClientTypes.SubscribedWorkteam] {
        return try await self.asyncCompactMap { item in item.subscribedWorkteams }
    }
}

/// Paginate over `[ListTagsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTagsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTagsOutputResponse`
extension SageMakerClient {
    public func listTagsPaginated(input: ListTagsInput) -> ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutputResponse>(input: input, inputKey: \ListTagsInput.nextToken, outputKey: \ListTagsOutputResponse.nextToken, paginationFunction: self.listTags(input:))
    }
}

extension ListTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsInput {
        return ListTagsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTagsPaginated`
/// to access the nested member `[SageMakerClientTypes.Tag]`
/// - Returns: `[SageMakerClientTypes.Tag]`
extension PaginatorSequence where Input == ListTagsInput, Output == ListTagsOutputResponse {
    public func tags() async throws -> [SageMakerClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}

/// Paginate over `[ListTrainingJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTrainingJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTrainingJobsOutputResponse`
extension SageMakerClient {
    public func listTrainingJobsPaginated(input: ListTrainingJobsInput) -> ClientRuntime.PaginatorSequence<ListTrainingJobsInput, ListTrainingJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTrainingJobsInput, ListTrainingJobsOutputResponse>(input: input, inputKey: \ListTrainingJobsInput.nextToken, outputKey: \ListTrainingJobsOutputResponse.nextToken, paginationFunction: self.listTrainingJobs(input:))
    }
}

extension ListTrainingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrainingJobsInput {
        return ListTrainingJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals,
            warmPoolStatusEquals: self.warmPoolStatusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTrainingJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.TrainingJobSummary]`
/// - Returns: `[SageMakerClientTypes.TrainingJobSummary]`
extension PaginatorSequence where Input == ListTrainingJobsInput, Output == ListTrainingJobsOutputResponse {
    public func trainingJobSummaries() async throws -> [SageMakerClientTypes.TrainingJobSummary] {
        return try await self.asyncCompactMap { item in item.trainingJobSummaries }
    }
}

/// Paginate over `[ListTrainingJobsForHyperParameterTuningJobOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTrainingJobsForHyperParameterTuningJobInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTrainingJobsForHyperParameterTuningJobOutputResponse`
extension SageMakerClient {
    public func listTrainingJobsForHyperParameterTuningJobPaginated(input: ListTrainingJobsForHyperParameterTuningJobInput) -> ClientRuntime.PaginatorSequence<ListTrainingJobsForHyperParameterTuningJobInput, ListTrainingJobsForHyperParameterTuningJobOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTrainingJobsForHyperParameterTuningJobInput, ListTrainingJobsForHyperParameterTuningJobOutputResponse>(input: input, inputKey: \ListTrainingJobsForHyperParameterTuningJobInput.nextToken, outputKey: \ListTrainingJobsForHyperParameterTuningJobOutputResponse.nextToken, paginationFunction: self.listTrainingJobsForHyperParameterTuningJob(input:))
    }
}

extension ListTrainingJobsForHyperParameterTuningJobInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrainingJobsForHyperParameterTuningJobInput {
        return ListTrainingJobsForHyperParameterTuningJobInput(
            hyperParameterTuningJobName: self.hyperParameterTuningJobName,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTrainingJobsForHyperParameterTuningJobPaginated`
/// to access the nested member `[SageMakerClientTypes.HyperParameterTrainingJobSummary]`
/// - Returns: `[SageMakerClientTypes.HyperParameterTrainingJobSummary]`
extension PaginatorSequence where Input == ListTrainingJobsForHyperParameterTuningJobInput, Output == ListTrainingJobsForHyperParameterTuningJobOutputResponse {
    public func trainingJobSummaries() async throws -> [SageMakerClientTypes.HyperParameterTrainingJobSummary] {
        return try await self.asyncCompactMap { item in item.trainingJobSummaries }
    }
}

/// Paginate over `[ListTransformJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTransformJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTransformJobsOutputResponse`
extension SageMakerClient {
    public func listTransformJobsPaginated(input: ListTransformJobsInput) -> ClientRuntime.PaginatorSequence<ListTransformJobsInput, ListTransformJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTransformJobsInput, ListTransformJobsOutputResponse>(input: input, inputKey: \ListTransformJobsInput.nextToken, outputKey: \ListTransformJobsOutputResponse.nextToken, paginationFunction: self.listTransformJobs(input:))
    }
}

extension ListTransformJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTransformJobsInput {
        return ListTransformJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTransformJobsPaginated`
/// to access the nested member `[SageMakerClientTypes.TransformJobSummary]`
/// - Returns: `[SageMakerClientTypes.TransformJobSummary]`
extension PaginatorSequence where Input == ListTransformJobsInput, Output == ListTransformJobsOutputResponse {
    public func transformJobSummaries() async throws -> [SageMakerClientTypes.TransformJobSummary] {
        return try await self.asyncCompactMap { item in item.transformJobSummaries }
    }
}

/// Paginate over `[ListTrialComponentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTrialComponentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTrialComponentsOutputResponse`
extension SageMakerClient {
    public func listTrialComponentsPaginated(input: ListTrialComponentsInput) -> ClientRuntime.PaginatorSequence<ListTrialComponentsInput, ListTrialComponentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTrialComponentsInput, ListTrialComponentsOutputResponse>(input: input, inputKey: \ListTrialComponentsInput.nextToken, outputKey: \ListTrialComponentsOutputResponse.nextToken, paginationFunction: self.listTrialComponents(input:))
    }
}

extension ListTrialComponentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrialComponentsInput {
        return ListTrialComponentsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            experimentName: self.experimentName,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceArn: self.sourceArn,
            trialName: self.trialName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTrialComponentsPaginated`
/// to access the nested member `[SageMakerClientTypes.TrialComponentSummary]`
/// - Returns: `[SageMakerClientTypes.TrialComponentSummary]`
extension PaginatorSequence where Input == ListTrialComponentsInput, Output == ListTrialComponentsOutputResponse {
    public func trialComponentSummaries() async throws -> [SageMakerClientTypes.TrialComponentSummary] {
        return try await self.asyncCompactMap { item in item.trialComponentSummaries }
    }
}

/// Paginate over `[ListTrialsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTrialsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTrialsOutputResponse`
extension SageMakerClient {
    public func listTrialsPaginated(input: ListTrialsInput) -> ClientRuntime.PaginatorSequence<ListTrialsInput, ListTrialsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTrialsInput, ListTrialsOutputResponse>(input: input, inputKey: \ListTrialsInput.nextToken, outputKey: \ListTrialsOutputResponse.nextToken, paginationFunction: self.listTrials(input:))
    }
}

extension ListTrialsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrialsInput {
        return ListTrialsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            experimentName: self.experimentName,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            trialComponentName: self.trialComponentName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTrialsPaginated`
/// to access the nested member `[SageMakerClientTypes.TrialSummary]`
/// - Returns: `[SageMakerClientTypes.TrialSummary]`
extension PaginatorSequence where Input == ListTrialsInput, Output == ListTrialsOutputResponse {
    public func trialSummaries() async throws -> [SageMakerClientTypes.TrialSummary] {
        return try await self.asyncCompactMap { item in item.trialSummaries }
    }
}

/// Paginate over `[ListUserProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUserProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUserProfilesOutputResponse`
extension SageMakerClient {
    public func listUserProfilesPaginated(input: ListUserProfilesInput) -> ClientRuntime.PaginatorSequence<ListUserProfilesInput, ListUserProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUserProfilesInput, ListUserProfilesOutputResponse>(input: input, inputKey: \ListUserProfilesInput.nextToken, outputKey: \ListUserProfilesOutputResponse.nextToken, paginationFunction: self.listUserProfiles(input:))
    }
}

extension ListUserProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserProfilesInput {
        return ListUserProfilesInput(
            domainIdEquals: self.domainIdEquals,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            userProfileNameContains: self.userProfileNameContains
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUserProfilesPaginated`
/// to access the nested member `[SageMakerClientTypes.UserProfileDetails]`
/// - Returns: `[SageMakerClientTypes.UserProfileDetails]`
extension PaginatorSequence where Input == ListUserProfilesInput, Output == ListUserProfilesOutputResponse {
    public func userProfiles() async throws -> [SageMakerClientTypes.UserProfileDetails] {
        return try await self.asyncCompactMap { item in item.userProfiles }
    }
}

/// Paginate over `[ListWorkforcesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListWorkforcesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListWorkforcesOutputResponse`
extension SageMakerClient {
    public func listWorkforcesPaginated(input: ListWorkforcesInput) -> ClientRuntime.PaginatorSequence<ListWorkforcesInput, ListWorkforcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorkforcesInput, ListWorkforcesOutputResponse>(input: input, inputKey: \ListWorkforcesInput.nextToken, outputKey: \ListWorkforcesOutputResponse.nextToken, paginationFunction: self.listWorkforces(input:))
    }
}

extension ListWorkforcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkforcesInput {
        return ListWorkforcesInput(
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listWorkforcesPaginated`
/// to access the nested member `[SageMakerClientTypes.Workforce]`
/// - Returns: `[SageMakerClientTypes.Workforce]`
extension PaginatorSequence where Input == ListWorkforcesInput, Output == ListWorkforcesOutputResponse {
    public func workforces() async throws -> [SageMakerClientTypes.Workforce] {
        return try await self.asyncCompactMap { item in item.workforces }
    }
}

/// Paginate over `[ListWorkteamsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListWorkteamsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListWorkteamsOutputResponse`
extension SageMakerClient {
    public func listWorkteamsPaginated(input: ListWorkteamsInput) -> ClientRuntime.PaginatorSequence<ListWorkteamsInput, ListWorkteamsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListWorkteamsInput, ListWorkteamsOutputResponse>(input: input, inputKey: \ListWorkteamsInput.nextToken, outputKey: \ListWorkteamsOutputResponse.nextToken, paginationFunction: self.listWorkteams(input:))
    }
}

extension ListWorkteamsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkteamsInput {
        return ListWorkteamsInput(
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listWorkteamsPaginated`
/// to access the nested member `[SageMakerClientTypes.Workteam]`
/// - Returns: `[SageMakerClientTypes.Workteam]`
extension PaginatorSequence where Input == ListWorkteamsInput, Output == ListWorkteamsOutputResponse {
    public func workteams() async throws -> [SageMakerClientTypes.Workteam] {
        return try await self.asyncCompactMap { item in item.workteams }
    }
}

/// Paginate over `[QueryLineageOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[QueryLineageInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `QueryLineageOutputResponse`
extension SageMakerClient {
    public func queryLineagePaginated(input: QueryLineageInput) -> ClientRuntime.PaginatorSequence<QueryLineageInput, QueryLineageOutputResponse> {
        return ClientRuntime.PaginatorSequence<QueryLineageInput, QueryLineageOutputResponse>(input: input, inputKey: \QueryLineageInput.nextToken, outputKey: \QueryLineageOutputResponse.nextToken, paginationFunction: self.queryLineage(input:))
    }
}

extension QueryLineageInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> QueryLineageInput {
        return QueryLineageInput(
            direction: self.direction,
            filters: self.filters,
            includeEdges: self.includeEdges,
            maxDepth: self.maxDepth,
            maxResults: self.maxResults,
            nextToken: token,
            startArns: self.startArns
        )}
}

/// Paginate over `[SearchOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchOutputResponse`
extension SageMakerClient {
    public func searchPaginated(input: SearchInput) -> ClientRuntime.PaginatorSequence<SearchInput, SearchOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchInput, SearchOutputResponse>(input: input, inputKey: \SearchInput.nextToken, outputKey: \SearchOutputResponse.nextToken, paginationFunction: self.search(input:))
    }
}

extension SearchInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchInput {
        return SearchInput(
            maxResults: self.maxResults,
            nextToken: token,
            resource: self.resource,
            searchExpression: self.searchExpression,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchPaginated`
/// to access the nested member `[SageMakerClientTypes.SearchRecord]`
/// - Returns: `[SageMakerClientTypes.SearchRecord]`
extension PaginatorSequence where Input == SearchInput, Output == SearchOutputResponse {
    public func results() async throws -> [SageMakerClientTypes.SearchRecord] {
        return try await self.asyncCompactMap { item in item.results }
    }
}
