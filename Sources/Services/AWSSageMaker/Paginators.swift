// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SageMakerClient {
    /// Paginate over `[ListActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListActionsOutput`
    public func listActionsPaginated(input: ListActionsInput) -> ClientRuntime.PaginatorSequence<ListActionsInput, ListActionsOutput> {
        return ClientRuntime.PaginatorSequence<ListActionsInput, ListActionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listActions(input:))
    }
}

extension ListActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListActionsInput {
        return ListActionsInput(
            actionType: self.actionType,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceUri: self.sourceUri
        )}
}

extension PaginatorSequence where OperationStackInput == ListActionsInput, OperationStackOutput == ListActionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listActionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ActionSummary]`
    /// - Returns: `[SageMakerClientTypes.ActionSummary]`
    public func actionSummaries() async throws -> [SageMakerClientTypes.ActionSummary] {
        return try await self.asyncCompactMap { item in item.actionSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListAlgorithmsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAlgorithmsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAlgorithmsOutput`
    public func listAlgorithmsPaginated(input: ListAlgorithmsInput) -> ClientRuntime.PaginatorSequence<ListAlgorithmsInput, ListAlgorithmsOutput> {
        return ClientRuntime.PaginatorSequence<ListAlgorithmsInput, ListAlgorithmsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAlgorithms(input:))
    }
}

extension ListAlgorithmsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAlgorithmsInput {
        return ListAlgorithmsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListAlgorithmsInput, OperationStackOutput == ListAlgorithmsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAlgorithmsPaginated`
    /// to access the nested member `[SageMakerClientTypes.AlgorithmSummary]`
    /// - Returns: `[SageMakerClientTypes.AlgorithmSummary]`
    public func algorithmSummaryList() async throws -> [SageMakerClientTypes.AlgorithmSummary] {
        return try await self.asyncCompactMap { item in item.algorithmSummaryList }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListAliasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAliasesOutput`
    public func listAliasesPaginated(input: ListAliasesInput) -> ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutput> {
        return ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAliases(input:))
    }
}

extension ListAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAliasesInput {
        return ListAliasesInput(
            alias: self.alias,
            imageName: self.imageName,
            maxResults: self.maxResults,
            nextToken: token,
            version: self.version
        )}
}

extension PaginatorSequence where OperationStackInput == ListAliasesInput, OperationStackOutput == ListAliasesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAliasesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func sageMakerImageVersionAliases() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.sageMakerImageVersionAliases }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListAppImageConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppImageConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppImageConfigsOutput`
    public func listAppImageConfigsPaginated(input: ListAppImageConfigsInput) -> ClientRuntime.PaginatorSequence<ListAppImageConfigsInput, ListAppImageConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListAppImageConfigsInput, ListAppImageConfigsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAppImageConfigs(input:))
    }
}

extension ListAppImageConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppImageConfigsInput {
        return ListAppImageConfigsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modifiedTimeAfter: self.modifiedTimeAfter,
            modifiedTimeBefore: self.modifiedTimeBefore,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListAppImageConfigsInput, OperationStackOutput == ListAppImageConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAppImageConfigsPaginated`
    /// to access the nested member `[SageMakerClientTypes.AppImageConfigDetails]`
    /// - Returns: `[SageMakerClientTypes.AppImageConfigDetails]`
    public func appImageConfigs() async throws -> [SageMakerClientTypes.AppImageConfigDetails] {
        return try await self.asyncCompactMap { item in item.appImageConfigs }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListAppsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppsOutput`
    public func listAppsPaginated(input: ListAppsInput) -> ClientRuntime.PaginatorSequence<ListAppsInput, ListAppsOutput> {
        return ClientRuntime.PaginatorSequence<ListAppsInput, ListAppsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listApps(input:))
    }
}

extension ListAppsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppsInput {
        return ListAppsInput(
            domainIdEquals: self.domainIdEquals,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            spaceNameEquals: self.spaceNameEquals,
            userProfileNameEquals: self.userProfileNameEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListAppsInput, OperationStackOutput == ListAppsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAppsPaginated`
    /// to access the nested member `[SageMakerClientTypes.AppDetails]`
    /// - Returns: `[SageMakerClientTypes.AppDetails]`
    public func apps() async throws -> [SageMakerClientTypes.AppDetails] {
        return try await self.asyncCompactMap { item in item.apps }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListArtifactsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListArtifactsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListArtifactsOutput`
    public func listArtifactsPaginated(input: ListArtifactsInput) -> ClientRuntime.PaginatorSequence<ListArtifactsInput, ListArtifactsOutput> {
        return ClientRuntime.PaginatorSequence<ListArtifactsInput, ListArtifactsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listArtifacts(input:))
    }
}

extension ListArtifactsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListArtifactsInput {
        return ListArtifactsInput(
            artifactType: self.artifactType,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceUri: self.sourceUri
        )}
}

extension PaginatorSequence where OperationStackInput == ListArtifactsInput, OperationStackOutput == ListArtifactsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listArtifactsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ArtifactSummary]`
    /// - Returns: `[SageMakerClientTypes.ArtifactSummary]`
    public func artifactSummaries() async throws -> [SageMakerClientTypes.ArtifactSummary] {
        return try await self.asyncCompactMap { item in item.artifactSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssociationsOutput`
    public func listAssociationsPaginated(input: ListAssociationsInput) -> ClientRuntime.PaginatorSequence<ListAssociationsInput, ListAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssociationsInput, ListAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssociations(input:))
    }
}

extension ListAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssociationsInput {
        return ListAssociationsInput(
            associationType: self.associationType,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            destinationArn: self.destinationArn,
            destinationType: self.destinationType,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceArn: self.sourceArn,
            sourceType: self.sourceType
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssociationsInput, OperationStackOutput == ListAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssociationsPaginated`
    /// to access the nested member `[SageMakerClientTypes.AssociationSummary]`
    /// - Returns: `[SageMakerClientTypes.AssociationSummary]`
    public func associationSummaries() async throws -> [SageMakerClientTypes.AssociationSummary] {
        return try await self.asyncCompactMap { item in item.associationSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListAutoMLJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAutoMLJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAutoMLJobsOutput`
    public func listAutoMLJobsPaginated(input: ListAutoMLJobsInput) -> ClientRuntime.PaginatorSequence<ListAutoMLJobsInput, ListAutoMLJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListAutoMLJobsInput, ListAutoMLJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAutoMLJobs(input:))
    }
}

extension ListAutoMLJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAutoMLJobsInput {
        return ListAutoMLJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListAutoMLJobsInput, OperationStackOutput == ListAutoMLJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAutoMLJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.AutoMLJobSummary]`
    /// - Returns: `[SageMakerClientTypes.AutoMLJobSummary]`
    public func autoMLJobSummaries() async throws -> [SageMakerClientTypes.AutoMLJobSummary] {
        return try await self.asyncCompactMap { item in item.autoMLJobSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListCandidatesForAutoMLJobOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCandidatesForAutoMLJobInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCandidatesForAutoMLJobOutput`
    public func listCandidatesForAutoMLJobPaginated(input: ListCandidatesForAutoMLJobInput) -> ClientRuntime.PaginatorSequence<ListCandidatesForAutoMLJobInput, ListCandidatesForAutoMLJobOutput> {
        return ClientRuntime.PaginatorSequence<ListCandidatesForAutoMLJobInput, ListCandidatesForAutoMLJobOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCandidatesForAutoMLJob(input:))
    }
}

extension ListCandidatesForAutoMLJobInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCandidatesForAutoMLJobInput {
        return ListCandidatesForAutoMLJobInput(
            autoMLJobName: self.autoMLJobName,
            candidateNameEquals: self.candidateNameEquals,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListCandidatesForAutoMLJobInput, OperationStackOutput == ListCandidatesForAutoMLJobOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCandidatesForAutoMLJobPaginated`
    /// to access the nested member `[SageMakerClientTypes.AutoMLCandidate]`
    /// - Returns: `[SageMakerClientTypes.AutoMLCandidate]`
    public func candidates() async throws -> [SageMakerClientTypes.AutoMLCandidate] {
        return try await self.asyncCompactMap { item in item.candidates }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListCodeRepositoriesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCodeRepositoriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCodeRepositoriesOutput`
    public func listCodeRepositoriesPaginated(input: ListCodeRepositoriesInput) -> ClientRuntime.PaginatorSequence<ListCodeRepositoriesInput, ListCodeRepositoriesOutput> {
        return ClientRuntime.PaginatorSequence<ListCodeRepositoriesInput, ListCodeRepositoriesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCodeRepositories(input:))
    }
}

extension ListCodeRepositoriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCodeRepositoriesInput {
        return ListCodeRepositoriesInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListCodeRepositoriesInput, OperationStackOutput == ListCodeRepositoriesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCodeRepositoriesPaginated`
    /// to access the nested member `[SageMakerClientTypes.CodeRepositorySummary]`
    /// - Returns: `[SageMakerClientTypes.CodeRepositorySummary]`
    public func codeRepositorySummaryList() async throws -> [SageMakerClientTypes.CodeRepositorySummary] {
        return try await self.asyncCompactMap { item in item.codeRepositorySummaryList }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListCompilationJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCompilationJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCompilationJobsOutput`
    public func listCompilationJobsPaginated(input: ListCompilationJobsInput) -> ClientRuntime.PaginatorSequence<ListCompilationJobsInput, ListCompilationJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListCompilationJobsInput, ListCompilationJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCompilationJobs(input:))
    }
}

extension ListCompilationJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCompilationJobsInput {
        return ListCompilationJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListCompilationJobsInput, OperationStackOutput == ListCompilationJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCompilationJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.CompilationJobSummary]`
    /// - Returns: `[SageMakerClientTypes.CompilationJobSummary]`
    public func compilationJobSummaries() async throws -> [SageMakerClientTypes.CompilationJobSummary] {
        return try await self.asyncCompactMap { item in item.compilationJobSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListContextsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListContextsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListContextsOutput`
    public func listContextsPaginated(input: ListContextsInput) -> ClientRuntime.PaginatorSequence<ListContextsInput, ListContextsOutput> {
        return ClientRuntime.PaginatorSequence<ListContextsInput, ListContextsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listContexts(input:))
    }
}

extension ListContextsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContextsInput {
        return ListContextsInput(
            contextType: self.contextType,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceUri: self.sourceUri
        )}
}

extension PaginatorSequence where OperationStackInput == ListContextsInput, OperationStackOutput == ListContextsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listContextsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ContextSummary]`
    /// - Returns: `[SageMakerClientTypes.ContextSummary]`
    public func contextSummaries() async throws -> [SageMakerClientTypes.ContextSummary] {
        return try await self.asyncCompactMap { item in item.contextSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListDataQualityJobDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityJobDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityJobDefinitionsOutput`
    public func listDataQualityJobDefinitionsPaginated(input: ListDataQualityJobDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityJobDefinitionsInput, ListDataQualityJobDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityJobDefinitionsInput, ListDataQualityJobDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataQualityJobDefinitions(input:))
    }
}

extension ListDataQualityJobDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityJobDefinitionsInput {
        return ListDataQualityJobDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListDataQualityJobDefinitionsInput, OperationStackOutput == ListDataQualityJobDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDataQualityJobDefinitionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
    /// - Returns: `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
    public func jobDefinitionSummaries() async throws -> [SageMakerClientTypes.MonitoringJobDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.jobDefinitionSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListDeviceFleetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDeviceFleetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDeviceFleetsOutput`
    public func listDeviceFleetsPaginated(input: ListDeviceFleetsInput) -> ClientRuntime.PaginatorSequence<ListDeviceFleetsInput, ListDeviceFleetsOutput> {
        return ClientRuntime.PaginatorSequence<ListDeviceFleetsInput, ListDeviceFleetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDeviceFleets(input:))
    }
}

extension ListDeviceFleetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeviceFleetsInput {
        return ListDeviceFleetsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListDeviceFleetsInput, OperationStackOutput == ListDeviceFleetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDeviceFleetsPaginated`
    /// to access the nested member `[SageMakerClientTypes.DeviceFleetSummary]`
    /// - Returns: `[SageMakerClientTypes.DeviceFleetSummary]`
    public func deviceFleetSummaries() async throws -> [SageMakerClientTypes.DeviceFleetSummary] {
        return try await self.asyncCompactMap { item in item.deviceFleetSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListDevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicesOutput`
    public func listDevicesPaginated(input: ListDevicesInput) -> ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutput> {
        return ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDevices(input:))
    }
}

extension ListDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicesInput {
        return ListDevicesInput(
            deviceFleetName: self.deviceFleetName,
            latestHeartbeatAfter: self.latestHeartbeatAfter,
            maxResults: self.maxResults,
            modelName: self.modelName,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDevicesInput, OperationStackOutput == ListDevicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDevicesPaginated`
    /// to access the nested member `[SageMakerClientTypes.DeviceSummary]`
    /// - Returns: `[SageMakerClientTypes.DeviceSummary]`
    public func deviceSummaries() async throws -> [SageMakerClientTypes.DeviceSummary] {
        return try await self.asyncCompactMap { item in item.deviceSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListDomainsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDomainsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDomainsOutput`
    public func listDomainsPaginated(input: ListDomainsInput) -> ClientRuntime.PaginatorSequence<ListDomainsInput, ListDomainsOutput> {
        return ClientRuntime.PaginatorSequence<ListDomainsInput, ListDomainsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDomains(input:))
    }
}

extension ListDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDomainsInput {
        return ListDomainsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDomainsInput, OperationStackOutput == ListDomainsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDomainsPaginated`
    /// to access the nested member `[SageMakerClientTypes.DomainDetails]`
    /// - Returns: `[SageMakerClientTypes.DomainDetails]`
    public func domains() async throws -> [SageMakerClientTypes.DomainDetails] {
        return try await self.asyncCompactMap { item in item.domains }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListEdgeDeploymentPlansOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEdgeDeploymentPlansInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEdgeDeploymentPlansOutput`
    public func listEdgeDeploymentPlansPaginated(input: ListEdgeDeploymentPlansInput) -> ClientRuntime.PaginatorSequence<ListEdgeDeploymentPlansInput, ListEdgeDeploymentPlansOutput> {
        return ClientRuntime.PaginatorSequence<ListEdgeDeploymentPlansInput, ListEdgeDeploymentPlansOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEdgeDeploymentPlans(input:))
    }
}

extension ListEdgeDeploymentPlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEdgeDeploymentPlansInput {
        return ListEdgeDeploymentPlansInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            deviceFleetNameContains: self.deviceFleetNameContains,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListEdgeDeploymentPlansInput, OperationStackOutput == ListEdgeDeploymentPlansOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listEdgeDeploymentPlansPaginated`
    /// to access the nested member `[SageMakerClientTypes.EdgeDeploymentPlanSummary]`
    /// - Returns: `[SageMakerClientTypes.EdgeDeploymentPlanSummary]`
    public func edgeDeploymentPlanSummaries() async throws -> [SageMakerClientTypes.EdgeDeploymentPlanSummary] {
        return try await self.asyncCompactMap { item in item.edgeDeploymentPlanSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListEdgePackagingJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEdgePackagingJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEdgePackagingJobsOutput`
    public func listEdgePackagingJobsPaginated(input: ListEdgePackagingJobsInput) -> ClientRuntime.PaginatorSequence<ListEdgePackagingJobsInput, ListEdgePackagingJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListEdgePackagingJobsInput, ListEdgePackagingJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEdgePackagingJobs(input:))
    }
}

extension ListEdgePackagingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEdgePackagingJobsInput {
        return ListEdgePackagingJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            modelNameContains: self.modelNameContains,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListEdgePackagingJobsInput, OperationStackOutput == ListEdgePackagingJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listEdgePackagingJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.EdgePackagingJobSummary]`
    /// - Returns: `[SageMakerClientTypes.EdgePackagingJobSummary]`
    public func edgePackagingJobSummaries() async throws -> [SageMakerClientTypes.EdgePackagingJobSummary] {
        return try await self.asyncCompactMap { item in item.edgePackagingJobSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListEndpointConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEndpointConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEndpointConfigsOutput`
    public func listEndpointConfigsPaginated(input: ListEndpointConfigsInput) -> ClientRuntime.PaginatorSequence<ListEndpointConfigsInput, ListEndpointConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListEndpointConfigsInput, ListEndpointConfigsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEndpointConfigs(input:))
    }
}

extension ListEndpointConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEndpointConfigsInput {
        return ListEndpointConfigsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListEndpointConfigsInput, OperationStackOutput == ListEndpointConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listEndpointConfigsPaginated`
    /// to access the nested member `[SageMakerClientTypes.EndpointConfigSummary]`
    /// - Returns: `[SageMakerClientTypes.EndpointConfigSummary]`
    public func endpointConfigs() async throws -> [SageMakerClientTypes.EndpointConfigSummary] {
        return try await self.asyncCompactMap { item in item.endpointConfigs }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEndpointsOutput`
    public func listEndpointsPaginated(input: ListEndpointsInput) -> ClientRuntime.PaginatorSequence<ListEndpointsInput, ListEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<ListEndpointsInput, ListEndpointsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEndpoints(input:))
    }
}

extension ListEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEndpointsInput {
        return ListEndpointsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListEndpointsInput, OperationStackOutput == ListEndpointsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listEndpointsPaginated`
    /// to access the nested member `[SageMakerClientTypes.EndpointSummary]`
    /// - Returns: `[SageMakerClientTypes.EndpointSummary]`
    public func endpoints() async throws -> [SageMakerClientTypes.EndpointSummary] {
        return try await self.asyncCompactMap { item in item.endpoints }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListExperimentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListExperimentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListExperimentsOutput`
    public func listExperimentsPaginated(input: ListExperimentsInput) -> ClientRuntime.PaginatorSequence<ListExperimentsInput, ListExperimentsOutput> {
        return ClientRuntime.PaginatorSequence<ListExperimentsInput, ListExperimentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listExperiments(input:))
    }
}

extension ListExperimentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExperimentsInput {
        return ListExperimentsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListExperimentsInput, OperationStackOutput == ListExperimentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listExperimentsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ExperimentSummary]`
    /// - Returns: `[SageMakerClientTypes.ExperimentSummary]`
    public func experimentSummaries() async throws -> [SageMakerClientTypes.ExperimentSummary] {
        return try await self.asyncCompactMap { item in item.experimentSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListFeatureGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFeatureGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFeatureGroupsOutput`
    public func listFeatureGroupsPaginated(input: ListFeatureGroupsInput) -> ClientRuntime.PaginatorSequence<ListFeatureGroupsInput, ListFeatureGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListFeatureGroupsInput, ListFeatureGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFeatureGroups(input:))
    }
}

extension ListFeatureGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFeatureGroupsInput {
        return ListFeatureGroupsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            featureGroupStatusEquals: self.featureGroupStatusEquals,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            offlineStoreStatusEquals: self.offlineStoreStatusEquals,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListFeatureGroupsInput, OperationStackOutput == ListFeatureGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFeatureGroupsPaginated`
    /// to access the nested member `[SageMakerClientTypes.FeatureGroupSummary]`
    /// - Returns: `[SageMakerClientTypes.FeatureGroupSummary]`
    public func featureGroupSummaries() async throws -> [SageMakerClientTypes.FeatureGroupSummary] {
        return try await self.asyncCompactMap { item in item.featureGroupSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListFlowDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFlowDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFlowDefinitionsOutput`
    public func listFlowDefinitionsPaginated(input: ListFlowDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListFlowDefinitionsInput, ListFlowDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<ListFlowDefinitionsInput, ListFlowDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFlowDefinitions(input:))
    }
}

extension ListFlowDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFlowDefinitionsInput {
        return ListFlowDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListFlowDefinitionsInput, OperationStackOutput == ListFlowDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFlowDefinitionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.FlowDefinitionSummary]`
    /// - Returns: `[SageMakerClientTypes.FlowDefinitionSummary]`
    public func flowDefinitionSummaries() async throws -> [SageMakerClientTypes.FlowDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.flowDefinitionSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListHumanTaskUisOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListHumanTaskUisInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListHumanTaskUisOutput`
    public func listHumanTaskUisPaginated(input: ListHumanTaskUisInput) -> ClientRuntime.PaginatorSequence<ListHumanTaskUisInput, ListHumanTaskUisOutput> {
        return ClientRuntime.PaginatorSequence<ListHumanTaskUisInput, ListHumanTaskUisOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listHumanTaskUis(input:))
    }
}

extension ListHumanTaskUisInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHumanTaskUisInput {
        return ListHumanTaskUisInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListHumanTaskUisInput, OperationStackOutput == ListHumanTaskUisOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listHumanTaskUisPaginated`
    /// to access the nested member `[SageMakerClientTypes.HumanTaskUiSummary]`
    /// - Returns: `[SageMakerClientTypes.HumanTaskUiSummary]`
    public func humanTaskUiSummaries() async throws -> [SageMakerClientTypes.HumanTaskUiSummary] {
        return try await self.asyncCompactMap { item in item.humanTaskUiSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListHyperParameterTuningJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListHyperParameterTuningJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListHyperParameterTuningJobsOutput`
    public func listHyperParameterTuningJobsPaginated(input: ListHyperParameterTuningJobsInput) -> ClientRuntime.PaginatorSequence<ListHyperParameterTuningJobsInput, ListHyperParameterTuningJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListHyperParameterTuningJobsInput, ListHyperParameterTuningJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listHyperParameterTuningJobs(input:))
    }
}

extension ListHyperParameterTuningJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHyperParameterTuningJobsInput {
        return ListHyperParameterTuningJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListHyperParameterTuningJobsInput, OperationStackOutput == ListHyperParameterTuningJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listHyperParameterTuningJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.HyperParameterTuningJobSummary]`
    /// - Returns: `[SageMakerClientTypes.HyperParameterTuningJobSummary]`
    public func hyperParameterTuningJobSummaries() async throws -> [SageMakerClientTypes.HyperParameterTuningJobSummary] {
        return try await self.asyncCompactMap { item in item.hyperParameterTuningJobSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListImagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImagesOutput`
    public func listImagesPaginated(input: ListImagesInput) -> ClientRuntime.PaginatorSequence<ListImagesInput, ListImagesOutput> {
        return ClientRuntime.PaginatorSequence<ListImagesInput, ListImagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImages(input:))
    }
}

extension ListImagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagesInput {
        return ListImagesInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListImagesInput, OperationStackOutput == ListImagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImagesPaginated`
    /// to access the nested member `[SageMakerClientTypes.Image]`
    /// - Returns: `[SageMakerClientTypes.Image]`
    public func images() async throws -> [SageMakerClientTypes.Image] {
        return try await self.asyncCompactMap { item in item.images }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListImageVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImageVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImageVersionsOutput`
    public func listImageVersionsPaginated(input: ListImageVersionsInput) -> ClientRuntime.PaginatorSequence<ListImageVersionsInput, ListImageVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListImageVersionsInput, ListImageVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImageVersions(input:))
    }
}

extension ListImageVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageVersionsInput {
        return ListImageVersionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            imageName: self.imageName,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListImageVersionsInput, OperationStackOutput == ListImageVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImageVersionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ImageVersion]`
    /// - Returns: `[SageMakerClientTypes.ImageVersion]`
    public func imageVersions() async throws -> [SageMakerClientTypes.ImageVersion] {
        return try await self.asyncCompactMap { item in item.imageVersions }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListInferenceComponentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInferenceComponentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInferenceComponentsOutput`
    public func listInferenceComponentsPaginated(input: ListInferenceComponentsInput) -> ClientRuntime.PaginatorSequence<ListInferenceComponentsInput, ListInferenceComponentsOutput> {
        return ClientRuntime.PaginatorSequence<ListInferenceComponentsInput, ListInferenceComponentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInferenceComponents(input:))
    }
}

extension ListInferenceComponentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceComponentsInput {
        return ListInferenceComponentsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointNameEquals: self.endpointNameEquals,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals,
            variantNameEquals: self.variantNameEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListInferenceComponentsInput, OperationStackOutput == ListInferenceComponentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInferenceComponentsPaginated`
    /// to access the nested member `[SageMakerClientTypes.InferenceComponentSummary]`
    /// - Returns: `[SageMakerClientTypes.InferenceComponentSummary]`
    public func inferenceComponents() async throws -> [SageMakerClientTypes.InferenceComponentSummary] {
        return try await self.asyncCompactMap { item in item.inferenceComponents }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListInferenceExperimentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInferenceExperimentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInferenceExperimentsOutput`
    public func listInferenceExperimentsPaginated(input: ListInferenceExperimentsInput) -> ClientRuntime.PaginatorSequence<ListInferenceExperimentsInput, ListInferenceExperimentsOutput> {
        return ClientRuntime.PaginatorSequence<ListInferenceExperimentsInput, ListInferenceExperimentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInferenceExperiments(input:))
    }
}

extension ListInferenceExperimentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceExperimentsInput {
        return ListInferenceExperimentsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == ListInferenceExperimentsInput, OperationStackOutput == ListInferenceExperimentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInferenceExperimentsPaginated`
    /// to access the nested member `[SageMakerClientTypes.InferenceExperimentSummary]`
    /// - Returns: `[SageMakerClientTypes.InferenceExperimentSummary]`
    public func inferenceExperiments() async throws -> [SageMakerClientTypes.InferenceExperimentSummary] {
        return try await self.asyncCompactMap { item in item.inferenceExperiments }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListInferenceRecommendationsJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInferenceRecommendationsJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInferenceRecommendationsJobsOutput`
    public func listInferenceRecommendationsJobsPaginated(input: ListInferenceRecommendationsJobsInput) -> ClientRuntime.PaginatorSequence<ListInferenceRecommendationsJobsInput, ListInferenceRecommendationsJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListInferenceRecommendationsJobsInput, ListInferenceRecommendationsJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInferenceRecommendationsJobs(input:))
    }
}

extension ListInferenceRecommendationsJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceRecommendationsJobsInput {
        return ListInferenceRecommendationsJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            modelNameEquals: self.modelNameEquals,
            modelPackageVersionArnEquals: self.modelPackageVersionArnEquals,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListInferenceRecommendationsJobsInput, OperationStackOutput == ListInferenceRecommendationsJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInferenceRecommendationsJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.InferenceRecommendationsJob]`
    /// - Returns: `[SageMakerClientTypes.InferenceRecommendationsJob]`
    public func inferenceRecommendationsJobs() async throws -> [SageMakerClientTypes.InferenceRecommendationsJob] {
        return try await self.asyncCompactMap { item in item.inferenceRecommendationsJobs }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListInferenceRecommendationsJobStepsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInferenceRecommendationsJobStepsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInferenceRecommendationsJobStepsOutput`
    public func listInferenceRecommendationsJobStepsPaginated(input: ListInferenceRecommendationsJobStepsInput) -> ClientRuntime.PaginatorSequence<ListInferenceRecommendationsJobStepsInput, ListInferenceRecommendationsJobStepsOutput> {
        return ClientRuntime.PaginatorSequence<ListInferenceRecommendationsJobStepsInput, ListInferenceRecommendationsJobStepsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInferenceRecommendationsJobSteps(input:))
    }
}

extension ListInferenceRecommendationsJobStepsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceRecommendationsJobStepsInput {
        return ListInferenceRecommendationsJobStepsInput(
            jobName: self.jobName,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status,
            stepType: self.stepType
        )}
}

extension PaginatorSequence where OperationStackInput == ListInferenceRecommendationsJobStepsInput, OperationStackOutput == ListInferenceRecommendationsJobStepsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInferenceRecommendationsJobStepsPaginated`
    /// to access the nested member `[SageMakerClientTypes.InferenceRecommendationsJobStep]`
    /// - Returns: `[SageMakerClientTypes.InferenceRecommendationsJobStep]`
    public func steps() async throws -> [SageMakerClientTypes.InferenceRecommendationsJobStep] {
        return try await self.asyncCompactMap { item in item.steps }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListLabelingJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLabelingJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLabelingJobsOutput`
    public func listLabelingJobsPaginated(input: ListLabelingJobsInput) -> ClientRuntime.PaginatorSequence<ListLabelingJobsInput, ListLabelingJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListLabelingJobsInput, ListLabelingJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLabelingJobs(input:))
    }
}

extension ListLabelingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLabelingJobsInput {
        return ListLabelingJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListLabelingJobsInput, OperationStackOutput == ListLabelingJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLabelingJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.LabelingJobSummary]`
    /// - Returns: `[SageMakerClientTypes.LabelingJobSummary]`
    public func labelingJobSummaryList() async throws -> [SageMakerClientTypes.LabelingJobSummary] {
        return try await self.asyncCompactMap { item in item.labelingJobSummaryList }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListLabelingJobsForWorkteamOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLabelingJobsForWorkteamInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLabelingJobsForWorkteamOutput`
    public func listLabelingJobsForWorkteamPaginated(input: ListLabelingJobsForWorkteamInput) -> ClientRuntime.PaginatorSequence<ListLabelingJobsForWorkteamInput, ListLabelingJobsForWorkteamOutput> {
        return ClientRuntime.PaginatorSequence<ListLabelingJobsForWorkteamInput, ListLabelingJobsForWorkteamOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLabelingJobsForWorkteam(input:))
    }
}

extension ListLabelingJobsForWorkteamInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLabelingJobsForWorkteamInput {
        return ListLabelingJobsForWorkteamInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            jobReferenceCodeContains: self.jobReferenceCodeContains,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            workteamArn: self.workteamArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListLabelingJobsForWorkteamInput, OperationStackOutput == ListLabelingJobsForWorkteamOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLabelingJobsForWorkteamPaginated`
    /// to access the nested member `[SageMakerClientTypes.LabelingJobForWorkteamSummary]`
    /// - Returns: `[SageMakerClientTypes.LabelingJobForWorkteamSummary]`
    public func labelingJobSummaryList() async throws -> [SageMakerClientTypes.LabelingJobForWorkteamSummary] {
        return try await self.asyncCompactMap { item in item.labelingJobSummaryList }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListLineageGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLineageGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLineageGroupsOutput`
    public func listLineageGroupsPaginated(input: ListLineageGroupsInput) -> ClientRuntime.PaginatorSequence<ListLineageGroupsInput, ListLineageGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListLineageGroupsInput, ListLineageGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLineageGroups(input:))
    }
}

extension ListLineageGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLineageGroupsInput {
        return ListLineageGroupsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListLineageGroupsInput, OperationStackOutput == ListLineageGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLineageGroupsPaginated`
    /// to access the nested member `[SageMakerClientTypes.LineageGroupSummary]`
    /// - Returns: `[SageMakerClientTypes.LineageGroupSummary]`
    public func lineageGroupSummaries() async throws -> [SageMakerClientTypes.LineageGroupSummary] {
        return try await self.asyncCompactMap { item in item.lineageGroupSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelBiasJobDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelBiasJobDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelBiasJobDefinitionsOutput`
    public func listModelBiasJobDefinitionsPaginated(input: ListModelBiasJobDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListModelBiasJobDefinitionsInput, ListModelBiasJobDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelBiasJobDefinitionsInput, ListModelBiasJobDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelBiasJobDefinitions(input:))
    }
}

extension ListModelBiasJobDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelBiasJobDefinitionsInput {
        return ListModelBiasJobDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelBiasJobDefinitionsInput, OperationStackOutput == ListModelBiasJobDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelBiasJobDefinitionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
    /// - Returns: `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
    public func jobDefinitionSummaries() async throws -> [SageMakerClientTypes.MonitoringJobDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.jobDefinitionSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelCardExportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelCardExportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelCardExportJobsOutput`
    public func listModelCardExportJobsPaginated(input: ListModelCardExportJobsInput) -> ClientRuntime.PaginatorSequence<ListModelCardExportJobsInput, ListModelCardExportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelCardExportJobsInput, ListModelCardExportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelCardExportJobs(input:))
    }
}

extension ListModelCardExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelCardExportJobsInput {
        return ListModelCardExportJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modelCardExportJobNameContains: self.modelCardExportJobNameContains,
            modelCardName: self.modelCardName,
            modelCardVersion: self.modelCardVersion,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelCardExportJobsInput, OperationStackOutput == ListModelCardExportJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelCardExportJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ModelCardExportJobSummary]`
    /// - Returns: `[SageMakerClientTypes.ModelCardExportJobSummary]`
    public func modelCardExportJobSummaries() async throws -> [SageMakerClientTypes.ModelCardExportJobSummary] {
        return try await self.asyncCompactMap { item in item.modelCardExportJobSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelCardsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelCardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelCardsOutput`
    public func listModelCardsPaginated(input: ListModelCardsInput) -> ClientRuntime.PaginatorSequence<ListModelCardsInput, ListModelCardsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelCardsInput, ListModelCardsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelCards(input:))
    }
}

extension ListModelCardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelCardsInput {
        return ListModelCardsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modelCardStatus: self.modelCardStatus,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelCardsInput, OperationStackOutput == ListModelCardsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelCardsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ModelCardSummary]`
    /// - Returns: `[SageMakerClientTypes.ModelCardSummary]`
    public func modelCardSummaries() async throws -> [SageMakerClientTypes.ModelCardSummary] {
        return try await self.asyncCompactMap { item in item.modelCardSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelCardVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelCardVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelCardVersionsOutput`
    public func listModelCardVersionsPaginated(input: ListModelCardVersionsInput) -> ClientRuntime.PaginatorSequence<ListModelCardVersionsInput, ListModelCardVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelCardVersionsInput, ListModelCardVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelCardVersions(input:))
    }
}

extension ListModelCardVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelCardVersionsInput {
        return ListModelCardVersionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modelCardName: self.modelCardName,
            modelCardStatus: self.modelCardStatus,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelCardVersionsInput, OperationStackOutput == ListModelCardVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelCardVersionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ModelCardVersionSummary]`
    /// - Returns: `[SageMakerClientTypes.ModelCardVersionSummary]`
    public func modelCardVersionSummaryList() async throws -> [SageMakerClientTypes.ModelCardVersionSummary] {
        return try await self.asyncCompactMap { item in item.modelCardVersionSummaryList }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelExplainabilityJobDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelExplainabilityJobDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelExplainabilityJobDefinitionsOutput`
    public func listModelExplainabilityJobDefinitionsPaginated(input: ListModelExplainabilityJobDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListModelExplainabilityJobDefinitionsInput, ListModelExplainabilityJobDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelExplainabilityJobDefinitionsInput, ListModelExplainabilityJobDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelExplainabilityJobDefinitions(input:))
    }
}

extension ListModelExplainabilityJobDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelExplainabilityJobDefinitionsInput {
        return ListModelExplainabilityJobDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelExplainabilityJobDefinitionsInput, OperationStackOutput == ListModelExplainabilityJobDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelExplainabilityJobDefinitionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
    /// - Returns: `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
    public func jobDefinitionSummaries() async throws -> [SageMakerClientTypes.MonitoringJobDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.jobDefinitionSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelMetadataOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelMetadataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelMetadataOutput`
    public func listModelMetadataPaginated(input: ListModelMetadataInput) -> ClientRuntime.PaginatorSequence<ListModelMetadataInput, ListModelMetadataOutput> {
        return ClientRuntime.PaginatorSequence<ListModelMetadataInput, ListModelMetadataOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelMetadata(input:))
    }
}

extension ListModelMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelMetadataInput {
        return ListModelMetadataInput(
            maxResults: self.maxResults,
            nextToken: token,
            searchExpression: self.searchExpression
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelMetadataInput, OperationStackOutput == ListModelMetadataOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelMetadataPaginated`
    /// to access the nested member `[SageMakerClientTypes.ModelMetadataSummary]`
    /// - Returns: `[SageMakerClientTypes.ModelMetadataSummary]`
    public func modelMetadataSummaries() async throws -> [SageMakerClientTypes.ModelMetadataSummary] {
        return try await self.asyncCompactMap { item in item.modelMetadataSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelPackageGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelPackageGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelPackageGroupsOutput`
    public func listModelPackageGroupsPaginated(input: ListModelPackageGroupsInput) -> ClientRuntime.PaginatorSequence<ListModelPackageGroupsInput, ListModelPackageGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelPackageGroupsInput, ListModelPackageGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelPackageGroups(input:))
    }
}

extension ListModelPackageGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelPackageGroupsInput {
        return ListModelPackageGroupsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelPackageGroupsInput, OperationStackOutput == ListModelPackageGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelPackageGroupsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ModelPackageGroupSummary]`
    /// - Returns: `[SageMakerClientTypes.ModelPackageGroupSummary]`
    public func modelPackageGroupSummaryList() async throws -> [SageMakerClientTypes.ModelPackageGroupSummary] {
        return try await self.asyncCompactMap { item in item.modelPackageGroupSummaryList }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelPackagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelPackagesOutput`
    public func listModelPackagesPaginated(input: ListModelPackagesInput) -> ClientRuntime.PaginatorSequence<ListModelPackagesInput, ListModelPackagesOutput> {
        return ClientRuntime.PaginatorSequence<ListModelPackagesInput, ListModelPackagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelPackages(input:))
    }
}

extension ListModelPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelPackagesInput {
        return ListModelPackagesInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modelApprovalStatus: self.modelApprovalStatus,
            modelPackageGroupName: self.modelPackageGroupName,
            modelPackageType: self.modelPackageType,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelPackagesInput, OperationStackOutput == ListModelPackagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelPackagesPaginated`
    /// to access the nested member `[SageMakerClientTypes.ModelPackageSummary]`
    /// - Returns: `[SageMakerClientTypes.ModelPackageSummary]`
    public func modelPackageSummaryList() async throws -> [SageMakerClientTypes.ModelPackageSummary] {
        return try await self.asyncCompactMap { item in item.modelPackageSummaryList }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelQualityJobDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelQualityJobDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelQualityJobDefinitionsOutput`
    public func listModelQualityJobDefinitionsPaginated(input: ListModelQualityJobDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListModelQualityJobDefinitionsInput, ListModelQualityJobDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelQualityJobDefinitionsInput, ListModelQualityJobDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelQualityJobDefinitions(input:))
    }
}

extension ListModelQualityJobDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelQualityJobDefinitionsInput {
        return ListModelQualityJobDefinitionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelQualityJobDefinitionsInput, OperationStackOutput == ListModelQualityJobDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelQualityJobDefinitionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
    /// - Returns: `[SageMakerClientTypes.MonitoringJobDefinitionSummary]`
    public func jobDefinitionSummaries() async throws -> [SageMakerClientTypes.MonitoringJobDefinitionSummary] {
        return try await self.asyncCompactMap { item in item.jobDefinitionSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListModelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelsOutput`
    public func listModelsPaginated(input: ListModelsInput) -> ClientRuntime.PaginatorSequence<ListModelsInput, ListModelsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelsInput, ListModelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModels(input:))
    }
}

extension ListModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelsInput {
        return ListModelsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListModelsInput, OperationStackOutput == ListModelsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listModelsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ModelSummary]`
    /// - Returns: `[SageMakerClientTypes.ModelSummary]`
    public func models() async throws -> [SageMakerClientTypes.ModelSummary] {
        return try await self.asyncCompactMap { item in item.models }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListMonitoringAlertHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMonitoringAlertHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMonitoringAlertHistoryOutput`
    public func listMonitoringAlertHistoryPaginated(input: ListMonitoringAlertHistoryInput) -> ClientRuntime.PaginatorSequence<ListMonitoringAlertHistoryInput, ListMonitoringAlertHistoryOutput> {
        return ClientRuntime.PaginatorSequence<ListMonitoringAlertHistoryInput, ListMonitoringAlertHistoryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMonitoringAlertHistory(input:))
    }
}

extension ListMonitoringAlertHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitoringAlertHistoryInput {
        return ListMonitoringAlertHistoryInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            monitoringAlertName: self.monitoringAlertName,
            monitoringScheduleName: self.monitoringScheduleName,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListMonitoringAlertHistoryInput, OperationStackOutput == ListMonitoringAlertHistoryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMonitoringAlertHistoryPaginated`
    /// to access the nested member `[SageMakerClientTypes.MonitoringAlertHistorySummary]`
    /// - Returns: `[SageMakerClientTypes.MonitoringAlertHistorySummary]`
    public func monitoringAlertHistory() async throws -> [SageMakerClientTypes.MonitoringAlertHistorySummary] {
        return try await self.asyncCompactMap { item in item.monitoringAlertHistory }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListMonitoringAlertsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMonitoringAlertsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMonitoringAlertsOutput`
    public func listMonitoringAlertsPaginated(input: ListMonitoringAlertsInput) -> ClientRuntime.PaginatorSequence<ListMonitoringAlertsInput, ListMonitoringAlertsOutput> {
        return ClientRuntime.PaginatorSequence<ListMonitoringAlertsInput, ListMonitoringAlertsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMonitoringAlerts(input:))
    }
}

extension ListMonitoringAlertsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitoringAlertsInput {
        return ListMonitoringAlertsInput(
            maxResults: self.maxResults,
            monitoringScheduleName: self.monitoringScheduleName,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListMonitoringAlertsInput, OperationStackOutput == ListMonitoringAlertsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMonitoringAlertsPaginated`
    /// to access the nested member `[SageMakerClientTypes.MonitoringAlertSummary]`
    /// - Returns: `[SageMakerClientTypes.MonitoringAlertSummary]`
    public func monitoringAlertSummaries() async throws -> [SageMakerClientTypes.MonitoringAlertSummary] {
        return try await self.asyncCompactMap { item in item.monitoringAlertSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListMonitoringExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMonitoringExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMonitoringExecutionsOutput`
    public func listMonitoringExecutionsPaginated(input: ListMonitoringExecutionsInput) -> ClientRuntime.PaginatorSequence<ListMonitoringExecutionsInput, ListMonitoringExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListMonitoringExecutionsInput, ListMonitoringExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMonitoringExecutions(input:))
    }
}

extension ListMonitoringExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitoringExecutionsInput {
        return ListMonitoringExecutionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            monitoringJobDefinitionName: self.monitoringJobDefinitionName,
            monitoringScheduleName: self.monitoringScheduleName,
            monitoringTypeEquals: self.monitoringTypeEquals,
            nextToken: token,
            scheduledTimeAfter: self.scheduledTimeAfter,
            scheduledTimeBefore: self.scheduledTimeBefore,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListMonitoringExecutionsInput, OperationStackOutput == ListMonitoringExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMonitoringExecutionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.MonitoringExecutionSummary]`
    /// - Returns: `[SageMakerClientTypes.MonitoringExecutionSummary]`
    public func monitoringExecutionSummaries() async throws -> [SageMakerClientTypes.MonitoringExecutionSummary] {
        return try await self.asyncCompactMap { item in item.monitoringExecutionSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListMonitoringSchedulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMonitoringSchedulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMonitoringSchedulesOutput`
    public func listMonitoringSchedulesPaginated(input: ListMonitoringSchedulesInput) -> ClientRuntime.PaginatorSequence<ListMonitoringSchedulesInput, ListMonitoringSchedulesOutput> {
        return ClientRuntime.PaginatorSequence<ListMonitoringSchedulesInput, ListMonitoringSchedulesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMonitoringSchedules(input:))
    }
}

extension ListMonitoringSchedulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitoringSchedulesInput {
        return ListMonitoringSchedulesInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endpointName: self.endpointName,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            monitoringJobDefinitionName: self.monitoringJobDefinitionName,
            monitoringTypeEquals: self.monitoringTypeEquals,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListMonitoringSchedulesInput, OperationStackOutput == ListMonitoringSchedulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMonitoringSchedulesPaginated`
    /// to access the nested member `[SageMakerClientTypes.MonitoringScheduleSummary]`
    /// - Returns: `[SageMakerClientTypes.MonitoringScheduleSummary]`
    public func monitoringScheduleSummaries() async throws -> [SageMakerClientTypes.MonitoringScheduleSummary] {
        return try await self.asyncCompactMap { item in item.monitoringScheduleSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListNotebookInstanceLifecycleConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNotebookInstanceLifecycleConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNotebookInstanceLifecycleConfigsOutput`
    public func listNotebookInstanceLifecycleConfigsPaginated(input: ListNotebookInstanceLifecycleConfigsInput) -> ClientRuntime.PaginatorSequence<ListNotebookInstanceLifecycleConfigsInput, ListNotebookInstanceLifecycleConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListNotebookInstanceLifecycleConfigsInput, ListNotebookInstanceLifecycleConfigsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listNotebookInstanceLifecycleConfigs(input:))
    }
}

extension ListNotebookInstanceLifecycleConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNotebookInstanceLifecycleConfigsInput {
        return ListNotebookInstanceLifecycleConfigsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListNotebookInstanceLifecycleConfigsInput, OperationStackOutput == ListNotebookInstanceLifecycleConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listNotebookInstanceLifecycleConfigsPaginated`
    /// to access the nested member `[SageMakerClientTypes.NotebookInstanceLifecycleConfigSummary]`
    /// - Returns: `[SageMakerClientTypes.NotebookInstanceLifecycleConfigSummary]`
    public func notebookInstanceLifecycleConfigs() async throws -> [SageMakerClientTypes.NotebookInstanceLifecycleConfigSummary] {
        return try await self.asyncCompactMap { item in item.notebookInstanceLifecycleConfigs }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListNotebookInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNotebookInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNotebookInstancesOutput`
    public func listNotebookInstancesPaginated(input: ListNotebookInstancesInput) -> ClientRuntime.PaginatorSequence<ListNotebookInstancesInput, ListNotebookInstancesOutput> {
        return ClientRuntime.PaginatorSequence<ListNotebookInstancesInput, ListNotebookInstancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listNotebookInstances(input:))
    }
}

extension ListNotebookInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNotebookInstancesInput {
        return ListNotebookInstancesInput(
            additionalCodeRepositoryEquals: self.additionalCodeRepositoryEquals,
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            defaultCodeRepositoryContains: self.defaultCodeRepositoryContains,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            notebookInstanceLifecycleConfigNameContains: self.notebookInstanceLifecycleConfigNameContains,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListNotebookInstancesInput, OperationStackOutput == ListNotebookInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listNotebookInstancesPaginated`
    /// to access the nested member `[SageMakerClientTypes.NotebookInstanceSummary]`
    /// - Returns: `[SageMakerClientTypes.NotebookInstanceSummary]`
    public func notebookInstances() async throws -> [SageMakerClientTypes.NotebookInstanceSummary] {
        return try await self.asyncCompactMap { item in item.notebookInstances }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListPipelineExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPipelineExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPipelineExecutionsOutput`
    public func listPipelineExecutionsPaginated(input: ListPipelineExecutionsInput) -> ClientRuntime.PaginatorSequence<ListPipelineExecutionsInput, ListPipelineExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListPipelineExecutionsInput, ListPipelineExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPipelineExecutions(input:))
    }
}

extension ListPipelineExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPipelineExecutionsInput {
        return ListPipelineExecutionsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            pipelineName: self.pipelineName,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListPipelineExecutionsInput, OperationStackOutput == ListPipelineExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPipelineExecutionsPaginated`
    /// to access the nested member `[SageMakerClientTypes.PipelineExecutionSummary]`
    /// - Returns: `[SageMakerClientTypes.PipelineExecutionSummary]`
    public func pipelineExecutionSummaries() async throws -> [SageMakerClientTypes.PipelineExecutionSummary] {
        return try await self.asyncCompactMap { item in item.pipelineExecutionSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListPipelineExecutionStepsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPipelineExecutionStepsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPipelineExecutionStepsOutput`
    public func listPipelineExecutionStepsPaginated(input: ListPipelineExecutionStepsInput) -> ClientRuntime.PaginatorSequence<ListPipelineExecutionStepsInput, ListPipelineExecutionStepsOutput> {
        return ClientRuntime.PaginatorSequence<ListPipelineExecutionStepsInput, ListPipelineExecutionStepsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPipelineExecutionSteps(input:))
    }
}

extension ListPipelineExecutionStepsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPipelineExecutionStepsInput {
        return ListPipelineExecutionStepsInput(
            maxResults: self.maxResults,
            nextToken: token,
            pipelineExecutionArn: self.pipelineExecutionArn,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListPipelineExecutionStepsInput, OperationStackOutput == ListPipelineExecutionStepsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPipelineExecutionStepsPaginated`
    /// to access the nested member `[SageMakerClientTypes.PipelineExecutionStep]`
    /// - Returns: `[SageMakerClientTypes.PipelineExecutionStep]`
    public func pipelineExecutionSteps() async throws -> [SageMakerClientTypes.PipelineExecutionStep] {
        return try await self.asyncCompactMap { item in item.pipelineExecutionSteps }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListPipelineParametersForExecutionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPipelineParametersForExecutionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPipelineParametersForExecutionOutput`
    public func listPipelineParametersForExecutionPaginated(input: ListPipelineParametersForExecutionInput) -> ClientRuntime.PaginatorSequence<ListPipelineParametersForExecutionInput, ListPipelineParametersForExecutionOutput> {
        return ClientRuntime.PaginatorSequence<ListPipelineParametersForExecutionInput, ListPipelineParametersForExecutionOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPipelineParametersForExecution(input:))
    }
}

extension ListPipelineParametersForExecutionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPipelineParametersForExecutionInput {
        return ListPipelineParametersForExecutionInput(
            maxResults: self.maxResults,
            nextToken: token,
            pipelineExecutionArn: self.pipelineExecutionArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListPipelineParametersForExecutionInput, OperationStackOutput == ListPipelineParametersForExecutionOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPipelineParametersForExecutionPaginated`
    /// to access the nested member `[SageMakerClientTypes.Parameter]`
    /// - Returns: `[SageMakerClientTypes.Parameter]`
    public func pipelineParameters() async throws -> [SageMakerClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.pipelineParameters }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListPipelinesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPipelinesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPipelinesOutput`
    public func listPipelinesPaginated(input: ListPipelinesInput) -> ClientRuntime.PaginatorSequence<ListPipelinesInput, ListPipelinesOutput> {
        return ClientRuntime.PaginatorSequence<ListPipelinesInput, ListPipelinesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPipelines(input:))
    }
}

extension ListPipelinesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPipelinesInput {
        return ListPipelinesInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            pipelineNamePrefix: self.pipelineNamePrefix,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListPipelinesInput, OperationStackOutput == ListPipelinesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPipelinesPaginated`
    /// to access the nested member `[SageMakerClientTypes.PipelineSummary]`
    /// - Returns: `[SageMakerClientTypes.PipelineSummary]`
    public func pipelineSummaries() async throws -> [SageMakerClientTypes.PipelineSummary] {
        return try await self.asyncCompactMap { item in item.pipelineSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListProcessingJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProcessingJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProcessingJobsOutput`
    public func listProcessingJobsPaginated(input: ListProcessingJobsInput) -> ClientRuntime.PaginatorSequence<ListProcessingJobsInput, ListProcessingJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListProcessingJobsInput, ListProcessingJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProcessingJobs(input:))
    }
}

extension ListProcessingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProcessingJobsInput {
        return ListProcessingJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListProcessingJobsInput, OperationStackOutput == ListProcessingJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProcessingJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ProcessingJobSummary]`
    /// - Returns: `[SageMakerClientTypes.ProcessingJobSummary]`
    public func processingJobSummaries() async throws -> [SageMakerClientTypes.ProcessingJobSummary] {
        return try await self.asyncCompactMap { item in item.processingJobSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListProjectsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProjectsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProjectsOutput`
    public func listProjectsPaginated(input: ListProjectsInput) -> ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutput> {
        return ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProjects(input:))
    }
}

extension ListProjectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProjectsInput {
        return ListProjectsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}
extension SageMakerClient {
    /// Paginate over `[ListResourceCatalogsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourceCatalogsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourceCatalogsOutput`
    public func listResourceCatalogsPaginated(input: ListResourceCatalogsInput) -> ClientRuntime.PaginatorSequence<ListResourceCatalogsInput, ListResourceCatalogsOutput> {
        return ClientRuntime.PaginatorSequence<ListResourceCatalogsInput, ListResourceCatalogsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResourceCatalogs(input:))
    }
}

extension ListResourceCatalogsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceCatalogsInput {
        return ListResourceCatalogsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListResourceCatalogsInput, OperationStackOutput == ListResourceCatalogsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResourceCatalogsPaginated`
    /// to access the nested member `[SageMakerClientTypes.ResourceCatalog]`
    /// - Returns: `[SageMakerClientTypes.ResourceCatalog]`
    public func resourceCatalogs() async throws -> [SageMakerClientTypes.ResourceCatalog] {
        return try await self.asyncCompactMap { item in item.resourceCatalogs }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListSpacesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSpacesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSpacesOutput`
    public func listSpacesPaginated(input: ListSpacesInput) -> ClientRuntime.PaginatorSequence<ListSpacesInput, ListSpacesOutput> {
        return ClientRuntime.PaginatorSequence<ListSpacesInput, ListSpacesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSpaces(input:))
    }
}

extension ListSpacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSpacesInput {
        return ListSpacesInput(
            domainIdEquals: self.domainIdEquals,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            spaceNameContains: self.spaceNameContains
        )}
}

extension PaginatorSequence where OperationStackInput == ListSpacesInput, OperationStackOutput == ListSpacesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSpacesPaginated`
    /// to access the nested member `[SageMakerClientTypes.SpaceDetails]`
    /// - Returns: `[SageMakerClientTypes.SpaceDetails]`
    public func spaces() async throws -> [SageMakerClientTypes.SpaceDetails] {
        return try await self.asyncCompactMap { item in item.spaces }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListStageDevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStageDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStageDevicesOutput`
    public func listStageDevicesPaginated(input: ListStageDevicesInput) -> ClientRuntime.PaginatorSequence<ListStageDevicesInput, ListStageDevicesOutput> {
        return ClientRuntime.PaginatorSequence<ListStageDevicesInput, ListStageDevicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listStageDevices(input:))
    }
}

extension ListStageDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStageDevicesInput {
        return ListStageDevicesInput(
            edgeDeploymentPlanName: self.edgeDeploymentPlanName,
            excludeDevicesDeployedInOtherStage: self.excludeDevicesDeployedInOtherStage,
            maxResults: self.maxResults,
            nextToken: token,
            stageName: self.stageName
        )}
}

extension PaginatorSequence where OperationStackInput == ListStageDevicesInput, OperationStackOutput == ListStageDevicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listStageDevicesPaginated`
    /// to access the nested member `[SageMakerClientTypes.DeviceDeploymentSummary]`
    /// - Returns: `[SageMakerClientTypes.DeviceDeploymentSummary]`
    public func deviceDeploymentSummaries() async throws -> [SageMakerClientTypes.DeviceDeploymentSummary] {
        return try await self.asyncCompactMap { item in item.deviceDeploymentSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListStudioLifecycleConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStudioLifecycleConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStudioLifecycleConfigsOutput`
    public func listStudioLifecycleConfigsPaginated(input: ListStudioLifecycleConfigsInput) -> ClientRuntime.PaginatorSequence<ListStudioLifecycleConfigsInput, ListStudioLifecycleConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListStudioLifecycleConfigsInput, ListStudioLifecycleConfigsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listStudioLifecycleConfigs(input:))
    }
}

extension ListStudioLifecycleConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStudioLifecycleConfigsInput {
        return ListStudioLifecycleConfigsInput(
            appTypeEquals: self.appTypeEquals,
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            maxResults: self.maxResults,
            modifiedTimeAfter: self.modifiedTimeAfter,
            modifiedTimeBefore: self.modifiedTimeBefore,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListStudioLifecycleConfigsInput, OperationStackOutput == ListStudioLifecycleConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listStudioLifecycleConfigsPaginated`
    /// to access the nested member `[SageMakerClientTypes.StudioLifecycleConfigDetails]`
    /// - Returns: `[SageMakerClientTypes.StudioLifecycleConfigDetails]`
    public func studioLifecycleConfigs() async throws -> [SageMakerClientTypes.StudioLifecycleConfigDetails] {
        return try await self.asyncCompactMap { item in item.studioLifecycleConfigs }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListSubscribedWorkteamsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSubscribedWorkteamsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSubscribedWorkteamsOutput`
    public func listSubscribedWorkteamsPaginated(input: ListSubscribedWorkteamsInput) -> ClientRuntime.PaginatorSequence<ListSubscribedWorkteamsInput, ListSubscribedWorkteamsOutput> {
        return ClientRuntime.PaginatorSequence<ListSubscribedWorkteamsInput, ListSubscribedWorkteamsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSubscribedWorkteams(input:))
    }
}

extension ListSubscribedWorkteamsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSubscribedWorkteamsInput {
        return ListSubscribedWorkteamsInput(
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSubscribedWorkteamsInput, OperationStackOutput == ListSubscribedWorkteamsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSubscribedWorkteamsPaginated`
    /// to access the nested member `[SageMakerClientTypes.SubscribedWorkteam]`
    /// - Returns: `[SageMakerClientTypes.SubscribedWorkteam]`
    public func subscribedWorkteams() async throws -> [SageMakerClientTypes.SubscribedWorkteam] {
        return try await self.asyncCompactMap { item in item.subscribedWorkteams }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsOutput`
    public func listTagsPaginated(input: ListTagsInput) -> ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTags(input:))
    }
}

extension ListTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsInput {
        return ListTagsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListTagsInput, OperationStackOutput == ListTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTagsPaginated`
    /// to access the nested member `[SageMakerClientTypes.Tag]`
    /// - Returns: `[SageMakerClientTypes.Tag]`
    public func tags() async throws -> [SageMakerClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListTrainingJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTrainingJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTrainingJobsOutput`
    public func listTrainingJobsPaginated(input: ListTrainingJobsInput) -> ClientRuntime.PaginatorSequence<ListTrainingJobsInput, ListTrainingJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListTrainingJobsInput, ListTrainingJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTrainingJobs(input:))
    }
}

extension ListTrainingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrainingJobsInput {
        return ListTrainingJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals,
            warmPoolStatusEquals: self.warmPoolStatusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListTrainingJobsInput, OperationStackOutput == ListTrainingJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTrainingJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.TrainingJobSummary]`
    /// - Returns: `[SageMakerClientTypes.TrainingJobSummary]`
    public func trainingJobSummaries() async throws -> [SageMakerClientTypes.TrainingJobSummary] {
        return try await self.asyncCompactMap { item in item.trainingJobSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListTrainingJobsForHyperParameterTuningJobOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTrainingJobsForHyperParameterTuningJobInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTrainingJobsForHyperParameterTuningJobOutput`
    public func listTrainingJobsForHyperParameterTuningJobPaginated(input: ListTrainingJobsForHyperParameterTuningJobInput) -> ClientRuntime.PaginatorSequence<ListTrainingJobsForHyperParameterTuningJobInput, ListTrainingJobsForHyperParameterTuningJobOutput> {
        return ClientRuntime.PaginatorSequence<ListTrainingJobsForHyperParameterTuningJobInput, ListTrainingJobsForHyperParameterTuningJobOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTrainingJobsForHyperParameterTuningJob(input:))
    }
}

extension ListTrainingJobsForHyperParameterTuningJobInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrainingJobsForHyperParameterTuningJobInput {
        return ListTrainingJobsForHyperParameterTuningJobInput(
            hyperParameterTuningJobName: self.hyperParameterTuningJobName,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListTrainingJobsForHyperParameterTuningJobInput, OperationStackOutput == ListTrainingJobsForHyperParameterTuningJobOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTrainingJobsForHyperParameterTuningJobPaginated`
    /// to access the nested member `[SageMakerClientTypes.HyperParameterTrainingJobSummary]`
    /// - Returns: `[SageMakerClientTypes.HyperParameterTrainingJobSummary]`
    public func trainingJobSummaries() async throws -> [SageMakerClientTypes.HyperParameterTrainingJobSummary] {
        return try await self.asyncCompactMap { item in item.trainingJobSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListTransformJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTransformJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTransformJobsOutput`
    public func listTransformJobsPaginated(input: ListTransformJobsInput) -> ClientRuntime.PaginatorSequence<ListTransformJobsInput, ListTransformJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListTransformJobsInput, ListTransformJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTransformJobs(input:))
    }
}

extension ListTransformJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTransformJobsInput {
        return ListTransformJobsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            lastModifiedTimeAfter: self.lastModifiedTimeAfter,
            lastModifiedTimeBefore: self.lastModifiedTimeBefore,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            statusEquals: self.statusEquals
        )}
}

extension PaginatorSequence where OperationStackInput == ListTransformJobsInput, OperationStackOutput == ListTransformJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTransformJobsPaginated`
    /// to access the nested member `[SageMakerClientTypes.TransformJobSummary]`
    /// - Returns: `[SageMakerClientTypes.TransformJobSummary]`
    public func transformJobSummaries() async throws -> [SageMakerClientTypes.TransformJobSummary] {
        return try await self.asyncCompactMap { item in item.transformJobSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListTrialComponentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTrialComponentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTrialComponentsOutput`
    public func listTrialComponentsPaginated(input: ListTrialComponentsInput) -> ClientRuntime.PaginatorSequence<ListTrialComponentsInput, ListTrialComponentsOutput> {
        return ClientRuntime.PaginatorSequence<ListTrialComponentsInput, ListTrialComponentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTrialComponents(input:))
    }
}

extension ListTrialComponentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrialComponentsInput {
        return ListTrialComponentsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            experimentName: self.experimentName,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            sourceArn: self.sourceArn,
            trialName: self.trialName
        )}
}

extension PaginatorSequence where OperationStackInput == ListTrialComponentsInput, OperationStackOutput == ListTrialComponentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTrialComponentsPaginated`
    /// to access the nested member `[SageMakerClientTypes.TrialComponentSummary]`
    /// - Returns: `[SageMakerClientTypes.TrialComponentSummary]`
    public func trialComponentSummaries() async throws -> [SageMakerClientTypes.TrialComponentSummary] {
        return try await self.asyncCompactMap { item in item.trialComponentSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListTrialsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTrialsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTrialsOutput`
    public func listTrialsPaginated(input: ListTrialsInput) -> ClientRuntime.PaginatorSequence<ListTrialsInput, ListTrialsOutput> {
        return ClientRuntime.PaginatorSequence<ListTrialsInput, ListTrialsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTrials(input:))
    }
}

extension ListTrialsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTrialsInput {
        return ListTrialsInput(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            experimentName: self.experimentName,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            trialComponentName: self.trialComponentName
        )}
}

extension PaginatorSequence where OperationStackInput == ListTrialsInput, OperationStackOutput == ListTrialsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTrialsPaginated`
    /// to access the nested member `[SageMakerClientTypes.TrialSummary]`
    /// - Returns: `[SageMakerClientTypes.TrialSummary]`
    public func trialSummaries() async throws -> [SageMakerClientTypes.TrialSummary] {
        return try await self.asyncCompactMap { item in item.trialSummaries }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListUserProfilesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUserProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUserProfilesOutput`
    public func listUserProfilesPaginated(input: ListUserProfilesInput) -> ClientRuntime.PaginatorSequence<ListUserProfilesInput, ListUserProfilesOutput> {
        return ClientRuntime.PaginatorSequence<ListUserProfilesInput, ListUserProfilesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUserProfiles(input:))
    }
}

extension ListUserProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserProfilesInput {
        return ListUserProfilesInput(
            domainIdEquals: self.domainIdEquals,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder,
            userProfileNameContains: self.userProfileNameContains
        )}
}

extension PaginatorSequence where OperationStackInput == ListUserProfilesInput, OperationStackOutput == ListUserProfilesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUserProfilesPaginated`
    /// to access the nested member `[SageMakerClientTypes.UserProfileDetails]`
    /// - Returns: `[SageMakerClientTypes.UserProfileDetails]`
    public func userProfiles() async throws -> [SageMakerClientTypes.UserProfileDetails] {
        return try await self.asyncCompactMap { item in item.userProfiles }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListWorkforcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkforcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkforcesOutput`
    public func listWorkforcesPaginated(input: ListWorkforcesInput) -> ClientRuntime.PaginatorSequence<ListWorkforcesInput, ListWorkforcesOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkforcesInput, ListWorkforcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkforces(input:))
    }
}

extension ListWorkforcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkforcesInput {
        return ListWorkforcesInput(
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListWorkforcesInput, OperationStackOutput == ListWorkforcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkforcesPaginated`
    /// to access the nested member `[SageMakerClientTypes.Workforce]`
    /// - Returns: `[SageMakerClientTypes.Workforce]`
    public func workforces() async throws -> [SageMakerClientTypes.Workforce] {
        return try await self.asyncCompactMap { item in item.workforces }
    }
}
extension SageMakerClient {
    /// Paginate over `[ListWorkteamsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkteamsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkteamsOutput`
    public func listWorkteamsPaginated(input: ListWorkteamsInput) -> ClientRuntime.PaginatorSequence<ListWorkteamsInput, ListWorkteamsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkteamsInput, ListWorkteamsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkteams(input:))
    }
}

extension ListWorkteamsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkteamsInput {
        return ListWorkteamsInput(
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListWorkteamsInput, OperationStackOutput == ListWorkteamsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkteamsPaginated`
    /// to access the nested member `[SageMakerClientTypes.Workteam]`
    /// - Returns: `[SageMakerClientTypes.Workteam]`
    public func workteams() async throws -> [SageMakerClientTypes.Workteam] {
        return try await self.asyncCompactMap { item in item.workteams }
    }
}
extension SageMakerClient {
    /// Paginate over `[QueryLineageOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[QueryLineageInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `QueryLineageOutput`
    public func queryLineagePaginated(input: QueryLineageInput) -> ClientRuntime.PaginatorSequence<QueryLineageInput, QueryLineageOutput> {
        return ClientRuntime.PaginatorSequence<QueryLineageInput, QueryLineageOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.queryLineage(input:))
    }
}

extension QueryLineageInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> QueryLineageInput {
        return QueryLineageInput(
            direction: self.direction,
            filters: self.filters,
            includeEdges: self.includeEdges,
            maxDepth: self.maxDepth,
            maxResults: self.maxResults,
            nextToken: token,
            startArns: self.startArns
        )}
}
extension SageMakerClient {
    /// Paginate over `[SearchOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchOutput`
    public func searchPaginated(input: SearchInput) -> ClientRuntime.PaginatorSequence<SearchInput, SearchOutput> {
        return ClientRuntime.PaginatorSequence<SearchInput, SearchOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.search(input:))
    }
}

extension SearchInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchInput {
        return SearchInput(
            crossAccountFilterOption: self.crossAccountFilterOption,
            maxResults: self.maxResults,
            nextToken: token,
            resource: self.resource,
            searchExpression: self.searchExpression,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == SearchInput, OperationStackOutput == SearchOutput {
    /// This paginator transforms the `AsyncSequence` returned by `searchPaginated`
    /// to access the nested member `[SageMakerClientTypes.SearchRecord]`
    /// - Returns: `[SageMakerClientTypes.SearchRecord]`
    public func results() async throws -> [SageMakerClientTypes.SearchRecord] {
        return try await self.asyncCompactMap { item in item.results }
    }
}
