// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTRoboRunnerClientTypes.CartesianCoordinates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case x
        case y
        case z
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let x = self.x {
            try encodeContainer.encode(x, forKey: .x)
        }
        if let y = self.y {
            try encodeContainer.encode(y, forKey: .y)
        }
        if let z = self.z {
            try encodeContainer.encode(z, forKey: .z)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .x)
        x = xDecoded
        let yDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .y)
        y = yDecoded
        let zDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .z)
        z = zDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// Cartesian coordinates in 3D space relative to the RoboRunner origin.
    public struct CartesianCoordinates: Swift.Equatable {
        /// X coordinate.
        /// This member is required.
        public var x: Swift.Double?
        /// Y coordinate.
        /// This member is required.
        public var y: Swift.Double?
        /// Z coordinate.
        public var z: Swift.Double?

        public init(
            x: Swift.Double? = nil,
            y: Swift.Double? = nil,
            z: Swift.Double? = nil
        )
        {
            self.x = x
            self.y = y
            self.z = z
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception thrown if a resource in a create request already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case clientToken
        case name
        case site
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension CreateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createDestination"
    }
}

public struct CreateDestinationInput: Swift.Equatable {
    /// JSON document containing additional fixed properties regarding the destination
    public var additionalFixedProperties: Swift.String?
    /// Token used for detecting replayed requests. Replayed requests will not be performed multiple times.
    public var clientToken: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// The state of the destination. Default used if not specified.
    public var state: IoTRoboRunnerClientTypes.DestinationState?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        site: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.clientToken = clientToken
        self.name = name
        self.site = site
        self.state = state
    }
}

struct CreateDestinationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let site: Swift.String?
    let state: IoTRoboRunnerClientTypes.DestinationState?
    let additionalFixedProperties: Swift.String?
}

extension CreateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case clientToken
        case name
        case site
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension CreateDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.state = output.state
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.state = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateDestinationOutput: Swift.Equatable {
    /// Destination ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the destination's identifier
    /// This member is required.
    public var id: Swift.String?
    /// State of the destination.
    /// This member is required.
    public var state: IoTRoboRunnerClientTypes.DestinationState?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.state = state
        self.updatedAt = updatedAt
    }
}

struct CreateDestinationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let state: IoTRoboRunnerClientTypes.DestinationState?
}

extension CreateDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case state
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
    }
}

enum CreateDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case countryCode
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSite"
    }
}

public struct CreateSiteInput: Swift.Equatable {
    /// Token used for detecting replayed requests. Replayed requests will not be performed multiple times.
    public var clientToken: Swift.String?
    /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
    /// This member is required.
    public var countryCode: Swift.String?
    /// A high-level description of the site.
    public var description: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        countryCode: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.countryCode = countryCode
        self.description = description
        self.name = name
    }
}

struct CreateSiteInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let countryCode: Swift.String?
    let description: Swift.String?
}

extension CreateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case countryCode
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateSiteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSiteOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateSiteOutput: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the site's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct CreateSiteOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension CreateSiteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum CreateSiteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkerFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case clientToken
        case name
        case site
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
    }
}

extension CreateWorkerFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorkerFleet"
    }
}

public struct CreateWorkerFleetInput: Swift.Equatable {
    /// JSON blob containing additional fixed properties regarding the worker fleet
    public var additionalFixedProperties: Swift.String?
    /// Token used for detecting replayed requests. Replayed requests will not be performed multiple times.
    public var clientToken: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        site: Swift.String? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.clientToken = clientToken
        self.name = name
        self.site = site
    }
}

struct CreateWorkerFleetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let site: Swift.String?
    let additionalFixedProperties: Swift.String?
}

extension CreateWorkerFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case clientToken
        case name
        case site
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension CreateWorkerFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkerFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateWorkerFleetOutput: Swift.Equatable {
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the worker fleet's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.updatedAt = updatedAt
    }
}

struct CreateWorkerFleetOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension CreateWorkerFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum CreateWorkerFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWorkerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case clientToken
        case fleet
        case name
        case orientation
        case position
        case vendorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let additionalTransientProperties = self.additionalTransientProperties {
            try encodeContainer.encode(additionalTransientProperties, forKey: .additionalTransientProperties)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation, forKey: .orientation)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let vendorProperties = self.vendorProperties {
            try encodeContainer.encode(vendorProperties, forKey: .vendorProperties)
        }
    }
}

extension CreateWorkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createWorker"
    }
}

public struct CreateWorkerInput: Swift.Equatable {
    /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
    public var additionalFixedProperties: Swift.String?
    /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
    public var additionalTransientProperties: Swift.String?
    /// Token used for detecting replayed requests. Replayed requests will not be performed multiple times.
    public var clientToken: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Worker orientation measured in units clockwise from north.
    public var orientation: IoTRoboRunnerClientTypes.Orientation?
    /// Supported coordinates for worker position.
    public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
    /// Properties of the worker that are provided by the vendor FMS.
    public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        additionalTransientProperties: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        fleet: Swift.String? = nil,
        name: Swift.String? = nil,
        orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
        position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
        vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.additionalTransientProperties = additionalTransientProperties
        self.clientToken = clientToken
        self.fleet = fleet
        self.name = name
        self.orientation = orientation
        self.position = position
        self.vendorProperties = vendorProperties
    }
}

struct CreateWorkerInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let fleet: Swift.String?
    let additionalTransientProperties: Swift.String?
    let additionalFixedProperties: Swift.String?
    let vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?
    let position: IoTRoboRunnerClientTypes.PositionCoordinates?
    let orientation: IoTRoboRunnerClientTypes.Orientation?
}

extension CreateWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case clientToken
        case fleet
        case name
        case orientation
        case position
        case vendorProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
    }
}

extension CreateWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWorkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.site = output.site
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.site = nil
            self.updatedAt = nil
        }
    }
}

public struct CreateWorkerOutput: Swift.Equatable {
    /// Full ARN of the worker.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the workers identifier
    /// This member is required.
    public var id: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        site: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.site = site
        self.updatedAt = updatedAt
    }
}

struct CreateWorkerOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let site: Swift.String?
}

extension CreateWorkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case site
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
    }
}

enum CreateWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteDestination"
    }
}

public struct DeleteDestinationInput: Swift.Equatable {
    /// Destination ARN.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteDestinationInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDestinationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteSite"
    }
}

public struct DeleteSiteInput: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSiteInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteSiteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSiteOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSiteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkerFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteWorkerFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteWorkerFleet"
    }
}

public struct DeleteWorkerFleetInput: Swift.Equatable {
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWorkerFleetInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteWorkerFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteWorkerFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkerFleetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkerFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWorkerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

extension DeleteWorkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteWorker"
    }
}

public struct DeleteWorkerInput: Swift.Equatable {
    /// Full ARN of the worker.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWorkerInputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWorkerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTRoboRunnerClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case createdAt
        case id
        case name
        case site
        case state
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// Area within a facility where work can be performed.
    public struct Destination: Swift.Equatable {
        /// JSON document containing additional fixed properties regarding the destination
        public var additionalFixedProperties: Swift.String?
        /// Destination ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Timestamp at which the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Filters access by the destination's identifier
        /// This member is required.
        public var id: Swift.String?
        /// Human friendly name of the resource.
        /// This member is required.
        public var name: Swift.String?
        /// Site ARN.
        /// This member is required.
        public var site: Swift.String?
        /// State of the destination.
        /// This member is required.
        public var state: IoTRoboRunnerClientTypes.DestinationState?
        /// Timestamp at which the resource was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            additionalFixedProperties: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            site: Swift.String? = nil,
            state: IoTRoboRunnerClientTypes.DestinationState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.additionalFixedProperties = additionalFixedProperties
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.site = site
            self.state = state
            self.updatedAt = updatedAt
        }
    }

}

extension IoTRoboRunnerClientTypes {
    /// State of the destination.
    public enum DestinationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case decommissioned
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationState] {
            return [
                .decommissioned,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .decommissioned: return "DECOMMISSIONED"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationState(rawValue: rawValue) ?? DestinationState.sdkUnknown(rawValue)
        }
    }
}

extension GetDestinationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension GetDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getDestination"
    }
}

public struct GetDestinationInput: Swift.Equatable {
    /// Destination ARN.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDestinationInputBody: Swift.Equatable {
}

extension GetDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.name = output.name
            self.site = output.site
            self.state = output.state
            self.updatedAt = output.updatedAt
        } else {
            self.additionalFixedProperties = nil
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.name = nil
            self.site = nil
            self.state = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDestinationOutput: Swift.Equatable {
    /// JSON document containing additional fixed properties regarding the destination
    public var additionalFixedProperties: Swift.String?
    /// Destination ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the destination's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// State of the destination.
    /// This member is required.
    public var state: IoTRoboRunnerClientTypes.DestinationState?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        site: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.name = name
        self.site = site
        self.state = state
        self.updatedAt = updatedAt
    }
}

struct GetDestinationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let site: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let state: IoTRoboRunnerClientTypes.DestinationState?
    let additionalFixedProperties: Swift.String?
}

extension GetDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case createdAt
        case id
        case name
        case site
        case state
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

enum GetDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSiteInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension GetSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getSite"
    }
}

public struct GetSiteInput: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSiteInputBody: Swift.Equatable {
}

extension GetSiteInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSiteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSiteOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.countryCode = output.countryCode
            self.createdAt = output.createdAt
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.countryCode = nil
            self.createdAt = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.updatedAt = nil
        }
    }
}

public struct GetSiteOutput: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
    /// This member is required.
    public var countryCode: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// A high-level description of the site.
    public var description: Swift.String?
    /// Filters access by the site's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        countryCode: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.countryCode = countryCode
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
    }
}

struct GetSiteOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let countryCode: Swift.String?
    let description: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
}

extension GetSiteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case countryCode
        case createdAt
        case description
        case id
        case name
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetSiteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkerFleetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension GetWorkerFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getWorkerFleet"
    }
}

public struct GetWorkerFleetInput: Swift.Equatable {
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWorkerFleetInputBody: Swift.Equatable {
}

extension GetWorkerFleetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkerFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkerFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.name = output.name
            self.site = output.site
            self.updatedAt = output.updatedAt
        } else {
            self.additionalFixedProperties = nil
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.name = nil
            self.site = nil
            self.updatedAt = nil
        }
    }
}

public struct GetWorkerFleetOutput: Swift.Equatable {
    /// JSON blob containing additional fixed properties regarding the worker fleet
    public var additionalFixedProperties: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Filters access by the worker fleet's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        site: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.name = name
        self.site = site
        self.updatedAt = updatedAt
    }
}

struct GetWorkerFleetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let site: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let additionalFixedProperties: Swift.String?
}

extension GetWorkerFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case createdAt
        case id
        case name
        case site
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

enum GetWorkerFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkerInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let id = id else {
                let message = "Creating a URL Query Item failed. id is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let idQueryItem = ClientRuntime.URLQueryItem(name: "id".urlPercentEncoding(), value: Swift.String(id).urlPercentEncoding())
            items.append(idQueryItem)
            return items
        }
    }
}

extension GetWorkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getWorker"
    }
}

public struct GetWorkerInput: Swift.Equatable {
    /// Full ARN of the worker.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetWorkerInputBody: Swift.Equatable {
}

extension GetWorkerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.additionalTransientProperties = output.additionalTransientProperties
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.fleet = output.fleet
            self.id = output.id
            self.name = output.name
            self.orientation = output.orientation
            self.position = output.position
            self.site = output.site
            self.updatedAt = output.updatedAt
            self.vendorProperties = output.vendorProperties
        } else {
            self.additionalFixedProperties = nil
            self.additionalTransientProperties = nil
            self.arn = nil
            self.createdAt = nil
            self.fleet = nil
            self.id = nil
            self.name = nil
            self.orientation = nil
            self.position = nil
            self.site = nil
            self.updatedAt = nil
            self.vendorProperties = nil
        }
    }
}

public struct GetWorkerOutput: Swift.Equatable {
    /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
    public var additionalFixedProperties: Swift.String?
    /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
    public var additionalTransientProperties: Swift.String?
    /// Full ARN of the worker.
    /// This member is required.
    public var arn: Swift.String?
    /// Timestamp at which the resource was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// Filters access by the workers identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Worker orientation measured in units clockwise from north.
    public var orientation: IoTRoboRunnerClientTypes.Orientation?
    /// Supported coordinates for worker position.
    public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// Properties of the worker that are provided by the vendor FMS.
    public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        additionalTransientProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        fleet: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
        position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
        site: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.additionalTransientProperties = additionalTransientProperties
        self.arn = arn
        self.createdAt = createdAt
        self.fleet = fleet
        self.id = id
        self.name = name
        self.orientation = orientation
        self.position = position
        self.site = site
        self.updatedAt = updatedAt
        self.vendorProperties = vendorProperties
    }
}

struct GetWorkerOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let fleet: Swift.String?
    let site: Swift.String?
    let createdAt: ClientRuntime.Date?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let additionalTransientProperties: Swift.String?
    let additionalFixedProperties: Swift.String?
    let vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?
    let position: IoTRoboRunnerClientTypes.PositionCoordinates?
    let orientation: IoTRoboRunnerClientTypes.Orientation?
}

extension GetWorkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case arn
        case createdAt
        case fleet
        case id
        case name
        case orientation
        case position
        case site
        case updatedAt
        case vendorProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
    }
}

enum GetWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception thrown if something goes wrong within the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let site = site else {
                let message = "Creating a URL Query Item failed. site is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let siteQueryItem = ClientRuntime.URLQueryItem(name: "site".urlPercentEncoding(), value: Swift.String(site).urlPercentEncoding())
            items.append(siteQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            return items
        }
    }
}

extension ListDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDestinations"
    }
}

public struct ListDestinationsInput: Swift.Equatable {
    /// Maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?
    /// State of the destination.
    public var state: IoTRoboRunnerClientTypes.DestinationState?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        site: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.site = site
        self.state = state
    }
}

struct ListDestinationsInputBody: Swift.Equatable {
}

extension ListDestinationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDestinationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDestinationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinations = output.destinations
            self.nextToken = output.nextToken
        } else {
            self.destinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListDestinationsOutput: Swift.Equatable {
    /// List of destinations.
    public var destinations: [IoTRoboRunnerClientTypes.Destination]?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?

    public init(
        destinations: [IoTRoboRunnerClientTypes.Destination]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinations = destinations
        self.nextToken = nextToken
    }
}

struct ListDestinationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let destinations: [IoTRoboRunnerClientTypes.Destination]?
}

extension ListDestinationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([IoTRoboRunnerClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[IoTRoboRunnerClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [IoTRoboRunnerClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

enum ListDestinationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSitesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSitesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSites"
    }
}

public struct ListSitesInput: Swift.Equatable {
    /// Maximum number of results to retrieve in a single ListSites call.
    public var maxResults: Swift.Int?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSitesInputBody: Swift.Equatable {
}

extension ListSitesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSitesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSitesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sites = output.sites
        } else {
            self.nextToken = nil
            self.sites = nil
        }
    }
}

public struct ListSitesOutput: Swift.Equatable {
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// List of facilities.
    public var sites: [IoTRoboRunnerClientTypes.Site]?

    public init(
        nextToken: Swift.String? = nil,
        sites: [IoTRoboRunnerClientTypes.Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

struct ListSitesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sites: [IoTRoboRunnerClientTypes.Site]?
}

extension ListSitesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sites
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sitesContainer = try containerValues.decodeIfPresent([IoTRoboRunnerClientTypes.Site?].self, forKey: .sites)
        var sitesDecoded0:[IoTRoboRunnerClientTypes.Site]? = nil
        if let sitesContainer = sitesContainer {
            sitesDecoded0 = [IoTRoboRunnerClientTypes.Site]()
            for structure0 in sitesContainer {
                if let structure0 = structure0 {
                    sitesDecoded0?.append(structure0)
                }
            }
        }
        sites = sitesDecoded0
    }
}

enum ListSitesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkerFleetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let site = site else {
                let message = "Creating a URL Query Item failed. site is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let siteQueryItem = ClientRuntime.URLQueryItem(name: "site".urlPercentEncoding(), value: Swift.String(site).urlPercentEncoding())
            items.append(siteQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListWorkerFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorkerFleets"
    }
}

public struct ListWorkerFleetsInput: Swift.Equatable {
    /// Maximum number of results to retrieve in a single ListWorkerFleets call.
    public var maxResults: Swift.Int?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        site: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.site = site
    }
}

struct ListWorkerFleetsInputBody: Swift.Equatable {
}

extension ListWorkerFleetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkerFleetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkerFleetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workerFleets = output.workerFleets
        } else {
            self.nextToken = nil
            self.workerFleets = nil
        }
    }
}

public struct ListWorkerFleetsOutput: Swift.Equatable {
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// List of worker fleets.
    public var workerFleets: [IoTRoboRunnerClientTypes.WorkerFleet]?

    public init(
        nextToken: Swift.String? = nil,
        workerFleets: [IoTRoboRunnerClientTypes.WorkerFleet]? = nil
    )
    {
        self.nextToken = nextToken
        self.workerFleets = workerFleets
    }
}

struct ListWorkerFleetsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workerFleets: [IoTRoboRunnerClientTypes.WorkerFleet]?
}

extension ListWorkerFleetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workerFleets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workerFleetsContainer = try containerValues.decodeIfPresent([IoTRoboRunnerClientTypes.WorkerFleet?].self, forKey: .workerFleets)
        var workerFleetsDecoded0:[IoTRoboRunnerClientTypes.WorkerFleet]? = nil
        if let workerFleetsContainer = workerFleetsContainer {
            workerFleetsDecoded0 = [IoTRoboRunnerClientTypes.WorkerFleet]()
            for structure0 in workerFleetsContainer {
                if let structure0 = structure0 {
                    workerFleetsDecoded0?.append(structure0)
                }
            }
        }
        workerFleets = workerFleetsDecoded0
    }
}

enum ListWorkerFleetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let fleet = fleet {
                let fleetQueryItem = ClientRuntime.URLQueryItem(name: "fleet".urlPercentEncoding(), value: Swift.String(fleet).urlPercentEncoding())
                items.append(fleetQueryItem)
            }
            guard let site = site else {
                let message = "Creating a URL Query Item failed. site is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let siteQueryItem = ClientRuntime.URLQueryItem(name: "site".urlPercentEncoding(), value: Swift.String(site).urlPercentEncoding())
            items.append(siteQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListWorkersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorkers"
    }
}

public struct ListWorkersInput: Swift.Equatable {
    /// Full ARN of the worker fleet.
    public var fleet: Swift.String?
    /// Maximum number of results to retrieve in a single ListWorkers call.
    public var maxResults: Swift.Int?
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var site: Swift.String?

    public init(
        fleet: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        site: Swift.String? = nil
    )
    {
        self.fleet = fleet
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.site = site
    }
}

struct ListWorkersInputBody: Swift.Equatable {
}

extension ListWorkersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workers = output.workers
        } else {
            self.nextToken = nil
            self.workers = nil
        }
    }
}

public struct ListWorkersOutput: Swift.Equatable {
    /// Pagination token returned when another page of data exists. Provide it in your next call to the API to receive the next page.
    public var nextToken: Swift.String?
    /// List of workers.
    public var workers: [IoTRoboRunnerClientTypes.Worker]?

    public init(
        nextToken: Swift.String? = nil,
        workers: [IoTRoboRunnerClientTypes.Worker]? = nil
    )
    {
        self.nextToken = nextToken
        self.workers = workers
    }
}

struct ListWorkersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let workers: [IoTRoboRunnerClientTypes.Worker]?
}

extension ListWorkersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workersContainer = try containerValues.decodeIfPresent([IoTRoboRunnerClientTypes.Worker?].self, forKey: .workers)
        var workersDecoded0:[IoTRoboRunnerClientTypes.Worker]? = nil
        if let workersContainer = workersContainer {
            workersDecoded0 = [IoTRoboRunnerClientTypes.Worker]()
            for structure0 in workersContainer {
                if let structure0 = structure0 {
                    workersDecoded0?.append(structure0)
                }
            }
        }
        workers = workersDecoded0
    }
}

enum ListWorkersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTRoboRunnerClientTypes.Orientation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case degrees
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .degrees(degrees):
                try container.encode(degrees, forKey: .degrees)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let degreesDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .degrees)
        if let degrees = degreesDecoded {
            self = .degrees(degrees)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTRoboRunnerClientTypes {
    /// Worker orientation measured in units clockwise from north.
    public enum Orientation: Swift.Equatable {
        /// Degrees, limited on [0, 360)
        case degrees(Swift.Double)
        case sdkUnknown(Swift.String)
    }

}

extension IoTRoboRunnerClientTypes.PositionCoordinates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cartesiancoordinates = "cartesianCoordinates"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .cartesiancoordinates(cartesiancoordinates):
                try container.encode(cartesiancoordinates, forKey: .cartesiancoordinates)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let cartesiancoordinatesDecoded = try values.decodeIfPresent(IoTRoboRunnerClientTypes.CartesianCoordinates.self, forKey: .cartesiancoordinates)
        if let cartesiancoordinates = cartesiancoordinatesDecoded {
            self = .cartesiancoordinates(cartesiancoordinates)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTRoboRunnerClientTypes {
    /// Supported coordinates for worker position.
    public enum PositionCoordinates: Swift.Equatable {
        /// Cartesian coordinates.
        case cartesiancoordinates(IoTRoboRunnerClientTypes.CartesianCoordinates)
        case sdkUnknown(Swift.String)
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception thrown if a resource referenced in the request doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception thrown if the user's AWS account has reached a service limit and the operation cannot proceed.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTRoboRunnerClientTypes.Site: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case countryCode
        case createdAt
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// Facility containing destinations, workers, activities, and tasks.
    public struct Site: Swift.Equatable {
        /// Site ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
        /// This member is required.
        public var countryCode: Swift.String?
        /// Timestamp at which the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the site. Mutable after creation and unique within a given account.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.countryCode = countryCode
            self.createdAt = createdAt
            self.name = name
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception thrown if the api has been called too quickly be the client.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case id
        case name
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension UpdateDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDestination"
    }
}

public struct UpdateDestinationInput: Swift.Equatable {
    /// JSON document containing additional fixed properties regarding the destination
    public var additionalFixedProperties: Swift.String?
    /// Destination ARN.
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    public var name: Swift.String?
    /// State of the destination.
    public var state: IoTRoboRunnerClientTypes.DestinationState?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.id = id
        self.name = name
        self.state = state
    }
}

struct UpdateDestinationInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let state: IoTRoboRunnerClientTypes.DestinationState?
    let additionalFixedProperties: Swift.String?
}

extension UpdateDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case id
        case name
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension UpdateDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.state = output.state
            self.updatedAt = output.updatedAt
        } else {
            self.additionalFixedProperties = nil
            self.arn = nil
            self.id = nil
            self.name = nil
            self.state = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateDestinationOutput: Swift.Equatable {
    /// JSON document containing additional fixed properties regarding the destination
    public var additionalFixedProperties: Swift.String?
    /// Destination ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// Filters access by the destination's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// State of the destination.
    /// This member is required.
    public var state: IoTRoboRunnerClientTypes.DestinationState?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        state: IoTRoboRunnerClientTypes.DestinationState? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.arn = arn
        self.id = id
        self.name = name
        self.state = state
        self.updatedAt = updatedAt
    }
}

struct UpdateDestinationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let state: IoTRoboRunnerClientTypes.DestinationState?
    let additionalFixedProperties: Swift.String?
}

extension UpdateDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case id
        case name
        case state
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.DestinationState.self, forKey: .state)
        state = stateDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

enum UpdateDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSiteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode
        case description
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateSiteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateSite"
    }
}

public struct UpdateSiteInput: Swift.Equatable {
    /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
    public var countryCode: Swift.String?
    /// A high-level description of the site.
    public var description: Swift.String?
    /// Site ARN.
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    public var name: Swift.String?

    public init(
        countryCode: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.countryCode = countryCode
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateSiteInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let countryCode: Swift.String?
    let description: Swift.String?
}

extension UpdateSiteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode
        case description
        case id
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateSiteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSiteOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.countryCode = output.countryCode
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.updatedAt = output.updatedAt
        } else {
            self.arn = nil
            self.countryCode = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateSiteOutput: Swift.Equatable {
    /// Site ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// A valid ISO 3166-1 alpha-2 code for the country in which the site resides. e.g., US.
    public var countryCode: Swift.String?
    /// A high-level description of the site.
    public var description: Swift.String?
    /// Filters access by the site's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        arn: Swift.String? = nil,
        countryCode: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.countryCode = countryCode
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
    }
}

struct UpdateSiteOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let countryCode: Swift.String?
    let description: Swift.String?
    let updatedAt: ClientRuntime.Date?
}

extension UpdateSiteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case countryCode
        case description
        case id
        case name
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum UpdateSiteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkerFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateWorkerFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateWorkerFleet"
    }
}

public struct UpdateWorkerFleetInput: Swift.Equatable {
    /// JSON blob containing additional fixed properties regarding the worker fleet
    public var additionalFixedProperties: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    public var name: Swift.String?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.id = id
        self.name = name
    }
}

struct UpdateWorkerFleetInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let additionalFixedProperties: Swift.String?
}

extension UpdateWorkerFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case id
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension UpdateWorkerFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkerFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.updatedAt = output.updatedAt
        } else {
            self.additionalFixedProperties = nil
            self.arn = nil
            self.id = nil
            self.name = nil
            self.updatedAt = nil
        }
    }
}

public struct UpdateWorkerFleetOutput: Swift.Equatable {
    /// JSON blob containing additional fixed properties regarding the worker fleet
    public var additionalFixedProperties: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// Filters access by the worker fleet's identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.arn = arn
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
    }
}

struct UpdateWorkerFleetOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let additionalFixedProperties: Swift.String?
}

extension UpdateWorkerFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case id
        case name
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

enum UpdateWorkerFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWorkerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case id
        case name
        case orientation
        case position
        case vendorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let additionalTransientProperties = self.additionalTransientProperties {
            try encodeContainer.encode(additionalTransientProperties, forKey: .additionalTransientProperties)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation, forKey: .orientation)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let vendorProperties = self.vendorProperties {
            try encodeContainer.encode(vendorProperties, forKey: .vendorProperties)
        }
    }
}

extension UpdateWorkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateWorker"
    }
}

public struct UpdateWorkerInput: Swift.Equatable {
    /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
    public var additionalFixedProperties: Swift.String?
    /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
    public var additionalTransientProperties: Swift.String?
    /// Full ARN of the worker.
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    public var name: Swift.String?
    /// Worker orientation measured in units clockwise from north.
    public var orientation: IoTRoboRunnerClientTypes.Orientation?
    /// Supported coordinates for worker position.
    public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
    /// Properties of the worker that are provided by the vendor FMS.
    public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        additionalTransientProperties: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
        position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
        vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.additionalTransientProperties = additionalTransientProperties
        self.id = id
        self.name = name
        self.orientation = orientation
        self.position = position
        self.vendorProperties = vendorProperties
    }
}

struct UpdateWorkerInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let additionalTransientProperties: Swift.String?
    let additionalFixedProperties: Swift.String?
    let vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?
    let position: IoTRoboRunnerClientTypes.PositionCoordinates?
    let orientation: IoTRoboRunnerClientTypes.Orientation?
}

extension UpdateWorkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case id
        case name
        case orientation
        case position
        case vendorProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
    }
}

extension UpdateWorkerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWorkerOutputBody = try responseDecoder.decode(responseBody: data)
            self.additionalFixedProperties = output.additionalFixedProperties
            self.additionalTransientProperties = output.additionalTransientProperties
            self.arn = output.arn
            self.fleet = output.fleet
            self.id = output.id
            self.name = output.name
            self.orientation = output.orientation
            self.position = output.position
            self.updatedAt = output.updatedAt
            self.vendorProperties = output.vendorProperties
        } else {
            self.additionalFixedProperties = nil
            self.additionalTransientProperties = nil
            self.arn = nil
            self.fleet = nil
            self.id = nil
            self.name = nil
            self.orientation = nil
            self.position = nil
            self.updatedAt = nil
            self.vendorProperties = nil
        }
    }
}

public struct UpdateWorkerOutput: Swift.Equatable {
    /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
    public var additionalFixedProperties: Swift.String?
    /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
    public var additionalTransientProperties: Swift.String?
    /// Full ARN of the worker.
    /// This member is required.
    public var arn: Swift.String?
    /// Full ARN of the worker fleet.
    /// This member is required.
    public var fleet: Swift.String?
    /// Filters access by the workers identifier
    /// This member is required.
    public var id: Swift.String?
    /// Human friendly name of the resource.
    /// This member is required.
    public var name: Swift.String?
    /// Worker orientation measured in units clockwise from north.
    public var orientation: IoTRoboRunnerClientTypes.Orientation?
    /// Supported coordinates for worker position.
    public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
    /// Timestamp at which the resource was last updated.
    /// This member is required.
    public var updatedAt: ClientRuntime.Date?
    /// Properties of the worker that are provided by the vendor FMS.
    public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

    public init(
        additionalFixedProperties: Swift.String? = nil,
        additionalTransientProperties: Swift.String? = nil,
        arn: Swift.String? = nil,
        fleet: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
        position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
        updatedAt: ClientRuntime.Date? = nil,
        vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
    )
    {
        self.additionalFixedProperties = additionalFixedProperties
        self.additionalTransientProperties = additionalTransientProperties
        self.arn = arn
        self.fleet = fleet
        self.id = id
        self.name = name
        self.orientation = orientation
        self.position = position
        self.updatedAt = updatedAt
        self.vendorProperties = vendorProperties
    }
}

struct UpdateWorkerOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let fleet: Swift.String?
    let updatedAt: ClientRuntime.Date?
    let name: Swift.String?
    let additionalTransientProperties: Swift.String?
    let additionalFixedProperties: Swift.String?
    let orientation: IoTRoboRunnerClientTypes.Orientation?
    let vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?
    let position: IoTRoboRunnerClientTypes.PositionCoordinates?
}

extension UpdateWorkerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case arn
        case fleet
        case id
        case name
        case orientation
        case position
        case updatedAt
        case vendorProperties
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
    }
}

enum UpdateWorkerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception thrown if an invalid parameter is provided to an API.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTRoboRunnerClientTypes.VendorProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vendorAdditionalFixedProperties
        case vendorAdditionalTransientProperties
        case vendorWorkerId
        case vendorWorkerIpAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vendorAdditionalFixedProperties = self.vendorAdditionalFixedProperties {
            try encodeContainer.encode(vendorAdditionalFixedProperties, forKey: .vendorAdditionalFixedProperties)
        }
        if let vendorAdditionalTransientProperties = self.vendorAdditionalTransientProperties {
            try encodeContainer.encode(vendorAdditionalTransientProperties, forKey: .vendorAdditionalTransientProperties)
        }
        if let vendorWorkerId = self.vendorWorkerId {
            try encodeContainer.encode(vendorWorkerId, forKey: .vendorWorkerId)
        }
        if let vendorWorkerIpAddress = self.vendorWorkerIpAddress {
            try encodeContainer.encode(vendorWorkerIpAddress, forKey: .vendorWorkerIpAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vendorWorkerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorWorkerId)
        vendorWorkerId = vendorWorkerIdDecoded
        let vendorWorkerIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorWorkerIpAddress)
        vendorWorkerIpAddress = vendorWorkerIpAddressDecoded
        let vendorAdditionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorAdditionalTransientProperties)
        vendorAdditionalTransientProperties = vendorAdditionalTransientPropertiesDecoded
        let vendorAdditionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorAdditionalFixedProperties)
        vendorAdditionalFixedProperties = vendorAdditionalFixedPropertiesDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// Properties of the worker that are provided by the vendor FMS.
    public struct VendorProperties: Swift.Equatable {
        /// JSON blob containing unstructured vendor properties that are fixed and won't change during regular operation.
        public var vendorAdditionalFixedProperties: Swift.String?
        /// JSON blob containing unstructured vendor properties that are transient and may change during regular operation.
        public var vendorAdditionalTransientProperties: Swift.String?
        /// The worker ID defined by the vendor FMS.
        /// This member is required.
        public var vendorWorkerId: Swift.String?
        /// The worker IP address defined by the vendor FMS.
        public var vendorWorkerIpAddress: Swift.String?

        public init(
            vendorAdditionalFixedProperties: Swift.String? = nil,
            vendorAdditionalTransientProperties: Swift.String? = nil,
            vendorWorkerId: Swift.String? = nil,
            vendorWorkerIpAddress: Swift.String? = nil
        )
        {
            self.vendorAdditionalFixedProperties = vendorAdditionalFixedProperties
            self.vendorAdditionalTransientProperties = vendorAdditionalTransientProperties
            self.vendorWorkerId = vendorWorkerId
            self.vendorWorkerIpAddress = vendorWorkerIpAddress
        }
    }

}

extension IoTRoboRunnerClientTypes.Worker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case additionalTransientProperties
        case arn
        case createdAt
        case fleet
        case id
        case name
        case orientation
        case position
        case site
        case updatedAt
        case vendorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let additionalTransientProperties = self.additionalTransientProperties {
            try encodeContainer.encode(additionalTransientProperties, forKey: .additionalTransientProperties)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let fleet = self.fleet {
            try encodeContainer.encode(fleet, forKey: .fleet)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation, forKey: .orientation)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let vendorProperties = self.vendorProperties {
            try encodeContainer.encode(vendorProperties, forKey: .vendorProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fleetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleet)
        fleet = fleetDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let additionalTransientPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalTransientProperties)
        additionalTransientProperties = additionalTransientPropertiesDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
        let vendorPropertiesDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.VendorProperties.self, forKey: .vendorProperties)
        vendorProperties = vendorPropertiesDecoded
        let positionDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.PositionCoordinates.self, forKey: .position)
        position = positionDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(IoTRoboRunnerClientTypes.Orientation.self, forKey: .orientation)
        orientation = orientationDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// A unit capable of performing tasks.
    public struct Worker: Swift.Equatable {
        /// JSON blob containing unstructured worker properties that are fixed and won't change during regular operation.
        public var additionalFixedProperties: Swift.String?
        /// JSON blob containing unstructured worker properties that are transient and may change during regular operation.
        public var additionalTransientProperties: Swift.String?
        /// Full ARN of the worker.
        /// This member is required.
        public var arn: Swift.String?
        /// Timestamp at which the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Full ARN of the worker fleet.
        /// This member is required.
        public var fleet: Swift.String?
        /// Filters access by the workers identifier
        /// This member is required.
        public var id: Swift.String?
        /// Human friendly name of the resource.
        /// This member is required.
        public var name: Swift.String?
        /// Worker orientation measured in units clockwise from north.
        public var orientation: IoTRoboRunnerClientTypes.Orientation?
        /// Supported coordinates for worker position.
        public var position: IoTRoboRunnerClientTypes.PositionCoordinates?
        /// Site ARN.
        /// This member is required.
        public var site: Swift.String?
        /// Timestamp at which the resource was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// Properties of the worker that are provided by the vendor FMS.
        public var vendorProperties: IoTRoboRunnerClientTypes.VendorProperties?

        public init(
            additionalFixedProperties: Swift.String? = nil,
            additionalTransientProperties: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            fleet: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            orientation: IoTRoboRunnerClientTypes.Orientation? = nil,
            position: IoTRoboRunnerClientTypes.PositionCoordinates? = nil,
            site: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            vendorProperties: IoTRoboRunnerClientTypes.VendorProperties? = nil
        )
        {
            self.additionalFixedProperties = additionalFixedProperties
            self.additionalTransientProperties = additionalTransientProperties
            self.arn = arn
            self.createdAt = createdAt
            self.fleet = fleet
            self.id = id
            self.name = name
            self.orientation = orientation
            self.position = position
            self.site = site
            self.updatedAt = updatedAt
            self.vendorProperties = vendorProperties
        }
    }

}

extension IoTRoboRunnerClientTypes.WorkerFleet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalFixedProperties
        case arn
        case createdAt
        case id
        case name
        case site
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalFixedProperties = self.additionalFixedProperties {
            try encodeContainer.encode(additionalFixedProperties, forKey: .additionalFixedProperties)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let site = self.site {
            try encodeContainer.encode(site, forKey: .site)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let siteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .site)
        site = siteDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let additionalFixedPropertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalFixedProperties)
        additionalFixedProperties = additionalFixedPropertiesDecoded
    }
}

extension IoTRoboRunnerClientTypes {
    /// A collection of workers organized within a facility.
    public struct WorkerFleet: Swift.Equatable {
        /// JSON blob containing additional fixed properties regarding the worker fleet
        public var additionalFixedProperties: Swift.String?
        /// Full ARN of the worker fleet.
        /// This member is required.
        public var arn: Swift.String?
        /// Timestamp at which the resource was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Filters access by the worker fleet's identifier
        /// This member is required.
        public var id: Swift.String?
        /// Human friendly name of the resource.
        /// This member is required.
        public var name: Swift.String?
        /// Site ARN.
        /// This member is required.
        public var site: Swift.String?
        /// Timestamp at which the resource was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            additionalFixedProperties: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            site: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.additionalFixedProperties = additionalFixedProperties
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.site = site
            self.updatedAt = updatedAt
        }
    }

}
