// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GroundStationClientTypes {
    public enum AngleUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degreeAngle
        case radian
        case sdkUnknown(Swift.String)

        public static var allCases: [AngleUnits] {
            return [
                .degreeAngle,
                .radian,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degreeAngle: return "DEGREE_ANGLE"
            case .radian: return "RADIAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AngleUnits(rawValue: rawValue) ?? AngleUnits.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.AntennaDemodDecodeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputNode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputNode = self.outputNode {
            try encodeContainer.encode(outputNode, forKey: .outputNode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputNodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputNode)
        outputNode = outputNodeDecoded
    }
}

extension GroundStationClientTypes {
    /// Details about an antenna demod decode Config used in a contact.
    public struct AntennaDemodDecodeDetails: Swift.Equatable {
        /// Name of an antenna demod decode output node used in a contact.
        public var outputNode: Swift.String?

        public init (
            outputNode: Swift.String? = nil
        )
        {
            self.outputNode = outputNode
        }
    }

}

extension GroundStationClientTypes.AntennaDownlinkConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spectrumConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = self.spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
    public struct AntennaDownlinkConfig: Swift.Equatable {
        /// Object that describes a spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init (
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
        }
    }

}

extension GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decodeConfig
        case demodulationConfig
        case spectrumConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decodeConfig = self.decodeConfig {
            try encodeContainer.encode(decodeConfig, forKey: .decodeConfig)
        }
        if let demodulationConfig = self.demodulationConfig {
            try encodeContainer.encode(demodulationConfig, forKey: .demodulationConfig)
        }
        if let spectrumConfig = self.spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let demodulationConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DemodulationConfig.self, forKey: .demodulationConfig)
        demodulationConfig = demodulationConfigDecoded
        let decodeConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DecodeConfig.self, forKey: .decodeConfig)
        decodeConfig = decodeConfigDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
    public struct AntennaDownlinkDemodDecodeConfig: Swift.Equatable {
        /// Information about the decode Config.
        /// This member is required.
        public var decodeConfig: GroundStationClientTypes.DecodeConfig?
        /// Information about the demodulation Config.
        /// This member is required.
        public var demodulationConfig: GroundStationClientTypes.DemodulationConfig?
        /// Information about the spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init (
            decodeConfig: GroundStationClientTypes.DecodeConfig? = nil,
            demodulationConfig: GroundStationClientTypes.DemodulationConfig? = nil,
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.decodeConfig = decodeConfig
            self.demodulationConfig = demodulationConfig
            self.spectrumConfig = spectrumConfig
        }
    }

}

extension GroundStationClientTypes.AntennaUplinkConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spectrumConfig
        case targetEirp
        case transmitDisabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = self.spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
        if let targetEirp = self.targetEirp {
            try encodeContainer.encode(targetEirp, forKey: .targetEirp)
        }
        if let transmitDisabled = self.transmitDisabled {
            try encodeContainer.encode(transmitDisabled, forKey: .transmitDisabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transmitDisabled)
        transmitDisabled = transmitDisabledDecoded
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.UplinkSpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let targetEirpDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Eirp.self, forKey: .targetEirp)
        targetEirp = targetEirpDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the uplink Config of an antenna.
    public struct AntennaUplinkConfig: Swift.Equatable {
        /// Information about the uplink spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig?
        /// EIRP of the target.
        /// This member is required.
        public var targetEirp: GroundStationClientTypes.Eirp?
        /// Whether or not uplink transmit is disabled.
        public var transmitDisabled: Swift.Bool?

        public init (
            spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig? = nil,
            targetEirp: GroundStationClientTypes.Eirp? = nil,
            transmitDisabled: Swift.Bool? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
            self.targetEirp = targetEirp
            self.transmitDisabled = transmitDisabled
        }
    }

}

extension GroundStationClientTypes {
    public enum BandwidthUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [BandwidthUnits] {
            return [
                .ghz,
                .khz,
                .mhz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BandwidthUnits(rawValue: rawValue) ?? BandwidthUnits.sdkUnknown(rawValue)
        }
    }
}

extension CancelContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/\(contactId.urlPercentEncoding())"
    }
}

///
public struct CancelContactInput: Swift.Equatable {
    /// UUID of a contact.
    /// This member is required.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactInputBody: Swift.Equatable {
}

extension CancelContactInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelContactOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

///
public struct CancelContactOutputResponse: Swift.Equatable {
    /// UUID of a contact.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactOutputResponseBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension CancelContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension GroundStationClientTypes {
    public enum ConfigCapabilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case antennaDownlink
        case antennaDownlinkDemodDecode
        case antennaUplink
        case dataflowEndpoint
        case s3Recording
        case tracking
        case uplinkEcho
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigCapabilityType] {
            return [
                .antennaDownlink,
                .antennaDownlinkDemodDecode,
                .antennaUplink,
                .dataflowEndpoint,
                .s3Recording,
                .tracking,
                .uplinkEcho,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .antennaDownlink: return "antenna-downlink"
            case .antennaDownlinkDemodDecode: return "antenna-downlink-demod-decode"
            case .antennaUplink: return "antenna-uplink"
            case .dataflowEndpoint: return "dataflow-endpoint"
            case .s3Recording: return "s3-recording"
            case .tracking: return "tracking"
            case .uplinkEcho: return "uplink-echo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigCapabilityType(rawValue: rawValue) ?? ConfigCapabilityType.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.ConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennademoddecodedetails = "antennaDemodDecodeDetails"
        case endpointdetails = "endpointDetails"
        case s3recordingdetails = "s3RecordingDetails"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennademoddecodedetails(antennademoddecodedetails):
                try container.encode(antennademoddecodedetails, forKey: .antennademoddecodedetails)
            case let .endpointdetails(endpointdetails):
                try container.encode(endpointdetails, forKey: .endpointdetails)
            case let .s3recordingdetails(s3recordingdetails):
                try container.encode(s3recordingdetails, forKey: .s3recordingdetails)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let endpointdetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.EndpointDetails.self, forKey: .endpointdetails)
        if let endpointdetails = endpointdetailsDecoded {
            self = .endpointdetails(endpointdetails)
            return
        }
        let antennademoddecodedetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDemodDecodeDetails.self, forKey: .antennademoddecodedetails)
        if let antennademoddecodedetails = antennademoddecodedetailsDecoded {
            self = .antennademoddecodedetails(antennademoddecodedetails)
            return
        }
        let s3recordingdetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.S3RecordingDetails.self, forKey: .s3recordingdetails)
        if let s3recordingdetails = s3recordingdetailsDecoded {
            self = .s3recordingdetails(s3recordingdetails)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// Details for certain Config object types in a contact.
    public enum ConfigDetails: Swift.Equatable {
        /// Information about the endpoint details.
        case endpointdetails(GroundStationClientTypes.EndpointDetails)
        /// Details for antenna demod decode Config in a contact.
        case antennademoddecodedetails(GroundStationClientTypes.AntennaDemodDecodeDetails)
        /// Details for an S3 recording Config in a contact.
        case s3recordingdetails(GroundStationClientTypes.S3RecordingDetails)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.ConfigListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configArn = self.configArn {
            try encodeContainer.encode(configArn, forKey: .configArn)
        }
        if let configId = self.configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = self.configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes {
    /// An item in a list of Config objects.
    public struct ConfigListItem: Swift.Equatable {
        /// ARN of a Config.
        public var configArn: Swift.String?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Name of a Config.
        public var name: Swift.String?

        public init (
            configArn: Swift.String? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            name: Swift.String? = nil
        )
        {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
            self.name = name
        }
    }

}

extension GroundStationClientTypes.ConfigTypeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennadownlinkconfig = "antennaDownlinkConfig"
        case antennadownlinkdemoddecodeconfig = "antennaDownlinkDemodDecodeConfig"
        case antennauplinkconfig = "antennaUplinkConfig"
        case dataflowendpointconfig = "dataflowEndpointConfig"
        case s3recordingconfig = "s3RecordingConfig"
        case sdkUnknown
        case trackingconfig = "trackingConfig"
        case uplinkechoconfig = "uplinkEchoConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennadownlinkconfig(antennadownlinkconfig):
                try container.encode(antennadownlinkconfig, forKey: .antennadownlinkconfig)
            case let .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig):
                try container.encode(antennadownlinkdemoddecodeconfig, forKey: .antennadownlinkdemoddecodeconfig)
            case let .antennauplinkconfig(antennauplinkconfig):
                try container.encode(antennauplinkconfig, forKey: .antennauplinkconfig)
            case let .dataflowendpointconfig(dataflowendpointconfig):
                try container.encode(dataflowendpointconfig, forKey: .dataflowendpointconfig)
            case let .s3recordingconfig(s3recordingconfig):
                try container.encode(s3recordingconfig, forKey: .s3recordingconfig)
            case let .trackingconfig(trackingconfig):
                try container.encode(trackingconfig, forKey: .trackingconfig)
            case let .uplinkechoconfig(uplinkechoconfig):
                try container.encode(uplinkechoconfig, forKey: .uplinkechoconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let antennadownlinkconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDownlinkConfig.self, forKey: .antennadownlinkconfig)
        if let antennadownlinkconfig = antennadownlinkconfigDecoded {
            self = .antennadownlinkconfig(antennadownlinkconfig)
            return
        }
        let trackingconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.TrackingConfig.self, forKey: .trackingconfig)
        if let trackingconfig = trackingconfigDecoded {
            self = .trackingconfig(trackingconfig)
            return
        }
        let dataflowendpointconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.DataflowEndpointConfig.self, forKey: .dataflowendpointconfig)
        if let dataflowendpointconfig = dataflowendpointconfigDecoded {
            self = .dataflowendpointconfig(dataflowendpointconfig)
            return
        }
        let antennadownlinkdemoddecodeconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig.self, forKey: .antennadownlinkdemoddecodeconfig)
        if let antennadownlinkdemoddecodeconfig = antennadownlinkdemoddecodeconfigDecoded {
            self = .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig)
            return
        }
        let antennauplinkconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaUplinkConfig.self, forKey: .antennauplinkconfig)
        if let antennauplinkconfig = antennauplinkconfigDecoded {
            self = .antennauplinkconfig(antennauplinkconfig)
            return
        }
        let uplinkechoconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.UplinkEchoConfig.self, forKey: .uplinkechoconfig)
        if let uplinkechoconfig = uplinkechoconfigDecoded {
            self = .uplinkechoconfig(uplinkechoconfig)
            return
        }
        let s3recordingconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.S3RecordingConfig.self, forKey: .s3recordingconfig)
        if let s3recordingconfig = s3recordingconfigDecoded {
            self = .s3recordingconfig(s3recordingconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// Object containing the parameters of a Config. See the subtype definitions for what each type of Config contains.
    public enum ConfigTypeData: Swift.Equatable {
        /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
        case antennadownlinkconfig(GroundStationClientTypes.AntennaDownlinkConfig)
        /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
        case trackingconfig(GroundStationClientTypes.TrackingConfig)
        /// Information about the dataflow endpoint Config.
        case dataflowendpointconfig(GroundStationClientTypes.DataflowEndpointConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
        case antennadownlinkdemoddecodeconfig(GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.
        case antennauplinkconfig(GroundStationClientTypes.AntennaUplinkConfig)
        /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
        case uplinkechoconfig(GroundStationClientTypes.UplinkEchoConfig)
        /// Information about an S3 recording Config.
        case s3recordingconfig(GroundStationClientTypes.S3RecordingConfig)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.ContactData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
        case contactStatus
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let contactStatus = self.contactStatus {
            try encodeContainer.encode(contactStatus.rawValue, forKey: .contactStatus)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let groundStation = self.groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maximumElevation = self.maximumElevation {
            try encodeContainer.encode(maximumElevation, forKey: .maximumElevation)
        }
        if let missionProfileArn = self.missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let postPassEndTime = self.postPassEndTime {
            try encodeContainer.encodeTimestamp(postPassEndTime, format: .epochSeconds, forKey: .postPassEndTime)
        }
        if let prePassStartTime = self.prePassStartTime {
            try encodeContainer.encodeTimestamp(prePassStartTime, format: .epochSeconds, forKey: .prePassStartTime)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let satelliteArn = self.satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GroundStationClientTypes {
    /// Data describing a contact.
    public struct ContactData: Swift.Equatable {
        /// UUID of a contact.
        public var contactId: Swift.String?
        /// Status of a contact.
        public var contactStatus: GroundStationClientTypes.ContactStatus?
        /// End time of a contact in UTC.
        public var endTime: ClientRuntime.Date?
        /// Error message of a contact.
        public var errorMessage: Swift.String?
        /// Name of a ground station.
        public var groundStation: Swift.String?
        /// Maximum elevation angle of a contact.
        public var maximumElevation: GroundStationClientTypes.Elevation?
        /// ARN of a mission profile.
        public var missionProfileArn: Swift.String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public var postPassEndTime: ClientRuntime.Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public var prePassStartTime: ClientRuntime.Date?
        /// Region of a contact.
        public var region: Swift.String?
        /// ARN of a satellite.
        public var satelliteArn: Swift.String?
        /// Start time of a contact in UTC.
        public var startTime: ClientRuntime.Date?
        /// Tags assigned to a contact.
        public var tags: [Swift.String:Swift.String]?

        public init (
            contactId: Swift.String? = nil,
            contactStatus: GroundStationClientTypes.ContactStatus? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorMessage: Swift.String? = nil,
            groundStation: Swift.String? = nil,
            maximumElevation: GroundStationClientTypes.Elevation? = nil,
            missionProfileArn: Swift.String? = nil,
            postPassEndTime: ClientRuntime.Date? = nil,
            prePassStartTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            satelliteArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }
    }

}

extension GroundStationClientTypes {
    public enum ContactStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case awsCancelled
        case awsFailed
        case cancelled
        case cancelling
        case completed
        case failed
        case failedToSchedule
        case pass
        case postpass
        case prepass
        case scheduled
        case scheduling
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactStatus] {
            return [
                .available,
                .awsCancelled,
                .awsFailed,
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .failedToSchedule,
                .pass,
                .postpass,
                .prepass,
                .scheduled,
                .scheduling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .awsCancelled: return "AWS_CANCELLED"
            case .awsFailed: return "AWS_FAILED"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .failedToSchedule: return "FAILED_TO_SCHEDULE"
            case .pass: return "PASS"
            case .postpass: return "POSTPASS"
            case .prepass: return "PREPASS"
            case .scheduled: return "SCHEDULED"
            case .scheduling: return "SCHEDULING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactStatus(rawValue: rawValue) ?? ContactStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = self.configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/config"
    }
}

///
public struct CreateConfigInput: Swift.Equatable {
    /// Parameters of a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a Config.
    public var tags: [Swift.String:Swift.String]?

    public init (
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configData = configData
        self.name = name
        self.tags = tags
    }
}

struct CreateConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let configData: GroundStationClientTypes.ConfigTypeData?
    let tags: [Swift.String:Swift.String]?
}

extension CreateConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

///
public struct CreateConfigOutputResponse: Swift.Equatable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct CreateConfigOutputResponseBody: Swift.Equatable {
    let configId: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configArn: Swift.String?
}

extension CreateConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

extension CreateDataflowEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDetails
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointDetails = endpointDetails {
            var endpointDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDetails)
            for endpointdetails0 in endpointDetails {
                try endpointDetailsContainer.encode(endpointdetails0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDataflowEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataflowEndpointGroup"
    }
}

///
public struct CreateDataflowEndpointGroupInput: Swift.Equatable {
    /// Endpoint details of each endpoint in the dataflow endpoint group.
    /// This member is required.
    public var endpointDetails: [GroundStationClientTypes.EndpointDetails]?
    /// Tags of a dataflow endpoint group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        endpointDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.endpointDetails = endpointDetails
        self.tags = tags
    }
}

struct CreateDataflowEndpointGroupInputBody: Swift.Equatable {
    let endpointDetails: [GroundStationClientTypes.EndpointDetails]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDataflowEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointDetails
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDetailsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EndpointDetails?].self, forKey: .endpointDetails)
        var endpointDetailsDecoded0:[GroundStationClientTypes.EndpointDetails]? = nil
        if let endpointDetailsContainer = endpointDetailsContainer {
            endpointDetailsDecoded0 = [GroundStationClientTypes.EndpointDetails]()
            for structure0 in endpointDetailsContainer {
                if let structure0 = structure0 {
                    endpointDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointDetails = endpointDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataflowEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDataflowEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataflowEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

///
public struct CreateDataflowEndpointGroupOutputResponse: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct CreateDataflowEndpointGroupOutputResponseBody: Swift.Equatable {
    let dataflowEndpointGroupId: Swift.String?
}

extension CreateDataflowEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

extension CreateEphemerisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case ephemeris
        case expirationTime
        case kmsKeyArn
        case name
        case priority
        case satelliteId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ephemeris = self.ephemeris {
            try encodeContainer.encode(ephemeris, forKey: .ephemeris)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .epochSeconds, forKey: .expirationTime)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let satelliteId = self.satelliteId {
            try encodeContainer.encode(satelliteId, forKey: .satelliteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEphemerisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ephemeris"
    }
}

public struct CreateEphemerisInput: Swift.Equatable {
    /// Whether to set the ephemeris status to ENABLED after validation. Setting this to false will set the ephemeris status to DISABLED after validation.
    public var enabled: Swift.Bool?
    /// Ephemeris data.
    public var ephemeris: GroundStationClientTypes.EphemerisData?
    /// An overall expiration time for the ephemeris in UTC, after which it will become EXPIRED.
    public var expirationTime: ClientRuntime.Date?
    /// The ARN of a KMS key used to encrypt the ephemeris in Ground Station.
    public var kmsKeyArn: Swift.String?
    /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
    /// This member is required.
    public var name: Swift.String?
    /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
    public var priority: Swift.Int?
    /// AWS Ground Station satellite ID for this ephemeris.
    /// This member is required.
    public var satelliteId: Swift.String?
    /// Tags assigned to an ephemeris.
    public var tags: [Swift.String:Swift.String]?

    public init (
        enabled: Swift.Bool? = nil,
        ephemeris: GroundStationClientTypes.EphemerisData? = nil,
        expirationTime: ClientRuntime.Date? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        satelliteId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.enabled = enabled
        self.ephemeris = ephemeris
        self.expirationTime = expirationTime
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.priority = priority
        self.satelliteId = satelliteId
        self.tags = tags
    }
}

struct CreateEphemerisInputBody: Swift.Equatable {
    let satelliteId: Swift.String?
    let enabled: Swift.Bool?
    let priority: Swift.Int?
    let expirationTime: ClientRuntime.Date?
    let name: Swift.String?
    let kmsKeyArn: Swift.String?
    let ephemeris: GroundStationClientTypes.EphemerisData?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEphemerisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case ephemeris
        case expirationTime
        case kmsKeyArn
        case name
        case priority
        case satelliteId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let ephemerisDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisData.self, forKey: .ephemeris)
        ephemeris = ephemerisDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEphemerisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEphemerisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateEphemerisOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEphemerisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateEphemerisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ephemerisId = output.ephemerisId
        } else {
            self.ephemerisId = nil
        }
    }
}

public struct CreateEphemerisOutputResponse: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?

    public init (
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct CreateEphemerisOutputResponseBody: Swift.Equatable {
    let ephemerisId: Swift.String?
}

extension CreateEphemerisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
    }
}

extension CreateMissionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case tags
        case trackingConfigArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = self.contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = self.contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedge0 in dataflowEdges {
                var dataflowedge0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for configarn1 in dataflowedge0 {
                    try dataflowedge0Container.encode(configarn1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = self.minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let trackingConfigArn = self.trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

extension CreateMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/missionprofile"
    }
}

///
public struct CreateMissionProfileInput: Swift.Equatable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    /// This member is required.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    /// This member is required.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// Name of a mission profile.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a mission profile.
    public var tags: [Swift.String:Swift.String]?
    /// ARN of a tracking Config.
    /// This member is required.
    public var trackingConfigArn: Swift.String?

    public init (
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.name = name
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct CreateMissionProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
    let minimumViableContactDurationSeconds: Swift.Int?
    let dataflowEdges: [[Swift.String]]?
    let trackingConfigArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateMissionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case tags
        case trackingConfigArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

///
public struct CreateMissionProfileOutputResponse: Swift.Equatable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct CreateMissionProfileOutputResponseBody: Swift.Equatable {
    let missionProfileId: Swift.String?
}

extension CreateMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension GroundStationClientTypes {
    public enum Criticality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case preferred
        case removed
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [Criticality] {
            return [
                .preferred,
                .removed,
                .required,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .preferred: return "PREFERRED"
            case .removed: return "REMOVED"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Criticality(rawValue: rawValue) ?? Criticality.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.DataflowDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case errorMessage
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about a dataflow edge used in a contact.
    public struct DataflowDetail: Swift.Equatable {
        /// Dataflow details for the destination side.
        public var destination: GroundStationClientTypes.Destination?
        /// Error message for a dataflow.
        public var errorMessage: Swift.String?
        /// Dataflow details for the source side.
        public var source: GroundStationClientTypes.Source?

        public init (
            destination: GroundStationClientTypes.Destination? = nil,
            errorMessage: Swift.String? = nil,
            source: GroundStationClientTypes.Source? = nil
        )
        {
            self.destination = destination
            self.errorMessage = errorMessage
            self.source = source
        }
    }

}

extension GroundStationClientTypes.DataflowEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case mtu
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let addressDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SocketAddress.self, forKey: .address)
        address = addressDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about a dataflow endpoint.
    public struct DataflowEndpoint: Swift.Equatable {
        /// Socket address of a dataflow endpoint.
        public var address: GroundStationClientTypes.SocketAddress?
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public var mtu: Swift.Int?
        /// Name of a dataflow endpoint.
        public var name: Swift.String?
        /// Status of a dataflow endpoint.
        public var status: GroundStationClientTypes.EndpointStatus?

        public init (
            address: GroundStationClientTypes.SocketAddress? = nil,
            mtu: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: GroundStationClientTypes.EndpointStatus? = nil
        )
        {
            self.address = address
            self.mtu = mtu
            self.name = name
            self.status = status
        }
    }

}

extension GroundStationClientTypes.DataflowEndpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointName
        case dataflowEndpointRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointName = self.dataflowEndpointName {
            try encodeContainer.encode(dataflowEndpointName, forKey: .dataflowEndpointName)
        }
        if let dataflowEndpointRegion = self.dataflowEndpointRegion {
            try encodeContainer.encode(dataflowEndpointRegion, forKey: .dataflowEndpointRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointName)
        dataflowEndpointName = dataflowEndpointNameDecoded
        let dataflowEndpointRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointRegion)
        dataflowEndpointRegion = dataflowEndpointRegionDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the dataflow endpoint Config.
    public struct DataflowEndpointConfig: Swift.Equatable {
        /// Name of a dataflow endpoint.
        /// This member is required.
        public var dataflowEndpointName: Swift.String?
        /// Region of a dataflow endpoint.
        public var dataflowEndpointRegion: Swift.String?

        public init (
            dataflowEndpointName: Swift.String? = nil,
            dataflowEndpointRegion: Swift.String? = nil
        )
        {
            self.dataflowEndpointName = dataflowEndpointName
            self.dataflowEndpointRegion = dataflowEndpointRegion
        }
    }

}

extension GroundStationClientTypes.DataflowEndpointListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointGroupArn = self.dataflowEndpointGroupArn {
            try encodeContainer.encode(dataflowEndpointGroupArn, forKey: .dataflowEndpointGroupArn)
        }
        if let dataflowEndpointGroupId = self.dataflowEndpointGroupId {
            try encodeContainer.encode(dataflowEndpointGroupId, forKey: .dataflowEndpointGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
    }
}

extension GroundStationClientTypes {
    /// Item in a list of DataflowEndpoint groups.
    public struct DataflowEndpointListItem: Swift.Equatable {
        /// ARN of a dataflow endpoint group.
        public var dataflowEndpointGroupArn: Swift.String?
        /// UUID of a dataflow endpoint group.
        public var dataflowEndpointGroupId: Swift.String?

        public init (
            dataflowEndpointGroupArn: Swift.String? = nil,
            dataflowEndpointGroupId: Swift.String? = nil
        )
        {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }
    }

}

extension GroundStationClientTypes.DecodeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = self.unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the decode Config.
    public struct DecodeConfig: Swift.Equatable {
        /// Unvalidated JSON of a decode Config.
        /// This member is required.
        public var unvalidatedJSON: Swift.String?

        public init (
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }

}

extension DeleteConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configType = configType else {
            return nil
        }
        guard let configId = configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

///
public struct DeleteConfigInput: Swift.Equatable {
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigInputBody: Swift.Equatable {
}

extension DeleteConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

///
public struct DeleteConfigOutputResponse: Swift.Equatable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigOutputResponseBody: Swift.Equatable {
    let configId: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configArn: Swift.String?
}

extension DeleteConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

extension DeleteDataflowEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dataflowEndpointGroupId = dataflowEndpointGroupId else {
            return nil
        }
        return "/dataflowEndpointGroup/\(dataflowEndpointGroupId.urlPercentEncoding())"
    }
}

///
public struct DeleteDataflowEndpointGroupInput: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    /// This member is required.
    public var dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupInputBody: Swift.Equatable {
}

extension DeleteDataflowEndpointGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataflowEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDataflowEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataflowEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

///
public struct DeleteDataflowEndpointGroupOutputResponse: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupOutputResponseBody: Swift.Equatable {
    let dataflowEndpointGroupId: Swift.String?
}

extension DeleteDataflowEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

extension DeleteEphemerisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ephemerisId = ephemerisId else {
            return nil
        }
        return "/ephemeris/\(ephemerisId.urlPercentEncoding())"
    }
}

public struct DeleteEphemerisInput: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    /// This member is required.
    public var ephemerisId: Swift.String?

    public init (
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct DeleteEphemerisInputBody: Swift.Equatable {
}

extension DeleteEphemerisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEphemerisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEphemerisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteEphemerisOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEphemerisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteEphemerisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ephemerisId = output.ephemerisId
        } else {
            self.ephemerisId = nil
        }
    }
}

public struct DeleteEphemerisOutputResponse: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?

    public init (
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct DeleteEphemerisOutputResponseBody: Swift.Equatable {
    let ephemerisId: Swift.String?
}

extension DeleteEphemerisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
    }
}

extension DeleteMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let missionProfileId = missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

///
public struct DeleteMissionProfileInput: Swift.Equatable {
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileInputBody: Swift.Equatable {
}

extension DeleteMissionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

///
public struct DeleteMissionProfileOutputResponse: Swift.Equatable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileOutputResponseBody: Swift.Equatable {
    let missionProfileId: Swift.String?
}

extension DeleteMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension GroundStationClientTypes.DemodulationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = self.unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the demodulation Config.
    public struct DemodulationConfig: Swift.Equatable {
        /// Unvalidated JSON of a demodulation Config.
        /// This member is required.
        public var unvalidatedJSON: Swift.String?

        public init (
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }

}

extension DependencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Dependency encountered an error.
public struct DependencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    ///
    public var parameterName: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct DependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension DependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension DescribeContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/\(contactId.urlPercentEncoding())"
    }
}

///
public struct DescribeContactInput: Swift.Equatable {
    /// UUID of a contact.
    /// This member is required.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct DescribeContactInputBody: Swift.Equatable {
}

extension DescribeContactInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeContactOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
            self.contactStatus = output.contactStatus
            self.dataflowList = output.dataflowList
            self.endTime = output.endTime
            self.errorMessage = output.errorMessage
            self.groundStation = output.groundStation
            self.maximumElevation = output.maximumElevation
            self.missionProfileArn = output.missionProfileArn
            self.postPassEndTime = output.postPassEndTime
            self.prePassStartTime = output.prePassStartTime
            self.region = output.region
            self.satelliteArn = output.satelliteArn
            self.startTime = output.startTime
            self.tags = output.tags
        } else {
            self.contactId = nil
            self.contactStatus = nil
            self.dataflowList = nil
            self.endTime = nil
            self.errorMessage = nil
            self.groundStation = nil
            self.maximumElevation = nil
            self.missionProfileArn = nil
            self.postPassEndTime = nil
            self.prePassStartTime = nil
            self.region = nil
            self.satelliteArn = nil
            self.startTime = nil
            self.tags = nil
        }
    }
}

///
public struct DescribeContactOutputResponse: Swift.Equatable {
    /// UUID of a contact.
    public var contactId: Swift.String?
    /// Status of a contact.
    public var contactStatus: GroundStationClientTypes.ContactStatus?
    /// List describing source and destination details for each dataflow edge.
    public var dataflowList: [GroundStationClientTypes.DataflowDetail]?
    /// End time of a contact in UTC.
    public var endTime: ClientRuntime.Date?
    /// Error message for a contact.
    public var errorMessage: Swift.String?
    /// Ground station for a contact.
    public var groundStation: Swift.String?
    /// Maximum elevation angle of a contact.
    public var maximumElevation: GroundStationClientTypes.Elevation?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var postPassEndTime: ClientRuntime.Date?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var prePassStartTime: ClientRuntime.Date?
    /// Region of a contact.
    public var region: Swift.String?
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// Start time of a contact in UTC.
    public var startTime: ClientRuntime.Date?
    /// Tags assigned to a contact.
    public var tags: [Swift.String:Swift.String]?

    public init (
        contactId: Swift.String? = nil,
        contactStatus: GroundStationClientTypes.ContactStatus? = nil,
        dataflowList: [GroundStationClientTypes.DataflowDetail]? = nil,
        endTime: ClientRuntime.Date? = nil,
        errorMessage: Swift.String? = nil,
        groundStation: Swift.String? = nil,
        maximumElevation: GroundStationClientTypes.Elevation? = nil,
        missionProfileArn: Swift.String? = nil,
        postPassEndTime: ClientRuntime.Date? = nil,
        prePassStartTime: ClientRuntime.Date? = nil,
        region: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.contactId = contactId
        self.contactStatus = contactStatus
        self.dataflowList = dataflowList
        self.endTime = endTime
        self.errorMessage = errorMessage
        self.groundStation = groundStation
        self.maximumElevation = maximumElevation
        self.missionProfileArn = missionProfileArn
        self.postPassEndTime = postPassEndTime
        self.prePassStartTime = prePassStartTime
        self.region = region
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct DescribeContactOutputResponseBody: Swift.Equatable {
    let contactId: Swift.String?
    let missionProfileArn: Swift.String?
    let satelliteArn: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let prePassStartTime: ClientRuntime.Date?
    let postPassEndTime: ClientRuntime.Date?
    let groundStation: Swift.String?
    let contactStatus: GroundStationClientTypes.ContactStatus?
    let errorMessage: Swift.String?
    let maximumElevation: GroundStationClientTypes.Elevation?
    let tags: [Swift.String:Swift.String]?
    let region: Swift.String?
    let dataflowList: [GroundStationClientTypes.DataflowDetail]?
}

extension DescribeContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
        case contactStatus
        case dataflowList
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dataflowListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.DataflowDetail?].self, forKey: .dataflowList)
        var dataflowListDecoded0:[GroundStationClientTypes.DataflowDetail]? = nil
        if let dataflowListContainer = dataflowListContainer {
            dataflowListDecoded0 = [GroundStationClientTypes.DataflowDetail]()
            for structure0 in dataflowListContainer {
                if let structure0 = structure0 {
                    dataflowListDecoded0?.append(structure0)
                }
            }
        }
        dataflowList = dataflowListDecoded0
    }
}

extension DescribeEphemerisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ephemerisId = ephemerisId else {
            return nil
        }
        return "/ephemeris/\(ephemerisId.urlPercentEncoding())"
    }
}

public struct DescribeEphemerisInput: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    /// This member is required.
    public var ephemerisId: Swift.String?

    public init (
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct DescribeEphemerisInputBody: Swift.Equatable {
}

extension DescribeEphemerisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEphemerisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEphemerisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEphemerisOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEphemerisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEphemerisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.enabled = output.enabled
            self.ephemerisId = output.ephemerisId
            self.invalidReason = output.invalidReason
            self.name = output.name
            self.priority = output.priority
            self.satelliteId = output.satelliteId
            self.status = output.status
            self.suppliedData = output.suppliedData
            self.tags = output.tags
        } else {
            self.creationTime = nil
            self.enabled = nil
            self.ephemerisId = nil
            self.invalidReason = nil
            self.name = nil
            self.priority = nil
            self.satelliteId = nil
            self.status = nil
            self.suppliedData = nil
            self.tags = nil
        }
    }
}

public struct DescribeEphemerisOutputResponse: Swift.Equatable {
    /// The time the ephemeris was uploaded in UTC.
    public var creationTime: ClientRuntime.Date?
    /// Whether or not the ephemeris is enabled.
    public var enabled: Swift.Bool?
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?
    /// Reason that an ephemeris failed validation. Only provided for ephemerides with INVALID status.
    public var invalidReason: GroundStationClientTypes.EphemerisInvalidReason?
    /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
    public var name: Swift.String?
    /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
    public var priority: Swift.Int?
    /// The AWS Ground Station satellite ID associated with ephemeris.
    public var satelliteId: Swift.String?
    /// The status of the ephemeris.
    public var status: GroundStationClientTypes.EphemerisStatus?
    /// Supplied ephemeris data.
    public var suppliedData: GroundStationClientTypes.EphemerisTypeDescription?
    /// Tags assigned to an ephemeris.
    public var tags: [Swift.String:Swift.String]?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        enabled: Swift.Bool? = nil,
        ephemerisId: Swift.String? = nil,
        invalidReason: GroundStationClientTypes.EphemerisInvalidReason? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        satelliteId: Swift.String? = nil,
        status: GroundStationClientTypes.EphemerisStatus? = nil,
        suppliedData: GroundStationClientTypes.EphemerisTypeDescription? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.creationTime = creationTime
        self.enabled = enabled
        self.ephemerisId = ephemerisId
        self.invalidReason = invalidReason
        self.name = name
        self.priority = priority
        self.satelliteId = satelliteId
        self.status = status
        self.suppliedData = suppliedData
        self.tags = tags
    }
}

struct DescribeEphemerisOutputResponseBody: Swift.Equatable {
    let ephemerisId: Swift.String?
    let satelliteId: Swift.String?
    let status: GroundStationClientTypes.EphemerisStatus?
    let priority: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let enabled: Swift.Bool?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let suppliedData: GroundStationClientTypes.EphemerisTypeDescription?
    let invalidReason: GroundStationClientTypes.EphemerisInvalidReason?
}

extension DescribeEphemerisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case enabled
        case ephemerisId
        case invalidReason
        case name
        case priority
        case satelliteId
        case status
        case suppliedData
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisStatus.self, forKey: .status)
        status = statusDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let suppliedDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisTypeDescription.self, forKey: .suppliedData)
        suppliedData = suppliedDataDecoded
        let invalidReasonDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisInvalidReason.self, forKey: .invalidReason)
        invalidReason = invalidReasonDecoded
    }
}

extension GroundStationClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowDestinationRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = self.configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = self.configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = self.configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowDestinationRegion = self.dataflowDestinationRegion {
            try encodeContainer.encode(dataflowDestinationRegion, forKey: .dataflowDestinationRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowDestinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowDestinationRegion)
        dataflowDestinationRegion = dataflowDestinationRegionDecoded
    }
}

extension GroundStationClientTypes {
    /// Dataflow details for the destination side.
    public struct Destination: Swift.Equatable {
        /// Additional details for a Config, if type is dataflow endpoint or antenna demod decode.
        public var configDetails: GroundStationClientTypes.ConfigDetails?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Region of a dataflow destination.
        public var dataflowDestinationRegion: Swift.String?

        public init (
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowDestinationRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowDestinationRegion = dataflowDestinationRegion
        }
    }

}

extension GroundStationClientTypes.Eirp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = self.units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EirpUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that represents EIRP.
    public struct Eirp: Swift.Equatable {
        /// Units of an EIRP.
        /// This member is required.
        public var units: GroundStationClientTypes.EirpUnits?
        /// Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            units: GroundStationClientTypes.EirpUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes {
    public enum EirpUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dbw
        case sdkUnknown(Swift.String)

        public static var allCases: [EirpUnits] {
            return [
                .dbw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dbw: return "dBW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EirpUnits(rawValue: rawValue) ?? EirpUnits.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.Elevation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AngleUnits.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension GroundStationClientTypes {
    /// Elevation angle of the satellite in the sky during a contact.
    public struct Elevation: Swift.Equatable {
        /// Elevation angle units.
        /// This member is required.
        public var unit: GroundStationClientTypes.AngleUnits?
        /// Elevation angle value.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            unit: GroundStationClientTypes.AngleUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension GroundStationClientTypes.EndpointDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case securityDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let securityDetails = self.securityDetails {
            try encodeContainer.encode(securityDetails, forKey: .securityDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SecurityDetails.self, forKey: .securityDetails)
        securityDetails = securityDetailsDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DataflowEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the endpoint details.
    public struct EndpointDetails: Swift.Equatable {
        /// A dataflow endpoint.
        public var endpoint: GroundStationClientTypes.DataflowEndpoint?
        /// Endpoint security details including a list of subnets, a list of security groups and a role to connect streams to instances.
        public var securityDetails: GroundStationClientTypes.SecurityDetails?

        public init (
            endpoint: GroundStationClientTypes.DataflowEndpoint? = nil,
            securityDetails: GroundStationClientTypes.SecurityDetails? = nil
        )
        {
            self.endpoint = endpoint
            self.securityDetails = securityDetails
        }
    }

}

extension GroundStationClientTypes {
    public enum EndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleted
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .created,
                .creating,
                .deleted,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "created"
            case .creating: return "creating"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .failed: return "failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.EphemerisData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oem
        case sdkUnknown
        case tle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .oem(oem):
                try container.encode(oem, forKey: .oem)
            case let .tle(tle):
                try container.encode(tle, forKey: .tle)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tleDecoded = try values.decodeIfPresent(GroundStationClientTypes.TLEEphemeris.self, forKey: .tle)
        if let tle = tleDecoded {
            self = .tle(tle)
            return
        }
        let oemDecoded = try values.decodeIfPresent(GroundStationClientTypes.OEMEphemeris.self, forKey: .oem)
        if let oem = oemDecoded {
            self = .oem(oem)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// Ephemeris data.
    public enum EphemerisData: Swift.Equatable {
        /// Two-line element set (TLE) ephemeris.
        case tle(GroundStationClientTypes.TLEEphemeris)
        /// Ephemeris data in Orbit Ephemeris Message (OEM) format.
        case oem(GroundStationClientTypes.OEMEphemeris)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.EphemerisDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisData
        case sourceS3Object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ephemerisData = self.ephemerisData {
            try encodeContainer.encode(ephemerisData, forKey: .ephemerisData)
        }
        if let sourceS3Object = self.sourceS3Object {
            try encodeContainer.encode(sourceS3Object, forKey: .sourceS3Object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceS3ObjectDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.S3Object.self, forKey: .sourceS3Object)
        sourceS3Object = sourceS3ObjectDecoded
        let ephemerisDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisData)
        ephemerisData = ephemerisDataDecoded
    }
}

extension GroundStationClientTypes {
    /// Description of ephemeris.
    public struct EphemerisDescription: Swift.Equatable {
        /// Supplied ephemeris data.
        public var ephemerisData: Swift.String?
        /// Source S3 object used for the ephemeris.
        public var sourceS3Object: GroundStationClientTypes.S3Object?

        public init (
            ephemerisData: Swift.String? = nil,
            sourceS3Object: GroundStationClientTypes.S3Object? = nil
        )
        {
            self.ephemerisData = ephemerisData
            self.sourceS3Object = sourceS3Object
        }
    }

}

extension GroundStationClientTypes {
    public enum EphemerisInvalidReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Provided KMS key is invalid
        case kmsKeyInvalid
        /// Provided spacecraft identifiers such as spacecraft NORAD Id are invalid
        case metadataInvalid
        /// Start, end, or expiration time(s) are invalid for the provided ephemeris
        case timeRangeInvalid
        /// Provided ephemeris defines invalid spacecraft trajectory
        case trajectoryInvalid
        /// Internal Service Error occurred while processing ephemeris
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [EphemerisInvalidReason] {
            return [
                .kmsKeyInvalid,
                .metadataInvalid,
                .timeRangeInvalid,
                .trajectoryInvalid,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kmsKeyInvalid: return "KMS_KEY_INVALID"
            case .metadataInvalid: return "METADATA_INVALID"
            case .timeRangeInvalid: return "TIME_RANGE_INVALID"
            case .trajectoryInvalid: return "TRAJECTORY_INVALID"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EphemerisInvalidReason(rawValue: rawValue) ?? EphemerisInvalidReason.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.EphemerisItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case enabled
        case ephemerisId
        case name
        case priority
        case sourceS3Object
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ephemerisId = self.ephemerisId {
            try encodeContainer.encode(ephemerisId, forKey: .ephemerisId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let sourceS3Object = self.sourceS3Object {
            try encodeContainer.encode(sourceS3Object, forKey: .sourceS3Object)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisStatus.self, forKey: .status)
        status = statusDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceS3ObjectDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.S3Object.self, forKey: .sourceS3Object)
        sourceS3Object = sourceS3ObjectDecoded
    }
}

extension GroundStationClientTypes {
    /// Ephemeris item.
    public struct EphemerisItem: Swift.Equatable {
        /// The time the ephemeris was uploaded in UTC.
        public var creationTime: ClientRuntime.Date?
        /// Whether or not the ephemeris is enabled.
        public var enabled: Swift.Bool?
        /// The AWS Ground Station ephemeris ID.
        public var ephemerisId: Swift.String?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public var name: Swift.String?
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public var priority: Swift.Int?
        /// Source S3 object used for the ephemeris.
        public var sourceS3Object: GroundStationClientTypes.S3Object?
        /// The status of the ephemeris.
        public var status: GroundStationClientTypes.EphemerisStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            enabled: Swift.Bool? = nil,
            ephemerisId: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sourceS3Object: GroundStationClientTypes.S3Object? = nil,
            status: GroundStationClientTypes.EphemerisStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.enabled = enabled
            self.ephemerisId = ephemerisId
            self.name = name
            self.priority = priority
            self.sourceS3Object = sourceS3Object
            self.status = status
        }
    }

}

extension GroundStationClientTypes.EphemerisMetaData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisId
        case epoch
        case name
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ephemerisId = self.ephemerisId {
            try encodeContainer.encode(ephemerisId, forKey: .ephemerisId)
        }
        if let epoch = self.epoch {
            try encodeContainer.encodeTimestamp(epoch, format: .epochSeconds, forKey: .epoch)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisSource.self, forKey: .source)
        source = sourceDecoded
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
        let epochDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .epoch)
        epoch = epochDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes {
    /// Metadata describing a particular ephemeris.
    public struct EphemerisMetaData: Swift.Equatable {
        /// UUID of a customer-provided ephemeris. This field is not populated for default ephemerides from Space Track.
        public var ephemerisId: Swift.String?
        /// The epoch of a default, ephemeris from Space Track in UTC. This field is not populated for customer-provided ephemerides.
        public var epoch: ClientRuntime.Date?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris. A name is only returned for customer-provider ephemerides that have a name associated.
        public var name: Swift.String?
        /// The EphemerisSource that generated a given ephemeris.
        /// This member is required.
        public var source: GroundStationClientTypes.EphemerisSource?

        public init (
            ephemerisId: Swift.String? = nil,
            epoch: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            source: GroundStationClientTypes.EphemerisSource? = nil
        )
        {
            self.ephemerisId = ephemerisId
            self.epoch = epoch
            self.name = name
            self.source = source
        }
    }

}

extension GroundStationClientTypes {
    public enum EphemerisSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerProvided
        case spaceTrack
        case sdkUnknown(Swift.String)

        public static var allCases: [EphemerisSource] {
            return [
                .customerProvided,
                .spaceTrack,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerProvided: return "CUSTOMER_PROVIDED"
            case .spaceTrack: return "SPACE_TRACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EphemerisSource(rawValue: rawValue) ?? EphemerisSource.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes {
    public enum EphemerisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case error
        case expired
        case invalid
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [EphemerisStatus] {
            return [
                .disabled,
                .enabled,
                .error,
                .expired,
                .invalid,
                .validating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .error: return "ERROR"
            case .expired: return "EXPIRED"
            case .invalid: return "INVALID"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EphemerisStatus(rawValue: rawValue) ?? EphemerisStatus.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.EphemerisTypeDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oem
        case sdkUnknown
        case tle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .oem(oem):
                try container.encode(oem, forKey: .oem)
            case let .tle(tle):
                try container.encode(tle, forKey: .tle)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tleDecoded = try values.decodeIfPresent(GroundStationClientTypes.EphemerisDescription.self, forKey: .tle)
        if let tle = tleDecoded {
            self = .tle(tle)
            return
        }
        let oemDecoded = try values.decodeIfPresent(GroundStationClientTypes.EphemerisDescription.self, forKey: .oem)
        if let oem = oemDecoded {
            self = .oem(oem)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    ///
    public enum EphemerisTypeDescription: Swift.Equatable {
        /// Description of ephemeris.
        case tle(GroundStationClientTypes.EphemerisDescription)
        /// Description of ephemeris.
        case oem(GroundStationClientTypes.EphemerisDescription)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.Frequency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = self.units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.FrequencyUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that describes the frequency.
    public struct Frequency: Swift.Equatable {
        /// Frequency units.
        /// This member is required.
        public var units: GroundStationClientTypes.FrequencyUnits?
        /// Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            units: GroundStationClientTypes.FrequencyUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes.FrequencyBandwidth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = self.units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.BandwidthUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that describes the frequency bandwidth.
    public struct FrequencyBandwidth: Swift.Equatable {
        /// Frequency bandwidth units.
        /// This member is required.
        public var units: GroundStationClientTypes.BandwidthUnits?
        /// Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:
        ///
        /// * For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.
        ///
        /// * For AntennaDownlinkconfig, valid values are between 10 kHz to 54 MHz.
        ///
        /// * For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        /// This member is required.
        public var value: Swift.Double?

        public init (
            units: GroundStationClientTypes.BandwidthUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes {
    public enum FrequencyUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [FrequencyUnits] {
            return [
                .ghz,
                .khz,
                .mhz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrequencyUnits(rawValue: rawValue) ?? FrequencyUnits.sdkUnknown(rawValue)
        }
    }
}

extension GetConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configType = configType else {
            return nil
        }
        guard let configId = configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

///
public struct GetConfigInput: Swift.Equatable {
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct GetConfigInputBody: Swift.Equatable {
}

extension GetConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configData = output.configData
            self.configId = output.configId
            self.configType = output.configType
            self.name = output.name
            self.tags = output.tags
        } else {
            self.configArn = nil
            self.configData = nil
            self.configId = nil
            self.configType = nil
            self.name = nil
            self.tags = nil
        }
    }
}

///
public struct GetConfigOutputResponse: Swift.Equatable {
    /// ARN of a Config
    /// This member is required.
    public var configArn: Swift.String?
    /// Data elements in a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a Config.
    public var tags: [Swift.String:Swift.String]?

    public init (
        configArn: Swift.String? = nil,
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configArn = configArn
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
        self.tags = tags
    }
}

struct GetConfigOutputResponseBody: Swift.Equatable {
    let configId: Swift.String?
    let configArn: Swift.String?
    let name: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configData: GroundStationClientTypes.ConfigTypeData?
    let tags: [Swift.String:Swift.String]?
}

extension GetConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configData
        case configId
        case configType
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetDataflowEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dataflowEndpointGroupId = dataflowEndpointGroupId else {
            return nil
        }
        return "/dataflowEndpointGroup/\(dataflowEndpointGroupId.urlPercentEncoding())"
    }
}

///
public struct GetDataflowEndpointGroupInput: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    /// This member is required.
    public var dataflowEndpointGroupId: Swift.String?

    public init (
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct GetDataflowEndpointGroupInputBody: Swift.Equatable {
}

extension GetDataflowEndpointGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataflowEndpointGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDataflowEndpointGroupOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataflowEndpointGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDataflowEndpointGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupArn = output.dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
            self.endpointsDetails = output.endpointsDetails
            self.tags = output.tags
        } else {
            self.dataflowEndpointGroupArn = nil
            self.dataflowEndpointGroupId = nil
            self.endpointsDetails = nil
            self.tags = nil
        }
    }
}

///
public struct GetDataflowEndpointGroupOutputResponse: Swift.Equatable {
    /// ARN of a dataflow endpoint group.
    public var dataflowEndpointGroupArn: Swift.String?
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?
    /// Details of a dataflow endpoint.
    public var endpointsDetails: [GroundStationClientTypes.EndpointDetails]?
    /// Tags assigned to a dataflow endpoint group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        dataflowEndpointGroupArn: Swift.String? = nil,
        dataflowEndpointGroupId: Swift.String? = nil,
        endpointsDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
        self.endpointsDetails = endpointsDetails
        self.tags = tags
    }
}

struct GetDataflowEndpointGroupOutputResponseBody: Swift.Equatable {
    let dataflowEndpointGroupId: Swift.String?
    let dataflowEndpointGroupArn: Swift.String?
    let endpointsDetails: [GroundStationClientTypes.EndpointDetails]?
    let tags: [Swift.String:Swift.String]?
}

extension GetDataflowEndpointGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
        case endpointsDetails
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
        let endpointsDetailsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EndpointDetails?].self, forKey: .endpointsDetails)
        var endpointsDetailsDecoded0:[GroundStationClientTypes.EndpointDetails]? = nil
        if let endpointsDetailsContainer = endpointsDetailsContainer {
            endpointsDetailsDecoded0 = [GroundStationClientTypes.EndpointDetails]()
            for structure0 in endpointsDetailsContainer {
                if let structure0 = structure0 {
                    endpointsDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointsDetails = endpointsDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetMinuteUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case month
        case year
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let month = self.month {
            try encodeContainer.encode(month, forKey: .month)
        }
        if let year = self.year {
            try encodeContainer.encode(year, forKey: .year)
        }
    }
}

extension GetMinuteUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/minute-usage"
    }
}

///
public struct GetMinuteUsageInput: Swift.Equatable {
    /// The month being requested, with a value of 1-12.
    /// This member is required.
    public var month: Swift.Int?
    /// The year being requested, in the format of YYYY.
    /// This member is required.
    public var year: Swift.Int?

    public init (
        month: Swift.Int? = nil,
        year: Swift.Int? = nil
    )
    {
        self.month = month
        self.year = year
    }
}

struct GetMinuteUsageInputBody: Swift.Equatable {
    let month: Swift.Int?
    let year: Swift.Int?
}

extension GetMinuteUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case month
        case year
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .month)
        month = monthDecoded
        let yearDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .year)
        year = yearDecoded
    }
}

extension GetMinuteUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMinuteUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMinuteUsageOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMinuteUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMinuteUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.estimatedMinutesRemaining = output.estimatedMinutesRemaining
            self.isReservedMinutesCustomer = output.isReservedMinutesCustomer
            self.totalReservedMinuteAllocation = output.totalReservedMinuteAllocation
            self.totalScheduledMinutes = output.totalScheduledMinutes
            self.upcomingMinutesScheduled = output.upcomingMinutesScheduled
        } else {
            self.estimatedMinutesRemaining = nil
            self.isReservedMinutesCustomer = nil
            self.totalReservedMinuteAllocation = nil
            self.totalScheduledMinutes = nil
            self.upcomingMinutesScheduled = nil
        }
    }
}

///
public struct GetMinuteUsageOutputResponse: Swift.Equatable {
    /// Estimated number of minutes remaining for an account, specific to the month being requested.
    public var estimatedMinutesRemaining: Swift.Int?
    /// Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.
    public var isReservedMinutesCustomer: Swift.Bool?
    /// Total number of reserved minutes allocated, specific to the month being requested.
    public var totalReservedMinuteAllocation: Swift.Int?
    /// Total scheduled minutes for an account, specific to the month being requested.
    public var totalScheduledMinutes: Swift.Int?
    /// Upcoming minutes scheduled for an account, specific to the month being requested.
    public var upcomingMinutesScheduled: Swift.Int?

    public init (
        estimatedMinutesRemaining: Swift.Int? = nil,
        isReservedMinutesCustomer: Swift.Bool? = nil,
        totalReservedMinuteAllocation: Swift.Int? = nil,
        totalScheduledMinutes: Swift.Int? = nil,
        upcomingMinutesScheduled: Swift.Int? = nil
    )
    {
        self.estimatedMinutesRemaining = estimatedMinutesRemaining
        self.isReservedMinutesCustomer = isReservedMinutesCustomer
        self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
        self.totalScheduledMinutes = totalScheduledMinutes
        self.upcomingMinutesScheduled = upcomingMinutesScheduled
    }
}

struct GetMinuteUsageOutputResponseBody: Swift.Equatable {
    let isReservedMinutesCustomer: Swift.Bool?
    let totalReservedMinuteAllocation: Swift.Int?
    let upcomingMinutesScheduled: Swift.Int?
    let totalScheduledMinutes: Swift.Int?
    let estimatedMinutesRemaining: Swift.Int?
}

extension GetMinuteUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMinutesRemaining
        case isReservedMinutesCustomer
        case totalReservedMinuteAllocation
        case totalScheduledMinutes
        case upcomingMinutesScheduled
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isReservedMinutesCustomerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isReservedMinutesCustomer)
        isReservedMinutesCustomer = isReservedMinutesCustomerDecoded
        let totalReservedMinuteAllocationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalReservedMinuteAllocation)
        totalReservedMinuteAllocation = totalReservedMinuteAllocationDecoded
        let upcomingMinutesScheduledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .upcomingMinutesScheduled)
        upcomingMinutesScheduled = upcomingMinutesScheduledDecoded
        let totalScheduledMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalScheduledMinutes)
        totalScheduledMinutes = totalScheduledMinutesDecoded
        let estimatedMinutesRemainingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedMinutesRemaining)
        estimatedMinutesRemaining = estimatedMinutesRemainingDecoded
    }
}

extension GetMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let missionProfileId = missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

///
public struct GetMissionProfileInput: Swift.Equatable {
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct GetMissionProfileInputBody: Swift.Equatable {
}

extension GetMissionProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactPostPassDurationSeconds = output.contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = output.contactPrePassDurationSeconds
            self.dataflowEdges = output.dataflowEdges
            self.minimumViableContactDurationSeconds = output.minimumViableContactDurationSeconds
            self.missionProfileArn = output.missionProfileArn
            self.missionProfileId = output.missionProfileId
            self.name = output.name
            self.region = output.region
            self.tags = output.tags
            self.trackingConfigArn = output.trackingConfigArn
        } else {
            self.contactPostPassDurationSeconds = nil
            self.contactPrePassDurationSeconds = nil
            self.dataflowEdges = nil
            self.minimumViableContactDurationSeconds = nil
            self.missionProfileArn = nil
            self.missionProfileId = nil
            self.name = nil
            self.region = nil
            self.tags = nil
            self.trackingConfigArn = nil
        }
    }
}

///
public struct GetMissionProfileOutputResponse: Swift.Equatable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?
    /// Name of a mission profile.
    public var name: Swift.String?
    /// Region of a mission profile.
    public var region: Swift.String?
    /// Tags assigned to a mission profile.
    public var tags: [Swift.String:Swift.String]?
    /// ARN of a tracking Config.
    public var trackingConfigArn: Swift.String?

    public init (
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileArn = missionProfileArn
        self.missionProfileId = missionProfileId
        self.name = name
        self.region = region
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct GetMissionProfileOutputResponseBody: Swift.Equatable {
    let missionProfileId: Swift.String?
    let missionProfileArn: Swift.String?
    let name: Swift.String?
    let region: Swift.String?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
    let minimumViableContactDurationSeconds: Swift.Int?
    let dataflowEdges: [[Swift.String]]?
    let trackingConfigArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case missionProfileArn
        case missionProfileId
        case name
        case region
        case tags
        case trackingConfigArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSatelliteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let satelliteId = satelliteId else {
            return nil
        }
        return "/satellite/\(satelliteId.urlPercentEncoding())"
    }
}

///
public struct GetSatelliteInput: Swift.Equatable {
    /// UUID of a satellite.
    /// This member is required.
    public var satelliteId: Swift.String?

    public init (
        satelliteId: Swift.String? = nil
    )
    {
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteInputBody: Swift.Equatable {
}

extension GetSatelliteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSatelliteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSatelliteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSatelliteOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSatelliteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSatelliteOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.currentEphemeris = output.currentEphemeris
            self.groundStations = output.groundStations
            self.noradSatelliteID = output.noradSatelliteID
            self.satelliteArn = output.satelliteArn
            self.satelliteId = output.satelliteId
        } else {
            self.currentEphemeris = nil
            self.groundStations = nil
            self.noradSatelliteID = 0
            self.satelliteArn = nil
            self.satelliteId = nil
        }
    }
}

///
public struct GetSatelliteOutputResponse: Swift.Equatable {
    /// The current ephemeris being used to compute the trajectory of the satellite.
    public var currentEphemeris: GroundStationClientTypes.EphemerisMetaData?
    /// A list of ground stations to which the satellite is on-boarded.
    public var groundStations: [Swift.String]?
    /// NORAD satellite ID number.
    public var noradSatelliteID: Swift.Int
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// UUID of a satellite.
    public var satelliteId: Swift.String?

    public init (
        currentEphemeris: GroundStationClientTypes.EphemerisMetaData? = nil,
        groundStations: [Swift.String]? = nil,
        noradSatelliteID: Swift.Int = 0,
        satelliteArn: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.currentEphemeris = currentEphemeris
        self.groundStations = groundStations
        self.noradSatelliteID = noradSatelliteID
        self.satelliteArn = satelliteArn
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteOutputResponseBody: Swift.Equatable {
    let satelliteId: Swift.String?
    let satelliteArn: Swift.String?
    let noradSatelliteID: Swift.Int
    let groundStations: [Swift.String]?
    let currentEphemeris: GroundStationClientTypes.EphemerisMetaData?
}

extension GetSatelliteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentEphemeris
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noradSatelliteID) ?? 0
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[Swift.String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [Swift.String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
        let currentEphemerisDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisMetaData.self, forKey: .currentEphemeris)
        currentEphemeris = currentEphemerisDecoded
    }
}

extension GroundStationClientTypes.GroundStationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStationId
        case groundStationName
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundStationId = self.groundStationId {
            try encodeContainer.encode(groundStationId, forKey: .groundStationId)
        }
        if let groundStationName = self.groundStationName {
            try encodeContainer.encode(groundStationName, forKey: .groundStationName)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groundStationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStationId)
        groundStationId = groundStationIdDecoded
        let groundStationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStationName)
        groundStationName = groundStationNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the ground station data.
    public struct GroundStationData: Swift.Equatable {
        /// UUID of a ground station.
        public var groundStationId: Swift.String?
        /// Name of a ground station.
        public var groundStationName: Swift.String?
        /// Ground station Region.
        public var region: Swift.String?

        public init (
            groundStationId: Swift.String? = nil,
            groundStationName: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.groundStationId = groundStationId
            self.groundStationName = groundStationName
            self.region = region
        }
    }

}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters are not valid.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    ///
    public var parameterName: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension ListConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/config"
    }
}

///
public struct ListConfigsInput: Swift.Equatable {
    /// Maximum number of Configs returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListConfigs call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigsInputBody: Swift.Equatable {
}

extension ListConfigsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConfigsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configList = output.configList
            self.nextToken = output.nextToken
        } else {
            self.configList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListConfigsOutputResponse: Swift.Equatable {
    /// List of Config items.
    public var configList: [GroundStationClientTypes.ConfigListItem]?
    /// Next token returned in the response of a previous ListConfigs call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        configList: [GroundStationClientTypes.ConfigListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configList = configList
        self.nextToken = nextToken
    }
}

struct ListConfigsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let configList: [GroundStationClientTypes.ConfigListItem]?
}

extension ListConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let configListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ConfigListItem?].self, forKey: .configList)
        var configListDecoded0:[GroundStationClientTypes.ConfigListItem]? = nil
        if let configListContainer = configListContainer {
            configListDecoded0 = [GroundStationClientTypes.ConfigListItem]()
            for structure0 in configListContainer {
                if let structure0 = structure0 {
                    configListDecoded0?.append(structure0)
                }
            }
        }
        configList = configListDecoded0
    }
}

extension ListContactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let groundStation = self.groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let missionProfileArn = self.missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let satelliteArn = self.satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statusList = statusList {
            var statusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusList)
            for contactstatus0 in statusList {
                try statusListContainer.encode(contactstatus0.rawValue)
            }
        }
    }
}

extension ListContactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contacts"
    }
}

///
public struct ListContactsInput: Swift.Equatable {
    /// End time of a contact in UTC.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Name of a ground station.
    public var groundStation: Swift.String?
    /// Maximum number of contacts returned.
    public var maxResults: Swift.Int?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// Next token returned in the request of a previous ListContacts call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// Start time of a contact in UTC.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// Status of a contact reservation.
    /// This member is required.
    public var statusList: [GroundStationClientTypes.ContactStatus]?

    public init (
        endTime: ClientRuntime.Date? = nil,
        groundStation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        statusList: [GroundStationClientTypes.ContactStatus]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.maxResults = maxResults
        self.missionProfileArn = missionProfileArn
        self.nextToken = nextToken
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.statusList = statusList
    }
}

struct ListContactsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let statusList: [GroundStationClientTypes.ContactStatus]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let groundStation: Swift.String?
    let satelliteArn: Swift.String?
    let missionProfileArn: Swift.String?
}

extension ListContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ContactStatus?].self, forKey: .statusList)
        var statusListDecoded0:[GroundStationClientTypes.ContactStatus]? = nil
        if let statusListContainer = statusListContainer {
            statusListDecoded0 = [GroundStationClientTypes.ContactStatus]()
            for string0 in statusListContainer {
                if let string0 = string0 {
                    statusListDecoded0?.append(string0)
                }
            }
        }
        statusList = statusListDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
    }
}

extension ListContactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListContactsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListContactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactList = output.contactList
            self.nextToken = output.nextToken
        } else {
            self.contactList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListContactsOutputResponse: Swift.Equatable {
    /// List of contacts.
    public var contactList: [GroundStationClientTypes.ContactData]?
    /// Next token returned in the response of a previous ListContacts call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        contactList: [GroundStationClientTypes.ContactData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactList = contactList
        self.nextToken = nextToken
    }
}

struct ListContactsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let contactList: [GroundStationClientTypes.ContactData]?
}

extension ListContactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ContactData?].self, forKey: .contactList)
        var contactListDecoded0:[GroundStationClientTypes.ContactData]? = nil
        if let contactListContainer = contactListContainer {
            contactListDecoded0 = [GroundStationClientTypes.ContactData]()
            for structure0 in contactListContainer {
                if let structure0 = structure0 {
                    contactListDecoded0?.append(structure0)
                }
            }
        }
        contactList = contactListDecoded0
    }
}

extension ListDataflowEndpointGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListDataflowEndpointGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataflowEndpointGroup"
    }
}

///
public struct ListDataflowEndpointGroupsInput: Swift.Equatable {
    /// Maximum number of dataflow endpoint groups returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsInputBody: Swift.Equatable {
}

extension ListDataflowEndpointGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataflowEndpointGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataflowEndpointGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDataflowEndpointGroupsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataflowEndpointGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDataflowEndpointGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupList = output.dataflowEndpointGroupList
            self.nextToken = output.nextToken
        } else {
            self.dataflowEndpointGroupList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListDataflowEndpointGroupsOutputResponse: Swift.Equatable {
    /// A list of dataflow endpoint groups.
    public var dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]?
    /// Next token returned in the response of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupList = dataflowEndpointGroupList
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]?
}

extension ListDataflowEndpointGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dataflowEndpointGroupListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.DataflowEndpointListItem?].self, forKey: .dataflowEndpointGroupList)
        var dataflowEndpointGroupListDecoded0:[GroundStationClientTypes.DataflowEndpointListItem]? = nil
        if let dataflowEndpointGroupListContainer = dataflowEndpointGroupListContainer {
            dataflowEndpointGroupListDecoded0 = [GroundStationClientTypes.DataflowEndpointListItem]()
            for structure0 in dataflowEndpointGroupListContainer {
                if let structure0 = structure0 {
                    dataflowEndpointGroupListDecoded0?.append(structure0)
                }
            }
        }
        dataflowEndpointGroupList = dataflowEndpointGroupListDecoded0
    }
}

extension ListEphemeridesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case satelliteId
        case startTime
        case statusList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let satelliteId = self.satelliteId {
            try encodeContainer.encode(satelliteId, forKey: .satelliteId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statusList = statusList {
            var statusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusList)
            for ephemerisstatus0 in statusList {
                try statusListContainer.encode(ephemerisstatus0.rawValue)
            }
        }
    }
}

extension ListEphemeridesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListEphemeridesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ephemerides"
    }
}

public struct ListEphemeridesInput: Swift.Equatable {
    /// The end time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Maximum number of ephemerides to return.
    public var maxResults: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The AWS Ground Station satellite ID to list ephemeris for.
    /// This member is required.
    public var satelliteId: Swift.String?
    /// The start time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The list of ephemeris status to return.
    public var statusList: [GroundStationClientTypes.EphemerisStatus]?

    public init (
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        satelliteId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        statusList: [GroundStationClientTypes.EphemerisStatus]? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.satelliteId = satelliteId
        self.startTime = startTime
        self.statusList = statusList
    }
}

struct ListEphemeridesInputBody: Swift.Equatable {
    let satelliteId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let statusList: [GroundStationClientTypes.EphemerisStatus]?
}

extension ListEphemeridesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case satelliteId
        case startTime
        case statusList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EphemerisStatus?].self, forKey: .statusList)
        var statusListDecoded0:[GroundStationClientTypes.EphemerisStatus]? = nil
        if let statusListContainer = statusListContainer {
            statusListDecoded0 = [GroundStationClientTypes.EphemerisStatus]()
            for string0 in statusListContainer {
                if let string0 = string0 {
                    statusListDecoded0?.append(string0)
                }
            }
        }
        statusList = statusListDecoded0
    }
}

extension ListEphemeridesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEphemeridesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEphemeridesOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEphemeridesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEphemeridesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ephemerides = output.ephemerides
            self.nextToken = output.nextToken
        } else {
            self.ephemerides = nil
            self.nextToken = nil
        }
    }
}

public struct ListEphemeridesOutputResponse: Swift.Equatable {
    /// List of ephemerides.
    public var ephemerides: [GroundStationClientTypes.EphemerisItem]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init (
        ephemerides: [GroundStationClientTypes.EphemerisItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ephemerides = ephemerides
        self.nextToken = nextToken
    }
}

struct ListEphemeridesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let ephemerides: [GroundStationClientTypes.EphemerisItem]?
}

extension ListEphemeridesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerides
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let ephemeridesContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EphemerisItem?].self, forKey: .ephemerides)
        var ephemeridesDecoded0:[GroundStationClientTypes.EphemerisItem]? = nil
        if let ephemeridesContainer = ephemeridesContainer {
            ephemeridesDecoded0 = [GroundStationClientTypes.EphemerisItem]()
            for structure0 in ephemeridesContainer {
                if let structure0 = structure0 {
                    ephemeridesDecoded0?.append(structure0)
                }
            }
        }
        ephemerides = ephemeridesDecoded0
    }
}

extension ListGroundStationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let satelliteId = satelliteId {
                let satelliteIdQueryItem = ClientRuntime.URLQueryItem(name: "satelliteId".urlPercentEncoding(), value: Swift.String(satelliteId).urlPercentEncoding())
                items.append(satelliteIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListGroundStationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/groundstation"
    }
}

///
public struct ListGroundStationsInput: Swift.Equatable {
    /// Maximum number of ground stations returned.
    public var maxResults: Swift.Int?
    /// Next token that can be supplied in the next call to get the next page of ground stations.
    public var nextToken: Swift.String?
    /// Satellite ID to retrieve on-boarded ground stations.
    public var satelliteId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.satelliteId = satelliteId
    }
}

struct ListGroundStationsInputBody: Swift.Equatable {
}

extension ListGroundStationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGroundStationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroundStationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGroundStationsOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroundStationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGroundStationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groundStationList = output.groundStationList
            self.nextToken = output.nextToken
        } else {
            self.groundStationList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListGroundStationsOutputResponse: Swift.Equatable {
    /// List of ground stations.
    public var groundStationList: [GroundStationClientTypes.GroundStationData]?
    /// Next token that can be supplied in the next call to get the next page of ground stations.
    public var nextToken: Swift.String?

    public init (
        groundStationList: [GroundStationClientTypes.GroundStationData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groundStationList = groundStationList
        self.nextToken = nextToken
    }
}

struct ListGroundStationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let groundStationList: [GroundStationClientTypes.GroundStationData]?
}

extension ListGroundStationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStationList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let groundStationListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.GroundStationData?].self, forKey: .groundStationList)
        var groundStationListDecoded0:[GroundStationClientTypes.GroundStationData]? = nil
        if let groundStationListContainer = groundStationListContainer {
            groundStationListDecoded0 = [GroundStationClientTypes.GroundStationData]()
            for structure0 in groundStationListContainer {
                if let structure0 = structure0 {
                    groundStationListDecoded0?.append(structure0)
                }
            }
        }
        groundStationList = groundStationListDecoded0
    }
}

extension ListMissionProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListMissionProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/missionprofile"
    }
}

///
public struct ListMissionProfilesInput: Swift.Equatable {
    /// Maximum number of mission profiles returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListMissionProfiles call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesInputBody: Swift.Equatable {
}

extension ListMissionProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMissionProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMissionProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMissionProfilesOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMissionProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMissionProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileList = output.missionProfileList
            self.nextToken = output.nextToken
        } else {
            self.missionProfileList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListMissionProfilesOutputResponse: Swift.Equatable {
    /// List of mission profiles.
    public var missionProfileList: [GroundStationClientTypes.MissionProfileListItem]?
    /// Next token returned in the response of a previous ListMissionProfiles call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        missionProfileList: [GroundStationClientTypes.MissionProfileListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.missionProfileList = missionProfileList
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let missionProfileList: [GroundStationClientTypes.MissionProfileListItem]?
}

extension ListMissionProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileList
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let missionProfileListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.MissionProfileListItem?].self, forKey: .missionProfileList)
        var missionProfileListDecoded0:[GroundStationClientTypes.MissionProfileListItem]? = nil
        if let missionProfileListContainer = missionProfileListContainer {
            missionProfileListDecoded0 = [GroundStationClientTypes.MissionProfileListItem]()
            for structure0 in missionProfileListContainer {
                if let structure0 = structure0 {
                    missionProfileListDecoded0?.append(structure0)
                }
            }
        }
        missionProfileList = missionProfileListDecoded0
    }
}

extension ListSatellitesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSatellitesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/satellite"
    }
}

///
public struct ListSatellitesInput: Swift.Equatable {
    /// Maximum number of satellites returned.
    public var maxResults: Swift.Int?
    /// Next token that can be supplied in the next call to get the next page of satellites.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSatellitesInputBody: Swift.Equatable {
}

extension ListSatellitesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSatellitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSatellitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSatellitesOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSatellitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSatellitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.satellites = output.satellites
        } else {
            self.nextToken = nil
            self.satellites = nil
        }
    }
}

///
public struct ListSatellitesOutputResponse: Swift.Equatable {
    /// Next token that can be supplied in the next call to get the next page of satellites.
    public var nextToken: Swift.String?
    /// List of satellites.
    public var satellites: [GroundStationClientTypes.SatelliteListItem]?

    public init (
        nextToken: Swift.String? = nil,
        satellites: [GroundStationClientTypes.SatelliteListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.satellites = satellites
    }
}

struct ListSatellitesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let satellites: [GroundStationClientTypes.SatelliteListItem]?
}

extension ListSatellitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case satellites
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let satellitesContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.SatelliteListItem?].self, forKey: .satellites)
        var satellitesDecoded0:[GroundStationClientTypes.SatelliteListItem]? = nil
        if let satellitesContainer = satellitesContainer {
            satellitesDecoded0 = [GroundStationClientTypes.SatelliteListItem]()
            for structure0 in satellitesContainer {
                if let structure0 = structure0 {
                    satellitesDecoded0?.append(structure0)
                }
            }
        }
        satellites = satellitesDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct ListTagsForResourceInput: Swift.Equatable {
    /// ARN of a resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

///
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Tags assigned to a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GroundStationClientTypes.MissionProfileListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileArn
        case missionProfileId
        case name
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let missionProfileArn = self.missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let missionProfileId = self.missionProfileId {
            try encodeContainer.encode(missionProfileId, forKey: .missionProfileId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes {
    /// Item in a list of mission profiles.
    public struct MissionProfileListItem: Swift.Equatable {
        /// ARN of a mission profile.
        public var missionProfileArn: Swift.String?
        /// UUID of a mission profile.
        public var missionProfileId: Swift.String?
        /// Name of a mission profile.
        public var name: Swift.String?
        /// Region of a mission profile.
        public var region: Swift.String?

        public init (
            missionProfileArn: Swift.String? = nil,
            missionProfileId: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
        }
    }

}

extension GroundStationClientTypes.OEMEphemeris: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oemData
        case s3Object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oemData = self.oemData {
            try encodeContainer.encode(oemData, forKey: .oemData)
        }
        if let s3Object = self.s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
        let oemDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oemData)
        oemData = oemDataDecoded
    }
}

extension GroundStationClientTypes {
    /// Ephemeris data in Orbit Ephemeris Message (OEM) format.
    public struct OEMEphemeris: Swift.Equatable {
        /// The data for an OEM ephemeris, supplied directly in the request rather than through an S3 object.
        public var oemData: Swift.String?
        /// Identifies the S3 object to be used as the ephemeris.
        public var s3Object: GroundStationClientTypes.S3Object?

        public init (
            oemData: Swift.String? = nil,
            s3Object: GroundStationClientTypes.S3Object? = nil
        )
        {
            self.oemData = oemData
            self.s3Object = s3Object
        }
    }

}

extension GroundStationClientTypes {
    public enum Polarization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case leftHand
        case `none`
        case rightHand
        case sdkUnknown(Swift.String)

        public static var allCases: [Polarization] {
            return [
                .leftHand,
                .none,
                .rightHand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .leftHand: return "LEFT_HAND"
            case .none: return "NONE"
            case .rightHand: return "RIGHT_HAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Polarization(rawValue: rawValue) ?? Polarization.sdkUnknown(rawValue)
        }
    }
}

extension ReserveContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let groundStation = self.groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let missionProfileArn = self.missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let satelliteArn = self.satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ReserveContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact"
    }
}

///
public struct ReserveContactInput: Swift.Equatable {
    /// End time of a contact in UTC.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Name of a ground station.
    /// This member is required.
    public var groundStation: Swift.String?
    /// ARN of a mission profile.
    /// This member is required.
    public var missionProfileArn: Swift.String?
    /// ARN of a satellite
    /// This member is required.
    public var satelliteArn: Swift.String?
    /// Start time of a contact in UTC.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// Tags assigned to a contact.
    public var tags: [Swift.String:Swift.String]?

    public init (
        endTime: ClientRuntime.Date? = nil,
        groundStation: Swift.String? = nil,
        missionProfileArn: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.missionProfileArn = missionProfileArn
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct ReserveContactInputBody: Swift.Equatable {
    let missionProfileArn: Swift.String?
    let satelliteArn: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let groundStation: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ReserveContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ReserveContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReserveContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ReserveContactOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReserveContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReserveContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

///
public struct ReserveContactOutputResponse: Swift.Equatable {
    /// UUID of a contact.
    public var contactId: Swift.String?

    public init (
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct ReserveContactOutputResponseBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension ReserveContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameterName = output.parameterName
        } else {
            self.message = nil
            self.parameterName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Account limits for this resource have been exceeded.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    ///
    public var parameterName: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.message = message
        self.parameterName = parameterName
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GroundStationClientTypes.S3Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GroundStationClientTypes {
    /// Object stored in S3 containing ephemeris data.
    public struct S3Object: Swift.Equatable {
        /// An Amazon S3 Bucket name.
        public var bucket: Swift.String?
        /// An Amazon S3 key for the ephemeris.
        public var key: Swift.String?
        /// For versioned S3 objects, the version to use for the ephemeris.
        public var version: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.version = version
        }
    }

}

extension GroundStationClientTypes.S3RecordingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case `prefix` = "prefix"
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about an S3 recording Config.
    public struct S3RecordingConfig: Swift.Equatable {
        /// ARN of the bucket to record to.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// S3 Key prefix to prefice data files.
        public var `prefix`: Swift.String?
        /// ARN of the role Ground Station assumes to write data to the bucket.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            bucketArn: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.`prefix` = `prefix`
            self.roleArn = roleArn
        }
    }

}

extension GroundStationClientTypes.S3RecordingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case keyTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let keyTemplate = self.keyTemplate {
            try encodeContainer.encode(keyTemplate, forKey: .keyTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let keyTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyTemplate)
        keyTemplate = keyTemplateDecoded
    }
}

extension GroundStationClientTypes {
    /// Details about an S3 recording Config used in a contact.
    public struct S3RecordingDetails: Swift.Equatable {
        /// ARN of the bucket used.
        public var bucketArn: Swift.String?
        /// Key template used for the S3 Recording Configuration
        public var keyTemplate: Swift.String?

        public init (
            bucketArn: Swift.String? = nil,
            keyTemplate: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.keyTemplate = keyTemplate
        }
    }

}

extension GroundStationClientTypes.SatelliteListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentEphemeris
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentEphemeris = self.currentEphemeris {
            try encodeContainer.encode(currentEphemeris, forKey: .currentEphemeris)
        }
        if let groundStations = groundStations {
            var groundStationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groundStations)
            for groundstationname0 in groundStations {
                try groundStationsContainer.encode(groundstationname0)
            }
        }
        if noradSatelliteID != 0 {
            try encodeContainer.encode(noradSatelliteID, forKey: .noradSatelliteID)
        }
        if let satelliteArn = self.satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let satelliteId = self.satelliteId {
            try encodeContainer.encode(satelliteId, forKey: .satelliteId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noradSatelliteID) ?? 0
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[Swift.String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [Swift.String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
        let currentEphemerisDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisMetaData.self, forKey: .currentEphemeris)
        currentEphemeris = currentEphemerisDecoded
    }
}

extension GroundStationClientTypes {
    /// Item in a list of satellites.
    public struct SatelliteListItem: Swift.Equatable {
        /// The current ephemeris being used to compute the trajectory of the satellite.
        public var currentEphemeris: GroundStationClientTypes.EphemerisMetaData?
        /// A list of ground stations to which the satellite is on-boarded.
        public var groundStations: [Swift.String]?
        /// NORAD satellite ID number.
        public var noradSatelliteID: Swift.Int
        /// ARN of a satellite.
        public var satelliteArn: Swift.String?
        /// UUID of a satellite.
        public var satelliteId: Swift.String?

        public init (
            currentEphemeris: GroundStationClientTypes.EphemerisMetaData? = nil,
            groundStations: [Swift.String]? = nil,
            noradSatelliteID: Swift.Int = 0,
            satelliteArn: Swift.String? = nil,
            satelliteId: Swift.String? = nil
        )
        {
            self.currentEphemeris = currentEphemeris
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }
    }

}

extension GroundStationClientTypes.SecurityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about endpoints.
    public struct SecurityDetails: Swift.Equatable {
        /// ARN to a role needed for connecting streams to your instances.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The security groups to attach to the elastic network interfaces.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init (
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension GroundStationClientTypes.SocketAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case port
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the socket address.
    public struct SocketAddress: Swift.Equatable {
        /// Name of a socket address.
        /// This member is required.
        public var name: Swift.String?
        /// Port of a socket address.
        /// This member is required.
        public var port: Swift.Int?

        public init (
            name: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.name = name
            self.port = port
        }
    }

}

extension GroundStationClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowSourceRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = self.configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = self.configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = self.configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowSourceRegion = self.dataflowSourceRegion {
            try encodeContainer.encode(dataflowSourceRegion, forKey: .dataflowSourceRegion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowSourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowSourceRegion)
        dataflowSourceRegion = dataflowSourceRegionDecoded
    }
}

extension GroundStationClientTypes {
    /// Dataflow details for the source side.
    public struct Source: Swift.Equatable {
        /// Additional details for a Config, if type is dataflow-endpoint or antenna-downlink-demod-decode
        public var configDetails: GroundStationClientTypes.ConfigDetails?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Region of a dataflow source.
        public var dataflowSourceRegion: Swift.String?

        public init (
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowSourceRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowSourceRegion = dataflowSourceRegion
        }
    }

}

extension GroundStationClientTypes.SpectrumConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let centerFrequency = self.centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = self.polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.FrequencyBandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that describes a spectral Config.
    public struct SpectrumConfig: Swift.Equatable {
        /// Bandwidth of a spectral Config. AWS Ground Station currently has the following bandwidth limitations:
        ///
        /// * For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.
        ///
        /// * For AntennaDownlinkconfig valid values are between 10 kHz to 54 MHz.
        ///
        /// * For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        /// This member is required.
        public var bandwidth: GroundStationClientTypes.FrequencyBandwidth?
        /// Center frequency of a spectral Config. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        /// This member is required.
        public var centerFrequency: GroundStationClientTypes.Frequency?
        /// Polarization of a spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public var polarization: GroundStationClientTypes.Polarization?

        public init (
            bandwidth: GroundStationClientTypes.FrequencyBandwidth? = nil,
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.bandwidth = bandwidth
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }

}

extension GroundStationClientTypes.TLEData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tleLine1
        case tleLine2
        case validTimeRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tleLine1 = self.tleLine1 {
            try encodeContainer.encode(tleLine1, forKey: .tleLine1)
        }
        if let tleLine2 = self.tleLine2 {
            try encodeContainer.encode(tleLine2, forKey: .tleLine2)
        }
        if let validTimeRange = self.validTimeRange {
            try encodeContainer.encode(validTimeRange, forKey: .validTimeRange)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tleLine1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tleLine1)
        tleLine1 = tleLine1Decoded
        let tleLine2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tleLine2)
        tleLine2 = tleLine2Decoded
        let validTimeRangeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.TimeRange.self, forKey: .validTimeRange)
        validTimeRange = validTimeRangeDecoded
    }
}

extension GroundStationClientTypes {
    /// Two-line element set (TLE) data.
    public struct TLEData: Swift.Equatable {
        /// First line of two-line element set (TLE) data.
        /// This member is required.
        public var tleLine1: Swift.String?
        /// Second line of two-line element set (TLE) data.
        /// This member is required.
        public var tleLine2: Swift.String?
        /// The valid time range for the TLE. Gaps or overlap are not permitted.
        /// This member is required.
        public var validTimeRange: GroundStationClientTypes.TimeRange?

        public init (
            tleLine1: Swift.String? = nil,
            tleLine2: Swift.String? = nil,
            validTimeRange: GroundStationClientTypes.TimeRange? = nil
        )
        {
            self.tleLine1 = tleLine1
            self.tleLine2 = tleLine2
            self.validTimeRange = validTimeRange
        }
    }

}

extension GroundStationClientTypes.TLEEphemeris: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Object
        case tleData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Object = self.s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
        if let tleData = tleData {
            var tleDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tleData)
            for tledata0 in tleData {
                try tleDataContainer.encode(tledata0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
        let tleDataContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.TLEData?].self, forKey: .tleData)
        var tleDataDecoded0:[GroundStationClientTypes.TLEData]? = nil
        if let tleDataContainer = tleDataContainer {
            tleDataDecoded0 = [GroundStationClientTypes.TLEData]()
            for structure0 in tleDataContainer {
                if let structure0 = structure0 {
                    tleDataDecoded0?.append(structure0)
                }
            }
        }
        tleData = tleDataDecoded0
    }
}

extension GroundStationClientTypes {
    /// Two-line element set (TLE) ephemeris.
    public struct TLEEphemeris: Swift.Equatable {
        /// Identifies the S3 object to be used as the ephemeris.
        public var s3Object: GroundStationClientTypes.S3Object?
        /// The data for a TLE ephemeris, supplied directly in the request rather than through an S3 object.
        public var tleData: [GroundStationClientTypes.TLEData]?

        public init (
            s3Object: GroundStationClientTypes.S3Object? = nil,
            tleData: [GroundStationClientTypes.TLEData]? = nil
        )
        {
            self.s3Object = s3Object
            self.tleData = tleData
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct TagResourceInput: Swift.Equatable {
    /// ARN of a resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags assigned to a resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension GroundStationClientTypes.TimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension GroundStationClientTypes {
    /// A time range with a start and end time.
    public struct TimeRange: Swift.Equatable {
        /// Time in UTC at which the time range ends.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// Time in UTC at which the time range starts.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension GroundStationClientTypes.TrackingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autotrack
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autotrack = self.autotrack {
            try encodeContainer.encode(autotrack.rawValue, forKey: .autotrack)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autotrackDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Criticality.self, forKey: .autotrack)
        autotrack = autotrackDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
    public struct TrackingConfig: Swift.Equatable {
        /// Current setting for autotrack.
        /// This member is required.
        public var autotrack: GroundStationClientTypes.Criticality?

        public init (
            autotrack: GroundStationClientTypes.Criticality? = nil
        )
        {
            self.autotrack = autotrack
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct UntagResourceInput: Swift.Equatable {
    /// ARN of a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of a resource tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = self.configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configType = configType else {
            return nil
        }
        guard let configId = configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

///
public struct UpdateConfigInput: Swift.Equatable {
    /// Parameters of a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?

    public init (
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil
    )
    {
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
    }
}

struct UpdateConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let configData: GroundStationClientTypes.ConfigTypeData?
}

extension UpdateConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
    }
}

extension UpdateConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateConfigOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

///
public struct UpdateConfigOutputResponse: Swift.Equatable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init (
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct UpdateConfigOutputResponseBody: Swift.Equatable {
    let configId: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configArn: Swift.String?
}

extension UpdateConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

extension UpdateEphemerisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case name
        case priority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension UpdateEphemerisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ephemerisId = ephemerisId else {
            return nil
        }
        return "/ephemeris/\(ephemerisId.urlPercentEncoding())"
    }
}

public struct UpdateEphemerisInput: Swift.Equatable {
    /// Whether the ephemeris is enabled or not. Changing this value will not require the ephemeris to be re-validated.
    /// This member is required.
    public var enabled: Swift.Bool?
    /// The AWS Ground Station ephemeris ID.
    /// This member is required.
    public var ephemerisId: Swift.String?
    /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
    public var name: Swift.String?
    /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
    public var priority: Swift.Int?

    public init (
        enabled: Swift.Bool? = nil,
        ephemerisId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.enabled = enabled
        self.ephemerisId = ephemerisId
        self.name = name
        self.priority = priority
    }
}

struct UpdateEphemerisInputBody: Swift.Equatable {
    let enabled: Swift.Bool?
    let name: Swift.String?
    let priority: Swift.Int?
}

extension UpdateEphemerisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case name
        case priority
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension UpdateEphemerisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEphemerisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateEphemerisOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEphemerisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateEphemerisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ephemerisId = output.ephemerisId
        } else {
            self.ephemerisId = nil
        }
    }
}

public struct UpdateEphemerisOutputResponse: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?

    public init (
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct UpdateEphemerisOutputResponseBody: Swift.Equatable {
    let ephemerisId: Swift.String?
}

extension UpdateEphemerisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
    }
}

extension UpdateMissionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case trackingConfigArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = self.contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = self.contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedge0 in dataflowEdges {
                var dataflowedge0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for configarn1 in dataflowedge0 {
                    try dataflowedge0Container.encode(configarn1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = self.minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trackingConfigArn = self.trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

extension UpdateMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let missionProfileId = missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

///
public struct UpdateMissionProfileInput: Swift.Equatable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?
    /// Name of a mission profile.
    public var name: Swift.String?
    /// ARN of a tracking Config.
    public var trackingConfigArn: Swift.String?

    public init (
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileId = missionProfileId
        self.name = name
        self.trackingConfigArn = trackingConfigArn
    }
}

struct UpdateMissionProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
    let minimumViableContactDurationSeconds: Swift.Int?
    let dataflowEdges: [[Swift.String]]?
    let trackingConfigArn: Swift.String?
}

extension UpdateMissionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case trackingConfigArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
    }
}

extension UpdateMissionProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMissionProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyException" : self = .dependencyException(try DependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMissionProfileOutputError: Swift.Error, Swift.Equatable {
    case dependencyException(DependencyException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMissionProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateMissionProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

///
public struct UpdateMissionProfileOutputResponse: Swift.Equatable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init (
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct UpdateMissionProfileOutputResponseBody: Swift.Equatable {
    let missionProfileId: Swift.String?
}

extension UpdateMissionProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

extension GroundStationClientTypes.UplinkEchoConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennaUplinkConfigArn
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let antennaUplinkConfigArn = self.antennaUplinkConfigArn {
            try encodeContainer.encode(antennaUplinkConfigArn, forKey: .antennaUplinkConfigArn)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let antennaUplinkConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antennaUplinkConfigArn)
        antennaUplinkConfigArn = antennaUplinkConfigArnDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
    public struct UplinkEchoConfig: Swift.Equatable {
        /// ARN of an uplink Config.
        /// This member is required.
        public var antennaUplinkConfigArn: Swift.String?
        /// Whether or not an uplink Config is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init (
            antennaUplinkConfigArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.antennaUplinkConfigArn = antennaUplinkConfigArn
            self.enabled = enabled
        }
    }

}

extension GroundStationClientTypes.UplinkSpectrumConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let centerFrequency = self.centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = self.polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the uplink spectral Config.
    public struct UplinkSpectrumConfig: Swift.Equatable {
        /// Center frequency of an uplink spectral Config. Valid values are between 2025 to 2120 MHz.
        /// This member is required.
        public var centerFrequency: GroundStationClientTypes.Frequency?
        /// Polarization of an uplink spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public var polarization: GroundStationClientTypes.Polarization?

        public init (
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }

}
