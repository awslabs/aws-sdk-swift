// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GroundStationClientTypes.AgentDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentCpuCores
        case agentVersion
        case componentVersions
        case instanceId
        case instanceType
        case reservedCpuCores
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentCpuCores = agentCpuCores {
            var agentCpuCoresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentCpuCores)
            for integer0 in agentCpuCores {
                try agentCpuCoresContainer.encode(integer0)
            }
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let componentVersions = componentVersions {
            var componentVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentVersions)
            for componentversion0 in componentVersions {
                try componentVersionsContainer.encode(componentversion0)
            }
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let reservedCpuCores = reservedCpuCores {
            var reservedCpuCoresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reservedCpuCores)
            for integer0 in reservedCpuCores {
                try reservedCpuCoresContainer.encode(integer0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let reservedCpuCoresContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .reservedCpuCores)
        var reservedCpuCoresDecoded0:[Swift.Int]? = nil
        if let reservedCpuCoresContainer = reservedCpuCoresContainer {
            reservedCpuCoresDecoded0 = [Swift.Int]()
            for integer0 in reservedCpuCoresContainer {
                if let integer0 = integer0 {
                    reservedCpuCoresDecoded0?.append(integer0)
                }
            }
        }
        reservedCpuCores = reservedCpuCoresDecoded0
        let agentCpuCoresContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .agentCpuCores)
        var agentCpuCoresDecoded0:[Swift.Int]? = nil
        if let agentCpuCoresContainer = agentCpuCoresContainer {
            agentCpuCoresDecoded0 = [Swift.Int]()
            for integer0 in agentCpuCoresContainer {
                if let integer0 = integer0 {
                    agentCpuCoresDecoded0?.append(integer0)
                }
            }
        }
        agentCpuCores = agentCpuCoresDecoded0
        let componentVersionsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ComponentVersion?].self, forKey: .componentVersions)
        var componentVersionsDecoded0:[GroundStationClientTypes.ComponentVersion]? = nil
        if let componentVersionsContainer = componentVersionsContainer {
            componentVersionsDecoded0 = [GroundStationClientTypes.ComponentVersion]()
            for structure0 in componentVersionsContainer {
                if let structure0 = structure0 {
                    componentVersionsDecoded0?.append(structure0)
                }
            }
        }
        componentVersions = componentVersionsDecoded0
    }
}

extension GroundStationClientTypes {
    /// Detailed information about the agent.
    public struct AgentDetails: Swift.Equatable {
        /// List of CPU cores reserved for the agent.
        public var agentCpuCores: [Swift.Int]?
        /// Current agent version.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// List of versions being used by agent components.
        /// This member is required.
        public var componentVersions: [GroundStationClientTypes.ComponentVersion]?
        /// ID of EC2 instance agent is running on.
        /// This member is required.
        public var instanceId: Swift.String?
        /// Type of EC2 instance agent is running on.
        /// This member is required.
        public var instanceType: Swift.String?
        /// This field should not be used. Use agentCpuCores instead. List of CPU cores reserved for processes other than the agent running on the EC2 instance.
        public var reservedCpuCores: [Swift.Int]?

        public init(
            agentCpuCores: [Swift.Int]? = nil,
            agentVersion: Swift.String? = nil,
            componentVersions: [GroundStationClientTypes.ComponentVersion]? = nil,
            instanceId: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            reservedCpuCores: [Swift.Int]? = nil
        )
        {
            self.agentCpuCores = agentCpuCores
            self.agentVersion = agentVersion
            self.componentVersions = componentVersions
            self.instanceId = instanceId
            self.instanceType = instanceType
            self.reservedCpuCores = reservedCpuCores
        }
    }

}

extension GroundStationClientTypes {
    public enum AgentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failed
        case inactive
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatus] {
            return [
                .active,
                .failed,
                .inactive,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentStatus(rawValue: rawValue) ?? AgentStatus.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.AggregateStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signatureMap
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signatureMap = signatureMap {
            var signatureMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .signatureMap)
            for (dictKey0, signatureMap0) in signatureMap {
                try signatureMapContainer.encode(signatureMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AgentStatus.self, forKey: .status)
        status = statusDecoded
        let signatureMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .signatureMap)
        var signatureMapDecoded0: [Swift.String:Swift.Bool]? = nil
        if let signatureMapContainer = signatureMapContainer {
            signatureMapDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, boolean0) in signatureMapContainer {
                if let boolean0 = boolean0 {
                    signatureMapDecoded0?[key0] = boolean0
                }
            }
        }
        signatureMap = signatureMapDecoded0
    }
}

extension GroundStationClientTypes {
    /// Aggregate status of Agent components.
    public struct AggregateStatus: Swift.Equatable {
        /// Sparse map of failure signatures.
        public var signatureMap: [Swift.String:Swift.Bool]?
        /// Aggregate status.
        /// This member is required.
        public var status: GroundStationClientTypes.AgentStatus?

        public init(
            signatureMap: [Swift.String:Swift.Bool]? = nil,
            status: GroundStationClientTypes.AgentStatus? = nil
        )
        {
            self.signatureMap = signatureMap
            self.status = status
        }
    }

}

extension GroundStationClientTypes {
    public enum AngleUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degreeAngle
        case radian
        case sdkUnknown(Swift.String)

        public static var allCases: [AngleUnits] {
            return [
                .degreeAngle,
                .radian,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degreeAngle: return "DEGREE_ANGLE"
            case .radian: return "RADIAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AngleUnits(rawValue: rawValue) ?? AngleUnits.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.AntennaDemodDecodeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputNode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputNode = self.outputNode {
            try encodeContainer.encode(outputNode, forKey: .outputNode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputNodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputNode)
        outputNode = outputNodeDecoded
    }
}

extension GroundStationClientTypes {
    /// Details about an antenna demod decode Config used in a contact.
    public struct AntennaDemodDecodeDetails: Swift.Equatable {
        /// Name of an antenna demod decode output node used in a contact.
        public var outputNode: Swift.String?

        public init(
            outputNode: Swift.String? = nil
        )
        {
            self.outputNode = outputNode
        }
    }

}

extension GroundStationClientTypes.AntennaDownlinkConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spectrumConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = self.spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
    public struct AntennaDownlinkConfig: Swift.Equatable {
        /// Object that describes a spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init(
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
        }
    }

}

extension GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decodeConfig
        case demodulationConfig
        case spectrumConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decodeConfig = self.decodeConfig {
            try encodeContainer.encode(decodeConfig, forKey: .decodeConfig)
        }
        if let demodulationConfig = self.demodulationConfig {
            try encodeContainer.encode(demodulationConfig, forKey: .demodulationConfig)
        }
        if let spectrumConfig = self.spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let demodulationConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DemodulationConfig.self, forKey: .demodulationConfig)
        demodulationConfig = demodulationConfigDecoded
        let decodeConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DecodeConfig.self, forKey: .decodeConfig)
        decodeConfig = decodeConfigDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
    public struct AntennaDownlinkDemodDecodeConfig: Swift.Equatable {
        /// Information about the decode Config.
        /// This member is required.
        public var decodeConfig: GroundStationClientTypes.DecodeConfig?
        /// Information about the demodulation Config.
        /// This member is required.
        public var demodulationConfig: GroundStationClientTypes.DemodulationConfig?
        /// Information about the spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init(
            decodeConfig: GroundStationClientTypes.DecodeConfig? = nil,
            demodulationConfig: GroundStationClientTypes.DemodulationConfig? = nil,
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.decodeConfig = decodeConfig
            self.demodulationConfig = demodulationConfig
            self.spectrumConfig = spectrumConfig
        }
    }

}

extension GroundStationClientTypes.AntennaUplinkConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case spectrumConfig
        case targetEirp
        case transmitDisabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spectrumConfig = self.spectrumConfig {
            try encodeContainer.encode(spectrumConfig, forKey: .spectrumConfig)
        }
        if let targetEirp = self.targetEirp {
            try encodeContainer.encode(targetEirp, forKey: .targetEirp)
        }
        if let transmitDisabled = self.transmitDisabled {
            try encodeContainer.encode(transmitDisabled, forKey: .transmitDisabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transmitDisabled)
        transmitDisabled = transmitDisabledDecoded
        let spectrumConfigDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.UplinkSpectrumConfig.self, forKey: .spectrumConfig)
        spectrumConfig = spectrumConfigDecoded
        let targetEirpDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Eirp.self, forKey: .targetEirp)
        targetEirp = targetEirpDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the uplink Config of an antenna.
    public struct AntennaUplinkConfig: Swift.Equatable {
        /// Information about the uplink spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig?
        /// EIRP of the target.
        /// This member is required.
        public var targetEirp: GroundStationClientTypes.Eirp?
        /// Whether or not uplink transmit is disabled.
        public var transmitDisabled: Swift.Bool?

        public init(
            spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig? = nil,
            targetEirp: GroundStationClientTypes.Eirp? = nil,
            transmitDisabled: Swift.Bool? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
            self.targetEirp = targetEirp
            self.transmitDisabled = transmitDisabled
        }
    }

}

extension GroundStationClientTypes {
    public enum AuditResults: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditResults] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuditResults(rawValue: rawValue) ?? AuditResults.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.AwsGroundStationAgentEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentStatus
        case auditResults
        case egressAddress
        case ingressAddress
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentStatus = self.agentStatus {
            try encodeContainer.encode(agentStatus.rawValue, forKey: .agentStatus)
        }
        if let auditResults = self.auditResults {
            try encodeContainer.encode(auditResults.rawValue, forKey: .auditResults)
        }
        if let egressAddress = self.egressAddress {
            try encodeContainer.encode(egressAddress, forKey: .egressAddress)
        }
        if let ingressAddress = self.ingressAddress {
            try encodeContainer.encode(ingressAddress, forKey: .ingressAddress)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let egressAddressDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConnectionDetails.self, forKey: .egressAddress)
        egressAddress = egressAddressDecoded
        let ingressAddressDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.RangedConnectionDetails.self, forKey: .ingressAddress)
        ingressAddress = ingressAddressDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let auditResultsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AuditResults.self, forKey: .auditResults)
        auditResults = auditResultsDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about AwsGroundStationAgentEndpoint.
    public struct AwsGroundStationAgentEndpoint: Swift.Equatable {
        /// The status of AgentEndpoint.
        public var agentStatus: GroundStationClientTypes.AgentStatus?
        /// The results of the audit.
        public var auditResults: GroundStationClientTypes.AuditResults?
        /// The egress address of AgentEndpoint.
        /// This member is required.
        public var egressAddress: GroundStationClientTypes.ConnectionDetails?
        /// The ingress address of AgentEndpoint.
        /// This member is required.
        public var ingressAddress: GroundStationClientTypes.RangedConnectionDetails?
        /// Name string associated with AgentEndpoint. Used as a human-readable identifier for AgentEndpoint.
        /// This member is required.
        public var name: Swift.String?

        public init(
            agentStatus: GroundStationClientTypes.AgentStatus? = nil,
            auditResults: GroundStationClientTypes.AuditResults? = nil,
            egressAddress: GroundStationClientTypes.ConnectionDetails? = nil,
            ingressAddress: GroundStationClientTypes.RangedConnectionDetails? = nil,
            name: Swift.String? = nil
        )
        {
            self.agentStatus = agentStatus
            self.auditResults = auditResults
            self.egressAddress = egressAddress
            self.ingressAddress = ingressAddress
            self.name = name
        }
    }

}

extension GroundStationClientTypes {
    public enum BandwidthUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [BandwidthUnits] {
            return [
                .ghz,
                .khz,
                .mhz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BandwidthUnits(rawValue: rawValue) ?? BandwidthUnits.sdkUnknown(rawValue)
        }
    }
}

extension CancelContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/\(contactId.urlPercentEncoding())"
    }
}

///
public struct CancelContactInput: Swift.Equatable {
    /// UUID of a contact.
    /// This member is required.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactInputBody: Swift.Equatable {
}

extension CancelContactInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

///
public struct CancelContactOutput: Swift.Equatable {
    /// UUID of a contact.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct CancelContactOutputBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension CancelContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

enum CancelContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GroundStationClientTypes {
    public enum CapabilityHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilityHealth] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CapabilityHealth(rawValue: rawValue) ?? CapabilityHealth.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes {
    public enum CapabilityHealthReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataplaneFailure
        case healthy
        case initializingDataplane
        case invalidIpOwnership
        case notAuthorizedToCreateSlr
        case noRegisteredAgent
        case unverifiedIpOwnership
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilityHealthReason] {
            return [
                .dataplaneFailure,
                .healthy,
                .initializingDataplane,
                .invalidIpOwnership,
                .notAuthorizedToCreateSlr,
                .noRegisteredAgent,
                .unverifiedIpOwnership,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataplaneFailure: return "DATAPLANE_FAILURE"
            case .healthy: return "HEALTHY"
            case .initializingDataplane: return "INITIALIZING_DATAPLANE"
            case .invalidIpOwnership: return "INVALID_IP_OWNERSHIP"
            case .notAuthorizedToCreateSlr: return "NOT_AUTHORIZED_TO_CREATE_SLR"
            case .noRegisteredAgent: return "NO_REGISTERED_AGENT"
            case .unverifiedIpOwnership: return "UNVERIFIED_IP_OWNERSHIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CapabilityHealthReason(rawValue: rawValue) ?? CapabilityHealthReason.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.ComponentStatusData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesReceived
        case bytesSent
        case capabilityArn
        case componentType
        case dataflowId
        case packetsDropped
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesReceived = self.bytesReceived {
            try encodeContainer.encode(bytesReceived, forKey: .bytesReceived)
        }
        if let bytesSent = self.bytesSent {
            try encodeContainer.encode(bytesSent, forKey: .bytesSent)
        }
        if let capabilityArn = self.capabilityArn {
            try encodeContainer.encode(capabilityArn, forKey: .capabilityArn)
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let dataflowId = self.dataflowId {
            try encodeContainer.encode(dataflowId, forKey: .dataflowId)
        }
        if let packetsDropped = self.packetsDropped {
            try encodeContainer.encode(packetsDropped, forKey: .packetsDropped)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let capabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityArn)
        capabilityArn = capabilityArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AgentStatus.self, forKey: .status)
        status = statusDecoded
        let bytesSentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesSent)
        bytesSent = bytesSentDecoded
        let bytesReceivedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesReceived)
        bytesReceived = bytesReceivedDecoded
        let packetsDroppedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packetsDropped)
        packetsDropped = packetsDroppedDecoded
        let dataflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowId)
        dataflowId = dataflowIdDecoded
    }
}

extension GroundStationClientTypes {
    /// Data on the status of agent components.
    public struct ComponentStatusData: Swift.Equatable {
        /// Bytes received by the component.
        public var bytesReceived: Swift.Int?
        /// Bytes sent by the component.
        public var bytesSent: Swift.Int?
        /// Capability ARN of the component.
        /// This member is required.
        public var capabilityArn: Swift.String?
        /// The Component type.
        /// This member is required.
        public var componentType: Swift.String?
        /// Dataflow UUID associated with the component.
        /// This member is required.
        public var dataflowId: Swift.String?
        /// Packets dropped by component.
        public var packetsDropped: Swift.Int?
        /// Component status.
        /// This member is required.
        public var status: GroundStationClientTypes.AgentStatus?

        public init(
            bytesReceived: Swift.Int? = nil,
            bytesSent: Swift.Int? = nil,
            capabilityArn: Swift.String? = nil,
            componentType: Swift.String? = nil,
            dataflowId: Swift.String? = nil,
            packetsDropped: Swift.Int? = nil,
            status: GroundStationClientTypes.AgentStatus? = nil
        )
        {
            self.bytesReceived = bytesReceived
            self.bytesSent = bytesSent
            self.capabilityArn = capabilityArn
            self.componentType = componentType
            self.dataflowId = dataflowId
            self.packetsDropped = packetsDropped
            self.status = status
        }
    }

}

extension GroundStationClientTypes.ComponentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentType
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for versionstring0 in versions {
                try versionsContainer.encode(versionstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

extension GroundStationClientTypes {
    /// Version information for agent components.
    public struct ComponentVersion: Swift.Equatable {
        /// Component type.
        /// This member is required.
        public var componentType: Swift.String?
        /// List of versions.
        /// This member is required.
        public var versions: [Swift.String]?

        public init(
            componentType: Swift.String? = nil,
            versions: [Swift.String]? = nil
        )
        {
            self.componentType = componentType
            self.versions = versions
        }
    }

}

extension GroundStationClientTypes {
    public enum ConfigCapabilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case antennaDownlink
        case antennaDownlinkDemodDecode
        case antennaUplink
        case dataflowEndpoint
        case s3Recording
        case tracking
        case uplinkEcho
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigCapabilityType] {
            return [
                .antennaDownlink,
                .antennaDownlinkDemodDecode,
                .antennaUplink,
                .dataflowEndpoint,
                .s3Recording,
                .tracking,
                .uplinkEcho,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .antennaDownlink: return "antenna-downlink"
            case .antennaDownlinkDemodDecode: return "antenna-downlink-demod-decode"
            case .antennaUplink: return "antenna-uplink"
            case .dataflowEndpoint: return "dataflow-endpoint"
            case .s3Recording: return "s3-recording"
            case .tracking: return "tracking"
            case .uplinkEcho: return "uplink-echo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigCapabilityType(rawValue: rawValue) ?? ConfigCapabilityType.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.ConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennademoddecodedetails = "antennaDemodDecodeDetails"
        case endpointdetails = "endpointDetails"
        case s3recordingdetails = "s3RecordingDetails"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennademoddecodedetails(antennademoddecodedetails):
                try container.encode(antennademoddecodedetails, forKey: .antennademoddecodedetails)
            case let .endpointdetails(endpointdetails):
                try container.encode(endpointdetails, forKey: .endpointdetails)
            case let .s3recordingdetails(s3recordingdetails):
                try container.encode(s3recordingdetails, forKey: .s3recordingdetails)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let endpointdetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.EndpointDetails.self, forKey: .endpointdetails)
        if let endpointdetails = endpointdetailsDecoded {
            self = .endpointdetails(endpointdetails)
            return
        }
        let antennademoddecodedetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDemodDecodeDetails.self, forKey: .antennademoddecodedetails)
        if let antennademoddecodedetails = antennademoddecodedetailsDecoded {
            self = .antennademoddecodedetails(antennademoddecodedetails)
            return
        }
        let s3recordingdetailsDecoded = try values.decodeIfPresent(GroundStationClientTypes.S3RecordingDetails.self, forKey: .s3recordingdetails)
        if let s3recordingdetails = s3recordingdetailsDecoded {
            self = .s3recordingdetails(s3recordingdetails)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// Details for certain Config object types in a contact.
    public enum ConfigDetails: Swift.Equatable {
        /// Information about the endpoint details.
        case endpointdetails(GroundStationClientTypes.EndpointDetails)
        /// Details for antenna demod decode Config in a contact.
        case antennademoddecodedetails(GroundStationClientTypes.AntennaDemodDecodeDetails)
        /// Details for an S3 recording Config in a contact.
        case s3recordingdetails(GroundStationClientTypes.S3RecordingDetails)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.ConfigListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configArn = self.configArn {
            try encodeContainer.encode(configArn, forKey: .configArn)
        }
        if let configId = self.configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = self.configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes {
    /// An item in a list of Config objects.
    public struct ConfigListItem: Swift.Equatable {
        /// ARN of a Config.
        public var configArn: Swift.String?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Name of a Config.
        public var name: Swift.String?

        public init(
            configArn: Swift.String? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            name: Swift.String? = nil
        )
        {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
            self.name = name
        }
    }

}

extension GroundStationClientTypes.ConfigTypeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennadownlinkconfig = "antennaDownlinkConfig"
        case antennadownlinkdemoddecodeconfig = "antennaDownlinkDemodDecodeConfig"
        case antennauplinkconfig = "antennaUplinkConfig"
        case dataflowendpointconfig = "dataflowEndpointConfig"
        case s3recordingconfig = "s3RecordingConfig"
        case sdkUnknown
        case trackingconfig = "trackingConfig"
        case uplinkechoconfig = "uplinkEchoConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .antennadownlinkconfig(antennadownlinkconfig):
                try container.encode(antennadownlinkconfig, forKey: .antennadownlinkconfig)
            case let .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig):
                try container.encode(antennadownlinkdemoddecodeconfig, forKey: .antennadownlinkdemoddecodeconfig)
            case let .antennauplinkconfig(antennauplinkconfig):
                try container.encode(antennauplinkconfig, forKey: .antennauplinkconfig)
            case let .dataflowendpointconfig(dataflowendpointconfig):
                try container.encode(dataflowendpointconfig, forKey: .dataflowendpointconfig)
            case let .s3recordingconfig(s3recordingconfig):
                try container.encode(s3recordingconfig, forKey: .s3recordingconfig)
            case let .trackingconfig(trackingconfig):
                try container.encode(trackingconfig, forKey: .trackingconfig)
            case let .uplinkechoconfig(uplinkechoconfig):
                try container.encode(uplinkechoconfig, forKey: .uplinkechoconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let antennadownlinkconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDownlinkConfig.self, forKey: .antennadownlinkconfig)
        if let antennadownlinkconfig = antennadownlinkconfigDecoded {
            self = .antennadownlinkconfig(antennadownlinkconfig)
            return
        }
        let trackingconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.TrackingConfig.self, forKey: .trackingconfig)
        if let trackingconfig = trackingconfigDecoded {
            self = .trackingconfig(trackingconfig)
            return
        }
        let dataflowendpointconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.DataflowEndpointConfig.self, forKey: .dataflowendpointconfig)
        if let dataflowendpointconfig = dataflowendpointconfigDecoded {
            self = .dataflowendpointconfig(dataflowendpointconfig)
            return
        }
        let antennadownlinkdemoddecodeconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig.self, forKey: .antennadownlinkdemoddecodeconfig)
        if let antennadownlinkdemoddecodeconfig = antennadownlinkdemoddecodeconfigDecoded {
            self = .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig)
            return
        }
        let antennauplinkconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.AntennaUplinkConfig.self, forKey: .antennauplinkconfig)
        if let antennauplinkconfig = antennauplinkconfigDecoded {
            self = .antennauplinkconfig(antennauplinkconfig)
            return
        }
        let uplinkechoconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.UplinkEchoConfig.self, forKey: .uplinkechoconfig)
        if let uplinkechoconfig = uplinkechoconfigDecoded {
            self = .uplinkechoconfig(uplinkechoconfig)
            return
        }
        let s3recordingconfigDecoded = try values.decodeIfPresent(GroundStationClientTypes.S3RecordingConfig.self, forKey: .s3recordingconfig)
        if let s3recordingconfig = s3recordingconfigDecoded {
            self = .s3recordingconfig(s3recordingconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// Object containing the parameters of a Config. See the subtype definitions for what each type of Config contains.
    public enum ConfigTypeData: Swift.Equatable {
        /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
        case antennadownlinkconfig(GroundStationClientTypes.AntennaDownlinkConfig)
        /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
        case trackingconfig(GroundStationClientTypes.TrackingConfig)
        /// Information about the dataflow endpoint Config.
        case dataflowendpointconfig(GroundStationClientTypes.DataflowEndpointConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
        case antennadownlinkdemoddecodeconfig(GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.
        case antennauplinkconfig(GroundStationClientTypes.AntennaUplinkConfig)
        /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
        case uplinkechoconfig(GroundStationClientTypes.UplinkEchoConfig)
        /// Information about an S3 recording Config.
        case s3recordingconfig(GroundStationClientTypes.S3RecordingConfig)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.ConnectionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mtu
        case socketAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let socketAddress = self.socketAddress {
            try encodeContainer.encode(socketAddress, forKey: .socketAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let socketAddressDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SocketAddress.self, forKey: .socketAddress)
        socketAddress = socketAddressDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
    }
}

extension GroundStationClientTypes {
    /// Egress address of AgentEndpoint with an optional mtu.
    public struct ConnectionDetails: Swift.Equatable {
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public var mtu: Swift.Int?
        /// A socket address.
        /// This member is required.
        public var socketAddress: GroundStationClientTypes.SocketAddress?

        public init(
            mtu: Swift.Int? = nil,
            socketAddress: GroundStationClientTypes.SocketAddress? = nil
        )
        {
            self.mtu = mtu
            self.socketAddress = socketAddress
        }
    }

}

extension GroundStationClientTypes.ContactData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
        case contactStatus
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let contactStatus = self.contactStatus {
            try encodeContainer.encode(contactStatus.rawValue, forKey: .contactStatus)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let groundStation = self.groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maximumElevation = self.maximumElevation {
            try encodeContainer.encode(maximumElevation, forKey: .maximumElevation)
        }
        if let missionProfileArn = self.missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let postPassEndTime = self.postPassEndTime {
            try encodeContainer.encodeTimestamp(postPassEndTime, format: .epochSeconds, forKey: .postPassEndTime)
        }
        if let prePassStartTime = self.prePassStartTime {
            try encodeContainer.encodeTimestamp(prePassStartTime, format: .epochSeconds, forKey: .prePassStartTime)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let satelliteArn = self.satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GroundStationClientTypes {
    /// Data describing a contact.
    public struct ContactData: Swift.Equatable {
        /// UUID of a contact.
        public var contactId: Swift.String?
        /// Status of a contact.
        public var contactStatus: GroundStationClientTypes.ContactStatus?
        /// End time of a contact in UTC.
        public var endTime: ClientRuntime.Date?
        /// Error message of a contact.
        public var errorMessage: Swift.String?
        /// Name of a ground station.
        public var groundStation: Swift.String?
        /// Maximum elevation angle of a contact.
        public var maximumElevation: GroundStationClientTypes.Elevation?
        /// ARN of a mission profile.
        public var missionProfileArn: Swift.String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public var postPassEndTime: ClientRuntime.Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public var prePassStartTime: ClientRuntime.Date?
        /// Region of a contact.
        public var region: Swift.String?
        /// ARN of a satellite.
        public var satelliteArn: Swift.String?
        /// Start time of a contact in UTC.
        public var startTime: ClientRuntime.Date?
        /// Tags assigned to a contact.
        public var tags: [Swift.String:Swift.String]?

        public init(
            contactId: Swift.String? = nil,
            contactStatus: GroundStationClientTypes.ContactStatus? = nil,
            endTime: ClientRuntime.Date? = nil,
            errorMessage: Swift.String? = nil,
            groundStation: Swift.String? = nil,
            maximumElevation: GroundStationClientTypes.Elevation? = nil,
            missionProfileArn: Swift.String? = nil,
            postPassEndTime: ClientRuntime.Date? = nil,
            prePassStartTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            satelliteArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
        }
    }

}

extension GroundStationClientTypes {
    public enum ContactStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case awsCancelled
        case awsFailed
        case cancelled
        case cancelling
        case completed
        case failed
        case failedToSchedule
        case pass
        case postpass
        case prepass
        case scheduled
        case scheduling
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactStatus] {
            return [
                .available,
                .awsCancelled,
                .awsFailed,
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .failedToSchedule,
                .pass,
                .postpass,
                .prepass,
                .scheduled,
                .scheduling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .awsCancelled: return "AWS_CANCELLED"
            case .awsFailed: return "AWS_FAILED"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .failedToSchedule: return "FAILED_TO_SCHEDULE"
            case .pass: return "PASS"
            case .postpass: return "POSTPASS"
            case .prepass: return "PREPASS"
            case .scheduled: return "SCHEDULED"
            case .scheduling: return "SCHEDULING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactStatus(rawValue: rawValue) ?? ContactStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = self.configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/config"
    }
}

///
public struct CreateConfigInput: Swift.Equatable {
    /// Parameters of a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a Config.
    public var tags: [Swift.String:Swift.String]?

    public init(
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configData = configData
        self.name = name
        self.tags = tags
    }
}

struct CreateConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let configData: GroundStationClientTypes.ConfigTypeData?
    let tags: [Swift.String:Swift.String]?
}

extension CreateConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

///
public struct CreateConfigOutput: Swift.Equatable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct CreateConfigOutputBody: Swift.Equatable {
    let configId: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configArn: Swift.String?
}

extension CreateConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

enum CreateConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataflowEndpointGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case endpointDetails
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = self.contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = self.contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let endpointDetails = endpointDetails {
            var endpointDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointDetails)
            for endpointdetails0 in endpointDetails {
                try endpointDetailsContainer.encode(endpointdetails0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDataflowEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataflowEndpointGroup"
    }
}

///
public struct CreateDataflowEndpointGroupInput: Swift.Equatable {
    /// Amount of time, in seconds, after a contact ends that the Ground Station Dataflow Endpoint Group will be in a POSTPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the POSTPASS state.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time, in seconds, before a contact starts that the Ground Station Dataflow Endpoint Group will be in a PREPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the PREPASS state.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// Endpoint details of each endpoint in the dataflow endpoint group.
    /// This member is required.
    public var endpointDetails: [GroundStationClientTypes.EndpointDetails]?
    /// Tags of a dataflow endpoint group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        endpointDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.endpointDetails = endpointDetails
        self.tags = tags
    }
}

struct CreateDataflowEndpointGroupInputBody: Swift.Equatable {
    let endpointDetails: [GroundStationClientTypes.EndpointDetails]?
    let tags: [Swift.String:Swift.String]?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
}

extension CreateDataflowEndpointGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case endpointDetails
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDetailsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EndpointDetails?].self, forKey: .endpointDetails)
        var endpointDetailsDecoded0:[GroundStationClientTypes.EndpointDetails]? = nil
        if let endpointDetailsContainer = endpointDetailsContainer {
            endpointDetailsDecoded0 = [GroundStationClientTypes.EndpointDetails]()
            for structure0 in endpointDetailsContainer {
                if let structure0 = structure0 {
                    endpointDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointDetails = endpointDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
    }
}

extension CreateDataflowEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataflowEndpointGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

///
public struct CreateDataflowEndpointGroupOutput: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?

    public init(
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct CreateDataflowEndpointGroupOutputBody: Swift.Equatable {
    let dataflowEndpointGroupId: Swift.String?
}

extension CreateDataflowEndpointGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

enum CreateDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEphemerisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case ephemeris
        case expirationTime
        case kmsKeyArn
        case name
        case priority
        case satelliteId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ephemeris = self.ephemeris {
            try encodeContainer.encode(ephemeris, forKey: .ephemeris)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .epochSeconds, forKey: .expirationTime)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let satelliteId = self.satelliteId {
            try encodeContainer.encode(satelliteId, forKey: .satelliteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEphemerisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ephemeris"
    }
}

public struct CreateEphemerisInput: Swift.Equatable {
    /// Whether to set the ephemeris status to ENABLED after validation. Setting this to false will set the ephemeris status to DISABLED after validation.
    public var enabled: Swift.Bool?
    /// Ephemeris data.
    public var ephemeris: GroundStationClientTypes.EphemerisData?
    /// An overall expiration time for the ephemeris in UTC, after which it will become EXPIRED.
    public var expirationTime: ClientRuntime.Date?
    /// The ARN of a KMS key used to encrypt the ephemeris in Ground Station.
    public var kmsKeyArn: Swift.String?
    /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
    /// This member is required.
    public var name: Swift.String?
    /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
    public var priority: Swift.Int?
    /// AWS Ground Station satellite ID for this ephemeris.
    /// This member is required.
    public var satelliteId: Swift.String?
    /// Tags assigned to an ephemeris.
    public var tags: [Swift.String:Swift.String]?

    public init(
        enabled: Swift.Bool? = nil,
        ephemeris: GroundStationClientTypes.EphemerisData? = nil,
        expirationTime: ClientRuntime.Date? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        satelliteId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.enabled = enabled
        self.ephemeris = ephemeris
        self.expirationTime = expirationTime
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.priority = priority
        self.satelliteId = satelliteId
        self.tags = tags
    }
}

struct CreateEphemerisInputBody: Swift.Equatable {
    let satelliteId: Swift.String?
    let enabled: Swift.Bool?
    let priority: Swift.Int?
    let expirationTime: ClientRuntime.Date?
    let name: Swift.String?
    let kmsKeyArn: Swift.String?
    let ephemeris: GroundStationClientTypes.EphemerisData?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEphemerisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case ephemeris
        case expirationTime
        case kmsKeyArn
        case name
        case priority
        case satelliteId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let ephemerisDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisData.self, forKey: .ephemeris)
        ephemeris = ephemerisDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEphemerisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEphemerisOutputBody = try responseDecoder.decode(responseBody: data)
            self.ephemerisId = output.ephemerisId
        } else {
            self.ephemerisId = nil
        }
    }
}

public struct CreateEphemerisOutput: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct CreateEphemerisOutputBody: Swift.Equatable {
    let ephemerisId: Swift.String?
}

extension CreateEphemerisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
    }
}

enum CreateEphemerisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMissionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case streamsKmsKey
        case streamsKmsRole
        case tags
        case trackingConfigArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = self.contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = self.contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedge0 in dataflowEdges {
                var dataflowedge0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for configarn1 in dataflowedge0 {
                    try dataflowedge0Container.encode(configarn1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = self.minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamsKmsKey = self.streamsKmsKey {
            try encodeContainer.encode(streamsKmsKey, forKey: .streamsKmsKey)
        }
        if let streamsKmsRole = self.streamsKmsRole {
            try encodeContainer.encode(streamsKmsRole, forKey: .streamsKmsRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let trackingConfigArn = self.trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

extension CreateMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/missionprofile"
    }
}

///
public struct CreateMissionProfileInput: Swift.Equatable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    /// This member is required.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    /// This member is required.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// Name of a mission profile.
    /// This member is required.
    public var name: Swift.String?
    /// KMS key to use for encrypting streams.
    public var streamsKmsKey: GroundStationClientTypes.KmsKey?
    /// Role to use for encrypting streams with KMS key.
    public var streamsKmsRole: Swift.String?
    /// Tags assigned to a mission profile.
    public var tags: [Swift.String:Swift.String]?
    /// ARN of a tracking Config.
    /// This member is required.
    public var trackingConfigArn: Swift.String?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        streamsKmsKey: GroundStationClientTypes.KmsKey? = nil,
        streamsKmsRole: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.name = name
        self.streamsKmsKey = streamsKmsKey
        self.streamsKmsRole = streamsKmsRole
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct CreateMissionProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
    let minimumViableContactDurationSeconds: Swift.Int?
    let dataflowEdges: [[Swift.String]]?
    let trackingConfigArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let streamsKmsKey: GroundStationClientTypes.KmsKey?
    let streamsKmsRole: Swift.String?
}

extension CreateMissionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case streamsKmsKey
        case streamsKmsRole
        case tags
        case trackingConfigArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let streamsKmsKeyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.KmsKey.self, forKey: .streamsKmsKey)
        streamsKmsKey = streamsKmsKeyDecoded
        let streamsKmsRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamsKmsRole)
        streamsKmsRole = streamsKmsRoleDecoded
    }
}

extension CreateMissionProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMissionProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

///
public struct CreateMissionProfileOutput: Swift.Equatable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct CreateMissionProfileOutputBody: Swift.Equatable {
    let missionProfileId: Swift.String?
}

extension CreateMissionProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

enum CreateMissionProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GroundStationClientTypes {
    public enum Criticality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case preferred
        case removed
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [Criticality] {
            return [
                .preferred,
                .removed,
                .required,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .preferred: return "PREFERRED"
            case .removed: return "REMOVED"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Criticality(rawValue: rawValue) ?? Criticality.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.DataflowDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case errorMessage
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about a dataflow edge used in a contact.
    public struct DataflowDetail: Swift.Equatable {
        /// Dataflow details for the destination side.
        public var destination: GroundStationClientTypes.Destination?
        /// Error message for a dataflow.
        public var errorMessage: Swift.String?
        /// Dataflow details for the source side.
        public var source: GroundStationClientTypes.Source?

        public init(
            destination: GroundStationClientTypes.Destination? = nil,
            errorMessage: Swift.String? = nil,
            source: GroundStationClientTypes.Source? = nil
        )
        {
            self.destination = destination
            self.errorMessage = errorMessage
            self.source = source
        }
    }

}

extension GroundStationClientTypes.DataflowEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case mtu
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let addressDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SocketAddress.self, forKey: .address)
        address = addressDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about a dataflow endpoint.
    public struct DataflowEndpoint: Swift.Equatable {
        /// Socket address of a dataflow endpoint.
        public var address: GroundStationClientTypes.SocketAddress?
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public var mtu: Swift.Int?
        /// Name of a dataflow endpoint.
        public var name: Swift.String?
        /// Status of a dataflow endpoint.
        public var status: GroundStationClientTypes.EndpointStatus?

        public init(
            address: GroundStationClientTypes.SocketAddress? = nil,
            mtu: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: GroundStationClientTypes.EndpointStatus? = nil
        )
        {
            self.address = address
            self.mtu = mtu
            self.name = name
            self.status = status
        }
    }

}

extension GroundStationClientTypes.DataflowEndpointConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointName
        case dataflowEndpointRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointName = self.dataflowEndpointName {
            try encodeContainer.encode(dataflowEndpointName, forKey: .dataflowEndpointName)
        }
        if let dataflowEndpointRegion = self.dataflowEndpointRegion {
            try encodeContainer.encode(dataflowEndpointRegion, forKey: .dataflowEndpointRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointName)
        dataflowEndpointName = dataflowEndpointNameDecoded
        let dataflowEndpointRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointRegion)
        dataflowEndpointRegion = dataflowEndpointRegionDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the dataflow endpoint Config.
    public struct DataflowEndpointConfig: Swift.Equatable {
        /// Name of a dataflow endpoint.
        /// This member is required.
        public var dataflowEndpointName: Swift.String?
        /// Region of a dataflow endpoint.
        public var dataflowEndpointRegion: Swift.String?

        public init(
            dataflowEndpointName: Swift.String? = nil,
            dataflowEndpointRegion: Swift.String? = nil
        )
        {
            self.dataflowEndpointName = dataflowEndpointName
            self.dataflowEndpointRegion = dataflowEndpointRegion
        }
    }

}

extension GroundStationClientTypes.DataflowEndpointListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataflowEndpointGroupArn = self.dataflowEndpointGroupArn {
            try encodeContainer.encode(dataflowEndpointGroupArn, forKey: .dataflowEndpointGroupArn)
        }
        if let dataflowEndpointGroupId = self.dataflowEndpointGroupId {
            try encodeContainer.encode(dataflowEndpointGroupId, forKey: .dataflowEndpointGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
    }
}

extension GroundStationClientTypes {
    /// Item in a list of DataflowEndpoint groups.
    public struct DataflowEndpointListItem: Swift.Equatable {
        /// ARN of a dataflow endpoint group.
        public var dataflowEndpointGroupArn: Swift.String?
        /// UUID of a dataflow endpoint group.
        public var dataflowEndpointGroupId: Swift.String?

        public init(
            dataflowEndpointGroupArn: Swift.String? = nil,
            dataflowEndpointGroupId: Swift.String? = nil
        )
        {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }
    }

}

extension GroundStationClientTypes.DecodeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = self.unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the decode Config.
    public struct DecodeConfig: Swift.Equatable {
        /// Unvalidated JSON of a decode Config.
        /// This member is required.
        public var unvalidatedJSON: Swift.String?

        public init(
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }

}

extension DeleteConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configType = configType else {
            return nil
        }
        guard let configId = configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

///
public struct DeleteConfigInput: Swift.Equatable {
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigInputBody: Swift.Equatable {
}

extension DeleteConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

///
public struct DeleteConfigOutput: Swift.Equatable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct DeleteConfigOutputBody: Swift.Equatable {
    let configId: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configArn: Swift.String?
}

extension DeleteConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

enum DeleteConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataflowEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dataflowEndpointGroupId = dataflowEndpointGroupId else {
            return nil
        }
        return "/dataflowEndpointGroup/\(dataflowEndpointGroupId.urlPercentEncoding())"
    }
}

///
public struct DeleteDataflowEndpointGroupInput: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    /// This member is required.
    public var dataflowEndpointGroupId: Swift.String?

    public init(
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupInputBody: Swift.Equatable {
}

extension DeleteDataflowEndpointGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataflowEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDataflowEndpointGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
        } else {
            self.dataflowEndpointGroupId = nil
        }
    }
}

///
public struct DeleteDataflowEndpointGroupOutput: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?

    public init(
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct DeleteDataflowEndpointGroupOutputBody: Swift.Equatable {
    let dataflowEndpointGroupId: Swift.String?
}

extension DeleteDataflowEndpointGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
    }
}

enum DeleteDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEphemerisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ephemerisId = ephemerisId else {
            return nil
        }
        return "/ephemeris/\(ephemerisId.urlPercentEncoding())"
    }
}

public struct DeleteEphemerisInput: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    /// This member is required.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct DeleteEphemerisInputBody: Swift.Equatable {
}

extension DeleteEphemerisInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEphemerisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEphemerisOutputBody = try responseDecoder.decode(responseBody: data)
            self.ephemerisId = output.ephemerisId
        } else {
            self.ephemerisId = nil
        }
    }
}

public struct DeleteEphemerisOutput: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct DeleteEphemerisOutputBody: Swift.Equatable {
    let ephemerisId: Swift.String?
}

extension DeleteEphemerisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
    }
}

enum DeleteEphemerisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let missionProfileId = missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

///
public struct DeleteMissionProfileInput: Swift.Equatable {
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileInputBody: Swift.Equatable {
}

extension DeleteMissionProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMissionProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMissionProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

///
public struct DeleteMissionProfileOutput: Swift.Equatable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct DeleteMissionProfileOutputBody: Swift.Equatable {
    let missionProfileId: Swift.String?
}

extension DeleteMissionProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

enum DeleteMissionProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GroundStationClientTypes.DemodulationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unvalidatedJSON
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unvalidatedJSON = self.unvalidatedJSON {
            try encodeContainer.encode(unvalidatedJSON, forKey: .unvalidatedJSON)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unvalidatedJSONDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unvalidatedJSON)
        unvalidatedJSON = unvalidatedJSONDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the demodulation Config.
    public struct DemodulationConfig: Swift.Equatable {
        /// Unvalidated JSON of a demodulation Config.
        /// This member is required.
        public var unvalidatedJSON: Swift.String?

        public init(
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }

}

extension DependencyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.parameterName = output.parameterName
        } else {
            self.properties.message = nil
            self.properties.parameterName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Dependency encountered an error.
public struct DependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var parameterName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterName = parameterName
    }
}

struct DependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension DependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension DescribeContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let contactId = contactId else {
            return nil
        }
        return "/contact/\(contactId.urlPercentEncoding())"
    }
}

///
public struct DescribeContactInput: Swift.Equatable {
    /// UUID of a contact.
    /// This member is required.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct DescribeContactInputBody: Swift.Equatable {
}

extension DescribeContactInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
            self.contactStatus = output.contactStatus
            self.dataflowList = output.dataflowList
            self.endTime = output.endTime
            self.errorMessage = output.errorMessage
            self.groundStation = output.groundStation
            self.maximumElevation = output.maximumElevation
            self.missionProfileArn = output.missionProfileArn
            self.postPassEndTime = output.postPassEndTime
            self.prePassStartTime = output.prePassStartTime
            self.region = output.region
            self.satelliteArn = output.satelliteArn
            self.startTime = output.startTime
            self.tags = output.tags
        } else {
            self.contactId = nil
            self.contactStatus = nil
            self.dataflowList = nil
            self.endTime = nil
            self.errorMessage = nil
            self.groundStation = nil
            self.maximumElevation = nil
            self.missionProfileArn = nil
            self.postPassEndTime = nil
            self.prePassStartTime = nil
            self.region = nil
            self.satelliteArn = nil
            self.startTime = nil
            self.tags = nil
        }
    }
}

///
public struct DescribeContactOutput: Swift.Equatable {
    /// UUID of a contact.
    public var contactId: Swift.String?
    /// Status of a contact.
    public var contactStatus: GroundStationClientTypes.ContactStatus?
    /// List describing source and destination details for each dataflow edge.
    public var dataflowList: [GroundStationClientTypes.DataflowDetail]?
    /// End time of a contact in UTC.
    public var endTime: ClientRuntime.Date?
    /// Error message for a contact.
    public var errorMessage: Swift.String?
    /// Ground station for a contact.
    public var groundStation: Swift.String?
    /// Maximum elevation angle of a contact.
    public var maximumElevation: GroundStationClientTypes.Elevation?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var postPassEndTime: ClientRuntime.Date?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var prePassStartTime: ClientRuntime.Date?
    /// Region of a contact.
    public var region: Swift.String?
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// Start time of a contact in UTC.
    public var startTime: ClientRuntime.Date?
    /// Tags assigned to a contact.
    public var tags: [Swift.String:Swift.String]?

    public init(
        contactId: Swift.String? = nil,
        contactStatus: GroundStationClientTypes.ContactStatus? = nil,
        dataflowList: [GroundStationClientTypes.DataflowDetail]? = nil,
        endTime: ClientRuntime.Date? = nil,
        errorMessage: Swift.String? = nil,
        groundStation: Swift.String? = nil,
        maximumElevation: GroundStationClientTypes.Elevation? = nil,
        missionProfileArn: Swift.String? = nil,
        postPassEndTime: ClientRuntime.Date? = nil,
        prePassStartTime: ClientRuntime.Date? = nil,
        region: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.contactId = contactId
        self.contactStatus = contactStatus
        self.dataflowList = dataflowList
        self.endTime = endTime
        self.errorMessage = errorMessage
        self.groundStation = groundStation
        self.maximumElevation = maximumElevation
        self.missionProfileArn = missionProfileArn
        self.postPassEndTime = postPassEndTime
        self.prePassStartTime = prePassStartTime
        self.region = region
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct DescribeContactOutputBody: Swift.Equatable {
    let contactId: Swift.String?
    let missionProfileArn: Swift.String?
    let satelliteArn: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let prePassStartTime: ClientRuntime.Date?
    let postPassEndTime: ClientRuntime.Date?
    let groundStation: Swift.String?
    let contactStatus: GroundStationClientTypes.ContactStatus?
    let errorMessage: Swift.String?
    let maximumElevation: GroundStationClientTypes.Elevation?
    let tags: [Swift.String:Swift.String]?
    let region: Swift.String?
    let dataflowList: [GroundStationClientTypes.DataflowDetail]?
}

extension DescribeContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
        case contactStatus
        case dataflowList
        case endTime
        case errorMessage
        case groundStation
        case maximumElevation
        case missionProfileArn
        case postPassEndTime
        case prePassStartTime
        case region
        case satelliteArn
        case startTime
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let prePassStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .prePassStartTime)
        prePassStartTime = prePassStartTimeDecoded
        let postPassEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .postPassEndTime)
        postPassEndTime = postPassEndTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let contactStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ContactStatus.self, forKey: .contactStatus)
        contactStatus = contactStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let maximumElevationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Elevation.self, forKey: .maximumElevation)
        maximumElevation = maximumElevationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let dataflowListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.DataflowDetail?].self, forKey: .dataflowList)
        var dataflowListDecoded0:[GroundStationClientTypes.DataflowDetail]? = nil
        if let dataflowListContainer = dataflowListContainer {
            dataflowListDecoded0 = [GroundStationClientTypes.DataflowDetail]()
            for structure0 in dataflowListContainer {
                if let structure0 = structure0 {
                    dataflowListDecoded0?.append(structure0)
                }
            }
        }
        dataflowList = dataflowListDecoded0
    }
}

enum DescribeContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEphemerisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ephemerisId = ephemerisId else {
            return nil
        }
        return "/ephemeris/\(ephemerisId.urlPercentEncoding())"
    }
}

public struct DescribeEphemerisInput: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    /// This member is required.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct DescribeEphemerisInputBody: Swift.Equatable {
}

extension DescribeEphemerisInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEphemerisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEphemerisOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.enabled = output.enabled
            self.ephemerisId = output.ephemerisId
            self.invalidReason = output.invalidReason
            self.name = output.name
            self.priority = output.priority
            self.satelliteId = output.satelliteId
            self.status = output.status
            self.suppliedData = output.suppliedData
            self.tags = output.tags
        } else {
            self.creationTime = nil
            self.enabled = nil
            self.ephemerisId = nil
            self.invalidReason = nil
            self.name = nil
            self.priority = nil
            self.satelliteId = nil
            self.status = nil
            self.suppliedData = nil
            self.tags = nil
        }
    }
}

public struct DescribeEphemerisOutput: Swift.Equatable {
    /// The time the ephemeris was uploaded in UTC.
    public var creationTime: ClientRuntime.Date?
    /// Whether or not the ephemeris is enabled.
    public var enabled: Swift.Bool?
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?
    /// Reason that an ephemeris failed validation. Only provided for ephemerides with INVALID status.
    public var invalidReason: GroundStationClientTypes.EphemerisInvalidReason?
    /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
    public var name: Swift.String?
    /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
    public var priority: Swift.Int?
    /// The AWS Ground Station satellite ID associated with ephemeris.
    public var satelliteId: Swift.String?
    /// The status of the ephemeris.
    public var status: GroundStationClientTypes.EphemerisStatus?
    /// Supplied ephemeris data.
    public var suppliedData: GroundStationClientTypes.EphemerisTypeDescription?
    /// Tags assigned to an ephemeris.
    public var tags: [Swift.String:Swift.String]?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        enabled: Swift.Bool? = nil,
        ephemerisId: Swift.String? = nil,
        invalidReason: GroundStationClientTypes.EphemerisInvalidReason? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        satelliteId: Swift.String? = nil,
        status: GroundStationClientTypes.EphemerisStatus? = nil,
        suppliedData: GroundStationClientTypes.EphemerisTypeDescription? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.creationTime = creationTime
        self.enabled = enabled
        self.ephemerisId = ephemerisId
        self.invalidReason = invalidReason
        self.name = name
        self.priority = priority
        self.satelliteId = satelliteId
        self.status = status
        self.suppliedData = suppliedData
        self.tags = tags
    }
}

struct DescribeEphemerisOutputBody: Swift.Equatable {
    let ephemerisId: Swift.String?
    let satelliteId: Swift.String?
    let status: GroundStationClientTypes.EphemerisStatus?
    let priority: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let enabled: Swift.Bool?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let suppliedData: GroundStationClientTypes.EphemerisTypeDescription?
    let invalidReason: GroundStationClientTypes.EphemerisInvalidReason?
}

extension DescribeEphemerisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case enabled
        case ephemerisId
        case invalidReason
        case name
        case priority
        case satelliteId
        case status
        case suppliedData
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisStatus.self, forKey: .status)
        status = statusDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let suppliedDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisTypeDescription.self, forKey: .suppliedData)
        suppliedData = suppliedDataDecoded
        let invalidReasonDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisInvalidReason.self, forKey: .invalidReason)
        invalidReason = invalidReasonDecoded
    }
}

enum DescribeEphemerisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GroundStationClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowDestinationRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = self.configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = self.configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = self.configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowDestinationRegion = self.dataflowDestinationRegion {
            try encodeContainer.encode(dataflowDestinationRegion, forKey: .dataflowDestinationRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowDestinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowDestinationRegion)
        dataflowDestinationRegion = dataflowDestinationRegionDecoded
    }
}

extension GroundStationClientTypes {
    /// Dataflow details for the destination side.
    public struct Destination: Swift.Equatable {
        /// Additional details for a Config, if type is dataflow endpoint or antenna demod decode.
        public var configDetails: GroundStationClientTypes.ConfigDetails?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Region of a dataflow destination.
        public var dataflowDestinationRegion: Swift.String?

        public init(
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowDestinationRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowDestinationRegion = dataflowDestinationRegion
        }
    }

}

extension GroundStationClientTypes.DiscoveryData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityArns
        case privateIpAddresses
        case publicIpAddresses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityArns = capabilityArns {
            var capabilityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilityArns)
            for capabilityarn0 in capabilityArns {
                try capabilityArnsContainer.encode(capabilityarn0)
            }
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for ipv4address0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(ipv4address0)
            }
        }
        if let publicIpAddresses = publicIpAddresses {
            var publicIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .publicIpAddresses)
            for ipv4address0 in publicIpAddresses {
                try publicIpAddressesContainer.encode(ipv4address0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .publicIpAddresses)
        var publicIpAddressesDecoded0:[Swift.String]? = nil
        if let publicIpAddressesContainer = publicIpAddressesContainer {
            publicIpAddressesDecoded0 = [Swift.String]()
            for string0 in publicIpAddressesContainer {
                if let string0 = string0 {
                    publicIpAddressesDecoded0?.append(string0)
                }
            }
        }
        publicIpAddresses = publicIpAddressesDecoded0
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[Swift.String]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [Swift.String]()
            for string0 in privateIpAddressesContainer {
                if let string0 = string0 {
                    privateIpAddressesDecoded0?.append(string0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let capabilityArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilityArns)
        var capabilityArnsDecoded0:[Swift.String]? = nil
        if let capabilityArnsContainer = capabilityArnsContainer {
            capabilityArnsDecoded0 = [Swift.String]()
            for string0 in capabilityArnsContainer {
                if let string0 = string0 {
                    capabilityArnsDecoded0?.append(string0)
                }
            }
        }
        capabilityArns = capabilityArnsDecoded0
    }
}

extension GroundStationClientTypes {
    /// Data for agent discovery.
    public struct DiscoveryData: Swift.Equatable {
        /// List of capabilities to associate with agent.
        /// This member is required.
        public var capabilityArns: [Swift.String]?
        /// List of private IP addresses to associate with agent.
        /// This member is required.
        public var privateIpAddresses: [Swift.String]?
        /// List of public IP addresses to associate with agent.
        /// This member is required.
        public var publicIpAddresses: [Swift.String]?

        public init(
            capabilityArns: [Swift.String]? = nil,
            privateIpAddresses: [Swift.String]? = nil,
            publicIpAddresses: [Swift.String]? = nil
        )
        {
            self.capabilityArns = capabilityArns
            self.privateIpAddresses = privateIpAddresses
            self.publicIpAddresses = publicIpAddresses
        }
    }

}

extension GroundStationClientTypes.Eirp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = self.units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EirpUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that represents EIRP.
    public struct Eirp: Swift.Equatable {
        /// Units of an EIRP.
        /// This member is required.
        public var units: GroundStationClientTypes.EirpUnits?
        /// Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            units: GroundStationClientTypes.EirpUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes {
    public enum EirpUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dbw
        case sdkUnknown(Swift.String)

        public static var allCases: [EirpUnits] {
            return [
                .dbw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dbw: return "dBW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EirpUnits(rawValue: rawValue) ?? EirpUnits.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.Elevation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AngleUnits.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension GroundStationClientTypes {
    /// Elevation angle of the satellite in the sky during a contact.
    public struct Elevation: Swift.Equatable {
        /// Elevation angle units.
        /// This member is required.
        public var unit: GroundStationClientTypes.AngleUnits?
        /// Elevation angle value.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            unit: GroundStationClientTypes.AngleUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension GroundStationClientTypes.EndpointDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsGroundStationAgentEndpoint
        case endpoint
        case healthReasons
        case healthStatus
        case securityDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsGroundStationAgentEndpoint = self.awsGroundStationAgentEndpoint {
            try encodeContainer.encode(awsGroundStationAgentEndpoint, forKey: .awsGroundStationAgentEndpoint)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let healthReasons = healthReasons {
            var healthReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .healthReasons)
            for capabilityhealthreason0 in healthReasons {
                try healthReasonsContainer.encode(capabilityhealthreason0.rawValue)
            }
        }
        if let healthStatus = self.healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let securityDetails = self.securityDetails {
            try encodeContainer.encode(securityDetails, forKey: .securityDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.SecurityDetails.self, forKey: .securityDetails)
        securityDetails = securityDetailsDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DataflowEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let awsGroundStationAgentEndpointDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AwsGroundStationAgentEndpoint.self, forKey: .awsGroundStationAgentEndpoint)
        awsGroundStationAgentEndpoint = awsGroundStationAgentEndpointDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.CapabilityHealth.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let healthReasonsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.CapabilityHealthReason?].self, forKey: .healthReasons)
        var healthReasonsDecoded0:[GroundStationClientTypes.CapabilityHealthReason]? = nil
        if let healthReasonsContainer = healthReasonsContainer {
            healthReasonsDecoded0 = [GroundStationClientTypes.CapabilityHealthReason]()
            for string0 in healthReasonsContainer {
                if let string0 = string0 {
                    healthReasonsDecoded0?.append(string0)
                }
            }
        }
        healthReasons = healthReasonsDecoded0
    }
}

extension GroundStationClientTypes {
    /// Information about the endpoint details.
    public struct EndpointDetails: Swift.Equatable {
        /// An agent endpoint.
        public var awsGroundStationAgentEndpoint: GroundStationClientTypes.AwsGroundStationAgentEndpoint?
        /// A dataflow endpoint.
        public var endpoint: GroundStationClientTypes.DataflowEndpoint?
        /// Health reasons for a dataflow endpoint. This field is ignored when calling CreateDataflowEndpointGroup.
        public var healthReasons: [GroundStationClientTypes.CapabilityHealthReason]?
        /// A dataflow endpoint health status. This field is ignored when calling CreateDataflowEndpointGroup.
        public var healthStatus: GroundStationClientTypes.CapabilityHealth?
        /// Endpoint security details including a list of subnets, a list of security groups and a role to connect streams to instances.
        public var securityDetails: GroundStationClientTypes.SecurityDetails?

        public init(
            awsGroundStationAgentEndpoint: GroundStationClientTypes.AwsGroundStationAgentEndpoint? = nil,
            endpoint: GroundStationClientTypes.DataflowEndpoint? = nil,
            healthReasons: [GroundStationClientTypes.CapabilityHealthReason]? = nil,
            healthStatus: GroundStationClientTypes.CapabilityHealth? = nil,
            securityDetails: GroundStationClientTypes.SecurityDetails? = nil
        )
        {
            self.awsGroundStationAgentEndpoint = awsGroundStationAgentEndpoint
            self.endpoint = endpoint
            self.healthReasons = healthReasons
            self.healthStatus = healthStatus
            self.securityDetails = securityDetails
        }
    }

}

extension GroundStationClientTypes {
    public enum EndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case creating
        case deleted
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .created,
                .creating,
                .deleted,
                .deleting,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "created"
            case .creating: return "creating"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .failed: return "failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.EphemerisData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oem
        case sdkUnknown
        case tle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .oem(oem):
                try container.encode(oem, forKey: .oem)
            case let .tle(tle):
                try container.encode(tle, forKey: .tle)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tleDecoded = try values.decodeIfPresent(GroundStationClientTypes.TLEEphemeris.self, forKey: .tle)
        if let tle = tleDecoded {
            self = .tle(tle)
            return
        }
        let oemDecoded = try values.decodeIfPresent(GroundStationClientTypes.OEMEphemeris.self, forKey: .oem)
        if let oem = oemDecoded {
            self = .oem(oem)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// Ephemeris data.
    public enum EphemerisData: Swift.Equatable {
        /// Two-line element set (TLE) ephemeris.
        case tle(GroundStationClientTypes.TLEEphemeris)
        /// Ephemeris data in Orbit Ephemeris Message (OEM) format.
        case oem(GroundStationClientTypes.OEMEphemeris)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.EphemerisDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisData
        case sourceS3Object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ephemerisData = self.ephemerisData {
            try encodeContainer.encode(ephemerisData, forKey: .ephemerisData)
        }
        if let sourceS3Object = self.sourceS3Object {
            try encodeContainer.encode(sourceS3Object, forKey: .sourceS3Object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceS3ObjectDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.S3Object.self, forKey: .sourceS3Object)
        sourceS3Object = sourceS3ObjectDecoded
        let ephemerisDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisData)
        ephemerisData = ephemerisDataDecoded
    }
}

extension GroundStationClientTypes {
    /// Description of ephemeris.
    public struct EphemerisDescription: Swift.Equatable {
        /// Supplied ephemeris data.
        public var ephemerisData: Swift.String?
        /// Source S3 object used for the ephemeris.
        public var sourceS3Object: GroundStationClientTypes.S3Object?

        public init(
            ephemerisData: Swift.String? = nil,
            sourceS3Object: GroundStationClientTypes.S3Object? = nil
        )
        {
            self.ephemerisData = ephemerisData
            self.sourceS3Object = sourceS3Object
        }
    }

}

extension GroundStationClientTypes {
    public enum EphemerisInvalidReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Provided KMS key is invalid
        case kmsKeyInvalid
        /// Provided spacecraft identifiers such as spacecraft NORAD Id are invalid
        case metadataInvalid
        /// Start, end, or expiration time(s) are invalid for the provided ephemeris
        case timeRangeInvalid
        /// Provided ephemeris defines invalid spacecraft trajectory
        case trajectoryInvalid
        /// Internal Service Error occurred while processing ephemeris
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [EphemerisInvalidReason] {
            return [
                .kmsKeyInvalid,
                .metadataInvalid,
                .timeRangeInvalid,
                .trajectoryInvalid,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kmsKeyInvalid: return "KMS_KEY_INVALID"
            case .metadataInvalid: return "METADATA_INVALID"
            case .timeRangeInvalid: return "TIME_RANGE_INVALID"
            case .trajectoryInvalid: return "TRAJECTORY_INVALID"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EphemerisInvalidReason(rawValue: rawValue) ?? EphemerisInvalidReason.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.EphemerisItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case enabled
        case ephemerisId
        case name
        case priority
        case sourceS3Object
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let ephemerisId = self.ephemerisId {
            try encodeContainer.encode(ephemerisId, forKey: .ephemerisId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let sourceS3Object = self.sourceS3Object {
            try encodeContainer.encode(sourceS3Object, forKey: .sourceS3Object)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisStatus.self, forKey: .status)
        status = statusDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceS3ObjectDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.S3Object.self, forKey: .sourceS3Object)
        sourceS3Object = sourceS3ObjectDecoded
    }
}

extension GroundStationClientTypes {
    /// Ephemeris item.
    public struct EphemerisItem: Swift.Equatable {
        /// The time the ephemeris was uploaded in UTC.
        public var creationTime: ClientRuntime.Date?
        /// Whether or not the ephemeris is enabled.
        public var enabled: Swift.Bool?
        /// The AWS Ground Station ephemeris ID.
        public var ephemerisId: Swift.String?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public var name: Swift.String?
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public var priority: Swift.Int?
        /// Source S3 object used for the ephemeris.
        public var sourceS3Object: GroundStationClientTypes.S3Object?
        /// The status of the ephemeris.
        public var status: GroundStationClientTypes.EphemerisStatus?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            enabled: Swift.Bool? = nil,
            ephemerisId: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sourceS3Object: GroundStationClientTypes.S3Object? = nil,
            status: GroundStationClientTypes.EphemerisStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.enabled = enabled
            self.ephemerisId = ephemerisId
            self.name = name
            self.priority = priority
            self.sourceS3Object = sourceS3Object
            self.status = status
        }
    }

}

extension GroundStationClientTypes.EphemerisMetaData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisId
        case epoch
        case name
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ephemerisId = self.ephemerisId {
            try encodeContainer.encode(ephemerisId, forKey: .ephemerisId)
        }
        if let epoch = self.epoch {
            try encodeContainer.encodeTimestamp(epoch, format: .epochSeconds, forKey: .epoch)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisSource.self, forKey: .source)
        source = sourceDecoded
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
        let epochDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .epoch)
        epoch = epochDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes {
    /// Metadata describing a particular ephemeris.
    public struct EphemerisMetaData: Swift.Equatable {
        /// UUID of a customer-provided ephemeris. This field is not populated for default ephemerides from Space Track.
        public var ephemerisId: Swift.String?
        /// The epoch of a default, ephemeris from Space Track in UTC. This field is not populated for customer-provided ephemerides.
        public var epoch: ClientRuntime.Date?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris. A name is only returned for customer-provider ephemerides that have a name associated.
        public var name: Swift.String?
        /// The EphemerisSource that generated a given ephemeris.
        /// This member is required.
        public var source: GroundStationClientTypes.EphemerisSource?

        public init(
            ephemerisId: Swift.String? = nil,
            epoch: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            source: GroundStationClientTypes.EphemerisSource? = nil
        )
        {
            self.ephemerisId = ephemerisId
            self.epoch = epoch
            self.name = name
            self.source = source
        }
    }

}

extension GroundStationClientTypes {
    public enum EphemerisSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerProvided
        case spaceTrack
        case sdkUnknown(Swift.String)

        public static var allCases: [EphemerisSource] {
            return [
                .customerProvided,
                .spaceTrack,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerProvided: return "CUSTOMER_PROVIDED"
            case .spaceTrack: return "SPACE_TRACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EphemerisSource(rawValue: rawValue) ?? EphemerisSource.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes {
    public enum EphemerisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case error
        case expired
        case invalid
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [EphemerisStatus] {
            return [
                .disabled,
                .enabled,
                .error,
                .expired,
                .invalid,
                .validating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .error: return "ERROR"
            case .expired: return "EXPIRED"
            case .invalid: return "INVALID"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EphemerisStatus(rawValue: rawValue) ?? EphemerisStatus.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.EphemerisTypeDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oem
        case sdkUnknown
        case tle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .oem(oem):
                try container.encode(oem, forKey: .oem)
            case let .tle(tle):
                try container.encode(tle, forKey: .tle)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tleDecoded = try values.decodeIfPresent(GroundStationClientTypes.EphemerisDescription.self, forKey: .tle)
        if let tle = tleDecoded {
            self = .tle(tle)
            return
        }
        let oemDecoded = try values.decodeIfPresent(GroundStationClientTypes.EphemerisDescription.self, forKey: .oem)
        if let oem = oemDecoded {
            self = .oem(oem)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    ///
    public enum EphemerisTypeDescription: Swift.Equatable {
        /// Description of ephemeris.
        case tle(GroundStationClientTypes.EphemerisDescription)
        /// Description of ephemeris.
        case oem(GroundStationClientTypes.EphemerisDescription)
        case sdkUnknown(Swift.String)
    }

}

extension GroundStationClientTypes.Frequency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = self.units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.FrequencyUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that describes the frequency.
    public struct Frequency: Swift.Equatable {
        /// Frequency units.
        /// This member is required.
        public var units: GroundStationClientTypes.FrequencyUnits?
        /// Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            units: GroundStationClientTypes.FrequencyUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes.FrequencyBandwidth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case units
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let units = self.units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .value)
        value = valueDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.BandwidthUnits.self, forKey: .units)
        units = unitsDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that describes the frequency bandwidth.
    public struct FrequencyBandwidth: Swift.Equatable {
        /// Frequency bandwidth units.
        /// This member is required.
        public var units: GroundStationClientTypes.BandwidthUnits?
        /// Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:
        ///
        /// * For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.
        ///
        /// * For AntennaDownlinkconfig, valid values are between 10 kHz to 54 MHz.
        ///
        /// * For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            units: GroundStationClientTypes.BandwidthUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }

}

extension GroundStationClientTypes {
    public enum FrequencyUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [FrequencyUnits] {
            return [
                .ghz,
                .khz,
                .mhz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FrequencyUnits(rawValue: rawValue) ?? FrequencyUnits.sdkUnknown(rawValue)
        }
    }
}

extension GetAgentConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let agentId = agentId else {
            return nil
        }
        return "/agent/\(agentId.urlPercentEncoding())/configuration"
    }
}

public struct GetAgentConfigurationInput: Swift.Equatable {
    /// UUID of agent to get configuration information for.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

struct GetAgentConfigurationInputBody: Swift.Equatable {
}

extension GetAgentConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentId = output.agentId
            self.taskingDocument = output.taskingDocument
        } else {
            self.agentId = nil
            self.taskingDocument = nil
        }
    }
}

public struct GetAgentConfigurationOutput: Swift.Equatable {
    /// UUID of agent.
    public var agentId: Swift.String?
    /// Tasking document for agent.
    public var taskingDocument: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        taskingDocument: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.taskingDocument = taskingDocument
    }
}

struct GetAgentConfigurationOutputBody: Swift.Equatable {
    let agentId: Swift.String?
    let taskingDocument: Swift.String?
}

extension GetAgentConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case taskingDocument
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let taskingDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskingDocument)
        taskingDocument = taskingDocumentDecoded
    }
}

enum GetAgentConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configType = configType else {
            return nil
        }
        guard let configId = configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

///
public struct GetConfigInput: Swift.Equatable {
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

struct GetConfigInputBody: Swift.Equatable {
}

extension GetConfigInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configData = output.configData
            self.configId = output.configId
            self.configType = output.configType
            self.name = output.name
            self.tags = output.tags
        } else {
            self.configArn = nil
            self.configData = nil
            self.configId = nil
            self.configType = nil
            self.name = nil
            self.tags = nil
        }
    }
}

///
public struct GetConfigOutput: Swift.Equatable {
    /// ARN of a Config
    /// This member is required.
    public var configArn: Swift.String?
    /// Data elements in a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a Config.
    public var tags: [Swift.String:Swift.String]?

    public init(
        configArn: Swift.String? = nil,
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configArn = configArn
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
        self.tags = tags
    }
}

struct GetConfigOutputBody: Swift.Equatable {
    let configId: Swift.String?
    let configArn: Swift.String?
    let name: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configData: GroundStationClientTypes.ConfigTypeData?
    let tags: [Swift.String:Swift.String]?
}

extension GetConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configData
        case configId
        case configType
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataflowEndpointGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dataflowEndpointGroupId = dataflowEndpointGroupId else {
            return nil
        }
        return "/dataflowEndpointGroup/\(dataflowEndpointGroupId.urlPercentEncoding())"
    }
}

///
public struct GetDataflowEndpointGroupInput: Swift.Equatable {
    /// UUID of a dataflow endpoint group.
    /// This member is required.
    public var dataflowEndpointGroupId: Swift.String?

    public init(
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

struct GetDataflowEndpointGroupInputBody: Swift.Equatable {
}

extension GetDataflowEndpointGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataflowEndpointGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataflowEndpointGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactPostPassDurationSeconds = output.contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = output.contactPrePassDurationSeconds
            self.dataflowEndpointGroupArn = output.dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = output.dataflowEndpointGroupId
            self.endpointsDetails = output.endpointsDetails
            self.tags = output.tags
        } else {
            self.contactPostPassDurationSeconds = nil
            self.contactPrePassDurationSeconds = nil
            self.dataflowEndpointGroupArn = nil
            self.dataflowEndpointGroupId = nil
            self.endpointsDetails = nil
            self.tags = nil
        }
    }
}

///
public struct GetDataflowEndpointGroupOutput: Swift.Equatable {
    /// Amount of time, in seconds, after a contact ends that the Ground Station Dataflow Endpoint Group will be in a POSTPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the POSTPASS state.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time, in seconds, before a contact starts that the Ground Station Dataflow Endpoint Group will be in a PREPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the PREPASS state.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// ARN of a dataflow endpoint group.
    public var dataflowEndpointGroupArn: Swift.String?
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?
    /// Details of a dataflow endpoint.
    public var endpointsDetails: [GroundStationClientTypes.EndpointDetails]?
    /// Tags assigned to a dataflow endpoint group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEndpointGroupArn: Swift.String? = nil,
        dataflowEndpointGroupId: Swift.String? = nil,
        endpointsDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
        self.endpointsDetails = endpointsDetails
        self.tags = tags
    }
}

struct GetDataflowEndpointGroupOutputBody: Swift.Equatable {
    let dataflowEndpointGroupId: Swift.String?
    let dataflowEndpointGroupArn: Swift.String?
    let endpointsDetails: [GroundStationClientTypes.EndpointDetails]?
    let tags: [Swift.String:Swift.String]?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
}

extension GetDataflowEndpointGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEndpointGroupArn
        case dataflowEndpointGroupId
        case endpointsDetails
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataflowEndpointGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupId)
        dataflowEndpointGroupId = dataflowEndpointGroupIdDecoded
        let dataflowEndpointGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowEndpointGroupArn)
        dataflowEndpointGroupArn = dataflowEndpointGroupArnDecoded
        let endpointsDetailsContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EndpointDetails?].self, forKey: .endpointsDetails)
        var endpointsDetailsDecoded0:[GroundStationClientTypes.EndpointDetails]? = nil
        if let endpointsDetailsContainer = endpointsDetailsContainer {
            endpointsDetailsDecoded0 = [GroundStationClientTypes.EndpointDetails]()
            for structure0 in endpointsDetailsContainer {
                if let structure0 = structure0 {
                    endpointsDetailsDecoded0?.append(structure0)
                }
            }
        }
        endpointsDetails = endpointsDetailsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
    }
}

enum GetDataflowEndpointGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMinuteUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case month
        case year
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let month = self.month {
            try encodeContainer.encode(month, forKey: .month)
        }
        if let year = self.year {
            try encodeContainer.encode(year, forKey: .year)
        }
    }
}

extension GetMinuteUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/minute-usage"
    }
}

///
public struct GetMinuteUsageInput: Swift.Equatable {
    /// The month being requested, with a value of 1-12.
    /// This member is required.
    public var month: Swift.Int?
    /// The year being requested, in the format of YYYY.
    /// This member is required.
    public var year: Swift.Int?

    public init(
        month: Swift.Int? = nil,
        year: Swift.Int? = nil
    )
    {
        self.month = month
        self.year = year
    }
}

struct GetMinuteUsageInputBody: Swift.Equatable {
    let month: Swift.Int?
    let year: Swift.Int?
}

extension GetMinuteUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case month
        case year
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .month)
        month = monthDecoded
        let yearDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .year)
        year = yearDecoded
    }
}

extension GetMinuteUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMinuteUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.estimatedMinutesRemaining = output.estimatedMinutesRemaining
            self.isReservedMinutesCustomer = output.isReservedMinutesCustomer
            self.totalReservedMinuteAllocation = output.totalReservedMinuteAllocation
            self.totalScheduledMinutes = output.totalScheduledMinutes
            self.upcomingMinutesScheduled = output.upcomingMinutesScheduled
        } else {
            self.estimatedMinutesRemaining = nil
            self.isReservedMinutesCustomer = nil
            self.totalReservedMinuteAllocation = nil
            self.totalScheduledMinutes = nil
            self.upcomingMinutesScheduled = nil
        }
    }
}

///
public struct GetMinuteUsageOutput: Swift.Equatable {
    /// Estimated number of minutes remaining for an account, specific to the month being requested.
    public var estimatedMinutesRemaining: Swift.Int?
    /// Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.
    public var isReservedMinutesCustomer: Swift.Bool?
    /// Total number of reserved minutes allocated, specific to the month being requested.
    public var totalReservedMinuteAllocation: Swift.Int?
    /// Total scheduled minutes for an account, specific to the month being requested.
    public var totalScheduledMinutes: Swift.Int?
    /// Upcoming minutes scheduled for an account, specific to the month being requested.
    public var upcomingMinutesScheduled: Swift.Int?

    public init(
        estimatedMinutesRemaining: Swift.Int? = nil,
        isReservedMinutesCustomer: Swift.Bool? = nil,
        totalReservedMinuteAllocation: Swift.Int? = nil,
        totalScheduledMinutes: Swift.Int? = nil,
        upcomingMinutesScheduled: Swift.Int? = nil
    )
    {
        self.estimatedMinutesRemaining = estimatedMinutesRemaining
        self.isReservedMinutesCustomer = isReservedMinutesCustomer
        self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
        self.totalScheduledMinutes = totalScheduledMinutes
        self.upcomingMinutesScheduled = upcomingMinutesScheduled
    }
}

struct GetMinuteUsageOutputBody: Swift.Equatable {
    let isReservedMinutesCustomer: Swift.Bool?
    let totalReservedMinuteAllocation: Swift.Int?
    let upcomingMinutesScheduled: Swift.Int?
    let totalScheduledMinutes: Swift.Int?
    let estimatedMinutesRemaining: Swift.Int?
}

extension GetMinuteUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMinutesRemaining
        case isReservedMinutesCustomer
        case totalReservedMinuteAllocation
        case totalScheduledMinutes
        case upcomingMinutesScheduled
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isReservedMinutesCustomerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isReservedMinutesCustomer)
        isReservedMinutesCustomer = isReservedMinutesCustomerDecoded
        let totalReservedMinuteAllocationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalReservedMinuteAllocation)
        totalReservedMinuteAllocation = totalReservedMinuteAllocationDecoded
        let upcomingMinutesScheduledDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .upcomingMinutesScheduled)
        upcomingMinutesScheduled = upcomingMinutesScheduledDecoded
        let totalScheduledMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalScheduledMinutes)
        totalScheduledMinutes = totalScheduledMinutesDecoded
        let estimatedMinutesRemainingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedMinutesRemaining)
        estimatedMinutesRemaining = estimatedMinutesRemainingDecoded
    }
}

enum GetMinuteUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let missionProfileId = missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

///
public struct GetMissionProfileInput: Swift.Equatable {
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct GetMissionProfileInputBody: Swift.Equatable {
}

extension GetMissionProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMissionProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMissionProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactPostPassDurationSeconds = output.contactPostPassDurationSeconds
            self.contactPrePassDurationSeconds = output.contactPrePassDurationSeconds
            self.dataflowEdges = output.dataflowEdges
            self.minimumViableContactDurationSeconds = output.minimumViableContactDurationSeconds
            self.missionProfileArn = output.missionProfileArn
            self.missionProfileId = output.missionProfileId
            self.name = output.name
            self.region = output.region
            self.streamsKmsKey = output.streamsKmsKey
            self.streamsKmsRole = output.streamsKmsRole
            self.tags = output.tags
            self.trackingConfigArn = output.trackingConfigArn
        } else {
            self.contactPostPassDurationSeconds = nil
            self.contactPrePassDurationSeconds = nil
            self.dataflowEdges = nil
            self.minimumViableContactDurationSeconds = nil
            self.missionProfileArn = nil
            self.missionProfileId = nil
            self.name = nil
            self.region = nil
            self.streamsKmsKey = nil
            self.streamsKmsRole = nil
            self.tags = nil
            self.trackingConfigArn = nil
        }
    }
}

///
public struct GetMissionProfileOutput: Swift.Equatable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?
    /// Name of a mission profile.
    public var name: Swift.String?
    /// Region of a mission profile.
    public var region: Swift.String?
    /// KMS key to use for encrypting streams.
    public var streamsKmsKey: GroundStationClientTypes.KmsKey?
    /// Role to use for encrypting streams with KMS key.
    public var streamsKmsRole: Swift.String?
    /// Tags assigned to a mission profile.
    public var tags: [Swift.String:Swift.String]?
    /// ARN of a tracking Config.
    public var trackingConfigArn: Swift.String?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        streamsKmsKey: GroundStationClientTypes.KmsKey? = nil,
        streamsKmsRole: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileArn = missionProfileArn
        self.missionProfileId = missionProfileId
        self.name = name
        self.region = region
        self.streamsKmsKey = streamsKmsKey
        self.streamsKmsRole = streamsKmsRole
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

struct GetMissionProfileOutputBody: Swift.Equatable {
    let missionProfileId: Swift.String?
    let missionProfileArn: Swift.String?
    let name: Swift.String?
    let region: Swift.String?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
    let minimumViableContactDurationSeconds: Swift.Int?
    let dataflowEdges: [[Swift.String]]?
    let trackingConfigArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let streamsKmsKey: GroundStationClientTypes.KmsKey?
    let streamsKmsRole: Swift.String?
}

extension GetMissionProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case missionProfileArn
        case missionProfileId
        case name
        case region
        case streamsKmsKey
        case streamsKmsRole
        case tags
        case trackingConfigArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let streamsKmsKeyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.KmsKey.self, forKey: .streamsKmsKey)
        streamsKmsKey = streamsKmsKeyDecoded
        let streamsKmsRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamsKmsRole)
        streamsKmsRole = streamsKmsRoleDecoded
    }
}

enum GetMissionProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSatelliteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let satelliteId = satelliteId else {
            return nil
        }
        return "/satellite/\(satelliteId.urlPercentEncoding())"
    }
}

///
public struct GetSatelliteInput: Swift.Equatable {
    /// UUID of a satellite.
    /// This member is required.
    public var satelliteId: Swift.String?

    public init(
        satelliteId: Swift.String? = nil
    )
    {
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteInputBody: Swift.Equatable {
}

extension GetSatelliteInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSatelliteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSatelliteOutputBody = try responseDecoder.decode(responseBody: data)
            self.currentEphemeris = output.currentEphemeris
            self.groundStations = output.groundStations
            self.noradSatelliteID = output.noradSatelliteID
            self.satelliteArn = output.satelliteArn
            self.satelliteId = output.satelliteId
        } else {
            self.currentEphemeris = nil
            self.groundStations = nil
            self.noradSatelliteID = 0
            self.satelliteArn = nil
            self.satelliteId = nil
        }
    }
}

///
public struct GetSatelliteOutput: Swift.Equatable {
    /// The current ephemeris being used to compute the trajectory of the satellite.
    public var currentEphemeris: GroundStationClientTypes.EphemerisMetaData?
    /// A list of ground stations to which the satellite is on-boarded.
    public var groundStations: [Swift.String]?
    /// NORAD satellite ID number.
    public var noradSatelliteID: Swift.Int
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// UUID of a satellite.
    public var satelliteId: Swift.String?

    public init(
        currentEphemeris: GroundStationClientTypes.EphemerisMetaData? = nil,
        groundStations: [Swift.String]? = nil,
        noradSatelliteID: Swift.Int = 0,
        satelliteArn: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.currentEphemeris = currentEphemeris
        self.groundStations = groundStations
        self.noradSatelliteID = noradSatelliteID
        self.satelliteArn = satelliteArn
        self.satelliteId = satelliteId
    }
}

struct GetSatelliteOutputBody: Swift.Equatable {
    let satelliteId: Swift.String?
    let satelliteArn: Swift.String?
    let noradSatelliteID: Swift.Int
    let groundStations: [Swift.String]?
    let currentEphemeris: GroundStationClientTypes.EphemerisMetaData?
}

extension GetSatelliteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentEphemeris
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noradSatelliteID) ?? 0
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[Swift.String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [Swift.String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
        let currentEphemerisDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisMetaData.self, forKey: .currentEphemeris)
        currentEphemeris = currentEphemerisDecoded
    }
}

enum GetSatelliteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GroundStationClientTypes.GroundStationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStationId
        case groundStationName
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundStationId = self.groundStationId {
            try encodeContainer.encode(groundStationId, forKey: .groundStationId)
        }
        if let groundStationName = self.groundStationName {
            try encodeContainer.encode(groundStationName, forKey: .groundStationName)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groundStationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStationId)
        groundStationId = groundStationIdDecoded
        let groundStationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStationName)
        groundStationName = groundStationNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the ground station data.
    public struct GroundStationData: Swift.Equatable {
        /// UUID of a ground station.
        public var groundStationId: Swift.String?
        /// Name of a ground station.
        public var groundStationName: Swift.String?
        /// Ground station Region.
        public var region: Swift.String?

        public init(
            groundStationId: Swift.String? = nil,
            groundStationName: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.groundStationId = groundStationId
            self.groundStationName = groundStationName
            self.region = region
        }
    }

}

extension GroundStationClientTypes.IntegerRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximum
        case minimum
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximum = self.maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = self.minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimum)
        minimum = minimumDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximum)
        maximum = maximumDecoded
    }
}

extension GroundStationClientTypes {
    /// An integer range that has a minimum and maximum value.
    public struct IntegerRange: Swift.Equatable {
        /// A maximum value.
        /// This member is required.
        public var maximum: Swift.Int?
        /// A minimum value.
        /// This member is required.
        public var minimum: Swift.Int?

        public init(
            maximum: Swift.Int? = nil,
            minimum: Swift.Int? = nil
        )
        {
            self.maximum = maximum
            self.minimum = minimum
        }
    }

}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.parameterName = output.parameterName
        } else {
            self.properties.message = nil
            self.properties.parameterName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameters are not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var parameterName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterName = parameterName
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension GroundStationClientTypes.KmsKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsaliasarn = "kmsAliasArn"
        case kmskeyarn = "kmsKeyArn"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .kmsaliasarn(kmsaliasarn):
                try container.encode(kmsaliasarn, forKey: .kmsaliasarn)
            case let .kmskeyarn(kmskeyarn):
                try container.encode(kmskeyarn, forKey: .kmskeyarn)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let kmskeyarnDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .kmskeyarn)
        if let kmskeyarn = kmskeyarnDecoded {
            self = .kmskeyarn(kmskeyarn)
            return
        }
        let kmsaliasarnDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .kmsaliasarn)
        if let kmsaliasarn = kmsaliasarnDecoded {
            self = .kmsaliasarn(kmsaliasarn)
            return
        }
        self = .sdkUnknown("")
    }
}

extension GroundStationClientTypes {
    /// AWS Key Management Service (KMS) Key.
    public enum KmsKey: Swift.Equatable {
        /// KMS Key Arn.
        case kmskeyarn(Swift.String)
        /// KMS Alias Arn.
        case kmsaliasarn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension ListConfigsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/config"
    }
}

///
public struct ListConfigsInput: Swift.Equatable {
    /// Maximum number of Configs returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListConfigs call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigsInputBody: Swift.Equatable {
}

extension ListConfigsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfigsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configList = output.configList
            self.nextToken = output.nextToken
        } else {
            self.configList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListConfigsOutput: Swift.Equatable {
    /// List of Config items.
    public var configList: [GroundStationClientTypes.ConfigListItem]?
    /// Next token returned in the response of a previous ListConfigs call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        configList: [GroundStationClientTypes.ConfigListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configList = configList
        self.nextToken = nextToken
    }
}

struct ListConfigsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let configList: [GroundStationClientTypes.ConfigListItem]?
}

extension ListConfigsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let configListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ConfigListItem?].self, forKey: .configList)
        var configListDecoded0:[GroundStationClientTypes.ConfigListItem]? = nil
        if let configListContainer = configListContainer {
            configListDecoded0 = [GroundStationClientTypes.ConfigListItem]()
            for structure0 in configListContainer {
                if let structure0 = structure0 {
                    configListDecoded0?.append(structure0)
                }
            }
        }
        configList = configListDecoded0
    }
}

enum ListConfigsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListContactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let groundStation = self.groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let missionProfileArn = self.missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let satelliteArn = self.satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statusList = statusList {
            var statusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusList)
            for contactstatus0 in statusList {
                try statusListContainer.encode(contactstatus0.rawValue)
            }
        }
    }
}

extension ListContactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contacts"
    }
}

///
public struct ListContactsInput: Swift.Equatable {
    /// End time of a contact in UTC.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Name of a ground station.
    public var groundStation: Swift.String?
    /// Maximum number of contacts returned.
    public var maxResults: Swift.Int?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// Next token returned in the request of a previous ListContacts call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// Start time of a contact in UTC.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// Status of a contact reservation.
    /// This member is required.
    public var statusList: [GroundStationClientTypes.ContactStatus]?

    public init(
        endTime: ClientRuntime.Date? = nil,
        groundStation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        statusList: [GroundStationClientTypes.ContactStatus]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.maxResults = maxResults
        self.missionProfileArn = missionProfileArn
        self.nextToken = nextToken
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.statusList = statusList
    }
}

struct ListContactsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let statusList: [GroundStationClientTypes.ContactStatus]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let groundStation: Swift.String?
    let satelliteArn: Swift.String?
    let missionProfileArn: Swift.String?
}

extension ListContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case maxResults
        case missionProfileArn
        case nextToken
        case satelliteArn
        case startTime
        case statusList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let statusListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ContactStatus?].self, forKey: .statusList)
        var statusListDecoded0:[GroundStationClientTypes.ContactStatus]? = nil
        if let statusListContainer = statusListContainer {
            statusListDecoded0 = [GroundStationClientTypes.ContactStatus]()
            for string0 in statusListContainer {
                if let string0 = string0 {
                    statusListDecoded0?.append(string0)
                }
            }
        }
        statusList = statusListDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
    }
}

extension ListContactsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContactsOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactList = output.contactList
            self.nextToken = output.nextToken
        } else {
            self.contactList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListContactsOutput: Swift.Equatable {
    /// List of contacts.
    public var contactList: [GroundStationClientTypes.ContactData]?
    /// Next token returned in the response of a previous ListContacts call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        contactList: [GroundStationClientTypes.ContactData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactList = contactList
        self.nextToken = nextToken
    }
}

struct ListContactsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let contactList: [GroundStationClientTypes.ContactData]?
}

extension ListContactsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ContactData?].self, forKey: .contactList)
        var contactListDecoded0:[GroundStationClientTypes.ContactData]? = nil
        if let contactListContainer = contactListContainer {
            contactListDecoded0 = [GroundStationClientTypes.ContactData]()
            for structure0 in contactListContainer {
                if let structure0 = structure0 {
                    contactListDecoded0?.append(structure0)
                }
            }
        }
        contactList = contactListDecoded0
    }
}

enum ListContactsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataflowEndpointGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListDataflowEndpointGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dataflowEndpointGroup"
    }
}

///
public struct ListDataflowEndpointGroupsInput: Swift.Equatable {
    /// Maximum number of dataflow endpoint groups returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsInputBody: Swift.Equatable {
}

extension ListDataflowEndpointGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataflowEndpointGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataflowEndpointGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataflowEndpointGroupList = output.dataflowEndpointGroupList
            self.nextToken = output.nextToken
        } else {
            self.dataflowEndpointGroupList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListDataflowEndpointGroupsOutput: Swift.Equatable {
    /// A list of dataflow endpoint groups.
    public var dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]?
    /// Next token returned in the response of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupList = dataflowEndpointGroupList
        self.nextToken = nextToken
    }
}

struct ListDataflowEndpointGroupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]?
}

extension ListDataflowEndpointGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataflowEndpointGroupList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dataflowEndpointGroupListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.DataflowEndpointListItem?].self, forKey: .dataflowEndpointGroupList)
        var dataflowEndpointGroupListDecoded0:[GroundStationClientTypes.DataflowEndpointListItem]? = nil
        if let dataflowEndpointGroupListContainer = dataflowEndpointGroupListContainer {
            dataflowEndpointGroupListDecoded0 = [GroundStationClientTypes.DataflowEndpointListItem]()
            for structure0 in dataflowEndpointGroupListContainer {
                if let structure0 = structure0 {
                    dataflowEndpointGroupListDecoded0?.append(structure0)
                }
            }
        }
        dataflowEndpointGroupList = dataflowEndpointGroupListDecoded0
    }
}

enum ListDataflowEndpointGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEphemeridesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case satelliteId
        case startTime
        case statusList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let satelliteId = self.satelliteId {
            try encodeContainer.encode(satelliteId, forKey: .satelliteId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statusList = statusList {
            var statusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusList)
            for ephemerisstatus0 in statusList {
                try statusListContainer.encode(ephemerisstatus0.rawValue)
            }
        }
    }
}

extension ListEphemeridesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListEphemeridesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ephemerides"
    }
}

public struct ListEphemeridesInput: Swift.Equatable {
    /// The end time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Maximum number of ephemerides to return.
    public var maxResults: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The AWS Ground Station satellite ID to list ephemeris for.
    /// This member is required.
    public var satelliteId: Swift.String?
    /// The start time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The list of ephemeris status to return.
    public var statusList: [GroundStationClientTypes.EphemerisStatus]?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        satelliteId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        statusList: [GroundStationClientTypes.EphemerisStatus]? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.satelliteId = satelliteId
        self.startTime = startTime
        self.statusList = statusList
    }
}

struct ListEphemeridesInputBody: Swift.Equatable {
    let satelliteId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let statusList: [GroundStationClientTypes.EphemerisStatus]?
}

extension ListEphemeridesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case satelliteId
        case startTime
        case statusList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EphemerisStatus?].self, forKey: .statusList)
        var statusListDecoded0:[GroundStationClientTypes.EphemerisStatus]? = nil
        if let statusListContainer = statusListContainer {
            statusListDecoded0 = [GroundStationClientTypes.EphemerisStatus]()
            for string0 in statusListContainer {
                if let string0 = string0 {
                    statusListDecoded0?.append(string0)
                }
            }
        }
        statusList = statusListDecoded0
    }
}

extension ListEphemeridesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEphemeridesOutputBody = try responseDecoder.decode(responseBody: data)
            self.ephemerides = output.ephemerides
            self.nextToken = output.nextToken
        } else {
            self.ephemerides = nil
            self.nextToken = nil
        }
    }
}

public struct ListEphemeridesOutput: Swift.Equatable {
    /// List of ephemerides.
    public var ephemerides: [GroundStationClientTypes.EphemerisItem]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        ephemerides: [GroundStationClientTypes.EphemerisItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ephemerides = ephemerides
        self.nextToken = nextToken
    }
}

struct ListEphemeridesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let ephemerides: [GroundStationClientTypes.EphemerisItem]?
}

extension ListEphemeridesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerides
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let ephemeridesContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.EphemerisItem?].self, forKey: .ephemerides)
        var ephemeridesDecoded0:[GroundStationClientTypes.EphemerisItem]? = nil
        if let ephemeridesContainer = ephemeridesContainer {
            ephemeridesDecoded0 = [GroundStationClientTypes.EphemerisItem]()
            for structure0 in ephemeridesContainer {
                if let structure0 = structure0 {
                    ephemeridesDecoded0?.append(structure0)
                }
            }
        }
        ephemerides = ephemeridesDecoded0
    }
}

enum ListEphemeridesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroundStationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let satelliteId = satelliteId {
                let satelliteIdQueryItem = ClientRuntime.URLQueryItem(name: "satelliteId".urlPercentEncoding(), value: Swift.String(satelliteId).urlPercentEncoding())
                items.append(satelliteIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListGroundStationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/groundstation"
    }
}

///
public struct ListGroundStationsInput: Swift.Equatable {
    /// Maximum number of ground stations returned.
    public var maxResults: Swift.Int?
    /// Next token that can be supplied in the next call to get the next page of ground stations.
    public var nextToken: Swift.String?
    /// Satellite ID to retrieve on-boarded ground stations.
    public var satelliteId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.satelliteId = satelliteId
    }
}

struct ListGroundStationsInputBody: Swift.Equatable {
}

extension ListGroundStationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGroundStationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroundStationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.groundStationList = output.groundStationList
            self.nextToken = output.nextToken
        } else {
            self.groundStationList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListGroundStationsOutput: Swift.Equatable {
    /// List of ground stations.
    public var groundStationList: [GroundStationClientTypes.GroundStationData]?
    /// Next token that can be supplied in the next call to get the next page of ground stations.
    public var nextToken: Swift.String?

    public init(
        groundStationList: [GroundStationClientTypes.GroundStationData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groundStationList = groundStationList
        self.nextToken = nextToken
    }
}

struct ListGroundStationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let groundStationList: [GroundStationClientTypes.GroundStationData]?
}

extension ListGroundStationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groundStationList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let groundStationListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.GroundStationData?].self, forKey: .groundStationList)
        var groundStationListDecoded0:[GroundStationClientTypes.GroundStationData]? = nil
        if let groundStationListContainer = groundStationListContainer {
            groundStationListDecoded0 = [GroundStationClientTypes.GroundStationData]()
            for structure0 in groundStationListContainer {
                if let structure0 = structure0 {
                    groundStationListDecoded0?.append(structure0)
                }
            }
        }
        groundStationList = groundStationListDecoded0
    }
}

enum ListGroundStationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMissionProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListMissionProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/missionprofile"
    }
}

///
public struct ListMissionProfilesInput: Swift.Equatable {
    /// Maximum number of mission profiles returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListMissionProfiles call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesInputBody: Swift.Equatable {
}

extension ListMissionProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMissionProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMissionProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileList = output.missionProfileList
            self.nextToken = output.nextToken
        } else {
            self.missionProfileList = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListMissionProfilesOutput: Swift.Equatable {
    /// List of mission profiles.
    public var missionProfileList: [GroundStationClientTypes.MissionProfileListItem]?
    /// Next token returned in the response of a previous ListMissionProfiles call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        missionProfileList: [GroundStationClientTypes.MissionProfileListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.missionProfileList = missionProfileList
        self.nextToken = nextToken
    }
}

struct ListMissionProfilesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let missionProfileList: [GroundStationClientTypes.MissionProfileListItem]?
}

extension ListMissionProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let missionProfileListContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.MissionProfileListItem?].self, forKey: .missionProfileList)
        var missionProfileListDecoded0:[GroundStationClientTypes.MissionProfileListItem]? = nil
        if let missionProfileListContainer = missionProfileListContainer {
            missionProfileListDecoded0 = [GroundStationClientTypes.MissionProfileListItem]()
            for structure0 in missionProfileListContainer {
                if let structure0 = structure0 {
                    missionProfileListDecoded0?.append(structure0)
                }
            }
        }
        missionProfileList = missionProfileListDecoded0
    }
}

enum ListMissionProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSatellitesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSatellitesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/satellite"
    }
}

///
public struct ListSatellitesInput: Swift.Equatable {
    /// Maximum number of satellites returned.
    public var maxResults: Swift.Int?
    /// Next token that can be supplied in the next call to get the next page of satellites.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSatellitesInputBody: Swift.Equatable {
}

extension ListSatellitesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSatellitesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSatellitesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.satellites = output.satellites
        } else {
            self.nextToken = nil
            self.satellites = nil
        }
    }
}

///
public struct ListSatellitesOutput: Swift.Equatable {
    /// Next token that can be supplied in the next call to get the next page of satellites.
    public var nextToken: Swift.String?
    /// List of satellites.
    public var satellites: [GroundStationClientTypes.SatelliteListItem]?

    public init(
        nextToken: Swift.String? = nil,
        satellites: [GroundStationClientTypes.SatelliteListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.satellites = satellites
    }
}

struct ListSatellitesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let satellites: [GroundStationClientTypes.SatelliteListItem]?
}

extension ListSatellitesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case satellites
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let satellitesContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.SatelliteListItem?].self, forKey: .satellites)
        var satellitesDecoded0:[GroundStationClientTypes.SatelliteListItem]? = nil
        if let satellitesContainer = satellitesContainer {
            satellitesDecoded0 = [GroundStationClientTypes.SatelliteListItem]()
            for structure0 in satellitesContainer {
                if let structure0 = structure0 {
                    satellitesDecoded0?.append(structure0)
                }
            }
        }
        satellites = satellitesDecoded0
    }
}

enum ListSatellitesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct ListTagsForResourceInput: Swift.Equatable {
    /// ARN of a resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

///
public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Tags assigned to a resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GroundStationClientTypes.MissionProfileListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileArn
        case missionProfileId
        case name
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let missionProfileArn = self.missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let missionProfileId = self.missionProfileId {
            try encodeContainer.encode(missionProfileId, forKey: .missionProfileId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GroundStationClientTypes {
    /// Item in a list of mission profiles.
    public struct MissionProfileListItem: Swift.Equatable {
        /// ARN of a mission profile.
        public var missionProfileArn: Swift.String?
        /// UUID of a mission profile.
        public var missionProfileId: Swift.String?
        /// Name of a mission profile.
        public var name: Swift.String?
        /// Region of a mission profile.
        public var region: Swift.String?

        public init(
            missionProfileArn: Swift.String? = nil,
            missionProfileId: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
        }
    }

}

extension GroundStationClientTypes.OEMEphemeris: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oemData
        case s3Object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oemData = self.oemData {
            try encodeContainer.encode(oemData, forKey: .oemData)
        }
        if let s3Object = self.s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
        let oemDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oemData)
        oemData = oemDataDecoded
    }
}

extension GroundStationClientTypes {
    /// Ephemeris data in Orbit Ephemeris Message (OEM) format.
    public struct OEMEphemeris: Swift.Equatable {
        /// The data for an OEM ephemeris, supplied directly in the request rather than through an S3 object.
        public var oemData: Swift.String?
        /// Identifies the S3 object to be used as the ephemeris.
        public var s3Object: GroundStationClientTypes.S3Object?

        public init(
            oemData: Swift.String? = nil,
            s3Object: GroundStationClientTypes.S3Object? = nil
        )
        {
            self.oemData = oemData
            self.s3Object = s3Object
        }
    }

}

extension GroundStationClientTypes {
    public enum Polarization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case leftHand
        case `none`
        case rightHand
        case sdkUnknown(Swift.String)

        public static var allCases: [Polarization] {
            return [
                .leftHand,
                .none,
                .rightHand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .leftHand: return "LEFT_HAND"
            case .none: return "NONE"
            case .rightHand: return "RIGHT_HAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Polarization(rawValue: rawValue) ?? Polarization.sdkUnknown(rawValue)
        }
    }
}

extension GroundStationClientTypes.RangedConnectionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mtu
        case socketAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mtu = self.mtu {
            try encodeContainer.encode(mtu, forKey: .mtu)
        }
        if let socketAddress = self.socketAddress {
            try encodeContainer.encode(socketAddress, forKey: .socketAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let socketAddressDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.RangedSocketAddress.self, forKey: .socketAddress)
        socketAddress = socketAddressDecoded
        let mtuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mtu)
        mtu = mtuDecoded
    }
}

extension GroundStationClientTypes {
    /// Ingress address of AgentEndpoint with a port range and an optional mtu.
    public struct RangedConnectionDetails: Swift.Equatable {
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public var mtu: Swift.Int?
        /// A ranged socket address.
        /// This member is required.
        public var socketAddress: GroundStationClientTypes.RangedSocketAddress?

        public init(
            mtu: Swift.Int? = nil,
            socketAddress: GroundStationClientTypes.RangedSocketAddress? = nil
        )
        {
            self.mtu = mtu
            self.socketAddress = socketAddress
        }
    }

}

extension GroundStationClientTypes.RangedSocketAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case portRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let portRange = self.portRange {
            try encodeContainer.encode(portRange, forKey: .portRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let portRangeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.IntegerRange.self, forKey: .portRange)
        portRange = portRangeDecoded
    }
}

extension GroundStationClientTypes {
    /// A socket address with a port range.
    public struct RangedSocketAddress: Swift.Equatable {
        /// IPv4 socket address.
        /// This member is required.
        public var name: Swift.String?
        /// Port range of a socket address.
        /// This member is required.
        public var portRange: GroundStationClientTypes.IntegerRange?

        public init(
            name: Swift.String? = nil,
            portRange: GroundStationClientTypes.IntegerRange? = nil
        )
        {
            self.name = name
            self.portRange = portRange
        }
    }

}

extension RegisterAgentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentDetails
        case discoveryData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentDetails = self.agentDetails {
            try encodeContainer.encode(agentDetails, forKey: .agentDetails)
        }
        if let discoveryData = self.discoveryData {
            try encodeContainer.encode(discoveryData, forKey: .discoveryData)
        }
    }
}

extension RegisterAgentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/agent"
    }
}

public struct RegisterAgentInput: Swift.Equatable {
    /// Detailed information about the agent being registered.
    /// This member is required.
    public var agentDetails: GroundStationClientTypes.AgentDetails?
    /// Data for associating an agent with the capabilities it is managing.
    /// This member is required.
    public var discoveryData: GroundStationClientTypes.DiscoveryData?

    public init(
        agentDetails: GroundStationClientTypes.AgentDetails? = nil,
        discoveryData: GroundStationClientTypes.DiscoveryData? = nil
    )
    {
        self.agentDetails = agentDetails
        self.discoveryData = discoveryData
    }
}

struct RegisterAgentInputBody: Swift.Equatable {
    let discoveryData: GroundStationClientTypes.DiscoveryData?
    let agentDetails: GroundStationClientTypes.AgentDetails?
}

extension RegisterAgentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentDetails
        case discoveryData
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let discoveryDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.DiscoveryData.self, forKey: .discoveryData)
        discoveryData = discoveryDataDecoded
        let agentDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AgentDetails.self, forKey: .agentDetails)
        agentDetails = agentDetailsDecoded
    }
}

extension RegisterAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentId = output.agentId
        } else {
            self.agentId = nil
        }
    }
}

public struct RegisterAgentOutput: Swift.Equatable {
    /// UUID of registered agent.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

struct RegisterAgentOutputBody: Swift.Equatable {
    let agentId: Swift.String?
}

extension RegisterAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
    }
}

enum RegisterAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReserveContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let groundStation = self.groundStation {
            try encodeContainer.encode(groundStation, forKey: .groundStation)
        }
        if let missionProfileArn = self.missionProfileArn {
            try encodeContainer.encode(missionProfileArn, forKey: .missionProfileArn)
        }
        if let satelliteArn = self.satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ReserveContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/contact"
    }
}

///
public struct ReserveContactInput: Swift.Equatable {
    /// End time of a contact in UTC.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// Name of a ground station.
    /// This member is required.
    public var groundStation: Swift.String?
    /// ARN of a mission profile.
    /// This member is required.
    public var missionProfileArn: Swift.String?
    /// ARN of a satellite
    /// This member is required.
    public var satelliteArn: Swift.String?
    /// Start time of a contact in UTC.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// Tags assigned to a contact.
    public var tags: [Swift.String:Swift.String]?

    public init(
        endTime: ClientRuntime.Date? = nil,
        groundStation: Swift.String? = nil,
        missionProfileArn: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.missionProfileArn = missionProfileArn
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

struct ReserveContactInputBody: Swift.Equatable {
    let missionProfileArn: Swift.String?
    let satelliteArn: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let groundStation: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ReserveContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case groundStation
        case missionProfileArn
        case satelliteArn
        case startTime
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileArn)
        missionProfileArn = missionProfileArnDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let groundStationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groundStation)
        groundStation = groundStationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ReserveContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReserveContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactId = output.contactId
        } else {
            self.contactId = nil
        }
    }
}

///
public struct ReserveContactOutput: Swift.Equatable {
    /// UUID of a contact.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct ReserveContactOutputBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension ReserveContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

enum ReserveContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.parameterName = output.parameterName
        } else {
            self.properties.message = nil
            self.properties.parameterName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Account limits for this resource have been exceeded.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var parameterName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterName = parameterName
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case parameterName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GroundStationClientTypes.S3Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GroundStationClientTypes {
    /// Object stored in S3 containing ephemeris data.
    public struct S3Object: Swift.Equatable {
        /// An Amazon S3 Bucket name.
        public var bucket: Swift.String?
        /// An Amazon S3 key for the ephemeris.
        public var key: Swift.String?
        /// For versioned S3 objects, the version to use for the ephemeris.
        public var version: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.version = version
        }
    }

}

extension GroundStationClientTypes.S3RecordingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case `prefix` = "prefix"
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about an S3 recording Config.
    public struct S3RecordingConfig: Swift.Equatable {
        /// ARN of the bucket to record to.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// S3 Key prefix to prefice data files.
        public var `prefix`: Swift.String?
        /// ARN of the role Ground Station assumes to write data to the bucket.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            bucketArn: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.`prefix` = `prefix`
            self.roleArn = roleArn
        }
    }

}

extension GroundStationClientTypes.S3RecordingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case keyTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let keyTemplate = self.keyTemplate {
            try encodeContainer.encode(keyTemplate, forKey: .keyTemplate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let keyTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyTemplate)
        keyTemplate = keyTemplateDecoded
    }
}

extension GroundStationClientTypes {
    /// Details about an S3 recording Config used in a contact.
    public struct S3RecordingDetails: Swift.Equatable {
        /// ARN of the bucket used.
        public var bucketArn: Swift.String?
        /// Key template used for the S3 Recording Configuration
        public var keyTemplate: Swift.String?

        public init(
            bucketArn: Swift.String? = nil,
            keyTemplate: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.keyTemplate = keyTemplate
        }
    }

}

extension GroundStationClientTypes.SatelliteListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentEphemeris
        case groundStations
        case noradSatelliteID
        case satelliteArn
        case satelliteId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentEphemeris = self.currentEphemeris {
            try encodeContainer.encode(currentEphemeris, forKey: .currentEphemeris)
        }
        if let groundStations = groundStations {
            var groundStationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groundStations)
            for groundstationname0 in groundStations {
                try groundStationsContainer.encode(groundstationname0)
            }
        }
        if noradSatelliteID != 0 {
            try encodeContainer.encode(noradSatelliteID, forKey: .noradSatelliteID)
        }
        if let satelliteArn = self.satelliteArn {
            try encodeContainer.encode(satelliteArn, forKey: .satelliteArn)
        }
        if let satelliteId = self.satelliteId {
            try encodeContainer.encode(satelliteId, forKey: .satelliteId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let satelliteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteId)
        satelliteId = satelliteIdDecoded
        let satelliteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .satelliteArn)
        satelliteArn = satelliteArnDecoded
        let noradSatelliteIDDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noradSatelliteID) ?? 0
        noradSatelliteID = noradSatelliteIDDecoded
        let groundStationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groundStations)
        var groundStationsDecoded0:[Swift.String]? = nil
        if let groundStationsContainer = groundStationsContainer {
            groundStationsDecoded0 = [Swift.String]()
            for string0 in groundStationsContainer {
                if let string0 = string0 {
                    groundStationsDecoded0?.append(string0)
                }
            }
        }
        groundStations = groundStationsDecoded0
        let currentEphemerisDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.EphemerisMetaData.self, forKey: .currentEphemeris)
        currentEphemeris = currentEphemerisDecoded
    }
}

extension GroundStationClientTypes {
    /// Item in a list of satellites.
    public struct SatelliteListItem: Swift.Equatable {
        /// The current ephemeris being used to compute the trajectory of the satellite.
        public var currentEphemeris: GroundStationClientTypes.EphemerisMetaData?
        /// A list of ground stations to which the satellite is on-boarded.
        public var groundStations: [Swift.String]?
        /// NORAD satellite ID number.
        public var noradSatelliteID: Swift.Int
        /// ARN of a satellite.
        public var satelliteArn: Swift.String?
        /// UUID of a satellite.
        public var satelliteId: Swift.String?

        public init(
            currentEphemeris: GroundStationClientTypes.EphemerisMetaData? = nil,
            groundStations: [Swift.String]? = nil,
            noradSatelliteID: Swift.Int = 0,
            satelliteArn: Swift.String? = nil,
            satelliteId: Swift.String? = nil
        )
        {
            self.currentEphemeris = currentEphemeris
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }
    }

}

extension GroundStationClientTypes.SecurityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case securityGroupIds
        case subnetIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(string0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about endpoints.
    public struct SecurityDetails: Swift.Equatable {
        /// ARN to a role needed for connecting streams to your instances.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The security groups to attach to the elastic network interfaces.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension GroundStationClientTypes.SocketAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case port
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the socket address.
    public struct SocketAddress: Swift.Equatable {
        /// Name of a socket address.
        /// This member is required.
        public var name: Swift.String?
        /// Port of a socket address.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            name: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.name = name
            self.port = port
        }
    }

}

extension GroundStationClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configDetails
        case configId
        case configType
        case dataflowSourceRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configDetails = self.configDetails {
            try encodeContainer.encode(configDetails, forKey: .configDetails)
        }
        if let configId = self.configId {
            try encodeContainer.encode(configId, forKey: .configId)
        }
        if let configType = self.configType {
            try encodeContainer.encode(configType.rawValue, forKey: .configType)
        }
        if let dataflowSourceRegion = self.dataflowSourceRegion {
            try encodeContainer.encode(dataflowSourceRegion, forKey: .dataflowSourceRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configDetailsDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigDetails.self, forKey: .configDetails)
        configDetails = configDetailsDecoded
        let dataflowSourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataflowSourceRegion)
        dataflowSourceRegion = dataflowSourceRegionDecoded
    }
}

extension GroundStationClientTypes {
    /// Dataflow details for the source side.
    public struct Source: Swift.Equatable {
        /// Additional details for a Config, if type is dataflow-endpoint or antenna-downlink-demod-decode
        public var configDetails: GroundStationClientTypes.ConfigDetails?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Region of a dataflow source.
        public var dataflowSourceRegion: Swift.String?

        public init(
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowSourceRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowSourceRegion = dataflowSourceRegion
        }
    }

}

extension GroundStationClientTypes.SpectrumConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidth
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = self.bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let centerFrequency = self.centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = self.polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.FrequencyBandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that describes a spectral Config.
    public struct SpectrumConfig: Swift.Equatable {
        /// Bandwidth of a spectral Config. AWS Ground Station currently has the following bandwidth limitations:
        ///
        /// * For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.
        ///
        /// * For AntennaDownlinkconfig valid values are between 10 kHz to 54 MHz.
        ///
        /// * For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        /// This member is required.
        public var bandwidth: GroundStationClientTypes.FrequencyBandwidth?
        /// Center frequency of a spectral Config. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        /// This member is required.
        public var centerFrequency: GroundStationClientTypes.Frequency?
        /// Polarization of a spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public var polarization: GroundStationClientTypes.Polarization?

        public init(
            bandwidth: GroundStationClientTypes.FrequencyBandwidth? = nil,
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.bandwidth = bandwidth
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }

}

extension GroundStationClientTypes.TLEData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tleLine1
        case tleLine2
        case validTimeRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tleLine1 = self.tleLine1 {
            try encodeContainer.encode(tleLine1, forKey: .tleLine1)
        }
        if let tleLine2 = self.tleLine2 {
            try encodeContainer.encode(tleLine2, forKey: .tleLine2)
        }
        if let validTimeRange = self.validTimeRange {
            try encodeContainer.encode(validTimeRange, forKey: .validTimeRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tleLine1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tleLine1)
        tleLine1 = tleLine1Decoded
        let tleLine2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tleLine2)
        tleLine2 = tleLine2Decoded
        let validTimeRangeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.TimeRange.self, forKey: .validTimeRange)
        validTimeRange = validTimeRangeDecoded
    }
}

extension GroundStationClientTypes {
    /// Two-line element set (TLE) data.
    public struct TLEData: Swift.Equatable {
        /// First line of two-line element set (TLE) data.
        /// This member is required.
        public var tleLine1: Swift.String?
        /// Second line of two-line element set (TLE) data.
        /// This member is required.
        public var tleLine2: Swift.String?
        /// The valid time range for the TLE. Gaps or overlap are not permitted.
        /// This member is required.
        public var validTimeRange: GroundStationClientTypes.TimeRange?

        public init(
            tleLine1: Swift.String? = nil,
            tleLine2: Swift.String? = nil,
            validTimeRange: GroundStationClientTypes.TimeRange? = nil
        )
        {
            self.tleLine1 = tleLine1
            self.tleLine2 = tleLine2
            self.validTimeRange = validTimeRange
        }
    }

}

extension GroundStationClientTypes.TLEEphemeris: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Object
        case tleData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Object = self.s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
        if let tleData = tleData {
            var tleDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tleData)
            for tledata0 in tleData {
                try tleDataContainer.encode(tledata0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.S3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
        let tleDataContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.TLEData?].self, forKey: .tleData)
        var tleDataDecoded0:[GroundStationClientTypes.TLEData]? = nil
        if let tleDataContainer = tleDataContainer {
            tleDataDecoded0 = [GroundStationClientTypes.TLEData]()
            for structure0 in tleDataContainer {
                if let structure0 = structure0 {
                    tleDataDecoded0?.append(structure0)
                }
            }
        }
        tleData = tleDataDecoded0
    }
}

extension GroundStationClientTypes {
    /// Two-line element set (TLE) ephemeris.
    public struct TLEEphemeris: Swift.Equatable {
        /// Identifies the S3 object to be used as the ephemeris.
        public var s3Object: GroundStationClientTypes.S3Object?
        /// The data for a TLE ephemeris, supplied directly in the request rather than through an S3 object.
        public var tleData: [GroundStationClientTypes.TLEData]?

        public init(
            s3Object: GroundStationClientTypes.S3Object? = nil,
            tleData: [GroundStationClientTypes.TLEData]? = nil
        )
        {
            self.s3Object = s3Object
            self.tleData = tleData
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct TagResourceInput: Swift.Equatable {
    /// ARN of a resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags assigned to a resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

///
public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GroundStationClientTypes.TimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension GroundStationClientTypes {
    /// A time range with a start and end time.
    public struct TimeRange: Swift.Equatable {
        /// Time in UTC at which the time range ends.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// Time in UTC at which the time range starts.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension GroundStationClientTypes.TrackingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autotrack
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autotrack = self.autotrack {
            try encodeContainer.encode(autotrack.rawValue, forKey: .autotrack)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autotrackDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Criticality.self, forKey: .autotrack)
        autotrack = autotrackDecoded
    }
}

extension GroundStationClientTypes {
    /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
    public struct TrackingConfig: Swift.Equatable {
        /// Current setting for autotrack.
        /// This member is required.
        public var autotrack: GroundStationClientTypes.Criticality?

        public init(
            autotrack: GroundStationClientTypes.Criticality? = nil
        )
        {
            self.autotrack = autotrack
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct UntagResourceInput: Swift.Equatable {
    /// ARN of a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of a resource tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

///
public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateStatus
        case componentStatuses
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateStatus = self.aggregateStatus {
            try encodeContainer.encode(aggregateStatus, forKey: .aggregateStatus)
        }
        if let componentStatuses = componentStatuses {
            var componentStatusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentStatuses)
            for componentstatusdata0 in componentStatuses {
                try componentStatusesContainer.encode(componentstatusdata0)
            }
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }
}

extension UpdateAgentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let agentId = agentId else {
            return nil
        }
        return "/agent/\(agentId.urlPercentEncoding())"
    }
}

public struct UpdateAgentStatusInput: Swift.Equatable {
    /// UUID of agent to update.
    /// This member is required.
    public var agentId: Swift.String?
    /// Aggregate status for agent.
    /// This member is required.
    public var aggregateStatus: GroundStationClientTypes.AggregateStatus?
    /// List of component statuses for agent.
    /// This member is required.
    public var componentStatuses: [GroundStationClientTypes.ComponentStatusData]?
    /// GUID of agent task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        aggregateStatus: GroundStationClientTypes.AggregateStatus? = nil,
        componentStatuses: [GroundStationClientTypes.ComponentStatusData]? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.aggregateStatus = aggregateStatus
        self.componentStatuses = componentStatuses
        self.taskId = taskId
    }
}

struct UpdateAgentStatusInputBody: Swift.Equatable {
    let taskId: Swift.String?
    let aggregateStatus: GroundStationClientTypes.AggregateStatus?
    let componentStatuses: [GroundStationClientTypes.ComponentStatusData]?
}

extension UpdateAgentStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateStatus
        case componentStatuses
        case taskId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let aggregateStatusDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.AggregateStatus.self, forKey: .aggregateStatus)
        aggregateStatus = aggregateStatusDecoded
        let componentStatusesContainer = try containerValues.decodeIfPresent([GroundStationClientTypes.ComponentStatusData?].self, forKey: .componentStatuses)
        var componentStatusesDecoded0:[GroundStationClientTypes.ComponentStatusData]? = nil
        if let componentStatusesContainer = componentStatusesContainer {
            componentStatusesDecoded0 = [GroundStationClientTypes.ComponentStatusData]()
            for structure0 in componentStatusesContainer {
                if let structure0 = structure0 {
                    componentStatusesDecoded0?.append(structure0)
                }
            }
        }
        componentStatuses = componentStatusesDecoded0
    }
}

extension UpdateAgentStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgentStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentId = output.agentId
        } else {
            self.agentId = nil
        }
    }
}

public struct UpdateAgentStatusOutput: Swift.Equatable {
    /// UUID of updated agent.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

struct UpdateAgentStatusOutputBody: Swift.Equatable {
    let agentId: Swift.String?
}

extension UpdateAgentStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
    }
}

enum UpdateAgentStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configData = self.configData {
            try encodeContainer.encode(configData, forKey: .configData)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configType = configType else {
            return nil
        }
        guard let configId = configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

///
public struct UpdateConfigInput: Swift.Equatable {
    /// Parameters of a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?

    public init(
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil
    )
    {
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
    }
}

struct UpdateConfigInputBody: Swift.Equatable {
    let name: Swift.String?
    let configData: GroundStationClientTypes.ConfigTypeData?
}

extension UpdateConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configData
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configDataDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigTypeData.self, forKey: .configData)
        configData = configDataDecoded
    }
}

extension UpdateConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConfigOutputBody = try responseDecoder.decode(responseBody: data)
            self.configArn = output.configArn
            self.configId = output.configId
            self.configType = output.configType
        } else {
            self.configArn = nil
            self.configId = nil
            self.configType = nil
        }
    }
}

///
public struct UpdateConfigOutput: Swift.Equatable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

struct UpdateConfigOutputBody: Swift.Equatable {
    let configId: Swift.String?
    let configType: GroundStationClientTypes.ConfigCapabilityType?
    let configArn: Swift.String?
}

extension UpdateConfigOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configArn
        case configId
        case configType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configId)
        configId = configIdDecoded
        let configTypeDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.ConfigCapabilityType.self, forKey: .configType)
        configType = configTypeDecoded
        let configArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configArn)
        configArn = configArnDecoded
    }
}

enum UpdateConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEphemerisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case name
        case priority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension UpdateEphemerisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ephemerisId = ephemerisId else {
            return nil
        }
        return "/ephemeris/\(ephemerisId.urlPercentEncoding())"
    }
}

public struct UpdateEphemerisInput: Swift.Equatable {
    /// Whether the ephemeris is enabled or not. Changing this value will not require the ephemeris to be re-validated.
    /// This member is required.
    public var enabled: Swift.Bool?
    /// The AWS Ground Station ephemeris ID.
    /// This member is required.
    public var ephemerisId: Swift.String?
    /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
    public var name: Swift.String?
    /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
    public var priority: Swift.Int?

    public init(
        enabled: Swift.Bool? = nil,
        ephemerisId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.enabled = enabled
        self.ephemerisId = ephemerisId
        self.name = name
        self.priority = priority
    }
}

struct UpdateEphemerisInputBody: Swift.Equatable {
    let enabled: Swift.Bool?
    let name: Swift.String?
    let priority: Swift.Int?
}

extension UpdateEphemerisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case name
        case priority
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension UpdateEphemerisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEphemerisOutputBody = try responseDecoder.decode(responseBody: data)
            self.ephemerisId = output.ephemerisId
        } else {
            self.ephemerisId = nil
        }
    }
}

public struct UpdateEphemerisOutput: Swift.Equatable {
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

struct UpdateEphemerisOutputBody: Swift.Equatable {
    let ephemerisId: Swift.String?
}

extension UpdateEphemerisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ephemerisId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ephemerisIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ephemerisId)
        ephemerisId = ephemerisIdDecoded
    }
}

enum UpdateEphemerisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMissionProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case streamsKmsKey
        case streamsKmsRole
        case trackingConfigArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactPostPassDurationSeconds = self.contactPostPassDurationSeconds {
            try encodeContainer.encode(contactPostPassDurationSeconds, forKey: .contactPostPassDurationSeconds)
        }
        if let contactPrePassDurationSeconds = self.contactPrePassDurationSeconds {
            try encodeContainer.encode(contactPrePassDurationSeconds, forKey: .contactPrePassDurationSeconds)
        }
        if let dataflowEdges = dataflowEdges {
            var dataflowEdgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataflowEdges)
            for dataflowedge0 in dataflowEdges {
                var dataflowedge0Container = dataflowEdgesContainer.nestedUnkeyedContainer()
                for configarn1 in dataflowedge0 {
                    try dataflowedge0Container.encode(configarn1)
                }
            }
        }
        if let minimumViableContactDurationSeconds = self.minimumViableContactDurationSeconds {
            try encodeContainer.encode(minimumViableContactDurationSeconds, forKey: .minimumViableContactDurationSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamsKmsKey = self.streamsKmsKey {
            try encodeContainer.encode(streamsKmsKey, forKey: .streamsKmsKey)
        }
        if let streamsKmsRole = self.streamsKmsRole {
            try encodeContainer.encode(streamsKmsRole, forKey: .streamsKmsRole)
        }
        if let trackingConfigArn = self.trackingConfigArn {
            try encodeContainer.encode(trackingConfigArn, forKey: .trackingConfigArn)
        }
    }
}

extension UpdateMissionProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let missionProfileId = missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

///
public struct UpdateMissionProfileInput: Swift.Equatable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?
    /// Name of a mission profile.
    public var name: Swift.String?
    /// KMS key to use for encrypting streams.
    public var streamsKmsKey: GroundStationClientTypes.KmsKey?
    /// Role to use for encrypting streams with KMS key.
    public var streamsKmsRole: Swift.String?
    /// ARN of a tracking Config.
    public var trackingConfigArn: Swift.String?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        streamsKmsKey: GroundStationClientTypes.KmsKey? = nil,
        streamsKmsRole: Swift.String? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileId = missionProfileId
        self.name = name
        self.streamsKmsKey = streamsKmsKey
        self.streamsKmsRole = streamsKmsRole
        self.trackingConfigArn = trackingConfigArn
    }
}

struct UpdateMissionProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let contactPrePassDurationSeconds: Swift.Int?
    let contactPostPassDurationSeconds: Swift.Int?
    let minimumViableContactDurationSeconds: Swift.Int?
    let dataflowEdges: [[Swift.String]]?
    let trackingConfigArn: Swift.String?
    let streamsKmsKey: GroundStationClientTypes.KmsKey?
    let streamsKmsRole: Swift.String?
}

extension UpdateMissionProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactPostPassDurationSeconds
        case contactPrePassDurationSeconds
        case dataflowEdges
        case minimumViableContactDurationSeconds
        case name
        case streamsKmsKey
        case streamsKmsRole
        case trackingConfigArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactPrePassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPrePassDurationSeconds)
        contactPrePassDurationSeconds = contactPrePassDurationSecondsDecoded
        let contactPostPassDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contactPostPassDurationSeconds)
        contactPostPassDurationSeconds = contactPostPassDurationSecondsDecoded
        let minimumViableContactDurationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumViableContactDurationSeconds)
        minimumViableContactDurationSeconds = minimumViableContactDurationSecondsDecoded
        let dataflowEdgesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .dataflowEdges)
        var dataflowEdgesDecoded0:[[Swift.String]]? = nil
        if let dataflowEdgesContainer = dataflowEdgesContainer {
            dataflowEdgesDecoded0 = [[Swift.String]]()
            for list0 in dataflowEdgesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    dataflowEdgesDecoded0?.append(list0Decoded0)
                }
            }
        }
        dataflowEdges = dataflowEdgesDecoded0
        let trackingConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingConfigArn)
        trackingConfigArn = trackingConfigArnDecoded
        let streamsKmsKeyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.KmsKey.self, forKey: .streamsKmsKey)
        streamsKmsKey = streamsKmsKeyDecoded
        let streamsKmsRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamsKmsRole)
        streamsKmsRole = streamsKmsRoleDecoded
    }
}

extension UpdateMissionProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMissionProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.missionProfileId = output.missionProfileId
        } else {
            self.missionProfileId = nil
        }
    }
}

///
public struct UpdateMissionProfileOutput: Swift.Equatable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

struct UpdateMissionProfileOutputBody: Swift.Equatable {
    let missionProfileId: Swift.String?
}

extension UpdateMissionProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case missionProfileId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let missionProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .missionProfileId)
        missionProfileId = missionProfileIdDecoded
    }
}

enum UpdateMissionProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GroundStationClientTypes.UplinkEchoConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antennaUplinkConfigArn
        case enabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let antennaUplinkConfigArn = self.antennaUplinkConfigArn {
            try encodeContainer.encode(antennaUplinkConfigArn, forKey: .antennaUplinkConfigArn)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let antennaUplinkConfigArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antennaUplinkConfigArn)
        antennaUplinkConfigArn = antennaUplinkConfigArnDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
    public struct UplinkEchoConfig: Swift.Equatable {
        /// ARN of an uplink Config.
        /// This member is required.
        public var antennaUplinkConfigArn: Swift.String?
        /// Whether or not an uplink Config is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init(
            antennaUplinkConfigArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.antennaUplinkConfigArn = antennaUplinkConfigArn
            self.enabled = enabled
        }
    }

}

extension GroundStationClientTypes.UplinkSpectrumConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case centerFrequency
        case polarization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let centerFrequency = self.centerFrequency {
            try encodeContainer.encode(centerFrequency, forKey: .centerFrequency)
        }
        if let polarization = self.polarization {
            try encodeContainer.encode(polarization.rawValue, forKey: .polarization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let centerFrequencyDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Frequency.self, forKey: .centerFrequency)
        centerFrequency = centerFrequencyDecoded
        let polarizationDecoded = try containerValues.decodeIfPresent(GroundStationClientTypes.Polarization.self, forKey: .polarization)
        polarization = polarizationDecoded
    }
}

extension GroundStationClientTypes {
    /// Information about the uplink spectral Config.
    public struct UplinkSpectrumConfig: Swift.Equatable {
        /// Center frequency of an uplink spectral Config. Valid values are between 2025 to 2120 MHz.
        /// This member is required.
        public var centerFrequency: GroundStationClientTypes.Frequency?
        /// Polarization of an uplink spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public var polarization: GroundStationClientTypes.Polarization?

        public init(
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }

}
