//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// Dependency encountered an error.
public struct DependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var parameterName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterName = parameterName
    }
}

/// One or more parameters are not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var parameterName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterName = parameterName
    }
}

/// Resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetAgentConfigurationInput: Swift.Sendable {
    /// UUID of agent to get configuration information for.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

public struct GetAgentConfigurationOutput: Swift.Sendable {
    /// UUID of agent.
    public var agentId: Swift.String?
    /// Tasking document for agent.
    public var taskingDocument: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        taskingDocument: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.taskingDocument = taskingDocument
    }
}

extension GroundStationClientTypes {

    /// Version information for agent components.
    public struct ComponentVersion: Swift.Sendable {
        /// Component type.
        /// This member is required.
        public var componentType: Swift.String?
        /// List of versions.
        /// This member is required.
        public var versions: [Swift.String]?

        public init(
            componentType: Swift.String? = nil,
            versions: [Swift.String]? = nil
        )
        {
            self.componentType = componentType
            self.versions = versions
        }
    }
}

extension GroundStationClientTypes {

    /// Detailed information about the agent.
    public struct AgentDetails: Swift.Sendable {
        /// List of CPU cores reserved for the agent.
        public var agentCpuCores: [Swift.Int]?
        /// Current agent version.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// List of versions being used by agent components.
        /// This member is required.
        public var componentVersions: [GroundStationClientTypes.ComponentVersion]?
        /// ID of EC2 instance agent is running on.
        /// This member is required.
        public var instanceId: Swift.String?
        /// Type of EC2 instance agent is running on.
        /// This member is required.
        public var instanceType: Swift.String?
        /// This field should not be used. Use agentCpuCores instead. List of CPU cores reserved for processes other than the agent running on the EC2 instance.
        public var reservedCpuCores: [Swift.Int]?

        public init(
            agentCpuCores: [Swift.Int]? = nil,
            agentVersion: Swift.String? = nil,
            componentVersions: [GroundStationClientTypes.ComponentVersion]? = nil,
            instanceId: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            reservedCpuCores: [Swift.Int]? = nil
        )
        {
            self.agentCpuCores = agentCpuCores
            self.agentVersion = agentVersion
            self.componentVersions = componentVersions
            self.instanceId = instanceId
            self.instanceType = instanceType
            self.reservedCpuCores = reservedCpuCores
        }
    }
}

extension GroundStationClientTypes {

    /// Data for agent discovery.
    public struct DiscoveryData: Swift.Sendable {
        /// List of capabilities to associate with agent.
        /// This member is required.
        public var capabilityArns: [Swift.String]?
        /// List of private IP addresses to associate with agent.
        /// This member is required.
        public var privateIpAddresses: [Swift.String]?
        /// List of public IP addresses to associate with agent.
        /// This member is required.
        public var publicIpAddresses: [Swift.String]?

        public init(
            capabilityArns: [Swift.String]? = nil,
            privateIpAddresses: [Swift.String]? = nil,
            publicIpAddresses: [Swift.String]? = nil
        )
        {
            self.capabilityArns = capabilityArns
            self.privateIpAddresses = privateIpAddresses
            self.publicIpAddresses = publicIpAddresses
        }
    }
}

public struct RegisterAgentInput: Swift.Sendable {
    /// Detailed information about the agent being registered.
    /// This member is required.
    public var agentDetails: GroundStationClientTypes.AgentDetails?
    /// Data for associating an agent with the capabilities it is managing.
    /// This member is required.
    public var discoveryData: GroundStationClientTypes.DiscoveryData?

    public init(
        agentDetails: GroundStationClientTypes.AgentDetails? = nil,
        discoveryData: GroundStationClientTypes.DiscoveryData? = nil
    )
    {
        self.agentDetails = agentDetails
        self.discoveryData = discoveryData
    }
}

public struct RegisterAgentOutput: Swift.Sendable {
    /// UUID of registered agent.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

extension GroundStationClientTypes {

    public enum AgentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case inactive
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatus] {
            return [
                .active,
                .failed,
                .inactive,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .inactive: return "INACTIVE"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Aggregate status of Agent components.
    public struct AggregateStatus: Swift.Sendable {
        /// Sparse map of failure signatures.
        public var signatureMap: [Swift.String: Swift.Bool]?
        /// Aggregate status.
        /// This member is required.
        public var status: GroundStationClientTypes.AgentStatus?

        public init(
            signatureMap: [Swift.String: Swift.Bool]? = nil,
            status: GroundStationClientTypes.AgentStatus? = nil
        )
        {
            self.signatureMap = signatureMap
            self.status = status
        }
    }
}

extension GroundStationClientTypes {

    /// Data on the status of agent components.
    public struct ComponentStatusData: Swift.Sendable {
        /// Bytes received by the component.
        public var bytesReceived: Swift.Int?
        /// Bytes sent by the component.
        public var bytesSent: Swift.Int?
        /// Capability ARN of the component.
        /// This member is required.
        public var capabilityArn: Swift.String?
        /// The Component type.
        /// This member is required.
        public var componentType: Swift.String?
        /// Dataflow UUID associated with the component.
        /// This member is required.
        public var dataflowId: Swift.String?
        /// Packets dropped by component.
        public var packetsDropped: Swift.Int?
        /// Component status.
        /// This member is required.
        public var status: GroundStationClientTypes.AgentStatus?

        public init(
            bytesReceived: Swift.Int? = nil,
            bytesSent: Swift.Int? = nil,
            capabilityArn: Swift.String? = nil,
            componentType: Swift.String? = nil,
            dataflowId: Swift.String? = nil,
            packetsDropped: Swift.Int? = nil,
            status: GroundStationClientTypes.AgentStatus? = nil
        )
        {
            self.bytesReceived = bytesReceived
            self.bytesSent = bytesSent
            self.capabilityArn = capabilityArn
            self.componentType = componentType
            self.dataflowId = dataflowId
            self.packetsDropped = packetsDropped
            self.status = status
        }
    }
}

public struct UpdateAgentStatusInput: Swift.Sendable {
    /// UUID of agent to update.
    /// This member is required.
    public var agentId: Swift.String?
    /// Aggregate status for agent.
    /// This member is required.
    public var aggregateStatus: GroundStationClientTypes.AggregateStatus?
    /// List of component statuses for agent.
    /// This member is required.
    public var componentStatuses: [GroundStationClientTypes.ComponentStatusData]?
    /// GUID of agent task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        aggregateStatus: GroundStationClientTypes.AggregateStatus? = nil,
        componentStatuses: [GroundStationClientTypes.ComponentStatusData]? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.aggregateStatus = aggregateStatus
        self.componentStatuses = componentStatuses
        self.taskId = taskId
    }
}

public struct UpdateAgentStatusOutput: Swift.Sendable {
    /// UUID of updated agent.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

extension GroundStationClientTypes {

    public enum AngleUnits: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case degreeAngle
        case radian
        case sdkUnknown(Swift.String)

        public static var allCases: [AngleUnits] {
            return [
                .degreeAngle,
                .radian
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .degreeAngle: return "DEGREE_ANGLE"
            case .radian: return "RADIAN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Details about an antenna demod decode Config used in a contact.
    public struct AntennaDemodDecodeDetails: Swift.Sendable {
        /// Name of an antenna demod decode output node used in a contact.
        public var outputNode: Swift.String?

        public init(
            outputNode: Swift.String? = nil
        )
        {
            self.outputNode = outputNode
        }
    }
}

extension GroundStationClientTypes {

    public enum BandwidthUnits: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [BandwidthUnits] {
            return [
                .ghz,
                .khz,
                .mhz
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Object that describes the frequency bandwidth.
    public struct FrequencyBandwidth: Swift.Sendable {
        /// Frequency bandwidth units.
        /// This member is required.
        public var units: GroundStationClientTypes.BandwidthUnits?
        /// Frequency bandwidth value. AWS Ground Station currently has the following bandwidth limitations:
        ///
        /// * For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.
        ///
        /// * For AntennaDownlinkconfig, valid values are between 10 kHz to 54 MHz.
        ///
        /// * For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            units: GroundStationClientTypes.BandwidthUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }
}

extension GroundStationClientTypes {

    public enum FrequencyUnits: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ghz
        case khz
        case mhz
        case sdkUnknown(Swift.String)

        public static var allCases: [FrequencyUnits] {
            return [
                .ghz,
                .khz,
                .mhz
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ghz: return "GHz"
            case .khz: return "kHz"
            case .mhz: return "MHz"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Object that describes the frequency.
    public struct Frequency: Swift.Sendable {
        /// Frequency units.
        /// This member is required.
        public var units: GroundStationClientTypes.FrequencyUnits?
        /// Frequency value. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            units: GroundStationClientTypes.FrequencyUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }
}

extension GroundStationClientTypes {

    public enum Polarization: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case leftHand
        case `none`
        case rightHand
        case sdkUnknown(Swift.String)

        public static var allCases: [Polarization] {
            return [
                .leftHand,
                .none,
                .rightHand
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .leftHand: return "LEFT_HAND"
            case .none: return "NONE"
            case .rightHand: return "RIGHT_HAND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Object that describes a spectral Config.
    public struct SpectrumConfig: Swift.Sendable {
        /// Bandwidth of a spectral Config. AWS Ground Station currently has the following bandwidth limitations:
        ///
        /// * For AntennaDownlinkDemodDecodeconfig, valid values are between 125 kHz to 650 MHz.
        ///
        /// * For AntennaDownlinkconfig valid values are between 10 kHz to 54 MHz.
        ///
        /// * For AntennaUplinkConfig, valid values are between 10 kHz to 54 MHz.
        /// This member is required.
        public var bandwidth: GroundStationClientTypes.FrequencyBandwidth?
        /// Center frequency of a spectral Config. Valid values are between 2200 to 2300 MHz and 7750 to 8400 MHz for downlink and 2025 to 2120 MHz for uplink.
        /// This member is required.
        public var centerFrequency: GroundStationClientTypes.Frequency?
        /// Polarization of a spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public var polarization: GroundStationClientTypes.Polarization?

        public init(
            bandwidth: GroundStationClientTypes.FrequencyBandwidth? = nil,
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.bandwidth = bandwidth
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }
}

extension GroundStationClientTypes {

    /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
    public struct AntennaDownlinkConfig: Swift.Sendable {
        /// Object that describes a spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init(
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
        }
    }
}

extension GroundStationClientTypes {

    /// Information about the decode Config.
    public struct DecodeConfig: Swift.Sendable {
        /// Unvalidated JSON of a decode Config.
        /// This member is required.
        public var unvalidatedJSON: Swift.String?

        public init(
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }
}

extension GroundStationClientTypes {

    /// Information about the demodulation Config.
    public struct DemodulationConfig: Swift.Sendable {
        /// Unvalidated JSON of a demodulation Config.
        /// This member is required.
        public var unvalidatedJSON: Swift.String?

        public init(
            unvalidatedJSON: Swift.String? = nil
        )
        {
            self.unvalidatedJSON = unvalidatedJSON
        }
    }
}

extension GroundStationClientTypes {

    /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
    public struct AntennaDownlinkDemodDecodeConfig: Swift.Sendable {
        /// Information about the decode Config.
        /// This member is required.
        public var decodeConfig: GroundStationClientTypes.DecodeConfig?
        /// Information about the demodulation Config.
        /// This member is required.
        public var demodulationConfig: GroundStationClientTypes.DemodulationConfig?
        /// Information about the spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.SpectrumConfig?

        public init(
            decodeConfig: GroundStationClientTypes.DecodeConfig? = nil,
            demodulationConfig: GroundStationClientTypes.DemodulationConfig? = nil,
            spectrumConfig: GroundStationClientTypes.SpectrumConfig? = nil
        )
        {
            self.decodeConfig = decodeConfig
            self.demodulationConfig = demodulationConfig
            self.spectrumConfig = spectrumConfig
        }
    }
}

extension GroundStationClientTypes {

    /// Information about the uplink spectral Config.
    public struct UplinkSpectrumConfig: Swift.Sendable {
        /// Center frequency of an uplink spectral Config. Valid values are between 2025 to 2120 MHz.
        /// This member is required.
        public var centerFrequency: GroundStationClientTypes.Frequency?
        /// Polarization of an uplink spectral Config. Capturing both "RIGHT_HAND" and "LEFT_HAND" polarization requires two separate configs.
        public var polarization: GroundStationClientTypes.Polarization?

        public init(
            centerFrequency: GroundStationClientTypes.Frequency? = nil,
            polarization: GroundStationClientTypes.Polarization? = nil
        )
        {
            self.centerFrequency = centerFrequency
            self.polarization = polarization
        }
    }
}

extension GroundStationClientTypes {

    public enum EirpUnits: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dbw
        case sdkUnknown(Swift.String)

        public static var allCases: [EirpUnits] {
            return [
                .dbw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dbw: return "dBW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Object that represents EIRP.
    public struct Eirp: Swift.Sendable {
        /// Units of an EIRP.
        /// This member is required.
        public var units: GroundStationClientTypes.EirpUnits?
        /// Value of an EIRP. Valid values are between 20.0 to 50.0 dBW.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            units: GroundStationClientTypes.EirpUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.units = units
            self.value = value
        }
    }
}

extension GroundStationClientTypes {

    /// Information about the uplink Config of an antenna.
    public struct AntennaUplinkConfig: Swift.Sendable {
        /// Information about the uplink spectral Config.
        /// This member is required.
        public var spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig?
        /// EIRP of the target.
        /// This member is required.
        public var targetEirp: GroundStationClientTypes.Eirp?
        /// Whether or not uplink transmit is disabled.
        public var transmitDisabled: Swift.Bool?

        public init(
            spectrumConfig: GroundStationClientTypes.UplinkSpectrumConfig? = nil,
            targetEirp: GroundStationClientTypes.Eirp? = nil,
            transmitDisabled: Swift.Bool? = nil
        )
        {
            self.spectrumConfig = spectrumConfig
            self.targetEirp = targetEirp
            self.transmitDisabled = transmitDisabled
        }
    }
}

extension GroundStationClientTypes {

    public enum AuditResults: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [AuditResults] {
            return [
                .healthy,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Information about the socket address.
    public struct SocketAddress: Swift.Sendable {
        /// Name of a socket address.
        /// This member is required.
        public var name: Swift.String?
        /// Port of a socket address.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            name: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.name = name
            self.port = port
        }
    }
}

extension GroundStationClientTypes {

    /// Egress address of AgentEndpoint with an optional mtu.
    public struct ConnectionDetails: Swift.Sendable {
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public var mtu: Swift.Int?
        /// A socket address.
        /// This member is required.
        public var socketAddress: GroundStationClientTypes.SocketAddress?

        public init(
            mtu: Swift.Int? = nil,
            socketAddress: GroundStationClientTypes.SocketAddress? = nil
        )
        {
            self.mtu = mtu
            self.socketAddress = socketAddress
        }
    }
}

extension GroundStationClientTypes {

    /// An integer range that has a minimum and maximum value.
    public struct IntegerRange: Swift.Sendable {
        /// A maximum value.
        /// This member is required.
        public var maximum: Swift.Int?
        /// A minimum value.
        /// This member is required.
        public var minimum: Swift.Int?

        public init(
            maximum: Swift.Int? = nil,
            minimum: Swift.Int? = nil
        )
        {
            self.maximum = maximum
            self.minimum = minimum
        }
    }
}

extension GroundStationClientTypes {

    /// A socket address with a port range.
    public struct RangedSocketAddress: Swift.Sendable {
        /// IPv4 socket address.
        /// This member is required.
        public var name: Swift.String?
        /// Port range of a socket address.
        /// This member is required.
        public var portRange: GroundStationClientTypes.IntegerRange?

        public init(
            name: Swift.String? = nil,
            portRange: GroundStationClientTypes.IntegerRange? = nil
        )
        {
            self.name = name
            self.portRange = portRange
        }
    }
}

extension GroundStationClientTypes {

    /// Ingress address of AgentEndpoint with a port range and an optional mtu.
    public struct RangedConnectionDetails: Swift.Sendable {
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public var mtu: Swift.Int?
        /// A ranged socket address.
        /// This member is required.
        public var socketAddress: GroundStationClientTypes.RangedSocketAddress?

        public init(
            mtu: Swift.Int? = nil,
            socketAddress: GroundStationClientTypes.RangedSocketAddress? = nil
        )
        {
            self.mtu = mtu
            self.socketAddress = socketAddress
        }
    }
}

extension GroundStationClientTypes {

    /// Information about AwsGroundStationAgentEndpoint.
    public struct AwsGroundStationAgentEndpoint: Swift.Sendable {
        /// The status of AgentEndpoint.
        public var agentStatus: GroundStationClientTypes.AgentStatus?
        /// The results of the audit.
        public var auditResults: GroundStationClientTypes.AuditResults?
        /// The egress address of AgentEndpoint.
        /// This member is required.
        public var egressAddress: GroundStationClientTypes.ConnectionDetails?
        /// The ingress address of AgentEndpoint.
        /// This member is required.
        public var ingressAddress: GroundStationClientTypes.RangedConnectionDetails?
        /// Name string associated with AgentEndpoint. Used as a human-readable identifier for AgentEndpoint.
        /// This member is required.
        public var name: Swift.String?

        public init(
            agentStatus: GroundStationClientTypes.AgentStatus? = nil,
            auditResults: GroundStationClientTypes.AuditResults? = nil,
            egressAddress: GroundStationClientTypes.ConnectionDetails? = nil,
            ingressAddress: GroundStationClientTypes.RangedConnectionDetails? = nil,
            name: Swift.String? = nil
        )
        {
            self.agentStatus = agentStatus
            self.auditResults = auditResults
            self.egressAddress = egressAddress
            self.ingressAddress = ingressAddress
            self.name = name
        }
    }
}

///
public struct CancelContactInput: Swift.Sendable {
    /// UUID of a contact.
    /// This member is required.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

///
public struct CancelContactOutput: Swift.Sendable {
    /// UUID of a contact.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

extension GroundStationClientTypes {

    public enum CapabilityHealth: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilityHealth] {
            return [
                .healthy,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    public enum CapabilityHealthReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dataplaneFailure
        case healthy
        case initializingDataplane
        case invalidIpOwnership
        case notAuthorizedToCreateSlr
        case noRegisteredAgent
        case unverifiedIpOwnership
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilityHealthReason] {
            return [
                .dataplaneFailure,
                .healthy,
                .initializingDataplane,
                .invalidIpOwnership,
                .notAuthorizedToCreateSlr,
                .noRegisteredAgent,
                .unverifiedIpOwnership
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dataplaneFailure: return "DATAPLANE_FAILURE"
            case .healthy: return "HEALTHY"
            case .initializingDataplane: return "INITIALIZING_DATAPLANE"
            case .invalidIpOwnership: return "INVALID_IP_OWNERSHIP"
            case .notAuthorizedToCreateSlr: return "NOT_AUTHORIZED_TO_CREATE_SLR"
            case .noRegisteredAgent: return "NO_REGISTERED_AGENT"
            case .unverifiedIpOwnership: return "UNVERIFIED_IP_OWNERSHIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    public enum ConfigCapabilityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case antennaDownlink
        case antennaDownlinkDemodDecode
        case antennaUplink
        case dataflowEndpoint
        case s3Recording
        case tracking
        case uplinkEcho
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigCapabilityType] {
            return [
                .antennaDownlink,
                .antennaDownlinkDemodDecode,
                .antennaUplink,
                .dataflowEndpoint,
                .s3Recording,
                .tracking,
                .uplinkEcho
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .antennaDownlink: return "antenna-downlink"
            case .antennaDownlinkDemodDecode: return "antenna-downlink-demod-decode"
            case .antennaUplink: return "antenna-uplink"
            case .dataflowEndpoint: return "dataflow-endpoint"
            case .s3Recording: return "s3-recording"
            case .tracking: return "tracking"
            case .uplinkEcho: return "uplink-echo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Account limits for this resource have been exceeded.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var parameterName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterName = parameterName
    }
}

extension GroundStationClientTypes {

    /// Information about the dataflow endpoint Config.
    public struct DataflowEndpointConfig: Swift.Sendable {
        /// Name of a dataflow endpoint.
        /// This member is required.
        public var dataflowEndpointName: Swift.String?
        /// Region of a dataflow endpoint.
        public var dataflowEndpointRegion: Swift.String?

        public init(
            dataflowEndpointName: Swift.String? = nil,
            dataflowEndpointRegion: Swift.String? = nil
        )
        {
            self.dataflowEndpointName = dataflowEndpointName
            self.dataflowEndpointRegion = dataflowEndpointRegion
        }
    }
}

extension GroundStationClientTypes {

    /// Information about an S3 recording Config.
    public struct S3RecordingConfig: Swift.Sendable {
        /// ARN of the bucket to record to.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// S3 Key prefix to prefice data files.
        public var `prefix`: Swift.String?
        /// ARN of the role Ground Station assumes to write data to the bucket.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            bucketArn: Swift.String? = nil,
            `prefix`: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.`prefix` = `prefix`
            self.roleArn = roleArn
        }
    }
}

extension GroundStationClientTypes {

    public enum Criticality: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case preferred
        case removed
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [Criticality] {
            return [
                .preferred,
                .removed,
                .required
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .preferred: return "PREFERRED"
            case .removed: return "REMOVED"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
    public struct TrackingConfig: Swift.Sendable {
        /// Current setting for autotrack.
        /// This member is required.
        public var autotrack: GroundStationClientTypes.Criticality?

        public init(
            autotrack: GroundStationClientTypes.Criticality? = nil
        )
        {
            self.autotrack = autotrack
        }
    }
}

extension GroundStationClientTypes {

    /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
    public struct UplinkEchoConfig: Swift.Sendable {
        /// ARN of an uplink Config.
        /// This member is required.
        public var antennaUplinkConfigArn: Swift.String?
        /// Whether or not an uplink Config is enabled.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init(
            antennaUplinkConfigArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.antennaUplinkConfigArn = antennaUplinkConfigArn
            self.enabled = enabled
        }
    }
}

extension GroundStationClientTypes {

    /// Object containing the parameters of a Config. See the subtype definitions for what each type of Config contains.
    public enum ConfigTypeData: Swift.Sendable {
        /// Information about how AWS Ground Station should configure an antenna for downlink during a contact.
        case antennadownlinkconfig(GroundStationClientTypes.AntennaDownlinkConfig)
        /// Object that determines whether tracking should be used during a contact executed with this Config in the mission profile.
        case trackingconfig(GroundStationClientTypes.TrackingConfig)
        /// Information about the dataflow endpoint Config.
        case dataflowendpointconfig(GroundStationClientTypes.DataflowEndpointConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for downlink demod decode during a contact.
        case antennadownlinkdemoddecodeconfig(GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig)
        /// Information about how AWS Ground Station should conﬁgure an antenna for uplink during a contact.
        case antennauplinkconfig(GroundStationClientTypes.AntennaUplinkConfig)
        /// Information about an uplink echo Config. Parameters from the AntennaUplinkConfig, corresponding to the specified AntennaUplinkConfigArn, are used when this UplinkEchoConfig is used in a contact.
        case uplinkechoconfig(GroundStationClientTypes.UplinkEchoConfig)
        /// Information about an S3 recording Config.
        case s3recordingconfig(GroundStationClientTypes.S3RecordingConfig)
        case sdkUnknown(Swift.String)
    }
}

///
public struct CreateConfigInput: Swift.Sendable {
    /// Parameters of a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a Config.
    public var tags: [Swift.String: Swift.String]?

    public init(
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.configData = configData
        self.name = name
        self.tags = tags
    }
}

///
public struct CreateConfigOutput: Swift.Sendable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

///
public struct DeleteConfigInput: Swift.Sendable {
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

///
public struct DeleteConfigOutput: Swift.Sendable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

///
public struct GetConfigInput: Swift.Sendable {
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configId = configId
        self.configType = configType
    }
}

///
public struct GetConfigOutput: Swift.Sendable {
    /// ARN of a Config
    /// This member is required.
    public var configArn: Swift.String?
    /// Data elements in a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to a Config.
    public var tags: [Swift.String: Swift.String]?

    public init(
        configArn: Swift.String? = nil,
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.configArn = configArn
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
        self.tags = tags
    }
}

///
public struct ListConfigsInput: Swift.Sendable {
    /// Maximum number of Configs returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListConfigs call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GroundStationClientTypes {

    /// An item in a list of Config objects.
    public struct ConfigListItem: Swift.Sendable {
        /// ARN of a Config.
        public var configArn: Swift.String?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Name of a Config.
        public var name: Swift.String?

        public init(
            configArn: Swift.String? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            name: Swift.String? = nil
        )
        {
            self.configArn = configArn
            self.configId = configId
            self.configType = configType
            self.name = name
        }
    }
}

///
public struct ListConfigsOutput: Swift.Sendable {
    /// List of Config items.
    public var configList: [GroundStationClientTypes.ConfigListItem]?
    /// Next token returned in the response of a previous ListConfigs call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        configList: [GroundStationClientTypes.ConfigListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configList = configList
        self.nextToken = nextToken
    }
}

///
public struct UpdateConfigInput: Swift.Sendable {
    /// Parameters of a Config.
    /// This member is required.
    public var configData: GroundStationClientTypes.ConfigTypeData?
    /// UUID of a Config.
    /// This member is required.
    public var configId: Swift.String?
    /// Type of a Config.
    /// This member is required.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?
    /// Name of a Config.
    /// This member is required.
    public var name: Swift.String?

    public init(
        configData: GroundStationClientTypes.ConfigTypeData? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
        name: Swift.String? = nil
    )
    {
        self.configData = configData
        self.configId = configId
        self.configType = configType
        self.name = name
    }
}

///
public struct UpdateConfigOutput: Swift.Sendable {
    /// ARN of a Config.
    public var configArn: Swift.String?
    /// UUID of a Config.
    public var configId: Swift.String?
    /// Type of a Config.
    public var configType: GroundStationClientTypes.ConfigCapabilityType?

    public init(
        configArn: Swift.String? = nil,
        configId: Swift.String? = nil,
        configType: GroundStationClientTypes.ConfigCapabilityType? = nil
    )
    {
        self.configArn = configArn
        self.configId = configId
        self.configType = configType
    }
}

extension GroundStationClientTypes {

    public enum EndpointStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case creating
        case deleted
        case deleting
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .created,
                .creating,
                .deleted,
                .deleting,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "created"
            case .creating: return "creating"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .failed: return "failed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Information about a dataflow endpoint.
    public struct DataflowEndpoint: Swift.Sendable {
        /// Socket address of a dataflow endpoint.
        public var address: GroundStationClientTypes.SocketAddress?
        /// Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
        public var mtu: Swift.Int?
        /// Name of a dataflow endpoint.
        public var name: Swift.String?
        /// Status of a dataflow endpoint.
        public var status: GroundStationClientTypes.EndpointStatus?

        public init(
            address: GroundStationClientTypes.SocketAddress? = nil,
            mtu: Swift.Int? = nil,
            name: Swift.String? = nil,
            status: GroundStationClientTypes.EndpointStatus? = nil
        )
        {
            self.address = address
            self.mtu = mtu
            self.name = name
            self.status = status
        }
    }
}

extension GroundStationClientTypes {

    /// Information about endpoints.
    public struct SecurityDetails: Swift.Sendable {
        /// ARN to a role needed for connecting streams to your instances.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The security groups to attach to the elastic network interfaces.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnets where AWS Ground Station places elastic network interfaces to send streams to your instances.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

extension GroundStationClientTypes {

    /// Information about the endpoint details.
    public struct EndpointDetails: Swift.Sendable {
        /// An agent endpoint.
        public var awsGroundStationAgentEndpoint: GroundStationClientTypes.AwsGroundStationAgentEndpoint?
        /// A dataflow endpoint.
        public var endpoint: GroundStationClientTypes.DataflowEndpoint?
        /// Health reasons for a dataflow endpoint. This field is ignored when calling CreateDataflowEndpointGroup.
        public var healthReasons: [GroundStationClientTypes.CapabilityHealthReason]?
        /// A dataflow endpoint health status. This field is ignored when calling CreateDataflowEndpointGroup.
        public var healthStatus: GroundStationClientTypes.CapabilityHealth?
        /// Endpoint security details including a list of subnets, a list of security groups and a role to connect streams to instances.
        public var securityDetails: GroundStationClientTypes.SecurityDetails?

        public init(
            awsGroundStationAgentEndpoint: GroundStationClientTypes.AwsGroundStationAgentEndpoint? = nil,
            endpoint: GroundStationClientTypes.DataflowEndpoint? = nil,
            healthReasons: [GroundStationClientTypes.CapabilityHealthReason]? = nil,
            healthStatus: GroundStationClientTypes.CapabilityHealth? = nil,
            securityDetails: GroundStationClientTypes.SecurityDetails? = nil
        )
        {
            self.awsGroundStationAgentEndpoint = awsGroundStationAgentEndpoint
            self.endpoint = endpoint
            self.healthReasons = healthReasons
            self.healthStatus = healthStatus
            self.securityDetails = securityDetails
        }
    }
}

extension GroundStationClientTypes {

    /// Details about an S3 recording Config used in a contact.
    public struct S3RecordingDetails: Swift.Sendable {
        /// ARN of the bucket used.
        public var bucketArn: Swift.String?
        /// Key template used for the S3 Recording Configuration
        public var keyTemplate: Swift.String?

        public init(
            bucketArn: Swift.String? = nil,
            keyTemplate: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.keyTemplate = keyTemplate
        }
    }
}

extension GroundStationClientTypes {

    /// Details for certain Config object types in a contact.
    public enum ConfigDetails: Swift.Sendable {
        /// Information about the endpoint details.
        case endpointdetails(GroundStationClientTypes.EndpointDetails)
        /// Details for antenna demod decode Config in a contact.
        case antennademoddecodedetails(GroundStationClientTypes.AntennaDemodDecodeDetails)
        /// Details for an S3 recording Config in a contact.
        case s3recordingdetails(GroundStationClientTypes.S3RecordingDetails)
        case sdkUnknown(Swift.String)
    }
}

///
public struct DescribeContactInput: Swift.Sendable {
    /// UUID of a contact.
    /// This member is required.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

extension GroundStationClientTypes {

    public enum ContactStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case awsCancelled
        case awsFailed
        case cancelled
        case cancelling
        case completed
        case failed
        case failedToSchedule
        case pass
        case postpass
        case prepass
        case scheduled
        case scheduling
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactStatus] {
            return [
                .available,
                .awsCancelled,
                .awsFailed,
                .cancelled,
                .cancelling,
                .completed,
                .failed,
                .failedToSchedule,
                .pass,
                .postpass,
                .prepass,
                .scheduled,
                .scheduling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .awsCancelled: return "AWS_CANCELLED"
            case .awsFailed: return "AWS_FAILED"
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .failedToSchedule: return "FAILED_TO_SCHEDULE"
            case .pass: return "PASS"
            case .postpass: return "POSTPASS"
            case .prepass: return "PREPASS"
            case .scheduled: return "SCHEDULED"
            case .scheduling: return "SCHEDULING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Dataflow details for the destination side.
    public struct Destination: Swift.Sendable {
        /// Additional details for a Config, if type is dataflow endpoint or antenna demod decode.
        public var configDetails: GroundStationClientTypes.ConfigDetails?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Region of a dataflow destination.
        public var dataflowDestinationRegion: Swift.String?

        public init(
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowDestinationRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowDestinationRegion = dataflowDestinationRegion
        }
    }
}

extension GroundStationClientTypes {

    /// Dataflow details for the source side.
    public struct Source: Swift.Sendable {
        /// Additional details for a Config, if type is dataflow-endpoint or antenna-downlink-demod-decode
        public var configDetails: GroundStationClientTypes.ConfigDetails?
        /// UUID of a Config.
        public var configId: Swift.String?
        /// Type of a Config.
        public var configType: GroundStationClientTypes.ConfigCapabilityType?
        /// Region of a dataflow source.
        public var dataflowSourceRegion: Swift.String?

        public init(
            configDetails: GroundStationClientTypes.ConfigDetails? = nil,
            configId: Swift.String? = nil,
            configType: GroundStationClientTypes.ConfigCapabilityType? = nil,
            dataflowSourceRegion: Swift.String? = nil
        )
        {
            self.configDetails = configDetails
            self.configId = configId
            self.configType = configType
            self.dataflowSourceRegion = dataflowSourceRegion
        }
    }
}

extension GroundStationClientTypes {

    /// Information about a dataflow edge used in a contact.
    public struct DataflowDetail: Swift.Sendable {
        /// Dataflow details for the destination side.
        public var destination: GroundStationClientTypes.Destination?
        /// Error message for a dataflow.
        public var errorMessage: Swift.String?
        /// Dataflow details for the source side.
        public var source: GroundStationClientTypes.Source?

        public init(
            destination: GroundStationClientTypes.Destination? = nil,
            errorMessage: Swift.String? = nil,
            source: GroundStationClientTypes.Source? = nil
        )
        {
            self.destination = destination
            self.errorMessage = errorMessage
            self.source = source
        }
    }
}

extension GroundStationClientTypes {

    /// Elevation angle of the satellite in the sky during a contact.
    public struct Elevation: Swift.Sendable {
        /// Elevation angle units.
        /// This member is required.
        public var unit: GroundStationClientTypes.AngleUnits?
        /// Elevation angle value.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            unit: GroundStationClientTypes.AngleUnits? = nil,
            value: Swift.Double? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }
}

///
public struct DescribeContactOutput: Swift.Sendable {
    /// UUID of a contact.
    public var contactId: Swift.String?
    /// Status of a contact.
    public var contactStatus: GroundStationClientTypes.ContactStatus?
    /// List describing source and destination details for each dataflow edge.
    public var dataflowList: [GroundStationClientTypes.DataflowDetail]?
    /// End time of a contact in UTC.
    public var endTime: Foundation.Date?
    /// Error message for a contact.
    public var errorMessage: Swift.String?
    /// Ground station for a contact.
    public var groundStation: Swift.String?
    /// Maximum elevation angle of a contact.
    public var maximumElevation: GroundStationClientTypes.Elevation?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var postPassEndTime: Foundation.Date?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var prePassStartTime: Foundation.Date?
    /// Region of a contact.
    public var region: Swift.String?
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// Start time of a contact in UTC.
    public var startTime: Foundation.Date?
    /// Tags assigned to a contact.
    public var tags: [Swift.String: Swift.String]?
    /// Projected time in UTC your satellite will set below the [receive mask](https://docs.aws.amazon.com/ground-station/latest/ug/site-masks.html). This time is based on the satellite's current active ephemeris for future contacts and the ephemeris that was active during contact execution for completed contacts.
    public var visibilityEndTime: Foundation.Date?
    /// Projected time in UTC your satellite will rise above the [receive mask](https://docs.aws.amazon.com/ground-station/latest/ug/site-masks.html). This time is based on the satellite's current active ephemeris for future contacts and the ephemeris that was active during contact execution for completed contacts.
    public var visibilityStartTime: Foundation.Date?

    public init(
        contactId: Swift.String? = nil,
        contactStatus: GroundStationClientTypes.ContactStatus? = nil,
        dataflowList: [GroundStationClientTypes.DataflowDetail]? = nil,
        endTime: Foundation.Date? = nil,
        errorMessage: Swift.String? = nil,
        groundStation: Swift.String? = nil,
        maximumElevation: GroundStationClientTypes.Elevation? = nil,
        missionProfileArn: Swift.String? = nil,
        postPassEndTime: Foundation.Date? = nil,
        prePassStartTime: Foundation.Date? = nil,
        region: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        visibilityEndTime: Foundation.Date? = nil,
        visibilityStartTime: Foundation.Date? = nil
    )
    {
        self.contactId = contactId
        self.contactStatus = contactStatus
        self.dataflowList = dataflowList
        self.endTime = endTime
        self.errorMessage = errorMessage
        self.groundStation = groundStation
        self.maximumElevation = maximumElevation
        self.missionProfileArn = missionProfileArn
        self.postPassEndTime = postPassEndTime
        self.prePassStartTime = prePassStartTime
        self.region = region
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
        self.visibilityEndTime = visibilityEndTime
        self.visibilityStartTime = visibilityStartTime
    }
}

///
public struct ListContactsInput: Swift.Sendable {
    /// End time of a contact in UTC.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Name of a ground station.
    public var groundStation: Swift.String?
    /// Maximum number of contacts returned.
    public var maxResults: Swift.Int?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// Next token returned in the request of a previous ListContacts call. Used to get the next page of results.
    public var nextToken: Swift.String?
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// Start time of a contact in UTC.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// Status of a contact reservation.
    /// This member is required.
    public var statusList: [GroundStationClientTypes.ContactStatus]?

    public init(
        endTime: Foundation.Date? = nil,
        groundStation: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        statusList: [GroundStationClientTypes.ContactStatus]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.maxResults = maxResults
        self.missionProfileArn = missionProfileArn
        self.nextToken = nextToken
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.statusList = statusList
    }
}

extension GroundStationClientTypes {

    /// Data describing a contact.
    public struct ContactData: Swift.Sendable {
        /// UUID of a contact.
        public var contactId: Swift.String?
        /// Status of a contact.
        public var contactStatus: GroundStationClientTypes.ContactStatus?
        /// End time of a contact in UTC.
        public var endTime: Foundation.Date?
        /// Error message of a contact.
        public var errorMessage: Swift.String?
        /// Name of a ground station.
        public var groundStation: Swift.String?
        /// Maximum elevation angle of a contact.
        public var maximumElevation: GroundStationClientTypes.Elevation?
        /// ARN of a mission profile.
        public var missionProfileArn: Swift.String?
        /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
        public var postPassEndTime: Foundation.Date?
        /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
        public var prePassStartTime: Foundation.Date?
        /// Region of a contact.
        public var region: Swift.String?
        /// ARN of a satellite.
        public var satelliteArn: Swift.String?
        /// Start time of a contact in UTC.
        public var startTime: Foundation.Date?
        /// Tags assigned to a contact.
        public var tags: [Swift.String: Swift.String]?
        /// Projected time in UTC your satellite will set below the [receive mask](https://docs.aws.amazon.com/ground-station/latest/ug/site-masks.html). This time is based on the satellite's current active ephemeris for future contacts and the ephemeris that was active during contact execution for completed contacts. This field is not present for contacts with a SCHEDULING or SCHEDULED status.
        public var visibilityEndTime: Foundation.Date?
        /// Projected time in UTC your satellite will rise above the [receive mask](https://docs.aws.amazon.com/ground-station/latest/ug/site-masks.html). This time is based on the satellite's current active ephemeris for future contacts and the ephemeris that was active during contact execution for completed contacts. This field is not present for contacts with a SCHEDULING or SCHEDULED status.
        public var visibilityStartTime: Foundation.Date?

        public init(
            contactId: Swift.String? = nil,
            contactStatus: GroundStationClientTypes.ContactStatus? = nil,
            endTime: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            groundStation: Swift.String? = nil,
            maximumElevation: GroundStationClientTypes.Elevation? = nil,
            missionProfileArn: Swift.String? = nil,
            postPassEndTime: Foundation.Date? = nil,
            prePassStartTime: Foundation.Date? = nil,
            region: Swift.String? = nil,
            satelliteArn: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            visibilityEndTime: Foundation.Date? = nil,
            visibilityStartTime: Foundation.Date? = nil
        )
        {
            self.contactId = contactId
            self.contactStatus = contactStatus
            self.endTime = endTime
            self.errorMessage = errorMessage
            self.groundStation = groundStation
            self.maximumElevation = maximumElevation
            self.missionProfileArn = missionProfileArn
            self.postPassEndTime = postPassEndTime
            self.prePassStartTime = prePassStartTime
            self.region = region
            self.satelliteArn = satelliteArn
            self.startTime = startTime
            self.tags = tags
            self.visibilityEndTime = visibilityEndTime
            self.visibilityStartTime = visibilityStartTime
        }
    }
}

///
public struct ListContactsOutput: Swift.Sendable {
    /// List of contacts.
    public var contactList: [GroundStationClientTypes.ContactData]?
    /// Next token returned in the response of a previous ListContacts call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        contactList: [GroundStationClientTypes.ContactData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactList = contactList
        self.nextToken = nextToken
    }
}

///
public struct ReserveContactInput: Swift.Sendable {
    /// End time of a contact in UTC.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Name of a ground station.
    /// This member is required.
    public var groundStation: Swift.String?
    /// ARN of a mission profile.
    /// This member is required.
    public var missionProfileArn: Swift.String?
    /// ARN of a satellite
    /// This member is required.
    public var satelliteArn: Swift.String?
    /// Start time of a contact in UTC.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// Tags assigned to a contact.
    public var tags: [Swift.String: Swift.String]?

    public init(
        endTime: Foundation.Date? = nil,
        groundStation: Swift.String? = nil,
        missionProfileArn: Swift.String? = nil,
        satelliteArn: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.endTime = endTime
        self.groundStation = groundStation
        self.missionProfileArn = missionProfileArn
        self.satelliteArn = satelliteArn
        self.startTime = startTime
        self.tags = tags
    }
}

///
public struct ReserveContactOutput: Swift.Sendable {
    /// UUID of a contact.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

///
public struct CreateDataflowEndpointGroupInput: Swift.Sendable {
    /// Amount of time, in seconds, after a contact ends that the Ground Station Dataflow Endpoint Group will be in a POSTPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the POSTPASS state.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time, in seconds, before a contact starts that the Ground Station Dataflow Endpoint Group will be in a PREPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the PREPASS state.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// Endpoint details of each endpoint in the dataflow endpoint group.
    /// This member is required.
    public var endpointDetails: [GroundStationClientTypes.EndpointDetails]?
    /// Tags of a dataflow endpoint group.
    public var tags: [Swift.String: Swift.String]?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        endpointDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.endpointDetails = endpointDetails
        self.tags = tags
    }
}

///
public struct CreateDataflowEndpointGroupOutput: Swift.Sendable {
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?

    public init(
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

extension GroundStationClientTypes {

    /// Object stored in S3 containing ephemeris data.
    public struct S3Object: Swift.Sendable {
        /// An Amazon S3 Bucket name.
        public var bucket: Swift.String?
        /// An Amazon S3 key for the ephemeris.
        public var key: Swift.String?
        /// For versioned S3 objects, the version to use for the ephemeris.
        public var version: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.version = version
        }
    }
}

extension GroundStationClientTypes {

    /// Ephemeris data in Orbit Ephemeris Message (OEM) format. AWS Ground Station processes OEM Customer Provided Ephemerides according to the [CCSDS standard](https://public.ccsds.org/Pubs/502x0b3e1.pdf) with some extra restrictions. OEM files should be in KVN format. For more detail about the OEM format that AWS Ground Station supports, see [OEM ephemeris format](https://docs.aws.amazon.com/ground-station/latest/ug/providing-custom-ephemeris-data.html#oem-ephemeris-format) in the AWS Ground Station user guide.
    public struct OEMEphemeris: Swift.Sendable {
        /// The data for an OEM ephemeris, supplied directly in the request rather than through an S3 object.
        public var oemData: Swift.String?
        /// Identifies the S3 object to be used as the ephemeris.
        public var s3Object: GroundStationClientTypes.S3Object?

        public init(
            oemData: Swift.String? = nil,
            s3Object: GroundStationClientTypes.S3Object? = nil
        )
        {
            self.oemData = oemData
            self.s3Object = s3Object
        }
    }
}

extension GroundStationClientTypes {

    /// A time range with a start and end time.
    public struct TimeRange: Swift.Sendable {
        /// Time in UTC at which the time range ends.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// Time in UTC at which the time range starts.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension GroundStationClientTypes {

    /// Two-line element set (TLE) data.
    public struct TLEData: Swift.Sendable {
        /// First line of two-line element set (TLE) data.
        /// This member is required.
        public var tleLine1: Swift.String?
        /// Second line of two-line element set (TLE) data.
        /// This member is required.
        public var tleLine2: Swift.String?
        /// The valid time range for the TLE. Gaps or overlap are not permitted.
        /// This member is required.
        public var validTimeRange: GroundStationClientTypes.TimeRange?

        public init(
            tleLine1: Swift.String? = nil,
            tleLine2: Swift.String? = nil,
            validTimeRange: GroundStationClientTypes.TimeRange? = nil
        )
        {
            self.tleLine1 = tleLine1
            self.tleLine2 = tleLine2
            self.validTimeRange = validTimeRange
        }
    }
}

extension GroundStationClientTypes {

    /// Two-line element set (TLE) ephemeris.
    public struct TLEEphemeris: Swift.Sendable {
        /// Identifies the S3 object to be used as the ephemeris.
        public var s3Object: GroundStationClientTypes.S3Object?
        /// The data for a TLE ephemeris, supplied directly in the request rather than through an S3 object.
        public var tleData: [GroundStationClientTypes.TLEData]?

        public init(
            s3Object: GroundStationClientTypes.S3Object? = nil,
            tleData: [GroundStationClientTypes.TLEData]? = nil
        )
        {
            self.s3Object = s3Object
            self.tleData = tleData
        }
    }
}

extension GroundStationClientTypes {

    /// Ephemeris data.
    public enum EphemerisData: Swift.Sendable {
        /// Two-line element set (TLE) ephemeris.
        case tle(GroundStationClientTypes.TLEEphemeris)
        /// Ephemeris data in Orbit Ephemeris Message (OEM) format. AWS Ground Station processes OEM Customer Provided Ephemerides according to the [CCSDS standard](https://public.ccsds.org/Pubs/502x0b3e1.pdf) with some extra restrictions. OEM files should be in KVN format. For more detail about the OEM format that AWS Ground Station supports, see [OEM ephemeris format](https://docs.aws.amazon.com/ground-station/latest/ug/providing-custom-ephemeris-data.html#oem-ephemeris-format) in the AWS Ground Station user guide.
        case oem(GroundStationClientTypes.OEMEphemeris)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateEphemerisInput: Swift.Sendable {
    /// Whether to set the ephemeris status to ENABLED after validation. Setting this to false will set the ephemeris status to DISABLED after validation.
    public var enabled: Swift.Bool?
    /// Ephemeris data.
    public var ephemeris: GroundStationClientTypes.EphemerisData?
    /// An overall expiration time for the ephemeris in UTC, after which it will become EXPIRED.
    public var expirationTime: Foundation.Date?
    /// The ARN of a KMS key used to encrypt the ephemeris in Ground Station.
    public var kmsKeyArn: Swift.String?
    /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
    /// This member is required.
    public var name: Swift.String?
    /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
    public var priority: Swift.Int?
    /// AWS Ground Station satellite ID for this ephemeris.
    /// This member is required.
    public var satelliteId: Swift.String?
    /// Tags assigned to an ephemeris.
    public var tags: [Swift.String: Swift.String]?

    public init(
        enabled: Swift.Bool? = nil,
        ephemeris: GroundStationClientTypes.EphemerisData? = nil,
        expirationTime: Foundation.Date? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        satelliteId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.enabled = enabled
        self.ephemeris = ephemeris
        self.expirationTime = expirationTime
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.priority = priority
        self.satelliteId = satelliteId
        self.tags = tags
    }
}

public struct CreateEphemerisOutput: Swift.Sendable {
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

extension GroundStationClientTypes {

    /// AWS Key Management Service (KMS) Key.
    public enum KmsKey: Swift.Sendable {
        /// KMS Key Arn.
        case kmskeyarn(Swift.String)
        /// KMS Alias Arn.
        case kmsaliasarn(Swift.String)
        /// KMS Alias Name.
        case kmsaliasname(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

///
public struct CreateMissionProfileInput: Swift.Sendable {
    /// Amount of time after a contact ends that you’d like to receive a Ground Station Contact State Change event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time prior to contact start you’d like to receive a Ground Station Contact State Change event indicating an upcoming pass.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    /// This member is required.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    /// This member is required.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// Name of a mission profile.
    /// This member is required.
    public var name: Swift.String?
    /// KMS key to use for encrypting streams.
    public var streamsKmsKey: GroundStationClientTypes.KmsKey?
    /// Role to use for encrypting streams with KMS key.
    public var streamsKmsRole: Swift.String?
    /// Tags assigned to a mission profile.
    public var tags: [Swift.String: Swift.String]?
    /// ARN of a tracking Config.
    /// This member is required.
    public var trackingConfigArn: Swift.String?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        streamsKmsKey: GroundStationClientTypes.KmsKey? = nil,
        streamsKmsRole: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.name = name
        self.streamsKmsKey = streamsKmsKey
        self.streamsKmsRole = streamsKmsRole
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

///
public struct CreateMissionProfileOutput: Swift.Sendable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

///
public struct DeleteDataflowEndpointGroupInput: Swift.Sendable {
    /// UUID of a dataflow endpoint group.
    /// This member is required.
    public var dataflowEndpointGroupId: Swift.String?

    public init(
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

///
public struct DeleteDataflowEndpointGroupOutput: Swift.Sendable {
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?

    public init(
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

///
public struct GetDataflowEndpointGroupInput: Swift.Sendable {
    /// UUID of a dataflow endpoint group.
    /// This member is required.
    public var dataflowEndpointGroupId: Swift.String?

    public init(
        dataflowEndpointGroupId: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
    }
}

///
public struct GetDataflowEndpointGroupOutput: Swift.Sendable {
    /// Amount of time, in seconds, after a contact ends that the Ground Station Dataflow Endpoint Group will be in a POSTPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the POSTPASS state.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time, in seconds, before a contact starts that the Ground Station Dataflow Endpoint Group will be in a PREPASS state. A Ground Station Dataflow Endpoint Group State Change event will be emitted when the Dataflow Endpoint Group enters and exits the PREPASS state.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// ARN of a dataflow endpoint group.
    public var dataflowEndpointGroupArn: Swift.String?
    /// UUID of a dataflow endpoint group.
    public var dataflowEndpointGroupId: Swift.String?
    /// Details of a dataflow endpoint.
    public var endpointsDetails: [GroundStationClientTypes.EndpointDetails]?
    /// Tags assigned to a dataflow endpoint group.
    public var tags: [Swift.String: Swift.String]?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEndpointGroupArn: Swift.String? = nil,
        dataflowEndpointGroupId: Swift.String? = nil,
        endpointsDetails: [GroundStationClientTypes.EndpointDetails]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
        self.dataflowEndpointGroupId = dataflowEndpointGroupId
        self.endpointsDetails = endpointsDetails
        self.tags = tags
    }
}

///
public struct ListDataflowEndpointGroupsInput: Swift.Sendable {
    /// Maximum number of dataflow endpoint groups returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GroundStationClientTypes {

    /// Item in a list of DataflowEndpoint groups.
    public struct DataflowEndpointListItem: Swift.Sendable {
        /// ARN of a dataflow endpoint group.
        public var dataflowEndpointGroupArn: Swift.String?
        /// UUID of a dataflow endpoint group.
        public var dataflowEndpointGroupId: Swift.String?

        public init(
            dataflowEndpointGroupArn: Swift.String? = nil,
            dataflowEndpointGroupId: Swift.String? = nil
        )
        {
            self.dataflowEndpointGroupArn = dataflowEndpointGroupArn
            self.dataflowEndpointGroupId = dataflowEndpointGroupId
        }
    }
}

///
public struct ListDataflowEndpointGroupsOutput: Swift.Sendable {
    /// A list of dataflow endpoint groups.
    public var dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]?
    /// Next token returned in the response of a previous ListDataflowEndpointGroups call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        dataflowEndpointGroupList: [GroundStationClientTypes.DataflowEndpointListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataflowEndpointGroupList = dataflowEndpointGroupList
        self.nextToken = nextToken
    }
}

public struct DeleteEphemerisInput: Swift.Sendable {
    /// The AWS Ground Station ephemeris ID.
    /// This member is required.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

public struct DeleteEphemerisOutput: Swift.Sendable {
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

///
public struct DeleteMissionProfileInput: Swift.Sendable {
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

///
public struct DeleteMissionProfileOutput: Swift.Sendable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

public struct DescribeEphemerisInput: Swift.Sendable {
    /// The AWS Ground Station ephemeris ID.
    /// This member is required.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

extension GroundStationClientTypes {

    public enum EphemerisInvalidReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Provided KMS key is invalid
        case kmsKeyInvalid
        /// Provided spacecraft identifiers such as spacecraft NORAD Id are invalid
        case metadataInvalid
        /// Start, end, or expiration time(s) are invalid for the provided ephemeris
        case timeRangeInvalid
        /// Provided ephemeris defines invalid spacecraft trajectory
        case trajectoryInvalid
        /// Internal Service Error occurred while processing ephemeris
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [EphemerisInvalidReason] {
            return [
                .kmsKeyInvalid,
                .metadataInvalid,
                .timeRangeInvalid,
                .trajectoryInvalid,
                .validationError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kmsKeyInvalid: return "KMS_KEY_INVALID"
            case .metadataInvalid: return "METADATA_INVALID"
            case .timeRangeInvalid: return "TIME_RANGE_INVALID"
            case .trajectoryInvalid: return "TRAJECTORY_INVALID"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    public enum EphemerisStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case error
        case expired
        case invalid
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [EphemerisStatus] {
            return [
                .disabled,
                .enabled,
                .error,
                .expired,
                .invalid,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .error: return "ERROR"
            case .expired: return "EXPIRED"
            case .invalid: return "INVALID"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Description of ephemeris.
    public struct EphemerisDescription: Swift.Sendable {
        /// Supplied ephemeris data.
        public var ephemerisData: Swift.String?
        /// Source S3 object used for the ephemeris.
        public var sourceS3Object: GroundStationClientTypes.S3Object?

        public init(
            ephemerisData: Swift.String? = nil,
            sourceS3Object: GroundStationClientTypes.S3Object? = nil
        )
        {
            self.ephemerisData = ephemerisData
            self.sourceS3Object = sourceS3Object
        }
    }
}

extension GroundStationClientTypes {

    ///
    public enum EphemerisTypeDescription: Swift.Sendable {
        /// Description of ephemeris.
        case tle(GroundStationClientTypes.EphemerisDescription)
        /// Description of ephemeris.
        case oem(GroundStationClientTypes.EphemerisDescription)
        case sdkUnknown(Swift.String)
    }
}

public struct DescribeEphemerisOutput: Swift.Sendable {
    /// The time the ephemeris was uploaded in UTC.
    public var creationTime: Foundation.Date?
    /// Whether or not the ephemeris is enabled.
    public var enabled: Swift.Bool?
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?
    /// Reason that an ephemeris failed validation. Only provided for ephemerides with INVALID status.
    public var invalidReason: GroundStationClientTypes.EphemerisInvalidReason?
    /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
    public var name: Swift.String?
    /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
    public var priority: Swift.Int?
    /// The AWS Ground Station satellite ID associated with ephemeris.
    public var satelliteId: Swift.String?
    /// The status of the ephemeris.
    public var status: GroundStationClientTypes.EphemerisStatus?
    /// Supplied ephemeris data.
    public var suppliedData: GroundStationClientTypes.EphemerisTypeDescription?
    /// Tags assigned to an ephemeris.
    public var tags: [Swift.String: Swift.String]?

    public init(
        creationTime: Foundation.Date? = nil,
        enabled: Swift.Bool? = nil,
        ephemerisId: Swift.String? = nil,
        invalidReason: GroundStationClientTypes.EphemerisInvalidReason? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        satelliteId: Swift.String? = nil,
        status: GroundStationClientTypes.EphemerisStatus? = nil,
        suppliedData: GroundStationClientTypes.EphemerisTypeDescription? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.creationTime = creationTime
        self.enabled = enabled
        self.ephemerisId = ephemerisId
        self.invalidReason = invalidReason
        self.name = name
        self.priority = priority
        self.satelliteId = satelliteId
        self.status = status
        self.suppliedData = suppliedData
        self.tags = tags
    }
}

extension GroundStationClientTypes {

    /// Ephemeris item.
    public struct EphemerisItem: Swift.Sendable {
        /// The time the ephemeris was uploaded in UTC.
        public var creationTime: Foundation.Date?
        /// Whether or not the ephemeris is enabled.
        public var enabled: Swift.Bool?
        /// The AWS Ground Station ephemeris ID.
        public var ephemerisId: Swift.String?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
        public var name: Swift.String?
        /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
        public var priority: Swift.Int?
        /// Source S3 object used for the ephemeris.
        public var sourceS3Object: GroundStationClientTypes.S3Object?
        /// The status of the ephemeris.
        public var status: GroundStationClientTypes.EphemerisStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            enabled: Swift.Bool? = nil,
            ephemerisId: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sourceS3Object: GroundStationClientTypes.S3Object? = nil,
            status: GroundStationClientTypes.EphemerisStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.enabled = enabled
            self.ephemerisId = ephemerisId
            self.name = name
            self.priority = priority
            self.sourceS3Object = sourceS3Object
            self.status = status
        }
    }
}

public struct ListEphemeridesInput: Swift.Sendable {
    /// The end time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Maximum number of ephemerides to return.
    public var maxResults: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The AWS Ground Station satellite ID to list ephemeris for.
    /// This member is required.
    public var satelliteId: Swift.String?
    /// The start time to list in UTC. The operation will return an ephemeris if its expiration time is within the time range defined by the startTime and endTime.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// The list of ephemeris status to return.
    public var statusList: [GroundStationClientTypes.EphemerisStatus]?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        satelliteId: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        statusList: [GroundStationClientTypes.EphemerisStatus]? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.satelliteId = satelliteId
        self.startTime = startTime
        self.statusList = statusList
    }
}

public struct ListEphemeridesOutput: Swift.Sendable {
    /// List of ephemerides.
    public var ephemerides: [GroundStationClientTypes.EphemerisItem]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        ephemerides: [GroundStationClientTypes.EphemerisItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ephemerides = ephemerides
        self.nextToken = nextToken
    }
}

public struct UpdateEphemerisInput: Swift.Sendable {
    /// Whether the ephemeris is enabled or not. Changing this value will not require the ephemeris to be re-validated.
    /// This member is required.
    public var enabled: Swift.Bool?
    /// The AWS Ground Station ephemeris ID.
    /// This member is required.
    public var ephemerisId: Swift.String?
    /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris.
    public var name: Swift.String?
    /// Customer-provided priority score to establish the order in which overlapping ephemerides should be used. The default for customer-provided ephemeris priority is 1, and higher numbers take precedence. Priority must be 1 or greater
    public var priority: Swift.Int?

    public init(
        enabled: Swift.Bool? = nil,
        ephemerisId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.enabled = enabled
        self.ephemerisId = ephemerisId
        self.name = name
        self.priority = priority
    }
}

public struct UpdateEphemerisOutput: Swift.Sendable {
    /// The AWS Ground Station ephemeris ID.
    public var ephemerisId: Swift.String?

    public init(
        ephemerisId: Swift.String? = nil
    )
    {
        self.ephemerisId = ephemerisId
    }
}

extension GroundStationClientTypes {

    public enum EphemerisSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customerProvided
        case spaceTrack
        case sdkUnknown(Swift.String)

        public static var allCases: [EphemerisSource] {
            return [
                .customerProvided,
                .spaceTrack
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customerProvided: return "CUSTOMER_PROVIDED"
            case .spaceTrack: return "SPACE_TRACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GroundStationClientTypes {

    /// Metadata describing a particular ephemeris.
    public struct EphemerisMetaData: Swift.Sendable {
        /// UUID of a customer-provided ephemeris. This field is not populated for default ephemerides from Space Track.
        public var ephemerisId: Swift.String?
        /// The epoch of a default, ephemeris from Space Track in UTC. This field is not populated for customer-provided ephemerides.
        public var epoch: Foundation.Date?
        /// A name string associated with the ephemeris. Used as a human-readable identifier for the ephemeris. A name is only returned for customer-provider ephemerides that have a name associated.
        public var name: Swift.String?
        /// The EphemerisSource that generated a given ephemeris.
        /// This member is required.
        public var source: GroundStationClientTypes.EphemerisSource?

        public init(
            ephemerisId: Swift.String? = nil,
            epoch: Foundation.Date? = nil,
            name: Swift.String? = nil,
            source: GroundStationClientTypes.EphemerisSource? = nil
        )
        {
            self.ephemerisId = ephemerisId
            self.epoch = epoch
            self.name = name
            self.source = source
        }
    }
}

///
public struct GetMinuteUsageInput: Swift.Sendable {
    /// The month being requested, with a value of 1-12.
    /// This member is required.
    public var month: Swift.Int?
    /// The year being requested, in the format of YYYY.
    /// This member is required.
    public var year: Swift.Int?

    public init(
        month: Swift.Int? = nil,
        year: Swift.Int? = nil
    )
    {
        self.month = month
        self.year = year
    }
}

///
public struct GetMinuteUsageOutput: Swift.Sendable {
    /// Estimated number of minutes remaining for an account, specific to the month being requested.
    public var estimatedMinutesRemaining: Swift.Int?
    /// Returns whether or not an account has signed up for the reserved minutes pricing plan, specific to the month being requested.
    public var isReservedMinutesCustomer: Swift.Bool?
    /// Total number of reserved minutes allocated, specific to the month being requested.
    public var totalReservedMinuteAllocation: Swift.Int?
    /// Total scheduled minutes for an account, specific to the month being requested.
    public var totalScheduledMinutes: Swift.Int?
    /// Upcoming minutes scheduled for an account, specific to the month being requested.
    public var upcomingMinutesScheduled: Swift.Int?

    public init(
        estimatedMinutesRemaining: Swift.Int? = nil,
        isReservedMinutesCustomer: Swift.Bool? = nil,
        totalReservedMinuteAllocation: Swift.Int? = nil,
        totalScheduledMinutes: Swift.Int? = nil,
        upcomingMinutesScheduled: Swift.Int? = nil
    )
    {
        self.estimatedMinutesRemaining = estimatedMinutesRemaining
        self.isReservedMinutesCustomer = isReservedMinutesCustomer
        self.totalReservedMinuteAllocation = totalReservedMinuteAllocation
        self.totalScheduledMinutes = totalScheduledMinutes
        self.upcomingMinutesScheduled = upcomingMinutesScheduled
    }
}

///
public struct GetMissionProfileInput: Swift.Sendable {
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

///
public struct GetMissionProfileOutput: Swift.Sendable {
    /// Amount of time after a contact ends that you’d like to receive a CloudWatch event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time prior to contact start you’d like to receive a CloudWatch event indicating an upcoming pass.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// ARN of a mission profile.
    public var missionProfileArn: Swift.String?
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?
    /// Name of a mission profile.
    public var name: Swift.String?
    /// Region of a mission profile.
    public var region: Swift.String?
    /// KMS key to use for encrypting streams.
    public var streamsKmsKey: GroundStationClientTypes.KmsKey?
    /// Role to use for encrypting streams with KMS key.
    public var streamsKmsRole: Swift.String?
    /// Tags assigned to a mission profile.
    public var tags: [Swift.String: Swift.String]?
    /// ARN of a tracking Config.
    public var trackingConfigArn: Swift.String?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileArn: Swift.String? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        streamsKmsKey: GroundStationClientTypes.KmsKey? = nil,
        streamsKmsRole: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileArn = missionProfileArn
        self.missionProfileId = missionProfileId
        self.name = name
        self.region = region
        self.streamsKmsKey = streamsKmsKey
        self.streamsKmsRole = streamsKmsRole
        self.tags = tags
        self.trackingConfigArn = trackingConfigArn
    }
}

///
public struct GetSatelliteInput: Swift.Sendable {
    /// UUID of a satellite.
    /// This member is required.
    public var satelliteId: Swift.String?

    public init(
        satelliteId: Swift.String? = nil
    )
    {
        self.satelliteId = satelliteId
    }
}

///
public struct GetSatelliteOutput: Swift.Sendable {
    /// The current ephemeris being used to compute the trajectory of the satellite.
    public var currentEphemeris: GroundStationClientTypes.EphemerisMetaData?
    /// A list of ground stations to which the satellite is on-boarded.
    public var groundStations: [Swift.String]?
    /// NORAD satellite ID number.
    public var noradSatelliteID: Swift.Int
    /// ARN of a satellite.
    public var satelliteArn: Swift.String?
    /// UUID of a satellite.
    public var satelliteId: Swift.String?

    public init(
        currentEphemeris: GroundStationClientTypes.EphemerisMetaData? = nil,
        groundStations: [Swift.String]? = nil,
        noradSatelliteID: Swift.Int = 0,
        satelliteArn: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.currentEphemeris = currentEphemeris
        self.groundStations = groundStations
        self.noradSatelliteID = noradSatelliteID
        self.satelliteArn = satelliteArn
        self.satelliteId = satelliteId
    }
}

///
public struct ListGroundStationsInput: Swift.Sendable {
    /// Maximum number of ground stations returned.
    public var maxResults: Swift.Int?
    /// Next token that can be supplied in the next call to get the next page of ground stations.
    public var nextToken: Swift.String?
    /// Satellite ID to retrieve on-boarded ground stations.
    public var satelliteId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        satelliteId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.satelliteId = satelliteId
    }
}

extension GroundStationClientTypes {

    /// Information about the ground station data.
    public struct GroundStationData: Swift.Sendable {
        /// UUID of a ground station.
        public var groundStationId: Swift.String?
        /// Name of a ground station.
        public var groundStationName: Swift.String?
        /// Ground station Region.
        public var region: Swift.String?

        public init(
            groundStationId: Swift.String? = nil,
            groundStationName: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.groundStationId = groundStationId
            self.groundStationName = groundStationName
            self.region = region
        }
    }
}

///
public struct ListGroundStationsOutput: Swift.Sendable {
    /// List of ground stations.
    public var groundStationList: [GroundStationClientTypes.GroundStationData]?
    /// Next token that can be supplied in the next call to get the next page of ground stations.
    public var nextToken: Swift.String?

    public init(
        groundStationList: [GroundStationClientTypes.GroundStationData]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groundStationList = groundStationList
        self.nextToken = nextToken
    }
}

///
public struct ListTagsForResourceInput: Swift.Sendable {
    /// ARN of a resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

///
public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Tags assigned to a resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

///
public struct ListMissionProfilesInput: Swift.Sendable {
    /// Maximum number of mission profiles returned.
    public var maxResults: Swift.Int?
    /// Next token returned in the request of a previous ListMissionProfiles call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GroundStationClientTypes {

    /// Item in a list of mission profiles.
    public struct MissionProfileListItem: Swift.Sendable {
        /// ARN of a mission profile.
        public var missionProfileArn: Swift.String?
        /// UUID of a mission profile.
        public var missionProfileId: Swift.String?
        /// Name of a mission profile.
        public var name: Swift.String?
        /// Region of a mission profile.
        public var region: Swift.String?

        public init(
            missionProfileArn: Swift.String? = nil,
            missionProfileId: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.missionProfileArn = missionProfileArn
            self.missionProfileId = missionProfileId
            self.name = name
            self.region = region
        }
    }
}

///
public struct ListMissionProfilesOutput: Swift.Sendable {
    /// List of mission profiles.
    public var missionProfileList: [GroundStationClientTypes.MissionProfileListItem]?
    /// Next token returned in the response of a previous ListMissionProfiles call. Used to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        missionProfileList: [GroundStationClientTypes.MissionProfileListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.missionProfileList = missionProfileList
        self.nextToken = nextToken
    }
}

///
public struct UpdateMissionProfileInput: Swift.Sendable {
    /// Amount of time after a contact ends that you’d like to receive a Ground Station Contact State Change event indicating the pass has finished.
    public var contactPostPassDurationSeconds: Swift.Int?
    /// Amount of time after a contact ends that you’d like to receive a Ground Station Contact State Change event indicating the pass has finished.
    public var contactPrePassDurationSeconds: Swift.Int?
    /// A list of lists of ARNs. Each list of ARNs is an edge, with a from Config and a to Config.
    public var dataflowEdges: [[Swift.String]]?
    /// Smallest amount of time in seconds that you’d like to see for an available contact. AWS Ground Station will not present you with contacts shorter than this duration.
    public var minimumViableContactDurationSeconds: Swift.Int?
    /// UUID of a mission profile.
    /// This member is required.
    public var missionProfileId: Swift.String?
    /// Name of a mission profile.
    public var name: Swift.String?
    /// KMS key to use for encrypting streams.
    public var streamsKmsKey: GroundStationClientTypes.KmsKey?
    /// Role to use for encrypting streams with KMS key.
    public var streamsKmsRole: Swift.String?
    /// ARN of a tracking Config.
    public var trackingConfigArn: Swift.String?

    public init(
        contactPostPassDurationSeconds: Swift.Int? = nil,
        contactPrePassDurationSeconds: Swift.Int? = nil,
        dataflowEdges: [[Swift.String]]? = nil,
        minimumViableContactDurationSeconds: Swift.Int? = nil,
        missionProfileId: Swift.String? = nil,
        name: Swift.String? = nil,
        streamsKmsKey: GroundStationClientTypes.KmsKey? = nil,
        streamsKmsRole: Swift.String? = nil,
        trackingConfigArn: Swift.String? = nil
    )
    {
        self.contactPostPassDurationSeconds = contactPostPassDurationSeconds
        self.contactPrePassDurationSeconds = contactPrePassDurationSeconds
        self.dataflowEdges = dataflowEdges
        self.minimumViableContactDurationSeconds = minimumViableContactDurationSeconds
        self.missionProfileId = missionProfileId
        self.name = name
        self.streamsKmsKey = streamsKmsKey
        self.streamsKmsRole = streamsKmsRole
        self.trackingConfigArn = trackingConfigArn
    }
}

///
public struct UpdateMissionProfileOutput: Swift.Sendable {
    /// UUID of a mission profile.
    public var missionProfileId: Swift.String?

    public init(
        missionProfileId: Swift.String? = nil
    )
    {
        self.missionProfileId = missionProfileId
    }
}

///
public struct ListSatellitesInput: Swift.Sendable {
    /// Maximum number of satellites returned.
    public var maxResults: Swift.Int?
    /// Next token that can be supplied in the next call to get the next page of satellites.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GroundStationClientTypes {

    /// Item in a list of satellites.
    public struct SatelliteListItem: Swift.Sendable {
        /// The current ephemeris being used to compute the trajectory of the satellite.
        public var currentEphemeris: GroundStationClientTypes.EphemerisMetaData?
        /// A list of ground stations to which the satellite is on-boarded.
        public var groundStations: [Swift.String]?
        /// NORAD satellite ID number.
        public var noradSatelliteID: Swift.Int
        /// ARN of a satellite.
        public var satelliteArn: Swift.String?
        /// UUID of a satellite.
        public var satelliteId: Swift.String?

        public init(
            currentEphemeris: GroundStationClientTypes.EphemerisMetaData? = nil,
            groundStations: [Swift.String]? = nil,
            noradSatelliteID: Swift.Int = 0,
            satelliteArn: Swift.String? = nil,
            satelliteId: Swift.String? = nil
        )
        {
            self.currentEphemeris = currentEphemeris
            self.groundStations = groundStations
            self.noradSatelliteID = noradSatelliteID
            self.satelliteArn = satelliteArn
            self.satelliteId = satelliteId
        }
    }
}

///
public struct ListSatellitesOutput: Swift.Sendable {
    /// Next token that can be supplied in the next call to get the next page of satellites.
    public var nextToken: Swift.String?
    /// List of satellites.
    public var satellites: [GroundStationClientTypes.SatelliteListItem]?

    public init(
        nextToken: Swift.String? = nil,
        satellites: [GroundStationClientTypes.SatelliteListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.satellites = satellites
    }
}

///
public struct TagResourceInput: Swift.Sendable {
    /// ARN of a resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags assigned to a resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

///
public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

///
public struct UntagResourceInput: Swift.Sendable {
    /// ARN of a resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of a resource tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

///
public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CancelContactInput {

    static func urlPathProvider(_ value: CancelContactInput) -> Swift.String? {
        guard let contactId = value.contactId else {
            return nil
        }
        return "/contact/\(contactId.urlPercentEncoding())"
    }
}

extension CreateConfigInput {

    static func urlPathProvider(_ value: CreateConfigInput) -> Swift.String? {
        return "/config"
    }
}

extension CreateDataflowEndpointGroupInput {

    static func urlPathProvider(_ value: CreateDataflowEndpointGroupInput) -> Swift.String? {
        return "/dataflowEndpointGroup"
    }
}

extension CreateEphemerisInput {

    static func urlPathProvider(_ value: CreateEphemerisInput) -> Swift.String? {
        return "/ephemeris"
    }
}

extension CreateMissionProfileInput {

    static func urlPathProvider(_ value: CreateMissionProfileInput) -> Swift.String? {
        return "/missionprofile"
    }
}

extension DeleteConfigInput {

    static func urlPathProvider(_ value: DeleteConfigInput) -> Swift.String? {
        guard let configType = value.configType else {
            return nil
        }
        guard let configId = value.configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

extension DeleteDataflowEndpointGroupInput {

    static func urlPathProvider(_ value: DeleteDataflowEndpointGroupInput) -> Swift.String? {
        guard let dataflowEndpointGroupId = value.dataflowEndpointGroupId else {
            return nil
        }
        return "/dataflowEndpointGroup/\(dataflowEndpointGroupId.urlPercentEncoding())"
    }
}

extension DeleteEphemerisInput {

    static func urlPathProvider(_ value: DeleteEphemerisInput) -> Swift.String? {
        guard let ephemerisId = value.ephemerisId else {
            return nil
        }
        return "/ephemeris/\(ephemerisId.urlPercentEncoding())"
    }
}

extension DeleteMissionProfileInput {

    static func urlPathProvider(_ value: DeleteMissionProfileInput) -> Swift.String? {
        guard let missionProfileId = value.missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

extension DescribeContactInput {

    static func urlPathProvider(_ value: DescribeContactInput) -> Swift.String? {
        guard let contactId = value.contactId else {
            return nil
        }
        return "/contact/\(contactId.urlPercentEncoding())"
    }
}

extension DescribeEphemerisInput {

    static func urlPathProvider(_ value: DescribeEphemerisInput) -> Swift.String? {
        guard let ephemerisId = value.ephemerisId else {
            return nil
        }
        return "/ephemeris/\(ephemerisId.urlPercentEncoding())"
    }
}

extension GetAgentConfigurationInput {

    static func urlPathProvider(_ value: GetAgentConfigurationInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agent/\(agentId.urlPercentEncoding())/configuration"
    }
}

extension GetConfigInput {

    static func urlPathProvider(_ value: GetConfigInput) -> Swift.String? {
        guard let configType = value.configType else {
            return nil
        }
        guard let configId = value.configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

extension GetDataflowEndpointGroupInput {

    static func urlPathProvider(_ value: GetDataflowEndpointGroupInput) -> Swift.String? {
        guard let dataflowEndpointGroupId = value.dataflowEndpointGroupId else {
            return nil
        }
        return "/dataflowEndpointGroup/\(dataflowEndpointGroupId.urlPercentEncoding())"
    }
}

extension GetMinuteUsageInput {

    static func urlPathProvider(_ value: GetMinuteUsageInput) -> Swift.String? {
        return "/minute-usage"
    }
}

extension GetMissionProfileInput {

    static func urlPathProvider(_ value: GetMissionProfileInput) -> Swift.String? {
        guard let missionProfileId = value.missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

extension GetSatelliteInput {

    static func urlPathProvider(_ value: GetSatelliteInput) -> Swift.String? {
        guard let satelliteId = value.satelliteId else {
            return nil
        }
        return "/satellite/\(satelliteId.urlPercentEncoding())"
    }
}

extension ListConfigsInput {

    static func urlPathProvider(_ value: ListConfigsInput) -> Swift.String? {
        return "/config"
    }
}

extension ListConfigsInput {

    static func queryItemProvider(_ value: ListConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListContactsInput {

    static func urlPathProvider(_ value: ListContactsInput) -> Swift.String? {
        return "/contacts"
    }
}

extension ListDataflowEndpointGroupsInput {

    static func urlPathProvider(_ value: ListDataflowEndpointGroupsInput) -> Swift.String? {
        return "/dataflowEndpointGroup"
    }
}

extension ListDataflowEndpointGroupsInput {

    static func queryItemProvider(_ value: ListDataflowEndpointGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListEphemeridesInput {

    static func urlPathProvider(_ value: ListEphemeridesInput) -> Swift.String? {
        return "/ephemerides"
    }
}

extension ListEphemeridesInput {

    static func queryItemProvider(_ value: ListEphemeridesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListGroundStationsInput {

    static func urlPathProvider(_ value: ListGroundStationsInput) -> Swift.String? {
        return "/groundstation"
    }
}

extension ListGroundStationsInput {

    static func queryItemProvider(_ value: ListGroundStationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let satelliteId = value.satelliteId {
            let satelliteIdQueryItem = Smithy.URIQueryItem(name: "satelliteId".urlPercentEncoding(), value: Swift.String(satelliteId).urlPercentEncoding())
            items.append(satelliteIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListMissionProfilesInput {

    static func urlPathProvider(_ value: ListMissionProfilesInput) -> Swift.String? {
        return "/missionprofile"
    }
}

extension ListMissionProfilesInput {

    static func queryItemProvider(_ value: ListMissionProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSatellitesInput {

    static func urlPathProvider(_ value: ListSatellitesInput) -> Swift.String? {
        return "/satellite"
    }
}

extension ListSatellitesInput {

    static func queryItemProvider(_ value: ListSatellitesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension RegisterAgentInput {

    static func urlPathProvider(_ value: RegisterAgentInput) -> Swift.String? {
        return "/agent"
    }
}

extension ReserveContactInput {

    static func urlPathProvider(_ value: ReserveContactInput) -> Swift.String? {
        return "/contact"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAgentStatusInput {

    static func urlPathProvider(_ value: UpdateAgentStatusInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agent/\(agentId.urlPercentEncoding())"
    }
}

extension UpdateConfigInput {

    static func urlPathProvider(_ value: UpdateConfigInput) -> Swift.String? {
        guard let configType = value.configType else {
            return nil
        }
        guard let configId = value.configId else {
            return nil
        }
        return "/config/\(configType.rawValue.urlPercentEncoding())/\(configId.urlPercentEncoding())"
    }
}

extension UpdateEphemerisInput {

    static func urlPathProvider(_ value: UpdateEphemerisInput) -> Swift.String? {
        guard let ephemerisId = value.ephemerisId else {
            return nil
        }
        return "/ephemeris/\(ephemerisId.urlPercentEncoding())"
    }
}

extension UpdateMissionProfileInput {

    static func urlPathProvider(_ value: UpdateMissionProfileInput) -> Swift.String? {
        guard let missionProfileId = value.missionProfileId else {
            return nil
        }
        return "/missionprofile/\(missionProfileId.urlPercentEncoding())"
    }
}

extension CreateConfigInput {

    static func write(value: CreateConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configData"].write(value.configData, with: GroundStationClientTypes.ConfigTypeData.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDataflowEndpointGroupInput {

    static func write(value: CreateDataflowEndpointGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contactPostPassDurationSeconds"].write(value.contactPostPassDurationSeconds)
        try writer["contactPrePassDurationSeconds"].write(value.contactPrePassDurationSeconds)
        try writer["endpointDetails"].writeList(value.endpointDetails, memberWritingClosure: GroundStationClientTypes.EndpointDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateEphemerisInput {

    static func write(value: CreateEphemerisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["ephemeris"].write(value.ephemeris, with: GroundStationClientTypes.EphemerisData.write(value:to:))
        try writer["expirationTime"].writeTimestamp(value.expirationTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
        try writer["satelliteId"].write(value.satelliteId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateMissionProfileInput {

    static func write(value: CreateMissionProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contactPostPassDurationSeconds"].write(value.contactPostPassDurationSeconds)
        try writer["contactPrePassDurationSeconds"].write(value.contactPrePassDurationSeconds)
        try writer["dataflowEdges"].writeList(value.dataflowEdges, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["minimumViableContactDurationSeconds"].write(value.minimumViableContactDurationSeconds)
        try writer["name"].write(value.name)
        try writer["streamsKmsKey"].write(value.streamsKmsKey, with: GroundStationClientTypes.KmsKey.write(value:to:))
        try writer["streamsKmsRole"].write(value.streamsKmsRole)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["trackingConfigArn"].write(value.trackingConfigArn)
    }
}

extension GetMinuteUsageInput {

    static func write(value: GetMinuteUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["month"].write(value.month)
        try writer["year"].write(value.year)
    }
}

extension ListContactsInput {

    static func write(value: ListContactsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["groundStation"].write(value.groundStation)
        try writer["maxResults"].write(value.maxResults)
        try writer["missionProfileArn"].write(value.missionProfileArn)
        try writer["nextToken"].write(value.nextToken)
        try writer["satelliteArn"].write(value.satelliteArn)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["statusList"].writeList(value.statusList, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GroundStationClientTypes.ContactStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListEphemeridesInput {

    static func write(value: ListEphemeridesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["satelliteId"].write(value.satelliteId)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["statusList"].writeList(value.statusList, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GroundStationClientTypes.EphemerisStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RegisterAgentInput {

    static func write(value: RegisterAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentDetails"].write(value.agentDetails, with: GroundStationClientTypes.AgentDetails.write(value:to:))
        try writer["discoveryData"].write(value.discoveryData, with: GroundStationClientTypes.DiscoveryData.write(value:to:))
    }
}

extension ReserveContactInput {

    static func write(value: ReserveContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["groundStation"].write(value.groundStation)
        try writer["missionProfileArn"].write(value.missionProfileArn)
        try writer["satelliteArn"].write(value.satelliteArn)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAgentStatusInput {

    static func write(value: UpdateAgentStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregateStatus"].write(value.aggregateStatus, with: GroundStationClientTypes.AggregateStatus.write(value:to:))
        try writer["componentStatuses"].writeList(value.componentStatuses, memberWritingClosure: GroundStationClientTypes.ComponentStatusData.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taskId"].write(value.taskId)
    }
}

extension UpdateConfigInput {

    static func write(value: UpdateConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configData"].write(value.configData, with: GroundStationClientTypes.ConfigTypeData.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension UpdateEphemerisInput {

    static func write(value: UpdateEphemerisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
    }
}

extension UpdateMissionProfileInput {

    static func write(value: UpdateMissionProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contactPostPassDurationSeconds"].write(value.contactPostPassDurationSeconds)
        try writer["contactPrePassDurationSeconds"].write(value.contactPrePassDurationSeconds)
        try writer["dataflowEdges"].writeList(value.dataflowEdges, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["minimumViableContactDurationSeconds"].write(value.minimumViableContactDurationSeconds)
        try writer["name"].write(value.name)
        try writer["streamsKmsKey"].write(value.streamsKmsKey, with: GroundStationClientTypes.KmsKey.write(value:to:))
        try writer["streamsKmsRole"].write(value.streamsKmsRole)
        try writer["trackingConfigArn"].write(value.trackingConfigArn)
    }
}

extension CancelContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelContactOutput()
        value.contactId = try reader["contactId"].readIfPresent()
        return value
    }
}

extension CreateConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfigOutput()
        value.configArn = try reader["configArn"].readIfPresent()
        value.configId = try reader["configId"].readIfPresent()
        value.configType = try reader["configType"].readIfPresent()
        return value
    }
}

extension CreateDataflowEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataflowEndpointGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataflowEndpointGroupOutput()
        value.dataflowEndpointGroupId = try reader["dataflowEndpointGroupId"].readIfPresent()
        return value
    }
}

extension CreateEphemerisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEphemerisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEphemerisOutput()
        value.ephemerisId = try reader["ephemerisId"].readIfPresent()
        return value
    }
}

extension CreateMissionProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMissionProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMissionProfileOutput()
        value.missionProfileId = try reader["missionProfileId"].readIfPresent()
        return value
    }
}

extension DeleteConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteConfigOutput()
        value.configArn = try reader["configArn"].readIfPresent()
        value.configId = try reader["configId"].readIfPresent()
        value.configType = try reader["configType"].readIfPresent()
        return value
    }
}

extension DeleteDataflowEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataflowEndpointGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataflowEndpointGroupOutput()
        value.dataflowEndpointGroupId = try reader["dataflowEndpointGroupId"].readIfPresent()
        return value
    }
}

extension DeleteEphemerisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEphemerisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEphemerisOutput()
        value.ephemerisId = try reader["ephemerisId"].readIfPresent()
        return value
    }
}

extension DeleteMissionProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMissionProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMissionProfileOutput()
        value.missionProfileId = try reader["missionProfileId"].readIfPresent()
        return value
    }
}

extension DescribeContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeContactOutput()
        value.contactId = try reader["contactId"].readIfPresent()
        value.contactStatus = try reader["contactStatus"].readIfPresent()
        value.dataflowList = try reader["dataflowList"].readListIfPresent(memberReadingClosure: GroundStationClientTypes.DataflowDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.groundStation = try reader["groundStation"].readIfPresent()
        value.maximumElevation = try reader["maximumElevation"].readIfPresent(with: GroundStationClientTypes.Elevation.read(from:))
        value.missionProfileArn = try reader["missionProfileArn"].readIfPresent()
        value.postPassEndTime = try reader["postPassEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.prePassStartTime = try reader["prePassStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.region = try reader["region"].readIfPresent()
        value.satelliteArn = try reader["satelliteArn"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.visibilityEndTime = try reader["visibilityEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.visibilityStartTime = try reader["visibilityStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DescribeEphemerisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEphemerisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEphemerisOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.enabled = try reader["enabled"].readIfPresent()
        value.ephemerisId = try reader["ephemerisId"].readIfPresent()
        value.invalidReason = try reader["invalidReason"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        value.satelliteId = try reader["satelliteId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.suppliedData = try reader["suppliedData"].readIfPresent(with: GroundStationClientTypes.EphemerisTypeDescription.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetAgentConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentConfigurationOutput()
        value.agentId = try reader["agentId"].readIfPresent()
        value.taskingDocument = try reader["taskingDocument"].readIfPresent()
        return value
    }
}

extension GetConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConfigOutput()
        value.configArn = try reader["configArn"].readIfPresent() ?? ""
        value.configData = try reader["configData"].readIfPresent(with: GroundStationClientTypes.ConfigTypeData.read(from:))
        value.configId = try reader["configId"].readIfPresent() ?? ""
        value.configType = try reader["configType"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetDataflowEndpointGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataflowEndpointGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataflowEndpointGroupOutput()
        value.contactPostPassDurationSeconds = try reader["contactPostPassDurationSeconds"].readIfPresent()
        value.contactPrePassDurationSeconds = try reader["contactPrePassDurationSeconds"].readIfPresent()
        value.dataflowEndpointGroupArn = try reader["dataflowEndpointGroupArn"].readIfPresent()
        value.dataflowEndpointGroupId = try reader["dataflowEndpointGroupId"].readIfPresent()
        value.endpointsDetails = try reader["endpointsDetails"].readListIfPresent(memberReadingClosure: GroundStationClientTypes.EndpointDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetMinuteUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMinuteUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMinuteUsageOutput()
        value.estimatedMinutesRemaining = try reader["estimatedMinutesRemaining"].readIfPresent()
        value.isReservedMinutesCustomer = try reader["isReservedMinutesCustomer"].readIfPresent()
        value.totalReservedMinuteAllocation = try reader["totalReservedMinuteAllocation"].readIfPresent()
        value.totalScheduledMinutes = try reader["totalScheduledMinutes"].readIfPresent()
        value.upcomingMinutesScheduled = try reader["upcomingMinutesScheduled"].readIfPresent()
        return value
    }
}

extension GetMissionProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMissionProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMissionProfileOutput()
        value.contactPostPassDurationSeconds = try reader["contactPostPassDurationSeconds"].readIfPresent()
        value.contactPrePassDurationSeconds = try reader["contactPrePassDurationSeconds"].readIfPresent()
        value.dataflowEdges = try reader["dataflowEdges"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.minimumViableContactDurationSeconds = try reader["minimumViableContactDurationSeconds"].readIfPresent()
        value.missionProfileArn = try reader["missionProfileArn"].readIfPresent()
        value.missionProfileId = try reader["missionProfileId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.streamsKmsKey = try reader["streamsKmsKey"].readIfPresent(with: GroundStationClientTypes.KmsKey.read(from:))
        value.streamsKmsRole = try reader["streamsKmsRole"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.trackingConfigArn = try reader["trackingConfigArn"].readIfPresent()
        return value
    }
}

extension GetSatelliteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSatelliteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSatelliteOutput()
        value.currentEphemeris = try reader["currentEphemeris"].readIfPresent(with: GroundStationClientTypes.EphemerisMetaData.read(from:))
        value.groundStations = try reader["groundStations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.noradSatelliteID = try reader["noradSatelliteID"].readIfPresent() ?? 0
        value.satelliteArn = try reader["satelliteArn"].readIfPresent()
        value.satelliteId = try reader["satelliteId"].readIfPresent()
        return value
    }
}

extension ListConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfigsOutput()
        value.configList = try reader["configList"].readListIfPresent(memberReadingClosure: GroundStationClientTypes.ConfigListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListContactsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContactsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContactsOutput()
        value.contactList = try reader["contactList"].readListIfPresent(memberReadingClosure: GroundStationClientTypes.ContactData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataflowEndpointGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataflowEndpointGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataflowEndpointGroupsOutput()
        value.dataflowEndpointGroupList = try reader["dataflowEndpointGroupList"].readListIfPresent(memberReadingClosure: GroundStationClientTypes.DataflowEndpointListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEphemeridesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEphemeridesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEphemeridesOutput()
        value.ephemerides = try reader["ephemerides"].readListIfPresent(memberReadingClosure: GroundStationClientTypes.EphemerisItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGroundStationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroundStationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroundStationsOutput()
        value.groundStationList = try reader["groundStationList"].readListIfPresent(memberReadingClosure: GroundStationClientTypes.GroundStationData.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMissionProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMissionProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMissionProfilesOutput()
        value.missionProfileList = try reader["missionProfileList"].readListIfPresent(memberReadingClosure: GroundStationClientTypes.MissionProfileListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSatellitesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSatellitesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSatellitesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.satellites = try reader["satellites"].readListIfPresent(memberReadingClosure: GroundStationClientTypes.SatelliteListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RegisterAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterAgentOutput()
        value.agentId = try reader["agentId"].readIfPresent()
        return value
    }
}

extension ReserveContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReserveContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReserveContactOutput()
        value.contactId = try reader["contactId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAgentStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAgentStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentStatusOutput()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConfigOutput()
        value.configArn = try reader["configArn"].readIfPresent()
        value.configId = try reader["configId"].readIfPresent()
        value.configType = try reader["configType"].readIfPresent()
        return value
    }
}

extension UpdateEphemerisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEphemerisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEphemerisOutput()
        value.ephemerisId = try reader["ephemerisId"].readIfPresent()
        return value
    }
}

extension UpdateMissionProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMissionProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMissionProfileOutput()
        value.missionProfileId = try reader["missionProfileId"].readIfPresent()
        return value
    }
}

enum CancelContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataflowEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEphemerisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMissionProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataflowEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEphemerisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMissionProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEphemerisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataflowEndpointGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMinuteUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMissionProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSatelliteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContactsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataflowEndpointGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEphemeridesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroundStationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMissionProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSatellitesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReserveContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAgentStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEphemerisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMissionProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.parameterName = try reader["parameterName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DependencyException {
        let reader = baseError.errorBodyReader
        var value = DependencyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.parameterName = try reader["parameterName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.parameterName = try reader["parameterName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GroundStationClientTypes.Elevation {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.Elevation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.Elevation()
        value.value = try reader["value"].readIfPresent() ?? 0.0
        value.unit = try reader["unit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GroundStationClientTypes.DataflowDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.DataflowDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.DataflowDetail()
        value.source = try reader["source"].readIfPresent(with: GroundStationClientTypes.Source.read(from:))
        value.destination = try reader["destination"].readIfPresent(with: GroundStationClientTypes.Destination.read(from:))
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.Destination {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.Destination()
        value.configType = try reader["configType"].readIfPresent()
        value.configId = try reader["configId"].readIfPresent()
        value.configDetails = try reader["configDetails"].readIfPresent(with: GroundStationClientTypes.ConfigDetails.read(from:))
        value.dataflowDestinationRegion = try reader["dataflowDestinationRegion"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.ConfigDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.ConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "endpointDetails":
                return .endpointdetails(try reader["endpointDetails"].read(with: GroundStationClientTypes.EndpointDetails.read(from:)))
            case "antennaDemodDecodeDetails":
                return .antennademoddecodedetails(try reader["antennaDemodDecodeDetails"].read(with: GroundStationClientTypes.AntennaDemodDecodeDetails.read(from:)))
            case "s3RecordingDetails":
                return .s3recordingdetails(try reader["s3RecordingDetails"].read(with: GroundStationClientTypes.S3RecordingDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension GroundStationClientTypes.S3RecordingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.S3RecordingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.S3RecordingDetails()
        value.bucketArn = try reader["bucketArn"].readIfPresent()
        value.keyTemplate = try reader["keyTemplate"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.AntennaDemodDecodeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.AntennaDemodDecodeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.AntennaDemodDecodeDetails()
        value.outputNode = try reader["outputNode"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.EndpointDetails {

    static func write(value: GroundStationClientTypes.EndpointDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsGroundStationAgentEndpoint"].write(value.awsGroundStationAgentEndpoint, with: GroundStationClientTypes.AwsGroundStationAgentEndpoint.write(value:to:))
        try writer["endpoint"].write(value.endpoint, with: GroundStationClientTypes.DataflowEndpoint.write(value:to:))
        try writer["healthReasons"].writeList(value.healthReasons, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GroundStationClientTypes.CapabilityHealthReason>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["healthStatus"].write(value.healthStatus)
        try writer["securityDetails"].write(value.securityDetails, with: GroundStationClientTypes.SecurityDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.EndpointDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.EndpointDetails()
        value.securityDetails = try reader["securityDetails"].readIfPresent(with: GroundStationClientTypes.SecurityDetails.read(from:))
        value.endpoint = try reader["endpoint"].readIfPresent(with: GroundStationClientTypes.DataflowEndpoint.read(from:))
        value.awsGroundStationAgentEndpoint = try reader["awsGroundStationAgentEndpoint"].readIfPresent(with: GroundStationClientTypes.AwsGroundStationAgentEndpoint.read(from:))
        value.healthStatus = try reader["healthStatus"].readIfPresent()
        value.healthReasons = try reader["healthReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GroundStationClientTypes.CapabilityHealthReason>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GroundStationClientTypes.AwsGroundStationAgentEndpoint {

    static func write(value: GroundStationClientTypes.AwsGroundStationAgentEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentStatus"].write(value.agentStatus)
        try writer["auditResults"].write(value.auditResults)
        try writer["egressAddress"].write(value.egressAddress, with: GroundStationClientTypes.ConnectionDetails.write(value:to:))
        try writer["ingressAddress"].write(value.ingressAddress, with: GroundStationClientTypes.RangedConnectionDetails.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.AwsGroundStationAgentEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.AwsGroundStationAgentEndpoint()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.egressAddress = try reader["egressAddress"].readIfPresent(with: GroundStationClientTypes.ConnectionDetails.read(from:))
        value.ingressAddress = try reader["ingressAddress"].readIfPresent(with: GroundStationClientTypes.RangedConnectionDetails.read(from:))
        value.agentStatus = try reader["agentStatus"].readIfPresent()
        value.auditResults = try reader["auditResults"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.RangedConnectionDetails {

    static func write(value: GroundStationClientTypes.RangedConnectionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mtu"].write(value.mtu)
        try writer["socketAddress"].write(value.socketAddress, with: GroundStationClientTypes.RangedSocketAddress.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.RangedConnectionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.RangedConnectionDetails()
        value.socketAddress = try reader["socketAddress"].readIfPresent(with: GroundStationClientTypes.RangedSocketAddress.read(from:))
        value.mtu = try reader["mtu"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.RangedSocketAddress {

    static func write(value: GroundStationClientTypes.RangedSocketAddress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["portRange"].write(value.portRange, with: GroundStationClientTypes.IntegerRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.RangedSocketAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.RangedSocketAddress()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.portRange = try reader["portRange"].readIfPresent(with: GroundStationClientTypes.IntegerRange.read(from:))
        return value
    }
}

extension GroundStationClientTypes.IntegerRange {

    static func write(value: GroundStationClientTypes.IntegerRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maximum"].write(value.maximum)
        try writer["minimum"].write(value.minimum)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.IntegerRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.IntegerRange()
        value.minimum = try reader["minimum"].readIfPresent() ?? 0
        value.maximum = try reader["maximum"].readIfPresent() ?? 0
        return value
    }
}

extension GroundStationClientTypes.ConnectionDetails {

    static func write(value: GroundStationClientTypes.ConnectionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mtu"].write(value.mtu)
        try writer["socketAddress"].write(value.socketAddress, with: GroundStationClientTypes.SocketAddress.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.ConnectionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.ConnectionDetails()
        value.socketAddress = try reader["socketAddress"].readIfPresent(with: GroundStationClientTypes.SocketAddress.read(from:))
        value.mtu = try reader["mtu"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.SocketAddress {

    static func write(value: GroundStationClientTypes.SocketAddress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.SocketAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.SocketAddress()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent() ?? 0
        return value
    }
}

extension GroundStationClientTypes.DataflowEndpoint {

    static func write(value: GroundStationClientTypes.DataflowEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["address"].write(value.address, with: GroundStationClientTypes.SocketAddress.write(value:to:))
        try writer["mtu"].write(value.mtu)
        try writer["name"].write(value.name)
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.DataflowEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.DataflowEndpoint()
        value.name = try reader["name"].readIfPresent()
        value.address = try reader["address"].readIfPresent(with: GroundStationClientTypes.SocketAddress.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.mtu = try reader["mtu"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.SecurityDetails {

    static func write(value: GroundStationClientTypes.SecurityDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.SecurityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.SecurityDetails()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension GroundStationClientTypes.Source {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.Source()
        value.configType = try reader["configType"].readIfPresent()
        value.configId = try reader["configId"].readIfPresent()
        value.configDetails = try reader["configDetails"].readIfPresent(with: GroundStationClientTypes.ConfigDetails.read(from:))
        value.dataflowSourceRegion = try reader["dataflowSourceRegion"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.EphemerisTypeDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.EphemerisTypeDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "tle":
                return .tle(try reader["tle"].read(with: GroundStationClientTypes.EphemerisDescription.read(from:)))
            case "oem":
                return .oem(try reader["oem"].read(with: GroundStationClientTypes.EphemerisDescription.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension GroundStationClientTypes.EphemerisDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.EphemerisDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.EphemerisDescription()
        value.sourceS3Object = try reader["sourceS3Object"].readIfPresent(with: GroundStationClientTypes.S3Object.read(from:))
        value.ephemerisData = try reader["ephemerisData"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.S3Object {

    static func write(value: GroundStationClientTypes.S3Object?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["key"].write(value.key)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.S3Object {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.S3Object()
        value.bucket = try reader["bucket"].readIfPresent()
        value.key = try reader["key"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.ConfigTypeData {

    static func write(value: GroundStationClientTypes.ConfigTypeData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .antennadownlinkconfig(antennadownlinkconfig):
                try writer["antennaDownlinkConfig"].write(antennadownlinkconfig, with: GroundStationClientTypes.AntennaDownlinkConfig.write(value:to:))
            case let .antennadownlinkdemoddecodeconfig(antennadownlinkdemoddecodeconfig):
                try writer["antennaDownlinkDemodDecodeConfig"].write(antennadownlinkdemoddecodeconfig, with: GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig.write(value:to:))
            case let .antennauplinkconfig(antennauplinkconfig):
                try writer["antennaUplinkConfig"].write(antennauplinkconfig, with: GroundStationClientTypes.AntennaUplinkConfig.write(value:to:))
            case let .dataflowendpointconfig(dataflowendpointconfig):
                try writer["dataflowEndpointConfig"].write(dataflowendpointconfig, with: GroundStationClientTypes.DataflowEndpointConfig.write(value:to:))
            case let .s3recordingconfig(s3recordingconfig):
                try writer["s3RecordingConfig"].write(s3recordingconfig, with: GroundStationClientTypes.S3RecordingConfig.write(value:to:))
            case let .trackingconfig(trackingconfig):
                try writer["trackingConfig"].write(trackingconfig, with: GroundStationClientTypes.TrackingConfig.write(value:to:))
            case let .uplinkechoconfig(uplinkechoconfig):
                try writer["uplinkEchoConfig"].write(uplinkechoconfig, with: GroundStationClientTypes.UplinkEchoConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.ConfigTypeData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "antennaDownlinkConfig":
                return .antennadownlinkconfig(try reader["antennaDownlinkConfig"].read(with: GroundStationClientTypes.AntennaDownlinkConfig.read(from:)))
            case "trackingConfig":
                return .trackingconfig(try reader["trackingConfig"].read(with: GroundStationClientTypes.TrackingConfig.read(from:)))
            case "dataflowEndpointConfig":
                return .dataflowendpointconfig(try reader["dataflowEndpointConfig"].read(with: GroundStationClientTypes.DataflowEndpointConfig.read(from:)))
            case "antennaDownlinkDemodDecodeConfig":
                return .antennadownlinkdemoddecodeconfig(try reader["antennaDownlinkDemodDecodeConfig"].read(with: GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig.read(from:)))
            case "antennaUplinkConfig":
                return .antennauplinkconfig(try reader["antennaUplinkConfig"].read(with: GroundStationClientTypes.AntennaUplinkConfig.read(from:)))
            case "uplinkEchoConfig":
                return .uplinkechoconfig(try reader["uplinkEchoConfig"].read(with: GroundStationClientTypes.UplinkEchoConfig.read(from:)))
            case "s3RecordingConfig":
                return .s3recordingconfig(try reader["s3RecordingConfig"].read(with: GroundStationClientTypes.S3RecordingConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension GroundStationClientTypes.S3RecordingConfig {

    static func write(value: GroundStationClientTypes.S3RecordingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketArn"].write(value.bucketArn)
        try writer["prefix"].write(value.`prefix`)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.S3RecordingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.S3RecordingConfig()
        value.bucketArn = try reader["bucketArn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.UplinkEchoConfig {

    static func write(value: GroundStationClientTypes.UplinkEchoConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["antennaUplinkConfigArn"].write(value.antennaUplinkConfigArn)
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.UplinkEchoConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.UplinkEchoConfig()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.antennaUplinkConfigArn = try reader["antennaUplinkConfigArn"].readIfPresent() ?? ""
        return value
    }
}

extension GroundStationClientTypes.AntennaUplinkConfig {

    static func write(value: GroundStationClientTypes.AntennaUplinkConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["spectrumConfig"].write(value.spectrumConfig, with: GroundStationClientTypes.UplinkSpectrumConfig.write(value:to:))
        try writer["targetEirp"].write(value.targetEirp, with: GroundStationClientTypes.Eirp.write(value:to:))
        try writer["transmitDisabled"].write(value.transmitDisabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.AntennaUplinkConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.AntennaUplinkConfig()
        value.transmitDisabled = try reader["transmitDisabled"].readIfPresent()
        value.spectrumConfig = try reader["spectrumConfig"].readIfPresent(with: GroundStationClientTypes.UplinkSpectrumConfig.read(from:))
        value.targetEirp = try reader["targetEirp"].readIfPresent(with: GroundStationClientTypes.Eirp.read(from:))
        return value
    }
}

extension GroundStationClientTypes.Eirp {

    static func write(value: GroundStationClientTypes.Eirp?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["units"].write(value.units)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.Eirp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.Eirp()
        value.value = try reader["value"].readIfPresent() ?? 0.0
        value.units = try reader["units"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GroundStationClientTypes.UplinkSpectrumConfig {

    static func write(value: GroundStationClientTypes.UplinkSpectrumConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["centerFrequency"].write(value.centerFrequency, with: GroundStationClientTypes.Frequency.write(value:to:))
        try writer["polarization"].write(value.polarization)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.UplinkSpectrumConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.UplinkSpectrumConfig()
        value.centerFrequency = try reader["centerFrequency"].readIfPresent(with: GroundStationClientTypes.Frequency.read(from:))
        value.polarization = try reader["polarization"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.Frequency {

    static func write(value: GroundStationClientTypes.Frequency?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["units"].write(value.units)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.Frequency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.Frequency()
        value.value = try reader["value"].readIfPresent() ?? 0.0
        value.units = try reader["units"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig {

    static func write(value: GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["decodeConfig"].write(value.decodeConfig, with: GroundStationClientTypes.DecodeConfig.write(value:to:))
        try writer["demodulationConfig"].write(value.demodulationConfig, with: GroundStationClientTypes.DemodulationConfig.write(value:to:))
        try writer["spectrumConfig"].write(value.spectrumConfig, with: GroundStationClientTypes.SpectrumConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.AntennaDownlinkDemodDecodeConfig()
        value.spectrumConfig = try reader["spectrumConfig"].readIfPresent(with: GroundStationClientTypes.SpectrumConfig.read(from:))
        value.demodulationConfig = try reader["demodulationConfig"].readIfPresent(with: GroundStationClientTypes.DemodulationConfig.read(from:))
        value.decodeConfig = try reader["decodeConfig"].readIfPresent(with: GroundStationClientTypes.DecodeConfig.read(from:))
        return value
    }
}

extension GroundStationClientTypes.DecodeConfig {

    static func write(value: GroundStationClientTypes.DecodeConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["unvalidatedJSON"].write(value.unvalidatedJSON)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.DecodeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.DecodeConfig()
        value.unvalidatedJSON = try reader["unvalidatedJSON"].readIfPresent() ?? ""
        return value
    }
}

extension GroundStationClientTypes.DemodulationConfig {

    static func write(value: GroundStationClientTypes.DemodulationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["unvalidatedJSON"].write(value.unvalidatedJSON)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.DemodulationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.DemodulationConfig()
        value.unvalidatedJSON = try reader["unvalidatedJSON"].readIfPresent() ?? ""
        return value
    }
}

extension GroundStationClientTypes.SpectrumConfig {

    static func write(value: GroundStationClientTypes.SpectrumConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bandwidth"].write(value.bandwidth, with: GroundStationClientTypes.FrequencyBandwidth.write(value:to:))
        try writer["centerFrequency"].write(value.centerFrequency, with: GroundStationClientTypes.Frequency.write(value:to:))
        try writer["polarization"].write(value.polarization)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.SpectrumConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.SpectrumConfig()
        value.centerFrequency = try reader["centerFrequency"].readIfPresent(with: GroundStationClientTypes.Frequency.read(from:))
        value.bandwidth = try reader["bandwidth"].readIfPresent(with: GroundStationClientTypes.FrequencyBandwidth.read(from:))
        value.polarization = try reader["polarization"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.FrequencyBandwidth {

    static func write(value: GroundStationClientTypes.FrequencyBandwidth?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["units"].write(value.units)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.FrequencyBandwidth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.FrequencyBandwidth()
        value.value = try reader["value"].readIfPresent() ?? 0.0
        value.units = try reader["units"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GroundStationClientTypes.DataflowEndpointConfig {

    static func write(value: GroundStationClientTypes.DataflowEndpointConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataflowEndpointName"].write(value.dataflowEndpointName)
        try writer["dataflowEndpointRegion"].write(value.dataflowEndpointRegion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.DataflowEndpointConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.DataflowEndpointConfig()
        value.dataflowEndpointName = try reader["dataflowEndpointName"].readIfPresent() ?? ""
        value.dataflowEndpointRegion = try reader["dataflowEndpointRegion"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.TrackingConfig {

    static func write(value: GroundStationClientTypes.TrackingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autotrack"].write(value.autotrack)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.TrackingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.TrackingConfig()
        value.autotrack = try reader["autotrack"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GroundStationClientTypes.AntennaDownlinkConfig {

    static func write(value: GroundStationClientTypes.AntennaDownlinkConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["spectrumConfig"].write(value.spectrumConfig, with: GroundStationClientTypes.SpectrumConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.AntennaDownlinkConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.AntennaDownlinkConfig()
        value.spectrumConfig = try reader["spectrumConfig"].readIfPresent(with: GroundStationClientTypes.SpectrumConfig.read(from:))
        return value
    }
}

extension GroundStationClientTypes.KmsKey {

    static func write(value: GroundStationClientTypes.KmsKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .kmsaliasarn(kmsaliasarn):
                try writer["kmsAliasArn"].write(kmsaliasarn)
            case let .kmsaliasname(kmsaliasname):
                try writer["kmsAliasName"].write(kmsaliasname)
            case let .kmskeyarn(kmskeyarn):
                try writer["kmsKeyArn"].write(kmskeyarn)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.KmsKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "kmsKeyArn":
                return .kmskeyarn(try reader["kmsKeyArn"].read())
            case "kmsAliasArn":
                return .kmsaliasarn(try reader["kmsAliasArn"].read())
            case "kmsAliasName":
                return .kmsaliasname(try reader["kmsAliasName"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension GroundStationClientTypes.EphemerisMetaData {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.EphemerisMetaData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.EphemerisMetaData()
        value.source = try reader["source"].readIfPresent() ?? .sdkUnknown("")
        value.ephemerisId = try reader["ephemerisId"].readIfPresent()
        value.epoch = try reader["epoch"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.ConfigListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.ConfigListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.ConfigListItem()
        value.configId = try reader["configId"].readIfPresent()
        value.configType = try reader["configType"].readIfPresent()
        value.configArn = try reader["configArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.ContactData {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.ContactData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.ContactData()
        value.contactId = try reader["contactId"].readIfPresent()
        value.missionProfileArn = try reader["missionProfileArn"].readIfPresent()
        value.satelliteArn = try reader["satelliteArn"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.prePassStartTime = try reader["prePassStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.postPassEndTime = try reader["postPassEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.groundStation = try reader["groundStation"].readIfPresent()
        value.contactStatus = try reader["contactStatus"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.maximumElevation = try reader["maximumElevation"].readIfPresent(with: GroundStationClientTypes.Elevation.read(from:))
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.visibilityStartTime = try reader["visibilityStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.visibilityEndTime = try reader["visibilityEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GroundStationClientTypes.DataflowEndpointListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.DataflowEndpointListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.DataflowEndpointListItem()
        value.dataflowEndpointGroupId = try reader["dataflowEndpointGroupId"].readIfPresent()
        value.dataflowEndpointGroupArn = try reader["dataflowEndpointGroupArn"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.EphemerisItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.EphemerisItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.EphemerisItem()
        value.ephemerisId = try reader["ephemerisId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.sourceS3Object = try reader["sourceS3Object"].readIfPresent(with: GroundStationClientTypes.S3Object.read(from:))
        return value
    }
}

extension GroundStationClientTypes.GroundStationData {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.GroundStationData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.GroundStationData()
        value.groundStationId = try reader["groundStationId"].readIfPresent()
        value.groundStationName = try reader["groundStationName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.MissionProfileListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.MissionProfileListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.MissionProfileListItem()
        value.missionProfileId = try reader["missionProfileId"].readIfPresent()
        value.missionProfileArn = try reader["missionProfileArn"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension GroundStationClientTypes.SatelliteListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> GroundStationClientTypes.SatelliteListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GroundStationClientTypes.SatelliteListItem()
        value.satelliteId = try reader["satelliteId"].readIfPresent()
        value.satelliteArn = try reader["satelliteArn"].readIfPresent()
        value.noradSatelliteID = try reader["noradSatelliteID"].readIfPresent() ?? 0
        value.groundStations = try reader["groundStations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.currentEphemeris = try reader["currentEphemeris"].readIfPresent(with: GroundStationClientTypes.EphemerisMetaData.read(from:))
        return value
    }
}

extension GroundStationClientTypes.EphemerisData {

    static func write(value: GroundStationClientTypes.EphemerisData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .oem(oem):
                try writer["oem"].write(oem, with: GroundStationClientTypes.OEMEphemeris.write(value:to:))
            case let .tle(tle):
                try writer["tle"].write(tle, with: GroundStationClientTypes.TLEEphemeris.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension GroundStationClientTypes.OEMEphemeris {

    static func write(value: GroundStationClientTypes.OEMEphemeris?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["oemData"].write(value.oemData)
        try writer["s3Object"].write(value.s3Object, with: GroundStationClientTypes.S3Object.write(value:to:))
    }
}

extension GroundStationClientTypes.TLEEphemeris {

    static func write(value: GroundStationClientTypes.TLEEphemeris?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Object"].write(value.s3Object, with: GroundStationClientTypes.S3Object.write(value:to:))
        try writer["tleData"].writeList(value.tleData, memberWritingClosure: GroundStationClientTypes.TLEData.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GroundStationClientTypes.TLEData {

    static func write(value: GroundStationClientTypes.TLEData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tleLine1"].write(value.tleLine1)
        try writer["tleLine2"].write(value.tleLine2)
        try writer["validTimeRange"].write(value.validTimeRange, with: GroundStationClientTypes.TimeRange.write(value:to:))
    }
}

extension GroundStationClientTypes.TimeRange {

    static func write(value: GroundStationClientTypes.TimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GroundStationClientTypes.DiscoveryData {

    static func write(value: GroundStationClientTypes.DiscoveryData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilityArns"].writeList(value.capabilityArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["privateIpAddresses"].writeList(value.privateIpAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["publicIpAddresses"].writeList(value.publicIpAddresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GroundStationClientTypes.AgentDetails {

    static func write(value: GroundStationClientTypes.AgentDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentCpuCores"].writeList(value.agentCpuCores, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["agentVersion"].write(value.agentVersion)
        try writer["componentVersions"].writeList(value.componentVersions, memberWritingClosure: GroundStationClientTypes.ComponentVersion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["instanceId"].write(value.instanceId)
        try writer["instanceType"].write(value.instanceType)
        try writer["reservedCpuCores"].writeList(value.reservedCpuCores, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GroundStationClientTypes.ComponentVersion {

    static func write(value: GroundStationClientTypes.ComponentVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentType"].write(value.componentType)
        try writer["versions"].writeList(value.versions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GroundStationClientTypes.AggregateStatus {

    static func write(value: GroundStationClientTypes.AggregateStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["signatureMap"].writeMap(value.signatureMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeBool(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["status"].write(value.status)
    }
}

extension GroundStationClientTypes.ComponentStatusData {

    static func write(value: GroundStationClientTypes.ComponentStatusData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bytesReceived"].write(value.bytesReceived)
        try writer["bytesSent"].write(value.bytesSent)
        try writer["capabilityArn"].write(value.capabilityArn)
        try writer["componentType"].write(value.componentType)
        try writer["dataflowId"].write(value.dataflowId)
        try writer["packetsDropped"].write(value.packetsDropped)
        try writer["status"].write(value.status)
    }
}

public enum GroundStationClientTypes {}
