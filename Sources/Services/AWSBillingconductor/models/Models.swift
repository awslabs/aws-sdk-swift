// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BillingconductorClientTypes.AccountAssociationsListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountEmail = "AccountEmail"
        case accountId = "AccountId"
        case accountName = "AccountName"
        case billingGroupArn = "BillingGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountEmail = self.accountEmail {
            try encodeContainer.encode(accountEmail, forKey: .accountEmail)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountName = self.accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let accountEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountEmail)
        accountEmail = accountEmailDecoded
    }
}

extension BillingconductorClientTypes.AccountAssociationsListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountAssociationsListElement(accountId: \(Swift.String(describing: accountId)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), accountEmail: \"CONTENT_REDACTED\", accountName: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a linked account.
    public struct AccountAssociationsListElement: Swift.Equatable {
        /// The Amazon Web Services account email.
        public var accountEmail: Swift.String?
        /// The associating array of account IDs.
        public var accountId: Swift.String?
        /// The Amazon Web Services account name.
        public var accountName: Swift.String?
        /// The Billing Group Arn that the linked account is associated to.
        public var billingGroupArn: Swift.String?

        public init (
            accountEmail: Swift.String? = nil,
            accountId: Swift.String? = nil,
            accountName: Swift.String? = nil,
            billingGroupArn: Swift.String? = nil
        )
        {
            self.accountEmail = accountEmail
            self.accountId = accountId
            self.accountName = accountName
            self.billingGroupArn = billingGroupArn
        }
    }

}

extension BillingconductorClientTypes.AccountGrouping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkedAccountIds = "LinkedAccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkedAccountIds = linkedAccountIds {
            var linkedAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .linkedAccountIds)
            for accountid0 in linkedAccountIds {
                try linkedAccountIdsContainer.encode(accountid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkedAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .linkedAccountIds)
        var linkedAccountIdsDecoded0:[Swift.String]? = nil
        if let linkedAccountIdsContainer = linkedAccountIdsContainer {
            linkedAccountIdsDecoded0 = [Swift.String]()
            for string0 in linkedAccountIdsContainer {
                if let string0 = string0 {
                    linkedAccountIdsDecoded0?.append(string0)
                }
            }
        }
        linkedAccountIds = linkedAccountIdsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// The set of accounts that will be under the billing group. The set of accounts resemble the linked accounts in a consolidated family.
    public struct AccountGrouping: Swift.Equatable {
        /// The account IDs that make up the billing group. Account IDs must be a part of the consolidated billing family, and not associated with another billing group.
        /// This member is required.
        public var linkedAccountIds: [Swift.String]?

        public init (
            linkedAccountIds: [Swift.String]? = nil
        )
        {
            self.linkedAccountIds = linkedAccountIds
        }
    }

}

extension AssociateAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension AssociateAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associate-accounts"
    }
}

public struct AssociateAccountsInput: Swift.Equatable {
    /// The associating array of account IDs.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the billing group that associates the array of account IDs.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        arn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.arn = arn
    }
}

struct AssociateAccountsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let accountIds: [Swift.String]?
}

extension AssociateAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension AssociateAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateAccountsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct AssociateAccountsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the billing group that associates the array of account IDs.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct AssociateAccountsOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension AssociateAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension AssociatePricingRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let pricingRuleArns = pricingRuleArns {
            var pricingRuleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pricingRuleArns)
            for pricingrulearn0 in pricingRuleArns {
                try pricingRuleArnsContainer.encode(pricingrulearn0)
            }
        }
    }
}

extension AssociatePricingRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associate-pricing-rules"
    }
}

public struct AssociatePricingRulesInput: Swift.Equatable {
    /// The PricingPlanArn that the PricingRuleArns are associated with.
    /// This member is required.
    public var arn: Swift.String?
    /// The PricingRuleArns that are associated with the Pricing Plan.
    /// This member is required.
    public var pricingRuleArns: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.pricingRuleArns = pricingRuleArns
    }
}

struct AssociatePricingRulesInputBody: Swift.Equatable {
    let arn: Swift.String?
    let pricingRuleArns: [Swift.String]?
}

extension AssociatePricingRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let pricingRuleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingRuleArns)
        var pricingRuleArnsDecoded0:[Swift.String]? = nil
        if let pricingRuleArnsContainer = pricingRuleArnsContainer {
            pricingRuleArnsDecoded0 = [Swift.String]()
            for string0 in pricingRuleArnsContainer {
                if let string0 = string0 {
                    pricingRuleArnsDecoded0?.append(string0)
                }
            }
        }
        pricingRuleArns = pricingRuleArnsDecoded0
    }
}

extension AssociatePricingRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociatePricingRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociatePricingRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociatePricingRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociatePricingRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct AssociatePricingRulesOutputResponse: Swift.Equatable {
    /// The PricingPlanArn that the PricingRuleArns are associated with.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct AssociatePricingRulesOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension AssociatePricingRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension BillingconductorClientTypes.AssociateResourceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.AssociateResourceErrorReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of a resource association error.
    public struct AssociateResourceError: Swift.Equatable {
        /// The reason why the resource association failed.
        public var message: Swift.String?
        /// A static error code that's used to classify the type of failure.
        public var reason: BillingconductorClientTypes.AssociateResourceErrorReason?

        public init (
            message: Swift.String? = nil,
            reason: BillingconductorClientTypes.AssociateResourceErrorReason? = nil
        )
        {
            self.message = message
            self.reason = reason
        }
    }

}

extension BillingconductorClientTypes {
    public enum AssociateResourceErrorReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case illegalCustomlineitem
        case internalServerException
        case invalidArn
        case invalidBillingPeriodRange
        case serviceLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociateResourceErrorReason] {
            return [
                .illegalCustomlineitem,
                .internalServerException,
                .invalidArn,
                .invalidBillingPeriodRange,
                .serviceLimitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .illegalCustomlineitem: return "ILLEGAL_CUSTOMLINEITEM"
            case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
            case .invalidArn: return "INVALID_ARN"
            case .invalidBillingPeriodRange: return "INVALID_BILLING_PERIOD_RANGE"
            case .serviceLimitExceeded: return "SERVICE_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociateResourceErrorReason(rawValue: rawValue) ?? AssociateResourceErrorReason.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.AssociateResourceResponseElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let errorDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.AssociateResourceError.self, forKey: .error)
        error = errorDecoded
    }
}

extension BillingconductorClientTypes {
    /// A resource association result for a percentage custom line item.
    public struct AssociateResourceResponseElement: Swift.Equatable {
        /// The resource ARN that was associated to the custom line item.
        public var arn: Swift.String?
        /// An AssociateResourceError that will populate if the resource association fails.
        public var error: BillingconductorClientTypes.AssociateResourceError?

        public init (
            arn: Swift.String? = nil,
            error: BillingconductorClientTypes.AssociateResourceError? = nil
        )
        {
            self.arn = arn
            self.error = error
        }
    }

}

extension BatchAssociateResourcesToCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
        case resourceArns = "ResourceArns"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for customlineitemassociationelement0 in resourceArns {
                try resourceArnsContainer.encode(customlineitemassociationelement0)
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension BatchAssociateResourcesToCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batch-associate-resources-to-custom-line-item"
    }
}

public struct BatchAssociateResourcesToCustomLineItemInput: Swift.Equatable {
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A list containing the ARNs of the resources to be associated.
    /// This member is required.
    public var resourceArns: [Swift.String]?
    /// A percentage custom line item ARN to associate the resources to.
    /// This member is required.
    public var targetArn: Swift.String?

    public init (
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        resourceArns: [Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.billingPeriodRange = billingPeriodRange
        self.resourceArns = resourceArns
        self.targetArn = targetArn
    }
}

struct BatchAssociateResourcesToCustomLineItemInputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let resourceArns: [Swift.String]?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
}

extension BatchAssociateResourcesToCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
        case resourceArns = "ResourceArns"
        case targetArn = "TargetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension BatchAssociateResourcesToCustomLineItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateResourcesToCustomLineItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchAssociateResourcesToCustomLineItemOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateResourcesToCustomLineItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchAssociateResourcesToCustomLineItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedAssociatedResources = output.failedAssociatedResources
            self.successfullyAssociatedResources = output.successfullyAssociatedResources
        } else {
            self.failedAssociatedResources = nil
            self.successfullyAssociatedResources = nil
        }
    }
}

public struct BatchAssociateResourcesToCustomLineItemOutputResponse: Swift.Equatable {
    /// A list of AssociateResourceResponseElement for each resource that failed association to a percentage custom line item.
    public var failedAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?
    /// A list of AssociateResourceResponseElement for each resource that's been associated to a percentage custom line item successfully.
    public var successfullyAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?

    public init (
        failedAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]? = nil,
        successfullyAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]? = nil
    )
    {
        self.failedAssociatedResources = failedAssociatedResources
        self.successfullyAssociatedResources = successfullyAssociatedResources
    }
}

struct BatchAssociateResourcesToCustomLineItemOutputResponseBody: Swift.Equatable {
    let successfullyAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?
    let failedAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?
}

extension BatchAssociateResourcesToCustomLineItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedAssociatedResources = "FailedAssociatedResources"
        case successfullyAssociatedResources = "SuccessfullyAssociatedResources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfullyAssociatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.AssociateResourceResponseElement?].self, forKey: .successfullyAssociatedResources)
        var successfullyAssociatedResourcesDecoded0:[BillingconductorClientTypes.AssociateResourceResponseElement]? = nil
        if let successfullyAssociatedResourcesContainer = successfullyAssociatedResourcesContainer {
            successfullyAssociatedResourcesDecoded0 = [BillingconductorClientTypes.AssociateResourceResponseElement]()
            for structure0 in successfullyAssociatedResourcesContainer {
                if let structure0 = structure0 {
                    successfullyAssociatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        successfullyAssociatedResources = successfullyAssociatedResourcesDecoded0
        let failedAssociatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.AssociateResourceResponseElement?].self, forKey: .failedAssociatedResources)
        var failedAssociatedResourcesDecoded0:[BillingconductorClientTypes.AssociateResourceResponseElement]? = nil
        if let failedAssociatedResourcesContainer = failedAssociatedResourcesContainer {
            failedAssociatedResourcesDecoded0 = [BillingconductorClientTypes.AssociateResourceResponseElement]()
            for structure0 in failedAssociatedResourcesContainer {
                if let structure0 = structure0 {
                    failedAssociatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedAssociatedResources = failedAssociatedResourcesDecoded0
    }
}

extension BatchDisassociateResourcesFromCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
        case resourceArns = "ResourceArns"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for customlineitemassociationelement0 in resourceArns {
                try resourceArnsContainer.encode(customlineitemassociationelement0)
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension BatchDisassociateResourcesFromCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batch-disassociate-resources-from-custom-line-item"
    }
}

public struct BatchDisassociateResourcesFromCustomLineItemInput: Swift.Equatable {
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A list containing the ARNs of resources to be disassociated.
    /// This member is required.
    public var resourceArns: [Swift.String]?
    /// A percentage custom line item ARN to disassociate the resources from.
    /// This member is required.
    public var targetArn: Swift.String?

    public init (
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        resourceArns: [Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.billingPeriodRange = billingPeriodRange
        self.resourceArns = resourceArns
        self.targetArn = targetArn
    }
}

struct BatchDisassociateResourcesFromCustomLineItemInputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let resourceArns: [Swift.String]?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
}

extension BatchDisassociateResourcesFromCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
        case resourceArns = "ResourceArns"
        case targetArn = "TargetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension BatchDisassociateResourcesFromCustomLineItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateResourcesFromCustomLineItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDisassociateResourcesFromCustomLineItemOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateResourcesFromCustomLineItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDisassociateResourcesFromCustomLineItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedDisassociatedResources = output.failedDisassociatedResources
            self.successfullyDisassociatedResources = output.successfullyDisassociatedResources
        } else {
            self.failedDisassociatedResources = nil
            self.successfullyDisassociatedResources = nil
        }
    }
}

public struct BatchDisassociateResourcesFromCustomLineItemOutputResponse: Swift.Equatable {
    /// A list of DisassociateResourceResponseElement for each resource that failed disassociation from a percentage custom line item.
    public var failedDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?
    /// A list of DisassociateResourceResponseElement for each resource that's been disassociated from a percentage custom line item successfully.
    public var successfullyDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?

    public init (
        failedDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil,
        successfullyDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil
    )
    {
        self.failedDisassociatedResources = failedDisassociatedResources
        self.successfullyDisassociatedResources = successfullyDisassociatedResources
    }
}

struct BatchDisassociateResourcesFromCustomLineItemOutputResponseBody: Swift.Equatable {
    let successfullyDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?
    let failedDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?
}

extension BatchDisassociateResourcesFromCustomLineItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedDisassociatedResources = "FailedDisassociatedResources"
        case successfullyDisassociatedResources = "SuccessfullyDisassociatedResources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfullyDisassociatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.DisassociateResourceResponseElement?].self, forKey: .successfullyDisassociatedResources)
        var successfullyDisassociatedResourcesDecoded0:[BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil
        if let successfullyDisassociatedResourcesContainer = successfullyDisassociatedResourcesContainer {
            successfullyDisassociatedResourcesDecoded0 = [BillingconductorClientTypes.DisassociateResourceResponseElement]()
            for structure0 in successfullyDisassociatedResourcesContainer {
                if let structure0 = structure0 {
                    successfullyDisassociatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        successfullyDisassociatedResources = successfullyDisassociatedResourcesDecoded0
        let failedDisassociatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.DisassociateResourceResponseElement?].self, forKey: .failedDisassociatedResources)
        var failedDisassociatedResourcesDecoded0:[BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil
        if let failedDisassociatedResourcesContainer = failedDisassociatedResourcesContainer {
            failedDisassociatedResourcesDecoded0 = [BillingconductorClientTypes.DisassociateResourceResponseElement]()
            for structure0 in failedDisassociatedResourcesContainer {
                if let structure0 = structure0 {
                    failedDisassociatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedDisassociatedResources = failedDisassociatedResourcesDecoded0
    }
}

extension BillingconductorClientTypes.BillingGroupCostReportElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsCost = "AWSCost"
        case arn = "Arn"
        case currency = "Currency"
        case margin = "Margin"
        case marginPercentage = "MarginPercentage"
        case proformaCost = "ProformaCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsCost = self.awsCost {
            try encodeContainer.encode(awsCost, forKey: .awsCost)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let currency = self.currency {
            try encodeContainer.encode(currency, forKey: .currency)
        }
        if let margin = self.margin {
            try encodeContainer.encode(margin, forKey: .margin)
        }
        if let marginPercentage = self.marginPercentage {
            try encodeContainer.encode(marginPercentage, forKey: .marginPercentage)
        }
        if let proformaCost = self.proformaCost {
            try encodeContainer.encode(proformaCost, forKey: .proformaCost)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsCost)
        awsCost = awsCostDecoded
        let proformaCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proformaCost)
        proformaCost = proformaCostDecoded
        let marginDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .margin)
        margin = marginDecoded
        let marginPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marginPercentage)
        marginPercentage = marginPercentageDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currency)
        currency = currencyDecoded
    }
}

extension BillingconductorClientTypes {
    /// A summary report of actual Amazon Web Services charges and calculated Amazon Web Services charges, based on the associated pricing plan of a billing group.
    public struct BillingGroupCostReportElement: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a billing group.
        public var arn: Swift.String?
        /// The actual Amazon Web Services charges for the billing group.
        public var awsCost: Swift.String?
        /// The displayed currency.
        public var currency: Swift.String?
        /// The billing group margin.
        public var margin: Swift.String?
        /// The percentage of billing group margin.
        public var marginPercentage: Swift.String?
        /// The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group.
        public var proformaCost: Swift.String?

        public init (
            arn: Swift.String? = nil,
            awsCost: Swift.String? = nil,
            currency: Swift.String? = nil,
            margin: Swift.String? = nil,
            marginPercentage: Swift.String? = nil,
            proformaCost: Swift.String? = nil
        )
        {
            self.arn = arn
            self.awsCost = awsCost
            self.currency = currency
            self.margin = margin
            self.marginPercentage = marginPercentage
            self.proformaCost = proformaCost
        }
    }

}

extension BillingconductorClientTypes.BillingGroupListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case computationPreference = "ComputationPreference"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case primaryAccountId = "PrimaryAccountId"
        case size = "Size"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computationPreference = self.computationPreference {
            try encodeContainer.encode(computationPreference, forKey: .computationPreference)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let primaryAccountId = self.primaryAccountId {
            try encodeContainer.encode(primaryAccountId, forKey: .primaryAccountId)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let primaryAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountId)
        primaryAccountId = primaryAccountIdDecoded
        let computationPreferenceDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ComputationPreference.self, forKey: .computationPreference)
        computationPreference = computationPreferenceDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.BillingGroupStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension BillingconductorClientTypes.BillingGroupListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BillingGroupListElement(arn: \(Swift.String(describing: arn)), computationPreference: \(Swift.String(describing: computationPreference)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), primaryAccountId: \(Swift.String(describing: primaryAccountId)), size: \(Swift.String(describing: size)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a billing group.
    public struct BillingGroupListElement: Swift.Equatable {
        /// The Amazon Resource Number (ARN) that can be used to uniquely identify the billing group.
        public var arn: Swift.String?
        /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
        public var computationPreference: BillingconductorClientTypes.ComputationPreference?
        /// The time when the billing group was created.
        public var creationTime: Swift.Int
        /// The description of the billing group.
        public var description: Swift.String?
        /// The most recent time when the billing group was modified.
        public var lastModifiedTime: Swift.Int
        /// The name of the billing group.
        public var name: Swift.String?
        /// The account ID that serves as the main account in a billing group.
        public var primaryAccountId: Swift.String?
        /// The number of accounts in the particular billing group.
        public var size: Swift.Int
        /// The billing group status. Only one of the valid values can be used.
        public var status: BillingconductorClientTypes.BillingGroupStatus?
        /// The reason why the billing group is in its current status.
        public var statusReason: Swift.String?

        public init (
            arn: Swift.String? = nil,
            computationPreference: BillingconductorClientTypes.ComputationPreference? = nil,
            creationTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            primaryAccountId: Swift.String? = nil,
            size: Swift.Int = 0,
            status: BillingconductorClientTypes.BillingGroupStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.arn = arn
            self.computationPreference = computationPreference
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.primaryAccountId = primaryAccountId
            self.size = size
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension BillingconductorClientTypes {
    public enum BillingGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case primaryAccountMissing
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingGroupStatus] {
            return [
                .active,
                .primaryAccountMissing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .primaryAccountMissing: return "PRIMARY_ACCOUNT_MISSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BillingGroupStatus(rawValue: rawValue) ?? BillingGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.ComputationPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pricingPlanArn = "PricingPlanArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pricingPlanArn = self.pricingPlanArn {
            try encodeContainer.encode(pricingPlanArn, forKey: .pricingPlanArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanArn)
        pricingPlanArn = pricingPlanArnDecoded
    }
}

extension BillingconductorClientTypes {
    /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
    public struct ComputationPreference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the pricing plan that's used to compute the Amazon Web Services charges for a billing group.
        /// This member is required.
        public var pricingPlanArn: Swift.String?

        public init (
            pricingPlanArn: Swift.String? = nil
        )
        {
            self.pricingPlanArn = pricingPlanArn
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.reason = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can cause an inconsistent state by updating or deleting a resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Reason for the inconsistent state.
    public var reason: BillingconductorClientTypes.ConflictExceptionReason?
    /// Identifier of the resource in use.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource in use.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        reason: BillingconductorClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.reason = reason
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let reason: BillingconductorClientTypes.ConflictExceptionReason?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension BillingconductorClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pricingPlanAttachedToBillingGroupDeleteConflict
        case pricingRuleAttachedToPricingPlanDeleteConflict
        case pricingRuleInPricingPlanConflict
        case resourceNameConflict
        case writeConflictRetry
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .pricingPlanAttachedToBillingGroupDeleteConflict,
                .pricingRuleAttachedToPricingPlanDeleteConflict,
                .pricingRuleInPricingPlanConflict,
                .resourceNameConflict,
                .writeConflictRetry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pricingPlanAttachedToBillingGroupDeleteConflict: return "PRICING_PLAN_ATTACHED_TO_BILLING_GROUP_DELETE_CONFLICT"
            case .pricingRuleAttachedToPricingPlanDeleteConflict: return "PRICING_RULE_ATTACHED_TO_PRICING_PLAN_DELETE_CONFLICT"
            case .pricingRuleInPricingPlanConflict: return "PRICING_RULE_IN_PRICING_PLAN_CONFLICT"
            case .resourceNameConflict: return "RESOURCE_NAME_CONFLICT"
            case .writeConflictRetry: return "WRITE_CONFLICT_RETRY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateBillingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBillingGroupInput(accountGrouping: \(Swift.String(describing: accountGrouping)), clientToken: \(Swift.String(describing: clientToken)), computationPreference: \(Swift.String(describing: computationPreference)), primaryAccountId: \(Swift.String(describing: primaryAccountId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountGrouping = "AccountGrouping"
        case computationPreference = "ComputationPreference"
        case description = "Description"
        case name = "Name"
        case primaryAccountId = "PrimaryAccountId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountGrouping = self.accountGrouping {
            try encodeContainer.encode(accountGrouping, forKey: .accountGrouping)
        }
        if let computationPreference = self.computationPreference {
            try encodeContainer.encode(computationPreference, forKey: .computationPreference)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let primaryAccountId = self.primaryAccountId {
            try encodeContainer.encode(primaryAccountId, forKey: .primaryAccountId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateBillingGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-billing-group"
    }
}

public struct CreateBillingGroupInput: Swift.Equatable {
    /// The set of accounts that will be under the billing group. The set of accounts resemble the linked accounts in a consolidated family.
    /// This member is required.
    public var accountGrouping: BillingconductorClientTypes.AccountGrouping?
    /// The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
    /// This member is required.
    public var computationPreference: BillingconductorClientTypes.ComputationPreference?
    /// The description of the billing group.
    public var description: Swift.String?
    /// The billing group name. The names must be unique.
    /// This member is required.
    public var name: Swift.String?
    /// The account ID that serves as the main account in a billing group.
    public var primaryAccountId: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a billing group. This feature isn't available during the beta.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accountGrouping: BillingconductorClientTypes.AccountGrouping? = nil,
        clientToken: Swift.String? = nil,
        computationPreference: BillingconductorClientTypes.ComputationPreference? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        primaryAccountId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountGrouping = accountGrouping
        self.clientToken = clientToken
        self.computationPreference = computationPreference
        self.description = description
        self.name = name
        self.primaryAccountId = primaryAccountId
        self.tags = tags
    }
}

struct CreateBillingGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let accountGrouping: BillingconductorClientTypes.AccountGrouping?
    let computationPreference: BillingconductorClientTypes.ComputationPreference?
    let primaryAccountId: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountGrouping = "AccountGrouping"
        case computationPreference = "ComputationPreference"
        case description = "Description"
        case name = "Name"
        case primaryAccountId = "PrimaryAccountId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountGroupingDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.AccountGrouping.self, forKey: .accountGrouping)
        accountGrouping = accountGroupingDecoded
        let computationPreferenceDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ComputationPreference.self, forKey: .computationPreference)
        computationPreference = computationPreferenceDecoded
        let primaryAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountId)
        primaryAccountId = primaryAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBillingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBillingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBillingGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBillingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBillingGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateBillingGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created billing group.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateBillingGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateBillingGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateCustomLineItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomLineItemInput(billingGroupArn: \(Swift.String(describing: billingGroupArn)), billingPeriodRange: \(Swift.String(describing: billingPeriodRange)), chargeDetails: \(Swift.String(describing: chargeDetails)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn = "BillingGroupArn"
        case billingPeriodRange = "BillingPeriodRange"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
        if let chargeDetails = self.chargeDetails {
            try encodeContainer.encode(chargeDetails, forKey: .chargeDetails)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCustomLineItemInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-custom-line-item"
    }
}

public struct CreateCustomLineItemInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to.
    /// This member is required.
    public var billingGroupArn: Swift.String?
    /// A time range for which the custom line item is effective.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A CustomLineItemChargeDetails that describes the charge details for a custom line item.
    /// This member is required.
    public var chargeDetails: BillingconductorClientTypes.CustomLineItemChargeDetails?
    /// The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The description of the custom line item. This is shown on the Bills page in association with the charge value.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the custom line item.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a custom line item.
    public var tags: [Swift.String:Swift.String]?

    public init (
        billingGroupArn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        chargeDetails: BillingconductorClientTypes.CustomLineItemChargeDetails? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingPeriodRange = billingPeriodRange
        self.chargeDetails = chargeDetails
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateCustomLineItemInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let billingGroupArn: Swift.String?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    let tags: [Swift.String:Swift.String]?
    let chargeDetails: BillingconductorClientTypes.CustomLineItemChargeDetails?
}

extension CreateCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn = "BillingGroupArn"
        case billingPeriodRange = "BillingPeriodRange"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
    }
}

extension CreateCustomLineItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomLineItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCustomLineItemOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomLineItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCustomLineItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateCustomLineItemOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created custom line item.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateCustomLineItemOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateCustomLineItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension BillingconductorClientTypes.CreateFreeTierConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activated = "Activated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activated = self.activated {
            try encodeContainer.encode(activated, forKey: .activated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activated)
        activated = activatedDecoded
    }
}

extension BillingconductorClientTypes {
    /// The possible Amazon Web Services Free Tier configurations.
    public struct CreateFreeTierConfig: Swift.Equatable {
        /// Activate or deactivate Amazon Web Services Free Tier.
        /// This member is required.
        public var activated: Swift.Bool?

        public init (
            activated: Swift.Bool? = nil
        )
        {
            self.activated = activated
        }
    }

}

extension CreatePricingPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePricingPlanInput(clientToken: \(Swift.String(describing: clientToken)), pricingRuleArns: \(Swift.String(describing: pricingRuleArns)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreatePricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case pricingRuleArns = "PricingRuleArns"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pricingRuleArns = pricingRuleArns {
            var pricingRuleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pricingRuleArns)
            for pricingrulearn0 in pricingRuleArns {
                try pricingRuleArnsContainer.encode(pricingrulearn0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePricingPlanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreatePricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-pricing-plan"
    }
}

public struct CreatePricingPlanInput: Swift.Equatable {
    /// The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The description of the pricing plan.
    public var description: Swift.String?
    /// The name of the pricing plan. The names must be unique to each pricing plan.
    /// This member is required.
    public var name: Swift.String?
    /// A list of Amazon Resource Names (ARNs) that define the pricing plan parameters.
    public var pricingRuleArns: [Swift.String]?
    /// A map that contains tag keys and tag values that are attached to a pricing plan.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.pricingRuleArns = pricingRuleArns
        self.tags = tags
    }
}

struct CreatePricingPlanInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let pricingRuleArns: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case pricingRuleArns = "PricingRuleArns"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingRuleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingRuleArns)
        var pricingRuleArnsDecoded0:[Swift.String]? = nil
        if let pricingRuleArnsContainer = pricingRuleArnsContainer {
            pricingRuleArnsDecoded0 = [Swift.String]()
            for string0 in pricingRuleArnsContainer {
                if let string0 = string0 {
                    pricingRuleArnsDecoded0?.append(string0)
                }
            }
        }
        pricingRuleArns = pricingRuleArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePricingPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePricingPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePricingPlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePricingPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePricingPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreatePricingPlanOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created pricing plan.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreatePricingPlanOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreatePricingPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreatePricingRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePricingRuleInput(billingEntity: \(Swift.String(describing: billingEntity)), clientToken: \(Swift.String(describing: clientToken)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), scope: \(Swift.String(describing: scope)), service: \(Swift.String(describing: service)), tags: \(Swift.String(describing: tags)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreatePricingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingEntity = "BillingEntity"
        case description = "Description"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case scope = "Scope"
        case service = "Service"
        case tags = "Tags"
        case tiering = "Tiering"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingEntity = self.billingEntity {
            try encodeContainer.encode(billingEntity, forKey: .billingEntity)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modifierPercentage = self.modifierPercentage {
            try encodeContainer.encode(modifierPercentage, forKey: .modifierPercentage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tiering = self.tiering {
            try encodeContainer.encode(tiering, forKey: .tiering)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreatePricingRuleInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreatePricingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-pricing-rule"
    }
}

public struct CreatePricingRuleInput: Swift.Equatable {
    /// The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
    public var billingEntity: Swift.String?
    /// The token that's needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The pricing rule description.
    public var description: Swift.String?
    /// A percentage modifier that's applied on the public pricing rates.
    public var modifierPercentage: Swift.Double?
    /// The pricing rule name. The names must be unique to each pricing rule.
    /// This member is required.
    public var name: Swift.String?
    /// The scope of pricing rule that indicates if it's globally applicable, or it's service-specific.
    /// This member is required.
    public var scope: BillingconductorClientTypes.PricingRuleScope?
    /// If the Scope attribute is set to SERVICE, the attribute indicates which service the PricingRule is applicable for.
    public var service: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a pricing rule.
    public var tags: [Swift.String:Swift.String]?
    /// The set of tiering configurations for the pricing rule.
    public var tiering: BillingconductorClientTypes.CreateTieringInput?
    /// The type of pricing rule.
    /// This member is required.
    public var type: BillingconductorClientTypes.PricingRuleType?

    public init (
        billingEntity: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        modifierPercentage: Swift.Double? = nil,
        name: Swift.String? = nil,
        scope: BillingconductorClientTypes.PricingRuleScope? = nil,
        service: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tiering: BillingconductorClientTypes.CreateTieringInput? = nil,
        type: BillingconductorClientTypes.PricingRuleType? = nil
    )
    {
        self.billingEntity = billingEntity
        self.clientToken = clientToken
        self.description = description
        self.modifierPercentage = modifierPercentage
        self.name = name
        self.scope = scope
        self.service = service
        self.tags = tags
        self.tiering = tiering
        self.type = type
    }
}

struct CreatePricingRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let scope: BillingconductorClientTypes.PricingRuleScope?
    let type: BillingconductorClientTypes.PricingRuleType?
    let modifierPercentage: Swift.Double?
    let service: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let billingEntity: Swift.String?
    let tiering: BillingconductorClientTypes.CreateTieringInput?
}

extension CreatePricingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingEntity = "BillingEntity"
        case description = "Description"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case scope = "Scope"
        case service = "Service"
        case tags = "Tags"
        case tiering = "Tiering"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleScope.self, forKey: .scope)
        scope = scopeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleType.self, forKey: .type)
        type = typeDecoded
        let modifierPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .modifierPercentage)
        modifierPercentage = modifierPercentageDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let billingEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingEntity)
        billingEntity = billingEntityDecoded
        let tieringDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CreateTieringInput.self, forKey: .tiering)
        tiering = tieringDecoded
    }
}

extension CreatePricingRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePricingRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceededException" : self = .serviceLimitExceededException(try ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePricingRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceLimitExceededException(ServiceLimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePricingRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePricingRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreatePricingRuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created pricing rule.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreatePricingRuleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreatePricingRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension BillingconductorClientTypes.CreateTieringInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTier = "FreeTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let freeTier = self.freeTier {
            try encodeContainer.encode(freeTier, forKey: .freeTier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeTierDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CreateFreeTierConfig.self, forKey: .freeTier)
        freeTier = freeTierDecoded
    }
}

extension BillingconductorClientTypes {
    /// The set of tiering configurations for the pricing rule.
    public struct CreateTieringInput: Swift.Equatable {
        /// The possible Amazon Web Services Free Tier configurations.
        /// This member is required.
        public var freeTier: BillingconductorClientTypes.CreateFreeTierConfig?

        public init (
            freeTier: BillingconductorClientTypes.CreateFreeTierConfig? = nil
        )
        {
            self.freeTier = freeTier
        }
    }

}

extension BillingconductorClientTypes {
    public enum CurrencyCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cny
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .cny,
                .usd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cny: return "CNY"
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CurrencyCode(rawValue: rawValue) ?? CurrencyCode.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.CustomLineItemBillingPeriodRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveEndBillingPeriod = "ExclusiveEndBillingPeriod"
        case inclusiveStartBillingPeriod = "InclusiveStartBillingPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveEndBillingPeriod = self.exclusiveEndBillingPeriod {
            try encodeContainer.encode(exclusiveEndBillingPeriod, forKey: .exclusiveEndBillingPeriod)
        }
        if let inclusiveStartBillingPeriod = self.inclusiveStartBillingPeriod {
            try encodeContainer.encode(inclusiveStartBillingPeriod, forKey: .inclusiveStartBillingPeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inclusiveStartBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inclusiveStartBillingPeriod)
        inclusiveStartBillingPeriod = inclusiveStartBillingPeriodDecoded
        let exclusiveEndBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exclusiveEndBillingPeriod)
        exclusiveEndBillingPeriod = exclusiveEndBillingPeriodDecoded
    }
}

extension BillingconductorClientTypes {
    /// The billing period range in which the custom line item request will be applied.
    public struct CustomLineItemBillingPeriodRange: Swift.Equatable {
        /// The inclusive end billing period that defines a billing period range where a custom line is applied.
        public var exclusiveEndBillingPeriod: Swift.String?
        /// The inclusive start billing period that defines a billing period range where a custom line is applied.
        /// This member is required.
        public var inclusiveStartBillingPeriod: Swift.String?

        public init (
            exclusiveEndBillingPeriod: Swift.String? = nil,
            inclusiveStartBillingPeriod: Swift.String? = nil
        )
        {
            self.exclusiveEndBillingPeriod = exclusiveEndBillingPeriod
            self.inclusiveStartBillingPeriod = inclusiveStartBillingPeriod
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flat = "Flat"
        case percentage = "Percentage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flat = self.flat {
            try encodeContainer.encode(flat, forKey: .flat)
        }
        if let percentage = self.percentage {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flatDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemFlatChargeDetails.self, forKey: .flat)
        flat = flatDecoded
        let percentageDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemPercentageChargeDetails.self, forKey: .percentage)
        percentage = percentageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemType.self, forKey: .type)
        type = typeDecoded
    }
}

extension BillingconductorClientTypes {
    /// The charge details of a custom line item. It should contain only one of Flat or Percentage.
    public struct CustomLineItemChargeDetails: Swift.Equatable {
        /// A CustomLineItemFlatChargeDetails that describes the charge details of a flat custom line item.
        public var flat: BillingconductorClientTypes.CustomLineItemFlatChargeDetails?
        /// A CustomLineItemPercentageChargeDetails that describes the charge details of a percentage custom line item.
        public var percentage: BillingconductorClientTypes.CustomLineItemPercentageChargeDetails?
        /// The type of the custom line item that indicates whether the charge is a fee or credit.
        /// This member is required.
        public var type: BillingconductorClientTypes.CustomLineItemType?

        public init (
            flat: BillingconductorClientTypes.CustomLineItemFlatChargeDetails? = nil,
            percentage: BillingconductorClientTypes.CustomLineItemPercentageChargeDetails? = nil,
            type: BillingconductorClientTypes.CustomLineItemType? = nil
        )
        {
            self.flat = flat
            self.percentage = percentage
            self.type = type
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemFlatChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chargeValue = "ChargeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chargeValue = self.chargeValue {
            try encodeContainer.encode(chargeValue, forKey: .chargeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chargeValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .chargeValue)
        chargeValue = chargeValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a flat custom line item.
    public struct CustomLineItemFlatChargeDetails: Swift.Equatable {
        /// The custom line item's fixed charge value in USD.
        /// This member is required.
        public var chargeValue: Swift.Double?

        public init (
            chargeValue: Swift.Double? = nil
        )
        {
            self.chargeValue = chargeValue
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associationSize = "AssociationSize"
        case billingGroupArn = "BillingGroupArn"
        case chargeDetails = "ChargeDetails"
        case creationTime = "CreationTime"
        case currencyCode = "CurrencyCode"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case productCode = "ProductCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if associationSize != 0 {
            try encodeContainer.encode(associationSize, forKey: .associationSize)
        }
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let chargeDetails = self.chargeDetails {
            try encodeContainer.encode(chargeDetails, forKey: .chargeDetails)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode.rawValue, forKey: .currencyCode)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CurrencyCode.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let associationSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associationSize) ?? 0
        associationSize = associationSizeDecoded
    }
}

extension BillingconductorClientTypes.CustomLineItemListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomLineItemListElement(arn: \(Swift.String(describing: arn)), associationSize: \(Swift.String(describing: associationSize)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), chargeDetails: \(Swift.String(describing: chargeDetails)), creationTime: \(Swift.String(describing: creationTime)), currencyCode: \(Swift.String(describing: currencyCode)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), productCode: \(Swift.String(describing: productCode)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a custom line item.
    public struct CustomLineItemListElement: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) for custom line items.
        public var arn: Swift.String?
        /// The number of resources that are associated to the custom line item.
        public var associationSize: Swift.Int
        /// The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to.
        public var billingGroupArn: Swift.String?
        /// A ListCustomLineItemChargeDetails that describes the charge details of a custom line item.
        public var chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
        /// The time created.
        public var creationTime: Swift.Int
        /// The custom line item's charge value currency. Only one of the valid values can be used.
        public var currencyCode: BillingconductorClientTypes.CurrencyCode?
        /// The custom line item's description. This is shown on the Bills page in association with the charge value.
        public var description: Swift.String?
        /// The most recent time when the custom line item was modified.
        public var lastModifiedTime: Swift.Int
        /// The custom line item's name.
        public var name: Swift.String?
        /// The product code that's associated with the custom line item.
        public var productCode: Swift.String?

        public init (
            arn: Swift.String? = nil,
            associationSize: Swift.Int = 0,
            billingGroupArn: Swift.String? = nil,
            chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails? = nil,
            creationTime: Swift.Int = 0,
            currencyCode: BillingconductorClientTypes.CurrencyCode? = nil,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            productCode: Swift.String? = nil
        )
        {
            self.arn = arn
            self.associationSize = associationSize
            self.billingGroupArn = billingGroupArn
            self.chargeDetails = chargeDetails
            self.creationTime = creationTime
            self.currencyCode = currencyCode
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.productCode = productCode
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemPercentageChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedValues = "AssociatedValues"
        case percentageValue = "PercentageValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedValues = associatedValues {
            var associatedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedValues)
            for customlineitemassociationelement0 in associatedValues {
                try associatedValuesContainer.encode(customlineitemassociationelement0)
            }
        }
        if let percentageValue = self.percentageValue {
            try encodeContainer.encode(percentageValue, forKey: .percentageValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentageValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentageValue)
        percentageValue = percentageValueDecoded
        let associatedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedValues)
        var associatedValuesDecoded0:[Swift.String]? = nil
        if let associatedValuesContainer = associatedValuesContainer {
            associatedValuesDecoded0 = [Swift.String]()
            for string0 in associatedValuesContainer {
                if let string0 = string0 {
                    associatedValuesDecoded0?.append(string0)
                }
            }
        }
        associatedValues = associatedValuesDecoded0
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a percentage custom line item.
    public struct CustomLineItemPercentageChargeDetails: Swift.Equatable {
        /// A list of resource ARNs to associate to the percentage custom line item.
        public var associatedValues: [Swift.String]?
        /// The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        /// This member is required.
        public var percentageValue: Swift.Double?

        public init (
            associatedValues: [Swift.String]? = nil,
            percentageValue: Swift.Double? = nil
        )
        {
            self.associatedValues = associatedValues
            self.percentageValue = percentageValue
        }
    }

}

extension BillingconductorClientTypes {
    public enum CustomLineItemRelationship: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case child
        case parent
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomLineItemRelationship] {
            return [
                .child,
                .parent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .child: return "CHILD"
            case .parent: return "PARENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomLineItemRelationship(rawValue: rawValue) ?? CustomLineItemRelationship.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes {
    public enum CustomLineItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case credit
        case fee
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomLineItemType] {
            return [
                .credit,
                .fee,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .credit: return "CREDIT"
            case .fee: return "FEE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomLineItemType(rawValue: rawValue) ?? CustomLineItemType.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.CustomLineItemVersionListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationSize = "AssociationSize"
        case billingGroupArn = "BillingGroupArn"
        case chargeDetails = "ChargeDetails"
        case creationTime = "CreationTime"
        case currencyCode = "CurrencyCode"
        case description = "Description"
        case endBillingPeriod = "EndBillingPeriod"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case productCode = "ProductCode"
        case startBillingPeriod = "StartBillingPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if associationSize != 0 {
            try encodeContainer.encode(associationSize, forKey: .associationSize)
        }
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let chargeDetails = self.chargeDetails {
            try encodeContainer.encode(chargeDetails, forKey: .chargeDetails)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode.rawValue, forKey: .currencyCode)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endBillingPeriod = self.endBillingPeriod {
            try encodeContainer.encode(endBillingPeriod, forKey: .endBillingPeriod)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let startBillingPeriod = self.startBillingPeriod {
            try encodeContainer.encode(startBillingPeriod, forKey: .startBillingPeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CurrencyCode.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let associationSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associationSize) ?? 0
        associationSize = associationSizeDecoded
        let startBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startBillingPeriod)
        startBillingPeriod = startBillingPeriodDecoded
        let endBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endBillingPeriod)
        endBillingPeriod = endBillingPeriodDecoded
    }
}

extension BillingconductorClientTypes.CustomLineItemVersionListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomLineItemVersionListElement(associationSize: \(Swift.String(describing: associationSize)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), chargeDetails: \(Swift.String(describing: chargeDetails)), creationTime: \(Swift.String(describing: creationTime)), currencyCode: \(Swift.String(describing: currencyCode)), endBillingPeriod: \(Swift.String(describing: endBillingPeriod)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), productCode: \(Swift.String(describing: productCode)), startBillingPeriod: \(Swift.String(describing: startBillingPeriod)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a custom line item version.
    public struct CustomLineItemVersionListElement: Swift.Equatable {
        /// The number of resources that are associated with the custom line item.
        public var associationSize: Swift.Int
        /// The Amazon Resource Name (ARN) of the billing group that the custom line item applies to.
        public var billingGroupArn: Swift.String?
        /// A representation of the charge details of a custom line item.
        public var chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
        /// The time when the custom line item version was created.
        public var creationTime: Swift.Int
        /// The charge value currency of the custom line item.
        public var currencyCode: BillingconductorClientTypes.CurrencyCode?
        /// The description of the custom line item.
        public var description: Swift.String?
        /// The end billing period of the custom line item version.
        public var endBillingPeriod: Swift.String?
        /// The most recent time that the custom line item version was modified.
        public var lastModifiedTime: Swift.Int
        /// The name of the custom line item.
        public var name: Swift.String?
        /// The product code that’s associated with the custom line item.
        public var productCode: Swift.String?
        /// The start billing period of the custom line item version.
        public var startBillingPeriod: Swift.String?

        public init (
            associationSize: Swift.Int = 0,
            billingGroupArn: Swift.String? = nil,
            chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails? = nil,
            creationTime: Swift.Int = 0,
            currencyCode: BillingconductorClientTypes.CurrencyCode? = nil,
            description: Swift.String? = nil,
            endBillingPeriod: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            productCode: Swift.String? = nil,
            startBillingPeriod: Swift.String? = nil
        )
        {
            self.associationSize = associationSize
            self.billingGroupArn = billingGroupArn
            self.chargeDetails = chargeDetails
            self.creationTime = creationTime
            self.currencyCode = currencyCode
            self.description = description
            self.endBillingPeriod = endBillingPeriod
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.productCode = productCode
            self.startBillingPeriod = startBillingPeriod
        }
    }

}

extension DeleteBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-billing-group"
    }
}

public struct DeleteBillingGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the billing group that you're deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteBillingGroupInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteBillingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBillingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBillingGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBillingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBillingGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteBillingGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted billing group.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteBillingGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteBillingGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriodRange = "BillingPeriodRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
    }
}

extension DeleteCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-custom-line-item"
    }
}

public struct DeleteCustomLineItemInput: Swift.Equatable {
    /// The ARN of the custom line item to be deleted.
    /// This member is required.
    public var arn: Swift.String?
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?

    public init (
        arn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil
    )
    {
        self.arn = arn
        self.billingPeriodRange = billingPeriodRange
    }
}

struct DeleteCustomLineItemInputBody: Swift.Equatable {
    let arn: Swift.String?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
}

extension DeleteCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriodRange = "BillingPeriodRange"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension DeleteCustomLineItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomLineItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCustomLineItemOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomLineItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteCustomLineItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteCustomLineItemOutputResponse: Swift.Equatable {
    /// Then ARN of the deleted custom line item.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteCustomLineItemOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteCustomLineItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeletePricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-pricing-plan"
    }
}

public struct DeletePricingPlanInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing plan that you're deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePricingPlanInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePricingPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePricingPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePricingPlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePricingPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeletePricingPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeletePricingPlanOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted pricing plan.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePricingPlanOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePricingPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePricingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeletePricingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-pricing-rule"
    }
}

public struct DeletePricingRuleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing rule that you are deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePricingRuleInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePricingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePricingRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePricingRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePricingRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePricingRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeletePricingRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeletePricingRuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted pricing rule.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePricingRuleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePricingRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DisassociateAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DisassociateAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociate-accounts"
    }
}

public struct DisassociateAccountsInput: Swift.Equatable {
    /// The array of account IDs to disassociate.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the billing group that the array of account IDs will disassociate from.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        arn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.arn = arn
    }
}

struct DisassociateAccountsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let accountIds: [Swift.String]?
}

extension DisassociateAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DisassociateAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateAccountsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DisassociateAccountsOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the billing group that the array of account IDs is disassociated from.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DisassociateAccountsOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DisassociateAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DisassociatePricingRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let pricingRuleArns = pricingRuleArns {
            var pricingRuleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pricingRuleArns)
            for pricingrulearn0 in pricingRuleArns {
                try pricingRuleArnsContainer.encode(pricingrulearn0)
            }
        }
    }
}

extension DisassociatePricingRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociate-pricing-rules"
    }
}

public struct DisassociatePricingRulesInput: Swift.Equatable {
    /// The pricing plan Amazon Resource Name (ARN) to disassociate pricing rules from.
    /// This member is required.
    public var arn: Swift.String?
    /// A list containing the Amazon Resource Name (ARN) of the pricing rules that will be disassociated.
    /// This member is required.
    public var pricingRuleArns: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.pricingRuleArns = pricingRuleArns
    }
}

struct DisassociatePricingRulesInputBody: Swift.Equatable {
    let arn: Swift.String?
    let pricingRuleArns: [Swift.String]?
}

extension DisassociatePricingRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let pricingRuleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingRuleArns)
        var pricingRuleArnsDecoded0:[Swift.String]? = nil
        if let pricingRuleArnsContainer = pricingRuleArnsContainer {
            pricingRuleArnsDecoded0 = [Swift.String]()
            for string0 in pricingRuleArnsContainer {
                if let string0 = string0 {
                    pricingRuleArnsDecoded0?.append(string0)
                }
            }
        }
        pricingRuleArns = pricingRuleArnsDecoded0
    }
}

extension DisassociatePricingRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociatePricingRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociatePricingRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociatePricingRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociatePricingRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DisassociatePricingRulesOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing plan that the pricing rules successfully disassociated from.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DisassociatePricingRulesOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DisassociatePricingRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension BillingconductorClientTypes.DisassociateResourceResponseElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let errorDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.AssociateResourceError.self, forKey: .error)
        error = errorDecoded
    }
}

extension BillingconductorClientTypes {
    /// A resource disassociation result for a percentage custom line item.
    public struct DisassociateResourceResponseElement: Swift.Equatable {
        /// The resource ARN that was disassociated from the custom line item.
        public var arn: Swift.String?
        /// An AssociateResourceError that's shown if the resource disassociation fails.
        public var error: BillingconductorClientTypes.AssociateResourceError?

        public init (
            arn: Swift.String? = nil,
            error: BillingconductorClientTypes.AssociateResourceError? = nil
        )
        {
            self.arn = arn
            self.error = error
        }
    }

}

extension BillingconductorClientTypes.FreeTierConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activated = "Activated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activated = self.activated {
            try encodeContainer.encode(activated, forKey: .activated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activated)
        activated = activatedDecoded
    }
}

extension BillingconductorClientTypes {
    /// The possible Amazon Web Services Free Tier configurations.
    public struct FreeTierConfig: Swift.Equatable {
        /// Activate or deactivate Amazon Web Services Free Tier application.
        /// This member is required.
        public var activated: Swift.Bool?

        public init (
            activated: Swift.Bool? = nil
        )
        {
            self.activated = activated
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred while processing a request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// Number of seconds you can retry after the call.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BillingconductorClientTypes.ListAccountAssociationsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case association = "Association"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let association = self.association {
            try encodeContainer.encode(association, forKey: .association)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .association)
        association = associationDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension BillingconductorClientTypes {
    /// The filter on the account ID of the linked account, or any of the following: MONITORED: linked accounts that are associated to billing groups. UNMONITORED: linked accounts that are not associated to billing groups. Billing Group Arn: linked accounts that are associated to the provided Billing Group Arn.
    public struct ListAccountAssociationsFilter: Swift.Equatable {
        /// The Amazon Web Services account ID to filter on.
        public var accountId: Swift.String?
        /// MONITORED: linked accounts that are associated to billing groups. UNMONITORED: linked accounts that are not associated to billing groups. Billing Group Arn: linked accounts that are associated to the provided Billing Group Arn.
        public var association: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            association: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.association = association
        }
    }

}

extension ListAccountAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccountAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-account-associations"
    }
}

public struct ListAccountAssociationsInput: Swift.Equatable {
    /// The preferred billing period to get account associations.
    public var billingPeriod: Swift.String?
    /// The filter on the account ID of the linked account, or any of the following: MONITORED: linked accounts that are associated to billing groups. UNMONITORED: linked accounts that aren't associated to billing groups. Billing Group Arn: linked accounts that are associated to the provided billing group Arn.
    public var filters: BillingconductorClientTypes.ListAccountAssociationsFilter?
    /// The pagination token that's used on subsequent calls to retrieve accounts.
    public var nextToken: Swift.String?

    public init (
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListAccountAssociationsFilter? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListAccountAssociationsInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let filters: BillingconductorClientTypes.ListAccountAssociationsFilter?
    let nextToken: Swift.String?
}

extension ListAccountAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListAccountAssociationsFilter.self, forKey: .filters)
        filters = filtersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccountAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccountAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.linkedAccounts = output.linkedAccounts
            self.nextToken = output.nextToken
        } else {
            self.linkedAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssociationsOutputResponse: Swift.Equatable {
    /// The list of linked accounts in the payer account.
    public var linkedAccounts: [BillingconductorClientTypes.AccountAssociationsListElement]?
    /// The pagination token that's used on subsequent calls to get accounts.
    public var nextToken: Swift.String?

    public init (
        linkedAccounts: [BillingconductorClientTypes.AccountAssociationsListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkedAccounts = linkedAccounts
        self.nextToken = nextToken
    }
}

struct ListAccountAssociationsOutputResponseBody: Swift.Equatable {
    let linkedAccounts: [BillingconductorClientTypes.AccountAssociationsListElement]?
    let nextToken: Swift.String?
}

extension ListAccountAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkedAccounts = "LinkedAccounts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkedAccountsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.AccountAssociationsListElement?].self, forKey: .linkedAccounts)
        var linkedAccountsDecoded0:[BillingconductorClientTypes.AccountAssociationsListElement]? = nil
        if let linkedAccountsContainer = linkedAccountsContainer {
            linkedAccountsDecoded0 = [BillingconductorClientTypes.AccountAssociationsListElement]()
            for structure0 in linkedAccountsContainer {
                if let structure0 = structure0 {
                    linkedAccountsDecoded0?.append(structure0)
                }
            }
        }
        linkedAccounts = linkedAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BillingconductorClientTypes.ListBillingGroupCostReportsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArns = "BillingGroupArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupArns = billingGroupArns {
            var billingGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .billingGroupArns)
            for billinggrouparn0 in billingGroupArns {
                try billingGroupArnsContainer.encode(billinggrouparn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .billingGroupArns)
        var billingGroupArnsDecoded0:[Swift.String]? = nil
        if let billingGroupArnsContainer = billingGroupArnsContainer {
            billingGroupArnsDecoded0 = [Swift.String]()
            for string0 in billingGroupArnsContainer {
                if let string0 = string0 {
                    billingGroupArnsDecoded0?.append(string0)
                }
            }
        }
        billingGroupArns = billingGroupArnsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// The filter used to retrieve specific BillingGroupCostReportElements.
    public struct ListBillingGroupCostReportsFilter: Swift.Equatable {
        /// The list of Amazon Resource Names (ARNs) used to filter billing groups to retrieve reports.
        public var billingGroupArns: [Swift.String]?

        public init (
            billingGroupArns: [Swift.String]? = nil
        )
        {
            self.billingGroupArns = billingGroupArns
        }
    }

}

extension ListBillingGroupCostReportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListBillingGroupCostReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-billing-group-cost-reports"
    }
}

public struct ListBillingGroupCostReportsInput: Swift.Equatable {
    /// The preferred billing period for your report.
    public var billingPeriod: Swift.String?
    /// A ListBillingGroupCostReportsFilter to specify billing groups to retrieve reports from.
    public var filters: BillingconductorClientTypes.ListBillingGroupCostReportsFilter?
    /// The maximum number of reports to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to get reports.
    public var nextToken: Swift.String?

    public init (
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListBillingGroupCostReportsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBillingGroupCostReportsInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListBillingGroupCostReportsFilter?
}

extension ListBillingGroupCostReportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListBillingGroupCostReportsFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListBillingGroupCostReportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBillingGroupCostReportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBillingGroupCostReportsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBillingGroupCostReportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBillingGroupCostReportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.billingGroupCostReports = output.billingGroupCostReports
            self.nextToken = output.nextToken
        } else {
            self.billingGroupCostReports = nil
            self.nextToken = nil
        }
    }
}

public struct ListBillingGroupCostReportsOutputResponse: Swift.Equatable {
    /// A list of BillingGroupCostReportElement retrieved.
    public var billingGroupCostReports: [BillingconductorClientTypes.BillingGroupCostReportElement]?
    /// The pagination token that's used on subsequent calls to get reports.
    public var nextToken: Swift.String?

    public init (
        billingGroupCostReports: [BillingconductorClientTypes.BillingGroupCostReportElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroupCostReports = billingGroupCostReports
        self.nextToken = nextToken
    }
}

struct ListBillingGroupCostReportsOutputResponseBody: Swift.Equatable {
    let billingGroupCostReports: [BillingconductorClientTypes.BillingGroupCostReportElement]?
    let nextToken: Swift.String?
}

extension ListBillingGroupCostReportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupCostReports = "BillingGroupCostReports"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupCostReportsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.BillingGroupCostReportElement?].self, forKey: .billingGroupCostReports)
        var billingGroupCostReportsDecoded0:[BillingconductorClientTypes.BillingGroupCostReportElement]? = nil
        if let billingGroupCostReportsContainer = billingGroupCostReportsContainer {
            billingGroupCostReportsDecoded0 = [BillingconductorClientTypes.BillingGroupCostReportElement]()
            for structure0 in billingGroupCostReportsContainer {
                if let structure0 = structure0 {
                    billingGroupCostReportsDecoded0?.append(structure0)
                }
            }
        }
        billingGroupCostReports = billingGroupCostReportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BillingconductorClientTypes.ListBillingGroupsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case pricingPlan = "PricingPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for billinggrouparn0 in arns {
                try arnsContainer.encode(billinggrouparn0)
            }
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan, forKey: .pricingPlan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let pricingPlanDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
    }
}

extension BillingconductorClientTypes {
    /// The filter that specifies the billing groups and pricing plans to retrieve billing group information.
    public struct ListBillingGroupsFilter: Swift.Equatable {
        /// The list of billing group Amazon Resource Names (ARNs) to retrieve information.
        public var arns: [Swift.String]?
        /// The pricing plan Amazon Resource Names (ARNs) to retrieve information.
        public var pricingPlan: Swift.String?

        public init (
            arns: [Swift.String]? = nil,
            pricingPlan: Swift.String? = nil
        )
        {
            self.arns = arns
            self.pricingPlan = pricingPlan
        }
    }

}

extension ListBillingGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListBillingGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-billing-groups"
    }
}

public struct ListBillingGroupsInput: Swift.Equatable {
    /// The preferred billing period to get billing groups.
    public var billingPeriod: Swift.String?
    /// A ListBillingGroupsFilter that specifies the billing group and pricing plan to retrieve billing group information.
    public var filters: BillingconductorClientTypes.ListBillingGroupsFilter?
    /// The maximum number of billing groups to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to get billing groups.
    public var nextToken: Swift.String?

    public init (
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListBillingGroupsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBillingGroupsInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListBillingGroupsFilter?
}

extension ListBillingGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListBillingGroupsFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListBillingGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBillingGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBillingGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBillingGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBillingGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.billingGroups = output.billingGroups
            self.nextToken = output.nextToken
        } else {
            self.billingGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListBillingGroupsOutputResponse: Swift.Equatable {
    /// A list of BillingGroupListElement retrieved.
    public var billingGroups: [BillingconductorClientTypes.BillingGroupListElement]?
    /// The pagination token that's used on subsequent calls to get billing groups.
    public var nextToken: Swift.String?

    public init (
        billingGroups: [BillingconductorClientTypes.BillingGroupListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroups = billingGroups
        self.nextToken = nextToken
    }
}

struct ListBillingGroupsOutputResponseBody: Swift.Equatable {
    let billingGroups: [BillingconductorClientTypes.BillingGroupListElement]?
    let nextToken: Swift.String?
}

extension ListBillingGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroups = "BillingGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.BillingGroupListElement?].self, forKey: .billingGroups)
        var billingGroupsDecoded0:[BillingconductorClientTypes.BillingGroupListElement]? = nil
        if let billingGroupsContainer = billingGroupsContainer {
            billingGroupsDecoded0 = [BillingconductorClientTypes.BillingGroupListElement]()
            for structure0 in billingGroupsContainer {
                if let structure0 = structure0 {
                    billingGroupsDecoded0?.append(structure0)
                }
            }
        }
        billingGroups = billingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BillingconductorClientTypes.ListCustomLineItemChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flat = "Flat"
        case percentage = "Percentage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flat = self.flat {
            try encodeContainer.encode(flat, forKey: .flat)
        }
        if let percentage = self.percentage {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flatDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails.self, forKey: .flat)
        flat = flatDecoded
        let percentageDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails.self, forKey: .percentage)
        percentage = percentageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemType.self, forKey: .type)
        type = typeDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details of a custom line item.
    public struct ListCustomLineItemChargeDetails: Swift.Equatable {
        /// A ListCustomLineItemFlatChargeDetails that describes the charge details of a flat custom line item.
        public var flat: BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails?
        /// A ListCustomLineItemPercentageChargeDetails that describes the charge details of a percentage custom line item.
        public var percentage: BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails?
        /// The type of the custom line item that indicates whether the charge is a fee or credit.
        /// This member is required.
        public var type: BillingconductorClientTypes.CustomLineItemType?

        public init (
            flat: BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails? = nil,
            percentage: BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails? = nil,
            type: BillingconductorClientTypes.CustomLineItemType? = nil
        )
        {
            self.flat = flat
            self.percentage = percentage
            self.type = type
        }
    }

}

extension BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chargeValue = "ChargeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chargeValue = self.chargeValue {
            try encodeContainer.encode(chargeValue, forKey: .chargeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chargeValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .chargeValue)
        chargeValue = chargeValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a flat custom line item.
    public struct ListCustomLineItemFlatChargeDetails: Swift.Equatable {
        /// The custom line item's fixed charge value in USD.
        /// This member is required.
        public var chargeValue: Swift.Double?

        public init (
            chargeValue: Swift.Double? = nil
        )
        {
            self.chargeValue = chargeValue
        }
    }

}

extension BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentageValue = "PercentageValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentageValue = self.percentageValue {
            try encodeContainer.encode(percentageValue, forKey: .percentageValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentageValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentageValue)
        percentageValue = percentageValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a percentage custom line item.
    public struct ListCustomLineItemPercentageChargeDetails: Swift.Equatable {
        /// The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        /// This member is required.
        public var percentageValue: Swift.Double?

        public init (
            percentageValue: Swift.Double? = nil
        )
        {
            self.percentageValue = percentageValue
        }
    }

}

extension BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endBillingPeriod = "EndBillingPeriod"
        case startBillingPeriod = "StartBillingPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endBillingPeriod = self.endBillingPeriod {
            try encodeContainer.encode(endBillingPeriod, forKey: .endBillingPeriod)
        }
        if let startBillingPeriod = self.startBillingPeriod {
            try encodeContainer.encode(startBillingPeriod, forKey: .startBillingPeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startBillingPeriod)
        startBillingPeriod = startBillingPeriodDecoded
        let endBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endBillingPeriod)
        endBillingPeriod = endBillingPeriodDecoded
    }
}

extension BillingconductorClientTypes {
    /// A billing period filter that specifies the custom line item versions to retrieve.
    public struct ListCustomLineItemVersionsBillingPeriodRangeFilter: Swift.Equatable {
        /// The exclusive end billing period that defines a billing period range where a custom line item version is applied.
        public var endBillingPeriod: Swift.String?
        /// The inclusive start billing period that defines a billing period range where a custom line item version is applied.
        public var startBillingPeriod: Swift.String?

        public init (
            endBillingPeriod: Swift.String? = nil,
            startBillingPeriod: Swift.String? = nil
        )
        {
            self.endBillingPeriod = endBillingPeriod
            self.startBillingPeriod = startBillingPeriod
        }
    }

}

extension BillingconductorClientTypes.ListCustomLineItemVersionsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension BillingconductorClientTypes {
    /// A filter that specifies the billing period range where the custom line item versions reside.
    public struct ListCustomLineItemVersionsFilter: Swift.Equatable {
        /// The billing period range in which the custom line item version is applied.
        public var billingPeriodRange: BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter?

        public init (
            billingPeriodRange: BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter? = nil
        )
        {
            self.billingPeriodRange = billingPeriodRange
        }
    }

}

extension ListCustomLineItemVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomLineItemVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-custom-line-item-versions"
    }
}

public struct ListCustomLineItemVersionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the custom line item.
    /// This member is required.
    public var arn: Swift.String?
    /// A ListCustomLineItemVersionsFilter that specifies the billing period range in which the custom line item versions are applied.
    public var filters: BillingconductorClientTypes.ListCustomLineItemVersionsFilter?
    /// The maximum number of custom line item versions to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to retrieve custom line item versions.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListCustomLineItemVersionsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomLineItemVersionsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListCustomLineItemVersionsFilter?
}

extension ListCustomLineItemVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemVersionsFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListCustomLineItemVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomLineItemVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCustomLineItemVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomLineItemVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCustomLineItemVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customLineItemVersions = output.customLineItemVersions
            self.nextToken = output.nextToken
        } else {
            self.customLineItemVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomLineItemVersionsOutputResponse: Swift.Equatable {
    /// A list of CustomLineItemVersionListElements that are received.
    public var customLineItemVersions: [BillingconductorClientTypes.CustomLineItemVersionListElement]?
    /// The pagination token that's used on subsequent calls to retrieve custom line item versions.
    public var nextToken: Swift.String?

    public init (
        customLineItemVersions: [BillingconductorClientTypes.CustomLineItemVersionListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customLineItemVersions = customLineItemVersions
        self.nextToken = nextToken
    }
}

struct ListCustomLineItemVersionsOutputResponseBody: Swift.Equatable {
    let customLineItemVersions: [BillingconductorClientTypes.CustomLineItemVersionListElement]?
    let nextToken: Swift.String?
}

extension ListCustomLineItemVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLineItemVersions = "CustomLineItemVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customLineItemVersionsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.CustomLineItemVersionListElement?].self, forKey: .customLineItemVersions)
        var customLineItemVersionsDecoded0:[BillingconductorClientTypes.CustomLineItemVersionListElement]? = nil
        if let customLineItemVersionsContainer = customLineItemVersionsContainer {
            customLineItemVersionsDecoded0 = [BillingconductorClientTypes.CustomLineItemVersionListElement]()
            for structure0 in customLineItemVersionsContainer {
                if let structure0 = structure0 {
                    customLineItemVersionsDecoded0?.append(structure0)
                }
            }
        }
        customLineItemVersions = customLineItemVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BillingconductorClientTypes.ListCustomLineItemsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case billingGroups = "BillingGroups"
        case names = "Names"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for customlineitemarn0 in arns {
                try arnsContainer.encode(customlineitemarn0)
            }
        }
        if let billingGroups = billingGroups {
            var billingGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .billingGroups)
            for billinggrouparn0 in billingGroups {
                try billingGroupsContainer.encode(billinggrouparn0)
            }
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for customlineitemname0 in names {
                try namesContainer.encode(customlineitemname0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let billingGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .billingGroups)
        var billingGroupsDecoded0:[Swift.String]? = nil
        if let billingGroupsContainer = billingGroupsContainer {
            billingGroupsDecoded0 = [Swift.String]()
            for string0 in billingGroupsContainer {
                if let string0 = string0 {
                    billingGroupsDecoded0?.append(string0)
                }
            }
        }
        billingGroups = billingGroupsDecoded0
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// A filter that specifies the custom line items and billing groups to retrieve FFLI information.
    public struct ListCustomLineItemsFilter: Swift.Equatable {
        /// A list of custom line item ARNs to retrieve information.
        public var arns: [Swift.String]?
        /// The billing group Amazon Resource Names (ARNs) to retrieve information.
        public var billingGroups: [Swift.String]?
        /// A list of custom line items to retrieve information.
        public var names: [Swift.String]?

        public init (
            arns: [Swift.String]? = nil,
            billingGroups: [Swift.String]? = nil,
            names: [Swift.String]? = nil
        )
        {
            self.arns = arns
            self.billingGroups = billingGroups
            self.names = names
        }
    }

}

extension ListCustomLineItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomLineItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-custom-line-items"
    }
}

public struct ListCustomLineItemsInput: Swift.Equatable {
    /// The preferred billing period to get custom line items (FFLIs).
    public var billingPeriod: Swift.String?
    /// A ListCustomLineItemsFilter that specifies the custom line item names and/or billing group Amazon Resource Names (ARNs) to retrieve FFLI information.
    public var filters: BillingconductorClientTypes.ListCustomLineItemsFilter?
    /// The maximum number of billing groups to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to get custom line items (FFLIs).
    public var nextToken: Swift.String?

    public init (
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListCustomLineItemsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomLineItemsInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListCustomLineItemsFilter?
}

extension ListCustomLineItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemsFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListCustomLineItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCustomLineItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCustomLineItemsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCustomLineItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCustomLineItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customLineItems = output.customLineItems
            self.nextToken = output.nextToken
        } else {
            self.customLineItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomLineItemsOutputResponse: Swift.Equatable {
    /// A list of FreeFormLineItemListElements received.
    public var customLineItems: [BillingconductorClientTypes.CustomLineItemListElement]?
    /// The pagination token that's used on subsequent calls to get custom line items (FFLIs).
    public var nextToken: Swift.String?

    public init (
        customLineItems: [BillingconductorClientTypes.CustomLineItemListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customLineItems = customLineItems
        self.nextToken = nextToken
    }
}

struct ListCustomLineItemsOutputResponseBody: Swift.Equatable {
    let customLineItems: [BillingconductorClientTypes.CustomLineItemListElement]?
    let nextToken: Swift.String?
}

extension ListCustomLineItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLineItems = "CustomLineItems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customLineItemsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.CustomLineItemListElement?].self, forKey: .customLineItems)
        var customLineItemsDecoded0:[BillingconductorClientTypes.CustomLineItemListElement]? = nil
        if let customLineItemsContainer = customLineItemsContainer {
            customLineItemsDecoded0 = [BillingconductorClientTypes.CustomLineItemListElement]()
            for structure0 in customLineItemsContainer {
                if let structure0 = structure0 {
                    customLineItemsDecoded0?.append(structure0)
                }
            }
        }
        customLineItems = customLineItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingPlansAssociatedWithPricingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pricingRuleArn = "PricingRuleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pricingRuleArn = self.pricingRuleArn {
            try encodeContainer.encode(pricingRuleArn, forKey: .pricingRuleArn)
        }
    }
}

extension ListPricingPlansAssociatedWithPricingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-pricing-plans-associated-with-pricing-rule"
    }
}

public struct ListPricingPlansAssociatedWithPricingRuleInput: Swift.Equatable {
    /// The pricing plan billing period for which associations will be listed.
    public var billingPeriod: Swift.String?
    /// The optional maximum number of pricing rule associations to retrieve.
    public var maxResults: Swift.Int?
    /// The optional pagination token returned by a previous call.
    public var nextToken: Swift.String?
    /// The pricing rule Amazon Resource Name (ARN) for which associations will be listed.
    /// This member is required.
    public var pricingRuleArn: Swift.String?

    public init (
        billingPeriod: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pricingRuleArn: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pricingRuleArn = pricingRuleArn
    }
}

struct ListPricingPlansAssociatedWithPricingRuleInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingRuleArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPricingPlansAssociatedWithPricingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pricingRuleArn = "PricingRuleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingRuleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingRuleArn)
        pricingRuleArn = pricingRuleArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingPlansAssociatedWithPricingRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPricingPlansAssociatedWithPricingRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPricingPlansAssociatedWithPricingRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPricingPlansAssociatedWithPricingRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPricingPlansAssociatedWithPricingRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.billingPeriod = output.billingPeriod
            self.nextToken = output.nextToken
            self.pricingPlanArns = output.pricingPlanArns
            self.pricingRuleArn = output.pricingRuleArn
        } else {
            self.billingPeriod = nil
            self.nextToken = nil
            self.pricingPlanArns = nil
            self.pricingRuleArn = nil
        }
    }
}

public struct ListPricingPlansAssociatedWithPricingRuleOutputResponse: Swift.Equatable {
    /// The pricing plan billing period for which associations will be listed.
    public var billingPeriod: Swift.String?
    /// The pagination token to be used on subsequent calls.
    public var nextToken: Swift.String?
    /// The list containing pricing plans that are associated with the requested pricing rule.
    public var pricingPlanArns: [Swift.String]?
    /// The pricing rule Amazon Resource Name (ARN) for which associations will be listed.
    public var pricingRuleArn: Swift.String?

    public init (
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingPlanArns: [Swift.String]? = nil,
        pricingRuleArn: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingPlanArns = pricingPlanArns
        self.pricingRuleArn = pricingRuleArn
    }
}

struct ListPricingPlansAssociatedWithPricingRuleOutputResponseBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingRuleArn: Swift.String?
    let pricingPlanArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPricingPlansAssociatedWithPricingRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case nextToken = "NextToken"
        case pricingPlanArns = "PricingPlanArns"
        case pricingRuleArn = "PricingRuleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingRuleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingRuleArn)
        pricingRuleArn = pricingRuleArnDecoded
        let pricingPlanArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingPlanArns)
        var pricingPlanArnsDecoded0:[Swift.String]? = nil
        if let pricingPlanArnsContainer = pricingPlanArnsContainer {
            pricingPlanArnsDecoded0 = [Swift.String]()
            for string0 in pricingPlanArnsContainer {
                if let string0 = string0 {
                    pricingPlanArnsDecoded0?.append(string0)
                }
            }
        }
        pricingPlanArns = pricingPlanArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BillingconductorClientTypes.ListPricingPlansFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for pricingplanarn0 in arns {
                try arnsContainer.encode(pricingplanarn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// The filter that specifies the Amazon Resource Names (ARNs) of pricing plans, to retrieve pricing plan information.
    public struct ListPricingPlansFilter: Swift.Equatable {
        /// A list of pricing plan Amazon Resource Names (ARNs) to retrieve information.
        public var arns: [Swift.String]?

        public init (
            arns: [Swift.String]? = nil
        )
        {
            self.arns = arns
        }
    }

}

extension ListPricingPlansInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPricingPlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-pricing-plans"
    }
}

public struct ListPricingPlansInput: Swift.Equatable {
    /// The preferred billing period to get pricing plan.
    public var billingPeriod: Swift.String?
    /// A ListPricingPlansFilter that specifies the Amazon Resource Name (ARNs) of pricing plans to retrieve pricing plans information.
    public var filters: BillingconductorClientTypes.ListPricingPlansFilter?
    /// The maximum number of pricing plans to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent call to get pricing plans.
    public var nextToken: Swift.String?

    public init (
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListPricingPlansFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPricingPlansInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let filters: BillingconductorClientTypes.ListPricingPlansFilter?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPricingPlansInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListPricingPlansFilter.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingPlansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPricingPlansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPricingPlansOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPricingPlansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPricingPlansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.billingPeriod = output.billingPeriod
            self.nextToken = output.nextToken
            self.pricingPlans = output.pricingPlans
        } else {
            self.billingPeriod = nil
            self.nextToken = nil
            self.pricingPlans = nil
        }
    }
}

public struct ListPricingPlansOutputResponse: Swift.Equatable {
    /// The billing period for which the described pricing plans are applicable.
    public var billingPeriod: Swift.String?
    /// The pagination token that's used on subsequent calls to get pricing plans.
    public var nextToken: Swift.String?
    /// A list of PricingPlanListElement retrieved.
    public var pricingPlans: [BillingconductorClientTypes.PricingPlanListElement]?

    public init (
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingPlans: [BillingconductorClientTypes.PricingPlanListElement]? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingPlans = pricingPlans
    }
}

struct ListPricingPlansOutputResponseBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingPlans: [BillingconductorClientTypes.PricingPlanListElement]?
    let nextToken: Swift.String?
}

extension ListPricingPlansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case nextToken = "NextToken"
        case pricingPlans = "PricingPlans"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingPlansContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.PricingPlanListElement?].self, forKey: .pricingPlans)
        var pricingPlansDecoded0:[BillingconductorClientTypes.PricingPlanListElement]? = nil
        if let pricingPlansContainer = pricingPlansContainer {
            pricingPlansDecoded0 = [BillingconductorClientTypes.PricingPlanListElement]()
            for structure0 in pricingPlansContainer {
                if let structure0 = structure0 {
                    pricingPlansDecoded0?.append(structure0)
                }
            }
        }
        pricingPlans = pricingPlansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingRulesAssociatedToPricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pricingPlanArn = "PricingPlanArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pricingPlanArn = self.pricingPlanArn {
            try encodeContainer.encode(pricingPlanArn, forKey: .pricingPlanArn)
        }
    }
}

extension ListPricingRulesAssociatedToPricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-pricing-rules-associated-to-pricing-plan"
    }
}

public struct ListPricingRulesAssociatedToPricingPlanInput: Swift.Equatable {
    /// The billing period for which the pricing rule associations are to be listed.
    public var billingPeriod: Swift.String?
    /// The optional maximum number of pricing rule associations to retrieve.
    public var maxResults: Swift.Int?
    /// The optional pagination token returned by a previous call.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the pricing plan for which associations are to be listed.
    /// This member is required.
    public var pricingPlanArn: Swift.String?

    public init (
        billingPeriod: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pricingPlanArn: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pricingPlanArn = pricingPlanArn
    }
}

struct ListPricingRulesAssociatedToPricingPlanInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingPlanArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPricingRulesAssociatedToPricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pricingPlanArn = "PricingPlanArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanArn)
        pricingPlanArn = pricingPlanArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingRulesAssociatedToPricingPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPricingRulesAssociatedToPricingPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPricingRulesAssociatedToPricingPlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPricingRulesAssociatedToPricingPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPricingRulesAssociatedToPricingPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.billingPeriod = output.billingPeriod
            self.nextToken = output.nextToken
            self.pricingPlanArn = output.pricingPlanArn
            self.pricingRuleArns = output.pricingRuleArns
        } else {
            self.billingPeriod = nil
            self.nextToken = nil
            self.pricingPlanArn = nil
            self.pricingRuleArns = nil
        }
    }
}

public struct ListPricingRulesAssociatedToPricingPlanOutputResponse: Swift.Equatable {
    /// The billing period for which the pricing rule associations are listed.
    public var billingPeriod: Swift.String?
    /// The pagination token to be used on subsequent calls.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the pricing plan for which associations are listed.
    public var pricingPlanArn: Swift.String?
    /// A list containing pricing rules that are associated with the requested pricing plan.
    public var pricingRuleArns: [Swift.String]?

    public init (
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingPlanArn: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingPlanArn = pricingPlanArn
        self.pricingRuleArns = pricingRuleArns
    }
}

struct ListPricingRulesAssociatedToPricingPlanOutputResponseBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingPlanArn: Swift.String?
    let pricingRuleArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPricingRulesAssociatedToPricingPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case nextToken = "NextToken"
        case pricingPlanArn = "PricingPlanArn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanArn)
        pricingPlanArn = pricingPlanArnDecoded
        let pricingRuleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingRuleArns)
        var pricingRuleArnsDecoded0:[Swift.String]? = nil
        if let pricingRuleArnsContainer = pricingRuleArnsContainer {
            pricingRuleArnsDecoded0 = [Swift.String]()
            for string0 in pricingRuleArnsContainer {
                if let string0 = string0 {
                    pricingRuleArnsDecoded0?.append(string0)
                }
            }
        }
        pricingRuleArns = pricingRuleArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BillingconductorClientTypes.ListPricingRulesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for pricingrulearn0 in arns {
                try arnsContainer.encode(pricingrulearn0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// The filter that specifies criteria that the pricing rules returned by the ListPricingRules API will adhere to.
    public struct ListPricingRulesFilter: Swift.Equatable {
        /// A list containing the pricing rule Amazon Resource Names (ARNs) to include in the API response.
        public var arns: [Swift.String]?

        public init (
            arns: [Swift.String]? = nil
        )
        {
            self.arns = arns
        }
    }

}

extension ListPricingRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPricingRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-pricing-rules"
    }
}

public struct ListPricingRulesInput: Swift.Equatable {
    /// The preferred billing period to get the pricing plan.
    public var billingPeriod: Swift.String?
    /// A DescribePricingRuleFilter that specifies the Amazon Resource Name (ARNs) of pricing rules to retrieve pricing rules information.
    public var filters: BillingconductorClientTypes.ListPricingRulesFilter?
    /// The maximum number of pricing rules to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent call to get pricing rules.
    public var nextToken: Swift.String?

    public init (
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListPricingRulesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPricingRulesInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let filters: BillingconductorClientTypes.ListPricingRulesFilter?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPricingRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListPricingRulesFilter.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPricingRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPricingRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPricingRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPricingRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.billingPeriod = output.billingPeriod
            self.nextToken = output.nextToken
            self.pricingRules = output.pricingRules
        } else {
            self.billingPeriod = nil
            self.nextToken = nil
            self.pricingRules = nil
        }
    }
}

public struct ListPricingRulesOutputResponse: Swift.Equatable {
    /// The billing period for which the described pricing rules are applicable.
    public var billingPeriod: Swift.String?
    /// The pagination token that's used on subsequent calls to get pricing rules.
    public var nextToken: Swift.String?
    /// A list containing the described pricing rules.
    public var pricingRules: [BillingconductorClientTypes.PricingRuleListElement]?

    public init (
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingRules: [BillingconductorClientTypes.PricingRuleListElement]? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingRules = pricingRules
    }
}

struct ListPricingRulesOutputResponseBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingRules: [BillingconductorClientTypes.PricingRuleListElement]?
    let nextToken: Swift.String?
}

extension ListPricingRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case nextToken = "NextToken"
        case pricingRules = "PricingRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingRulesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.PricingRuleListElement?].self, forKey: .pricingRules)
        var pricingRulesDecoded0:[BillingconductorClientTypes.PricingRuleListElement]? = nil
        if let pricingRulesContainer = pricingRulesContainer {
            pricingRulesDecoded0 = [BillingconductorClientTypes.PricingRuleListElement]()
            for structure0 in pricingRulesContainer {
                if let structure0 = structure0 {
                    pricingRulesDecoded0?.append(structure0)
                }
            }
        }
        pricingRules = pricingRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relationship = "Relationship"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relationship = self.relationship {
            try encodeContainer.encode(relationship.rawValue, forKey: .relationship)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relationshipDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemRelationship.self, forKey: .relationship)
        relationship = relationshipDecoded
    }
}

extension BillingconductorClientTypes {
    /// A filter that specifies the type of resource associations that should be retrieved for a custom line item.
    public struct ListResourcesAssociatedToCustomLineItemFilter: Swift.Equatable {
        /// The type of relationship between the custom line item and the associated resource.
        public var relationship: BillingconductorClientTypes.CustomLineItemRelationship?

        public init (
            relationship: BillingconductorClientTypes.CustomLineItemRelationship? = nil
        )
        {
            self.relationship = relationship
        }
    }

}

extension ListResourcesAssociatedToCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResourcesAssociatedToCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-resources-associated-to-custom-line-item"
    }
}

public struct ListResourcesAssociatedToCustomLineItemInput: Swift.Equatable {
    /// The ARN of the custom line item for which the resource associations will be listed.
    /// This member is required.
    public var arn: Swift.String?
    /// The billing period for which the resource associations will be listed.
    public var billingPeriod: Swift.String?
    /// (Optional) A ListResourcesAssociatedToCustomLineItemFilter that can specify the types of resources that should be retrieved.
    public var filters: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter?
    /// (Optional) The maximum number of resource associations to be retrieved.
    public var maxResults: Swift.Int?
    /// (Optional) The pagination token that's returned by a previous request.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourcesAssociatedToCustomLineItemInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let arn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter?
}

extension ListResourcesAssociatedToCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListResourcesAssociatedToCustomLineItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesAssociatedToCustomLineItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourcesAssociatedToCustomLineItemOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesAssociatedToCustomLineItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourcesAssociatedToCustomLineItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatedResources = output.associatedResources
            self.nextToken = output.nextToken
        } else {
            self.arn = nil
            self.associatedResources = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourcesAssociatedToCustomLineItemOutputResponse: Swift.Equatable {
    /// The custom line item ARN for which the resource associations are listed.
    public var arn: Swift.String?
    /// A list of ListResourcesAssociatedToCustomLineItemResponseElement for each resource association retrieved.
    public var associatedResources: [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]?
    /// The pagination token to be used in subsequent requests to retrieve additional results.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        associatedResources: [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.associatedResources = associatedResources
        self.nextToken = nextToken
    }
}

struct ListResourcesAssociatedToCustomLineItemOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let associatedResources: [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]?
    let nextToken: Swift.String?
}

extension ListResourcesAssociatedToCustomLineItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associatedResources = "AssociatedResources"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let associatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement?].self, forKey: .associatedResources)
        var associatedResourcesDecoded0:[BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]? = nil
        if let associatedResourcesContainer = associatedResourcesContainer {
            associatedResourcesDecoded0 = [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]()
            for structure0 in associatedResourcesContainer {
                if let structure0 = structure0 {
                    associatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        associatedResources = associatedResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case endBillingPeriod = "EndBillingPeriod"
        case relationship = "Relationship"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let endBillingPeriod = self.endBillingPeriod {
            try encodeContainer.encode(endBillingPeriod, forKey: .endBillingPeriod)
        }
        if let relationship = self.relationship {
            try encodeContainer.encode(relationship.rawValue, forKey: .relationship)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let relationshipDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemRelationship.self, forKey: .relationship)
        relationship = relationshipDecoded
        let endBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endBillingPeriod)
        endBillingPeriod = endBillingPeriodDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of a resource association for a custom line item.
    public struct ListResourcesAssociatedToCustomLineItemResponseElement: Swift.Equatable {
        /// The ARN of the associated resource.
        public var arn: Swift.String?
        /// The end billing period of the associated resource.
        public var endBillingPeriod: Swift.String?
        /// The type of relationship between the custom line item and the associated resource.
        public var relationship: BillingconductorClientTypes.CustomLineItemRelationship?

        public init (
            arn: Swift.String? = nil,
            endBillingPeriod: Swift.String? = nil,
            relationship: BillingconductorClientTypes.CustomLineItemRelationship? = nil
        )
        {
            self.arn = arn
            self.endBillingPeriod = endBillingPeriod
            self.relationship = relationship
        }
    }

}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BillingconductorClientTypes.PricingPlanListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension BillingconductorClientTypes.PricingPlanListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PricingPlanListElement(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), size: \(Swift.String(describing: size)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a pricing plan.
    public struct PricingPlanListElement: Swift.Equatable {
        /// The pricing plan Amazon Resource Names (ARN). This can be used to uniquely identify a pricing plan.
        public var arn: Swift.String?
        /// The time when the pricing plan was created.
        public var creationTime: Swift.Int
        /// The pricing plan description.
        public var description: Swift.String?
        /// The most recent time when the pricing plan was modified.
        public var lastModifiedTime: Swift.Int
        /// The name of a pricing plan.
        public var name: Swift.String?
        /// The pricing rules count that's currently associated with this pricing plan list element.
        public var size: Swift.Int

        public init (
            arn: Swift.String? = nil,
            creationTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.size = size
        }
    }

}

extension BillingconductorClientTypes.PricingRuleListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associatedPricingPlanCount = "AssociatedPricingPlanCount"
        case billingEntity = "BillingEntity"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case scope = "Scope"
        case service = "Service"
        case tiering = "Tiering"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if associatedPricingPlanCount != 0 {
            try encodeContainer.encode(associatedPricingPlanCount, forKey: .associatedPricingPlanCount)
        }
        if let billingEntity = self.billingEntity {
            try encodeContainer.encode(billingEntity, forKey: .billingEntity)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let modifierPercentage = self.modifierPercentage {
            try encodeContainer.encode(modifierPercentage, forKey: .modifierPercentage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let tiering = self.tiering {
            try encodeContainer.encode(tiering, forKey: .tiering)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleScope.self, forKey: .scope)
        scope = scopeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleType.self, forKey: .type)
        type = typeDecoded
        let modifierPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .modifierPercentage)
        modifierPercentage = modifierPercentageDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let associatedPricingPlanCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associatedPricingPlanCount) ?? 0
        associatedPricingPlanCount = associatedPricingPlanCountDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let billingEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingEntity)
        billingEntity = billingEntityDecoded
        let tieringDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.Tiering.self, forKey: .tiering)
        tiering = tieringDecoded
    }
}

extension BillingconductorClientTypes.PricingRuleListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PricingRuleListElement(arn: \(Swift.String(describing: arn)), associatedPricingPlanCount: \(Swift.String(describing: associatedPricingPlanCount)), billingEntity: \(Swift.String(describing: billingEntity)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), scope: \(Swift.String(describing: scope)), service: \(Swift.String(describing: service)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a pricing rule.
    public struct PricingRuleListElement: Swift.Equatable {
        /// The Amazon Resource Name (ARN) used to uniquely identify a pricing rule.
        public var arn: Swift.String?
        /// The pricing plans count that this pricing rule is associated with.
        public var associatedPricingPlanCount: Swift.Int
        /// The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
        public var billingEntity: Swift.String?
        /// The time when the pricing rule was created.
        public var creationTime: Swift.Int
        /// The pricing rule description.
        public var description: Swift.String?
        /// The most recent time when the pricing rule was modified.
        public var lastModifiedTime: Swift.Int
        /// A percentage modifier applied on the public pricing rates.
        public var modifierPercentage: Swift.Double?
        /// The name of a pricing rule.
        public var name: Swift.String?
        /// The scope of pricing rule that indicates if it is globally applicable, or if it is service-specific.
        public var scope: BillingconductorClientTypes.PricingRuleScope?
        /// If the Scope attribute is SERVICE, this attribute indicates which service the PricingRule is applicable for.
        public var service: Swift.String?
        /// The set of tiering configurations for the pricing rule.
        public var tiering: BillingconductorClientTypes.Tiering?
        /// The type of pricing rule.
        public var type: BillingconductorClientTypes.PricingRuleType?

        public init (
            arn: Swift.String? = nil,
            associatedPricingPlanCount: Swift.Int = 0,
            billingEntity: Swift.String? = nil,
            creationTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            modifierPercentage: Swift.Double? = nil,
            name: Swift.String? = nil,
            scope: BillingconductorClientTypes.PricingRuleScope? = nil,
            service: Swift.String? = nil,
            tiering: BillingconductorClientTypes.Tiering? = nil,
            type: BillingconductorClientTypes.PricingRuleType? = nil
        )
        {
            self.arn = arn
            self.associatedPricingPlanCount = associatedPricingPlanCount
            self.billingEntity = billingEntity
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.modifierPercentage = modifierPercentage
            self.name = name
            self.scope = scope
            self.service = service
            self.tiering = tiering
            self.type = type
        }
    }

}

extension BillingconductorClientTypes {
    public enum PricingRuleScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case billingEntity
        case global
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingRuleScope] {
            return [
                .billingEntity,
                .global,
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .billingEntity: return "BILLING_ENTITY"
            case .global: return "GLOBAL"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingRuleScope(rawValue: rawValue) ?? PricingRuleScope.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes {
    public enum PricingRuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case discount
        case markup
        case tiering
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingRuleType] {
            return [
                .discount,
                .markup,
                .tiering,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .discount: return "DISCOUNT"
            case .markup: return "MARKUP"
            case .tiering: return "TIERING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingRuleType(rawValue: rawValue) ?? PricingRuleType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request references a resource that doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Resource identifier that was not found.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Resource type that was not found.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limitCode = output.limitCode
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.limitCode = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service limit to exceed.
public struct ServiceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The unique code identifier of the service limit that is being exceeded.
    /// This member is required.
    public var limitCode: Swift.String?
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource affected.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    public var resourceType: Swift.String?
    /// The unique code for the service of the limit that is being exceeded.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        limitCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.limitCode = limitCode
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let limitCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitCode = "LimitCode"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitCode)
        limitCode = limitCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource as a list of key-value pairs.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Number of seconds you can safely retry after the call.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BillingconductorClientTypes.Tiering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTier = "FreeTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let freeTier = self.freeTier {
            try encodeContainer.encode(freeTier, forKey: .freeTier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeTierDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.FreeTierConfig.self, forKey: .freeTier)
        freeTier = freeTierDecoded
    }
}

extension BillingconductorClientTypes {
    /// The set of tiering configurations for the pricing rule.
    public struct Tiering: Swift.Equatable {
        /// The possible Amazon Web Services Free Tier configurations.
        /// This member is required.
        public var freeTier: BillingconductorClientTypes.FreeTierConfig?

        public init (
            freeTier: BillingconductorClientTypes.FreeTierConfig? = nil
        )
        {
            self.freeTier = freeTier
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which to delete tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to delete from the resource as a list of key-value pairs.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateBillingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBillingGroupInput(arn: \(Swift.String(describing: arn)), computationPreference: \(Swift.String(describing: computationPreference)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case computationPreference = "ComputationPreference"
        case description = "Description"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computationPreference = self.computationPreference {
            try encodeContainer.encode(computationPreference, forKey: .computationPreference)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-billing-group"
    }
}

public struct UpdateBillingGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the billing group being updated.
    /// This member is required.
    public var arn: Swift.String?
    /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
    public var computationPreference: BillingconductorClientTypes.ComputationPreference?
    /// A description of the billing group.
    public var description: Swift.String?
    /// The name of the billing group. The names must be unique to each billing group.
    public var name: Swift.String?
    /// The status of the billing group. Only one of the valid values can be used.
    public var status: BillingconductorClientTypes.BillingGroupStatus?

    public init (
        arn: Swift.String? = nil,
        computationPreference: BillingconductorClientTypes.ComputationPreference? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BillingconductorClientTypes.BillingGroupStatus? = nil
    )
    {
        self.arn = arn
        self.computationPreference = computationPreference
        self.description = description
        self.name = name
        self.status = status
    }
}

struct UpdateBillingGroupInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let status: BillingconductorClientTypes.BillingGroupStatus?
    let computationPreference: BillingconductorClientTypes.ComputationPreference?
    let description: Swift.String?
}

extension UpdateBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case computationPreference = "ComputationPreference"
        case description = "Description"
        case name = "Name"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.BillingGroupStatus.self, forKey: .status)
        status = statusDecoded
        let computationPreferenceDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ComputationPreference.self, forKey: .computationPreference)
        computationPreference = computationPreferenceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateBillingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBillingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBillingGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBillingGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBillingGroupOutputResponse(arn: \(Swift.String(describing: arn)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), pricingPlanArn: \(Swift.String(describing: pricingPlanArn)), primaryAccountId: \(Swift.String(describing: primaryAccountId)), size: \(Swift.String(describing: size)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateBillingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBillingGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.pricingPlanArn = output.pricingPlanArn
            self.primaryAccountId = output.primaryAccountId
            self.size = output.size
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.arn = nil
            self.description = nil
            self.lastModifiedTime = 0
            self.name = nil
            self.pricingPlanArn = nil
            self.primaryAccountId = nil
            self.size = 0
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct UpdateBillingGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the billing group that was updated.
    public var arn: Swift.String?
    /// A description of the billing group.
    public var description: Swift.String?
    /// The most recent time when the billing group was modified.
    public var lastModifiedTime: Swift.Int
    /// The name of the billing group. The names must be unique to each billing group.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the pricing plan to compute Amazon Web Services charges for the billing group.
    public var pricingPlanArn: Swift.String?
    /// The account ID that serves as the main account in a billing group.
    public var primaryAccountId: Swift.String?
    /// The number of accounts in the particular billing group.
    public var size: Swift.Int
    /// The status of the billing group. Only one of the valid values can be used.
    public var status: BillingconductorClientTypes.BillingGroupStatus?
    /// The reason why the billing group is in its current status.
    public var statusReason: Swift.String?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        name: Swift.String? = nil,
        pricingPlanArn: Swift.String? = nil,
        primaryAccountId: Swift.String? = nil,
        size: Swift.Int = 0,
        status: BillingconductorClientTypes.BillingGroupStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.pricingPlanArn = pricingPlanArn
        self.primaryAccountId = primaryAccountId
        self.size = size
        self.status = status
        self.statusReason = statusReason
    }
}

struct UpdateBillingGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let primaryAccountId: Swift.String?
    let pricingPlanArn: Swift.String?
    let size: Swift.Int
    let lastModifiedTime: Swift.Int
    let status: BillingconductorClientTypes.BillingGroupStatus?
    let statusReason: Swift.String?
}

extension UpdateBillingGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case pricingPlanArn = "PricingPlanArn"
        case primaryAccountId = "PrimaryAccountId"
        case size = "Size"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let primaryAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountId)
        primaryAccountId = primaryAccountIdDecoded
        let pricingPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanArn)
        pricingPlanArn = pricingPlanArnDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.BillingGroupStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension BillingconductorClientTypes.UpdateCustomLineItemChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flat = "Flat"
        case percentage = "Percentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flat = self.flat {
            try encodeContainer.encode(flat, forKey: .flat)
        }
        if let percentage = self.percentage {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flatDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails.self, forKey: .flat)
        flat = flatDecoded
        let percentageDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails.self, forKey: .percentage)
        percentage = percentageDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the new charge details of a custom line item. This should contain only one of Flat or Percentage.
    public struct UpdateCustomLineItemChargeDetails: Swift.Equatable {
        /// An UpdateCustomLineItemFlatChargeDetails that describes the new charge details of a flat custom line item.
        public var flat: BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails?
        /// An UpdateCustomLineItemPercentageChargeDetails that describes the new charge details of a percentage custom line item.
        public var percentage: BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails?

        public init (
            flat: BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails? = nil,
            percentage: BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails? = nil
        )
        {
            self.flat = flat
            self.percentage = percentage
        }
    }

}

extension BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chargeValue = "ChargeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chargeValue = self.chargeValue {
            try encodeContainer.encode(chargeValue, forKey: .chargeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chargeValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .chargeValue)
        chargeValue = chargeValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the new charge details that are associated with a flat custom line item.
    public struct UpdateCustomLineItemFlatChargeDetails: Swift.Equatable {
        /// The custom line item's new fixed charge value in USD.
        /// This member is required.
        public var chargeValue: Swift.Double?

        public init (
            chargeValue: Swift.Double? = nil
        )
        {
            self.chargeValue = chargeValue
        }
    }

}

extension UpdateCustomLineItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomLineItemInput(arn: \(Swift.String(describing: arn)), billingPeriodRange: \(Swift.String(describing: billingPeriodRange)), chargeDetails: \(Swift.String(describing: chargeDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriodRange = "BillingPeriodRange"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
        if let chargeDetails = self.chargeDetails {
            try encodeContainer.encode(chargeDetails, forKey: .chargeDetails)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-custom-line-item"
    }
}

public struct UpdateCustomLineItemInput: Swift.Equatable {
    /// The ARN of the custom line item to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A ListCustomLineItemChargeDetails containing the new charge details for the custom line item.
    public var chargeDetails: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails?
    /// The new line item description of the custom line item.
    public var description: Swift.String?
    /// The new name for the custom line item.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        chargeDetails: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.billingPeriodRange = billingPeriodRange
        self.chargeDetails = chargeDetails
        self.description = description
        self.name = name
    }
}

struct UpdateCustomLineItemInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let chargeDetails: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
}

extension UpdateCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriodRange = "BillingPeriodRange"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateCustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension UpdateCustomLineItemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCustomLineItemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCustomLineItemOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCustomLineItemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomLineItemOutputResponse(arn: \(Swift.String(describing: arn)), associationSize: \(Swift.String(describing: associationSize)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), chargeDetails: \(Swift.String(describing: chargeDetails)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateCustomLineItemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCustomLineItemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associationSize = output.associationSize
            self.billingGroupArn = output.billingGroupArn
            self.chargeDetails = output.chargeDetails
            self.description = output.description
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
        } else {
            self.arn = nil
            self.associationSize = 0
            self.billingGroupArn = nil
            self.chargeDetails = nil
            self.description = nil
            self.lastModifiedTime = 0
            self.name = nil
        }
    }
}

public struct UpdateCustomLineItemOutputResponse: Swift.Equatable {
    /// The ARN of the successfully updated custom line item.
    public var arn: Swift.String?
    /// The number of resources that are associated to the custom line item.
    public var associationSize: Swift.Int
    /// The ARN of the billing group that the custom line item is applied to.
    public var billingGroupArn: Swift.String?
    /// A ListCustomLineItemChargeDetails containing the charge details of the successfully updated custom line item.
    public var chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
    /// The description of the successfully updated custom line item.
    public var description: Swift.String?
    /// The most recent time when the custom line item was modified.
    public var lastModifiedTime: Swift.Int
    /// The name of the successfully updated custom line item.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        associationSize: Swift.Int = 0,
        billingGroupArn: Swift.String? = nil,
        chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.associationSize = associationSize
        self.billingGroupArn = billingGroupArn
        self.chargeDetails = chargeDetails
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.name = name
    }
}

struct UpdateCustomLineItemOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let billingGroupArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
    let lastModifiedTime: Swift.Int
    let associationSize: Swift.Int
}

extension UpdateCustomLineItemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associationSize = "AssociationSize"
        case billingGroupArn = "BillingGroupArn"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let associationSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associationSize) ?? 0
        associationSize = associationSizeDecoded
    }
}

extension BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentageValue = "PercentageValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentageValue = self.percentageValue {
            try encodeContainer.encode(percentageValue, forKey: .percentageValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentageValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentageValue)
        percentageValue = percentageValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the new charge details that are associated with a percentage custom line item.
    public struct UpdateCustomLineItemPercentageChargeDetails: Swift.Equatable {
        /// The custom line item's new percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        /// This member is required.
        public var percentageValue: Swift.Double?

        public init (
            percentageValue: Swift.Double? = nil
        )
        {
            self.percentageValue = percentageValue
        }
    }

}

extension BillingconductorClientTypes.UpdateFreeTierConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activated = "Activated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activated = self.activated {
            try encodeContainer.encode(activated, forKey: .activated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activated)
        activated = activatedDecoded
    }
}

extension BillingconductorClientTypes {
    /// The possible Amazon Web Services Free Tier configurations.
    public struct UpdateFreeTierConfig: Swift.Equatable {
        /// Activate or deactivate application of Amazon Web Services Free Tier.
        /// This member is required.
        public var activated: Swift.Bool?

        public init (
            activated: Swift.Bool? = nil
        )
        {
            self.activated = activated
        }
    }

}

extension UpdatePricingPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingPlanInput(arn: \(Swift.String(describing: arn)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdatePricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-pricing-plan"
    }
}

public struct UpdatePricingPlanInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing plan that you're updating.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the pricing plan.
    public var description: Swift.String?
    /// The name of the pricing plan. The name must be unique to each pricing plan.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.name = name
    }
}

struct UpdatePricingPlanInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdatePricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdatePricingPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePricingPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePricingPlanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePricingPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingPlanOutputResponse(arn: \(Swift.String(describing: arn)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), size: \(Swift.String(describing: size)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePricingPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePricingPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.size = output.size
        } else {
            self.arn = nil
            self.description = nil
            self.lastModifiedTime = 0
            self.name = nil
            self.size = 0
        }
    }
}

public struct UpdatePricingPlanOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated pricing plan.
    public var arn: Swift.String?
    /// The new description for the pricing rule.
    public var description: Swift.String?
    /// The most recent time when the pricing plan was modified.
    public var lastModifiedTime: Swift.Int
    /// The name of the pricing plan. The name must be unique to each pricing plan.
    public var name: Swift.String?
    /// The pricing rules count that's currently associated with this pricing plan list.
    public var size: Swift.Int

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        name: Swift.String? = nil,
        size: Swift.Int = 0
    )
    {
        self.arn = arn
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.size = size
    }
}

struct UpdatePricingPlanOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let size: Swift.Int
    let lastModifiedTime: Swift.Int
}

extension UpdatePricingPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case size = "Size"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension UpdatePricingRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingRuleInput(arn: \(Swift.String(describing: arn)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePricingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case tiering = "Tiering"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modifierPercentage = self.modifierPercentage {
            try encodeContainer.encode(modifierPercentage, forKey: .modifierPercentage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tiering = self.tiering {
            try encodeContainer.encode(tiering, forKey: .tiering)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdatePricingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-pricing-rule"
    }
}

public struct UpdatePricingRuleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing rule to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The new description for the pricing rule.
    public var description: Swift.String?
    /// The new modifier to show pricing plan rates as a percentage.
    public var modifierPercentage: Swift.Double?
    /// The new name of the pricing rule. The name must be unique to each pricing rule.
    public var name: Swift.String?
    /// The set of tiering configurations for the pricing rule.
    public var tiering: BillingconductorClientTypes.UpdateTieringInput?
    /// The new pricing rule type.
    public var type: BillingconductorClientTypes.PricingRuleType?

    public init (
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        modifierPercentage: Swift.Double? = nil,
        name: Swift.String? = nil,
        tiering: BillingconductorClientTypes.UpdateTieringInput? = nil,
        type: BillingconductorClientTypes.PricingRuleType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.modifierPercentage = modifierPercentage
        self.name = name
        self.tiering = tiering
        self.type = type
    }
}

struct UpdatePricingRuleInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let type: BillingconductorClientTypes.PricingRuleType?
    let modifierPercentage: Swift.Double?
    let tiering: BillingconductorClientTypes.UpdateTieringInput?
}

extension UpdatePricingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case tiering = "Tiering"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleType.self, forKey: .type)
        type = typeDecoded
        let modifierPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .modifierPercentage)
        modifierPercentage = modifierPercentageDecoded
        let tieringDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateTieringInput.self, forKey: .tiering)
        tiering = tieringDecoded
    }
}

extension UpdatePricingRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePricingRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePricingRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePricingRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingRuleOutputResponse(arn: \(Swift.String(describing: arn)), associatedPricingPlanCount: \(Swift.String(describing: associatedPricingPlanCount)), billingEntity: \(Swift.String(describing: billingEntity)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), scope: \(Swift.String(describing: scope)), service: \(Swift.String(describing: service)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePricingRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePricingRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatedPricingPlanCount = output.associatedPricingPlanCount
            self.billingEntity = output.billingEntity
            self.description = output.description
            self.lastModifiedTime = output.lastModifiedTime
            self.modifierPercentage = output.modifierPercentage
            self.name = output.name
            self.scope = output.scope
            self.service = output.service
            self.tiering = output.tiering
            self.type = output.type
        } else {
            self.arn = nil
            self.associatedPricingPlanCount = 0
            self.billingEntity = nil
            self.description = nil
            self.lastModifiedTime = 0
            self.modifierPercentage = nil
            self.name = nil
            self.scope = nil
            self.service = nil
            self.tiering = nil
            self.type = nil
        }
    }
}

public struct UpdatePricingRuleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the successfully updated pricing rule.
    public var arn: Swift.String?
    /// The pricing plans count that this pricing rule is associated with.
    public var associatedPricingPlanCount: Swift.Int
    /// The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
    public var billingEntity: Swift.String?
    /// The new description for the pricing rule.
    public var description: Swift.String?
    /// The most recent time the pricing rule was modified.
    public var lastModifiedTime: Swift.Int
    /// The new modifier to show pricing plan rates as a percentage.
    public var modifierPercentage: Swift.Double?
    /// The new name of the pricing rule. The name must be unique to each pricing rule.
    public var name: Swift.String?
    /// The scope of pricing rule that indicates if it's globally applicable, or it's service-specific.
    public var scope: BillingconductorClientTypes.PricingRuleScope?
    /// If the Scope attribute is set to SERVICE, the attribute indicates which service the PricingRule is applicable for.
    public var service: Swift.String?
    /// The set of tiering configurations for the pricing rule.
    public var tiering: BillingconductorClientTypes.UpdateTieringInput?
    /// The new pricing rule type.
    public var type: BillingconductorClientTypes.PricingRuleType?

    public init (
        arn: Swift.String? = nil,
        associatedPricingPlanCount: Swift.Int = 0,
        billingEntity: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        modifierPercentage: Swift.Double? = nil,
        name: Swift.String? = nil,
        scope: BillingconductorClientTypes.PricingRuleScope? = nil,
        service: Swift.String? = nil,
        tiering: BillingconductorClientTypes.UpdateTieringInput? = nil,
        type: BillingconductorClientTypes.PricingRuleType? = nil
    )
    {
        self.arn = arn
        self.associatedPricingPlanCount = associatedPricingPlanCount
        self.billingEntity = billingEntity
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.modifierPercentage = modifierPercentage
        self.name = name
        self.scope = scope
        self.service = service
        self.tiering = tiering
        self.type = type
    }
}

struct UpdatePricingRuleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let scope: BillingconductorClientTypes.PricingRuleScope?
    let type: BillingconductorClientTypes.PricingRuleType?
    let modifierPercentage: Swift.Double?
    let service: Swift.String?
    let associatedPricingPlanCount: Swift.Int
    let lastModifiedTime: Swift.Int
    let billingEntity: Swift.String?
    let tiering: BillingconductorClientTypes.UpdateTieringInput?
}

extension UpdatePricingRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associatedPricingPlanCount = "AssociatedPricingPlanCount"
        case billingEntity = "BillingEntity"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case scope = "Scope"
        case service = "Service"
        case tiering = "Tiering"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleScope.self, forKey: .scope)
        scope = scopeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleType.self, forKey: .type)
        type = typeDecoded
        let modifierPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .modifierPercentage)
        modifierPercentage = modifierPercentageDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let associatedPricingPlanCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associatedPricingPlanCount) ?? 0
        associatedPricingPlanCount = associatedPricingPlanCountDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let billingEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingEntity)
        billingEntity = billingEntityDecoded
        let tieringDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateTieringInput.self, forKey: .tiering)
        tiering = tieringDecoded
    }
}

extension BillingconductorClientTypes.UpdateTieringInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTier = "FreeTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let freeTier = self.freeTier {
            try encodeContainer.encode(freeTier, forKey: .freeTier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeTierDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateFreeTierConfig.self, forKey: .freeTier)
        freeTier = freeTierDecoded
    }
}

extension BillingconductorClientTypes {
    /// The set of tiering configurations for the pricing rule.
    public struct UpdateTieringInput: Swift.Equatable {
        /// The possible Amazon Web Services Free Tier configurations.
        /// This member is required.
        public var freeTier: BillingconductorClientTypes.UpdateFreeTierConfig?

        public init (
            freeTier: BillingconductorClientTypes.UpdateFreeTierConfig? = nil
        )
        {
            self.freeTier = freeTier
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input doesn't match with the constraints specified by Amazon Web Services services.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that caused the error, if applicable.
    public var fields: [BillingconductorClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason the request's validation failed.
    public var reason: BillingconductorClientTypes.ValidationExceptionReason?

    public init (
        fields: [BillingconductorClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BillingconductorClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: BillingconductorClientTypes.ValidationExceptionReason?
    let fields: [BillingconductorClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[BillingconductorClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [BillingconductorClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension BillingconductorClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BillingconductorClientTypes {
    /// The field's information of a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The field name.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension BillingconductorClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountsAlreadyAssociated
        case accountsNotAssociated
        case cannotParse
        case customLineItemAssociationExists
        case duplicateAccount
        case duplicatePricingruleArns
        case fieldValidationFailed
        case illegalAccounts
        case illegalBillingEntity
        case illegalBillingPeriod
        case illegalBillingPeriodRange
        case illegalChargeDetails
        case illegalChildAssociateResource
        case illegalCustomlineitem
        case illegalCustomlineitemModification
        case illegalCustomlineitemUpdate
        case illegalEndedBillinggroup
        case illegalExpression
        case illegalModifierPercentage
        case illegalPrimaryAccount
        case illegalResourceArns
        case illegalScope
        case illegalService
        case illegalTieringInput
        case illegalType
        case illegalUpdateChargeDetails
        case invalidArn
        case invalidBillingviewArn
        case invalidBillingGroup
        case invalidBillingGroupStatus
        case invalidBillingPeriodForOperation
        case invalidTimeRange
        case mismatchedBillinggroupArn
        case mismatchedBillingviewArn
        case mismatchedCustomlineitemArn
        case mismatchedPricingplanArn
        case mismatchedPricingruleArn
        case missingBillinggroup
        case missingCustomlineitem
        case missingLinkedAccountIds
        case missingPricingplan
        case missingPricingPlanArn
        case multipleLinkedAccountIds
        case multiplePricingPlanArn
        case other
        case pricingrulesAlreadyAssociated
        case pricingrulesNotAssociated
        case pricingrulesNotExist
        case primaryCannotDisassociate
        case primaryNotAssociated
        case tooManyAccountsInRequest
        case tooManyCustomlineitemsInRequest
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .accountsAlreadyAssociated,
                .accountsNotAssociated,
                .cannotParse,
                .customLineItemAssociationExists,
                .duplicateAccount,
                .duplicatePricingruleArns,
                .fieldValidationFailed,
                .illegalAccounts,
                .illegalBillingEntity,
                .illegalBillingPeriod,
                .illegalBillingPeriodRange,
                .illegalChargeDetails,
                .illegalChildAssociateResource,
                .illegalCustomlineitem,
                .illegalCustomlineitemModification,
                .illegalCustomlineitemUpdate,
                .illegalEndedBillinggroup,
                .illegalExpression,
                .illegalModifierPercentage,
                .illegalPrimaryAccount,
                .illegalResourceArns,
                .illegalScope,
                .illegalService,
                .illegalTieringInput,
                .illegalType,
                .illegalUpdateChargeDetails,
                .invalidArn,
                .invalidBillingviewArn,
                .invalidBillingGroup,
                .invalidBillingGroupStatus,
                .invalidBillingPeriodForOperation,
                .invalidTimeRange,
                .mismatchedBillinggroupArn,
                .mismatchedBillingviewArn,
                .mismatchedCustomlineitemArn,
                .mismatchedPricingplanArn,
                .mismatchedPricingruleArn,
                .missingBillinggroup,
                .missingCustomlineitem,
                .missingLinkedAccountIds,
                .missingPricingplan,
                .missingPricingPlanArn,
                .multipleLinkedAccountIds,
                .multiplePricingPlanArn,
                .other,
                .pricingrulesAlreadyAssociated,
                .pricingrulesNotAssociated,
                .pricingrulesNotExist,
                .primaryCannotDisassociate,
                .primaryNotAssociated,
                .tooManyAccountsInRequest,
                .tooManyCustomlineitemsInRequest,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountsAlreadyAssociated: return "ACCOUNTS_ALREADY_ASSOCIATED"
            case .accountsNotAssociated: return "ACCOUNTS_NOT_ASSOCIATED"
            case .cannotParse: return "CANNOT_PARSE"
            case .customLineItemAssociationExists: return "CUSTOM_LINE_ITEM_ASSOCIATION_EXISTS"
            case .duplicateAccount: return "DUPLICATE_ACCOUNT"
            case .duplicatePricingruleArns: return "DUPLICATE_PRICINGRULE_ARNS"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .illegalAccounts: return "ILLEGAL_ACCOUNTS"
            case .illegalBillingEntity: return "ILLEGAL_BILLING_ENTITY"
            case .illegalBillingPeriod: return "ILLEGAL_BILLING_PERIOD"
            case .illegalBillingPeriodRange: return "ILLEGAL_BILLING_PERIOD_RANGE"
            case .illegalChargeDetails: return "ILLEGAL_CHARGE_DETAILS"
            case .illegalChildAssociateResource: return "ILLEGAL_CHILD_ASSOCIATE_RESOURCE"
            case .illegalCustomlineitem: return "ILLEGAL_CUSTOMLINEITEM"
            case .illegalCustomlineitemModification: return "ILLEGAL_CUSTOMLINEITEM_MODIFICATION"
            case .illegalCustomlineitemUpdate: return "ILLEGAL_CUSTOMLINEITEM_UPDATE"
            case .illegalEndedBillinggroup: return "ILLEGAL_ENDED_BILLINGGROUP"
            case .illegalExpression: return "ILLEGAL_EXPRESSION"
            case .illegalModifierPercentage: return "ILLEGAL_MODIFIER_PERCENTAGE"
            case .illegalPrimaryAccount: return "ILLEGAL_PRIMARY_ACCOUNT"
            case .illegalResourceArns: return "ILLEGAL_RESOURCE_ARNS"
            case .illegalScope: return "ILLEGAL_SCOPE"
            case .illegalService: return "ILLEGAL_SERVICE"
            case .illegalTieringInput: return "ILLEGAL_TIERING_INPUT"
            case .illegalType: return "ILLEGAL_TYPE"
            case .illegalUpdateChargeDetails: return "ILLEGAL_UPDATE_CHARGE_DETAILS"
            case .invalidArn: return "INVALID_ARN"
            case .invalidBillingviewArn: return "INVALID_BILLINGVIEW_ARN"
            case .invalidBillingGroup: return "INVALID_BILLING_GROUP"
            case .invalidBillingGroupStatus: return "INVALID_BILLING_GROUP_STATUS"
            case .invalidBillingPeriodForOperation: return "INVALID_BILLING_PERIOD_FOR_OPERATION"
            case .invalidTimeRange: return "INVALID_TIME_RANGE"
            case .mismatchedBillinggroupArn: return "MISMATCHED_BILLINGGROUP_ARN"
            case .mismatchedBillingviewArn: return "MISMATCHED_BILLINGVIEW_ARN"
            case .mismatchedCustomlineitemArn: return "MISMATCHED_CUSTOMLINEITEM_ARN"
            case .mismatchedPricingplanArn: return "MISMATCHED_PRICINGPLAN_ARN"
            case .mismatchedPricingruleArn: return "MISMATCHED_PRICINGRULE_ARN"
            case .missingBillinggroup: return "MISSING_BILLINGGROUP"
            case .missingCustomlineitem: return "MISSING_CUSTOMLINEITEM"
            case .missingLinkedAccountIds: return "MISSING_LINKED_ACCOUNT_IDS"
            case .missingPricingplan: return "MISSING_PRICINGPLAN"
            case .missingPricingPlanArn: return "MISSING_PRICING_PLAN_ARN"
            case .multipleLinkedAccountIds: return "MULTIPLE_LINKED_ACCOUNT_IDS"
            case .multiplePricingPlanArn: return "MULTIPLE_PRICING_PLAN_ARN"
            case .other: return "OTHER"
            case .pricingrulesAlreadyAssociated: return "PRICINGRULES_ALREADY_ASSOCIATED"
            case .pricingrulesNotAssociated: return "PRICINGRULES_NOT_ASSOCIATED"
            case .pricingrulesNotExist: return "PRICINGRULES_NOT_EXIST"
            case .primaryCannotDisassociate: return "PRIMARY_CANNOT_DISASSOCIATE"
            case .primaryNotAssociated: return "PRIMARY_NOT_ASSOCIATED"
            case .tooManyAccountsInRequest: return "TOO_MANY_ACCOUNTS_IN_REQUEST"
            case .tooManyCustomlineitemsInRequest: return "TOO_MANY_CUSTOMLINEITEMS_IN_REQUEST"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
