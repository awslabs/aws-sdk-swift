// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BillingconductorClientTypes.AccountAssociationsListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountEmail = "AccountEmail"
        case accountId = "AccountId"
        case accountName = "AccountName"
        case billingGroupArn = "BillingGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountEmail = self.accountEmail {
            try encodeContainer.encode(accountEmail, forKey: .accountEmail)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountName = self.accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let accountEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountEmail)
        accountEmail = accountEmailDecoded
    }
}

extension BillingconductorClientTypes.AccountAssociationsListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountAssociationsListElement(accountId: \(Swift.String(describing: accountId)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), accountEmail: \"CONTENT_REDACTED\", accountName: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a linked account.
    public struct AccountAssociationsListElement: Swift.Equatable {
        /// The Amazon Web Services account email.
        public var accountEmail: Swift.String?
        /// The associating array of account IDs.
        public var accountId: Swift.String?
        /// The Amazon Web Services account name.
        public var accountName: Swift.String?
        /// The Billing Group Arn that the linked account is associated to.
        public var billingGroupArn: Swift.String?

        public init(
            accountEmail: Swift.String? = nil,
            accountId: Swift.String? = nil,
            accountName: Swift.String? = nil,
            billingGroupArn: Swift.String? = nil
        )
        {
            self.accountEmail = accountEmail
            self.accountId = accountId
            self.accountName = accountName
            self.billingGroupArn = billingGroupArn
        }
    }

}

extension BillingconductorClientTypes.AccountGrouping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAssociate = "AutoAssociate"
        case linkedAccountIds = "LinkedAccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoAssociate = self.autoAssociate {
            try encodeContainer.encode(autoAssociate, forKey: .autoAssociate)
        }
        if let linkedAccountIds = linkedAccountIds {
            var linkedAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .linkedAccountIds)
            for accountid0 in linkedAccountIds {
                try linkedAccountIdsContainer.encode(accountid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkedAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .linkedAccountIds)
        var linkedAccountIdsDecoded0:[Swift.String]? = nil
        if let linkedAccountIdsContainer = linkedAccountIdsContainer {
            linkedAccountIdsDecoded0 = [Swift.String]()
            for string0 in linkedAccountIdsContainer {
                if let string0 = string0 {
                    linkedAccountIdsDecoded0?.append(string0)
                }
            }
        }
        linkedAccountIds = linkedAccountIdsDecoded0
        let autoAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssociate)
        autoAssociate = autoAssociateDecoded
    }
}

extension BillingconductorClientTypes {
    /// The set of accounts that will be under the billing group. The set of accounts resemble the linked accounts in a consolidated billing family.
    public struct AccountGrouping: Swift.Equatable {
        /// Specifies if this billing group will automatically associate newly added Amazon Web Services accounts that join your consolidated billing family.
        public var autoAssociate: Swift.Bool?
        /// The account IDs that make up the billing group. Account IDs must be a part of the consolidated billing family, and not associated with another billing group.
        /// This member is required.
        public var linkedAccountIds: [Swift.String]?

        public init(
            autoAssociate: Swift.Bool? = nil,
            linkedAccountIds: [Swift.String]? = nil
        )
        {
            self.autoAssociate = autoAssociate
            self.linkedAccountIds = linkedAccountIds
        }
    }

}

extension AssociateAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension AssociateAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associate-accounts"
    }
}

public struct AssociateAccountsInput: Swift.Equatable {
    /// The associating array of account IDs.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the billing group that associates the array of account IDs.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        arn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.arn = arn
    }
}

struct AssociateAccountsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let accountIds: [Swift.String]?
}

extension AssociateAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension AssociateAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct AssociateAccountsOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the billing group that associates the array of account IDs.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct AssociateAccountsOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension AssociateAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum AssociateAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociatePricingRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let pricingRuleArns = pricingRuleArns {
            var pricingRuleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pricingRuleArns)
            for pricingrulearn0 in pricingRuleArns {
                try pricingRuleArnsContainer.encode(pricingrulearn0)
            }
        }
    }
}

extension AssociatePricingRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associate-pricing-rules"
    }
}

public struct AssociatePricingRulesInput: Swift.Equatable {
    /// The PricingPlanArn that the PricingRuleArns are associated with.
    /// This member is required.
    public var arn: Swift.String?
    /// The PricingRuleArns that are associated with the Pricing Plan.
    /// This member is required.
    public var pricingRuleArns: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.pricingRuleArns = pricingRuleArns
    }
}

struct AssociatePricingRulesInputBody: Swift.Equatable {
    let arn: Swift.String?
    let pricingRuleArns: [Swift.String]?
}

extension AssociatePricingRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let pricingRuleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingRuleArns)
        var pricingRuleArnsDecoded0:[Swift.String]? = nil
        if let pricingRuleArnsContainer = pricingRuleArnsContainer {
            pricingRuleArnsDecoded0 = [Swift.String]()
            for string0 in pricingRuleArnsContainer {
                if let string0 = string0 {
                    pricingRuleArnsDecoded0?.append(string0)
                }
            }
        }
        pricingRuleArns = pricingRuleArnsDecoded0
    }
}

extension AssociatePricingRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociatePricingRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct AssociatePricingRulesOutput: Swift.Equatable {
    /// The PricingPlanArn that the PricingRuleArns are associated with.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct AssociatePricingRulesOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension AssociatePricingRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum AssociatePricingRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.AssociateResourceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.AssociateResourceErrorReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of a resource association error.
    public struct AssociateResourceError: Swift.Equatable {
        /// The reason why the resource association failed.
        public var message: Swift.String?
        /// A static error code that's used to classify the type of failure.
        public var reason: BillingconductorClientTypes.AssociateResourceErrorReason?

        public init(
            message: Swift.String? = nil,
            reason: BillingconductorClientTypes.AssociateResourceErrorReason? = nil
        )
        {
            self.message = message
            self.reason = reason
        }
    }

}

extension BillingconductorClientTypes {
    public enum AssociateResourceErrorReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case illegalCustomlineitem
        case internalServerException
        case invalidArn
        case invalidBillingPeriodRange
        case serviceLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociateResourceErrorReason] {
            return [
                .illegalCustomlineitem,
                .internalServerException,
                .invalidArn,
                .invalidBillingPeriodRange,
                .serviceLimitExceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .illegalCustomlineitem: return "ILLEGAL_CUSTOMLINEITEM"
            case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
            case .invalidArn: return "INVALID_ARN"
            case .invalidBillingPeriodRange: return "INVALID_BILLING_PERIOD_RANGE"
            case .serviceLimitExceeded: return "SERVICE_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociateResourceErrorReason(rawValue: rawValue) ?? AssociateResourceErrorReason.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.AssociateResourceResponseElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let errorDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.AssociateResourceError.self, forKey: .error)
        error = errorDecoded
    }
}

extension BillingconductorClientTypes {
    /// A resource association result for a percentage custom line item.
    public struct AssociateResourceResponseElement: Swift.Equatable {
        /// The resource ARN that was associated to the custom line item.
        public var arn: Swift.String?
        /// An AssociateResourceError that will populate if the resource association fails.
        public var error: BillingconductorClientTypes.AssociateResourceError?

        public init(
            arn: Swift.String? = nil,
            error: BillingconductorClientTypes.AssociateResourceError? = nil
        )
        {
            self.arn = arn
            self.error = error
        }
    }

}

extension BatchAssociateResourcesToCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
        case resourceArns = "ResourceArns"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for customlineitemassociationelement0 in resourceArns {
                try resourceArnsContainer.encode(customlineitemassociationelement0)
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension BatchAssociateResourcesToCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batch-associate-resources-to-custom-line-item"
    }
}

public struct BatchAssociateResourcesToCustomLineItemInput: Swift.Equatable {
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A list containing the ARNs of the resources to be associated.
    /// This member is required.
    public var resourceArns: [Swift.String]?
    /// A percentage custom line item ARN to associate the resources to.
    /// This member is required.
    public var targetArn: Swift.String?

    public init(
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        resourceArns: [Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.billingPeriodRange = billingPeriodRange
        self.resourceArns = resourceArns
        self.targetArn = targetArn
    }
}

struct BatchAssociateResourcesToCustomLineItemInputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let resourceArns: [Swift.String]?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
}

extension BatchAssociateResourcesToCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
        case resourceArns = "ResourceArns"
        case targetArn = "TargetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension BatchAssociateResourcesToCustomLineItemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAssociateResourcesToCustomLineItemOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedAssociatedResources = output.failedAssociatedResources
            self.successfullyAssociatedResources = output.successfullyAssociatedResources
        } else {
            self.failedAssociatedResources = nil
            self.successfullyAssociatedResources = nil
        }
    }
}

public struct BatchAssociateResourcesToCustomLineItemOutput: Swift.Equatable {
    /// A list of AssociateResourceResponseElement for each resource that failed association to a percentage custom line item.
    public var failedAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?
    /// A list of AssociateResourceResponseElement for each resource that's been associated to a percentage custom line item successfully.
    public var successfullyAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?

    public init(
        failedAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]? = nil,
        successfullyAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]? = nil
    )
    {
        self.failedAssociatedResources = failedAssociatedResources
        self.successfullyAssociatedResources = successfullyAssociatedResources
    }
}

struct BatchAssociateResourcesToCustomLineItemOutputBody: Swift.Equatable {
    let successfullyAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?
    let failedAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?
}

extension BatchAssociateResourcesToCustomLineItemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedAssociatedResources = "FailedAssociatedResources"
        case successfullyAssociatedResources = "SuccessfullyAssociatedResources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfullyAssociatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.AssociateResourceResponseElement?].self, forKey: .successfullyAssociatedResources)
        var successfullyAssociatedResourcesDecoded0:[BillingconductorClientTypes.AssociateResourceResponseElement]? = nil
        if let successfullyAssociatedResourcesContainer = successfullyAssociatedResourcesContainer {
            successfullyAssociatedResourcesDecoded0 = [BillingconductorClientTypes.AssociateResourceResponseElement]()
            for structure0 in successfullyAssociatedResourcesContainer {
                if let structure0 = structure0 {
                    successfullyAssociatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        successfullyAssociatedResources = successfullyAssociatedResourcesDecoded0
        let failedAssociatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.AssociateResourceResponseElement?].self, forKey: .failedAssociatedResources)
        var failedAssociatedResourcesDecoded0:[BillingconductorClientTypes.AssociateResourceResponseElement]? = nil
        if let failedAssociatedResourcesContainer = failedAssociatedResourcesContainer {
            failedAssociatedResourcesDecoded0 = [BillingconductorClientTypes.AssociateResourceResponseElement]()
            for structure0 in failedAssociatedResourcesContainer {
                if let structure0 = structure0 {
                    failedAssociatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedAssociatedResources = failedAssociatedResourcesDecoded0
    }
}

enum BatchAssociateResourcesToCustomLineItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDisassociateResourcesFromCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
        case resourceArns = "ResourceArns"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for customlineitemassociationelement0 in resourceArns {
                try resourceArnsContainer.encode(customlineitemassociationelement0)
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension BatchDisassociateResourcesFromCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batch-disassociate-resources-from-custom-line-item"
    }
}

public struct BatchDisassociateResourcesFromCustomLineItemInput: Swift.Equatable {
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A list containing the ARNs of resources to be disassociated.
    /// This member is required.
    public var resourceArns: [Swift.String]?
    /// A percentage custom line item ARN to disassociate the resources from.
    /// This member is required.
    public var targetArn: Swift.String?

    public init(
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        resourceArns: [Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.billingPeriodRange = billingPeriodRange
        self.resourceArns = resourceArns
        self.targetArn = targetArn
    }
}

struct BatchDisassociateResourcesFromCustomLineItemInputBody: Swift.Equatable {
    let targetArn: Swift.String?
    let resourceArns: [Swift.String]?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
}

extension BatchDisassociateResourcesFromCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
        case resourceArns = "ResourceArns"
        case targetArn = "TargetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension BatchDisassociateResourcesFromCustomLineItemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisassociateResourcesFromCustomLineItemOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedDisassociatedResources = output.failedDisassociatedResources
            self.successfullyDisassociatedResources = output.successfullyDisassociatedResources
        } else {
            self.failedDisassociatedResources = nil
            self.successfullyDisassociatedResources = nil
        }
    }
}

public struct BatchDisassociateResourcesFromCustomLineItemOutput: Swift.Equatable {
    /// A list of DisassociateResourceResponseElement for each resource that failed disassociation from a percentage custom line item.
    public var failedDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?
    /// A list of DisassociateResourceResponseElement for each resource that's been disassociated from a percentage custom line item successfully.
    public var successfullyDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?

    public init(
        failedDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil,
        successfullyDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil
    )
    {
        self.failedDisassociatedResources = failedDisassociatedResources
        self.successfullyDisassociatedResources = successfullyDisassociatedResources
    }
}

struct BatchDisassociateResourcesFromCustomLineItemOutputBody: Swift.Equatable {
    let successfullyDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?
    let failedDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?
}

extension BatchDisassociateResourcesFromCustomLineItemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedDisassociatedResources = "FailedDisassociatedResources"
        case successfullyDisassociatedResources = "SuccessfullyDisassociatedResources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfullyDisassociatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.DisassociateResourceResponseElement?].self, forKey: .successfullyDisassociatedResources)
        var successfullyDisassociatedResourcesDecoded0:[BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil
        if let successfullyDisassociatedResourcesContainer = successfullyDisassociatedResourcesContainer {
            successfullyDisassociatedResourcesDecoded0 = [BillingconductorClientTypes.DisassociateResourceResponseElement]()
            for structure0 in successfullyDisassociatedResourcesContainer {
                if let structure0 = structure0 {
                    successfullyDisassociatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        successfullyDisassociatedResources = successfullyDisassociatedResourcesDecoded0
        let failedDisassociatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.DisassociateResourceResponseElement?].self, forKey: .failedDisassociatedResources)
        var failedDisassociatedResourcesDecoded0:[BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil
        if let failedDisassociatedResourcesContainer = failedDisassociatedResourcesContainer {
            failedDisassociatedResourcesDecoded0 = [BillingconductorClientTypes.DisassociateResourceResponseElement]()
            for structure0 in failedDisassociatedResourcesContainer {
                if let structure0 = structure0 {
                    failedDisassociatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        failedDisassociatedResources = failedDisassociatedResourcesDecoded0
    }
}

enum BatchDisassociateResourcesFromCustomLineItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.BillingGroupCostReportElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsCost = "AWSCost"
        case arn = "Arn"
        case currency = "Currency"
        case margin = "Margin"
        case marginPercentage = "MarginPercentage"
        case proformaCost = "ProformaCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsCost = self.awsCost {
            try encodeContainer.encode(awsCost, forKey: .awsCost)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let currency = self.currency {
            try encodeContainer.encode(currency, forKey: .currency)
        }
        if let margin = self.margin {
            try encodeContainer.encode(margin, forKey: .margin)
        }
        if let marginPercentage = self.marginPercentage {
            try encodeContainer.encode(marginPercentage, forKey: .marginPercentage)
        }
        if let proformaCost = self.proformaCost {
            try encodeContainer.encode(proformaCost, forKey: .proformaCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsCost)
        awsCost = awsCostDecoded
        let proformaCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proformaCost)
        proformaCost = proformaCostDecoded
        let marginDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .margin)
        margin = marginDecoded
        let marginPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marginPercentage)
        marginPercentage = marginPercentageDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currency)
        currency = currencyDecoded
    }
}

extension BillingconductorClientTypes {
    /// A summary report of actual Amazon Web Services charges and calculated Amazon Web Services charges, based on the associated pricing plan of a billing group.
    public struct BillingGroupCostReportElement: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a billing group.
        public var arn: Swift.String?
        /// The actual Amazon Web Services charges for the billing group.
        public var awsCost: Swift.String?
        /// The displayed currency.
        public var currency: Swift.String?
        /// The billing group margin.
        public var margin: Swift.String?
        /// The percentage of billing group margin.
        public var marginPercentage: Swift.String?
        /// The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group.
        public var proformaCost: Swift.String?

        public init(
            arn: Swift.String? = nil,
            awsCost: Swift.String? = nil,
            currency: Swift.String? = nil,
            margin: Swift.String? = nil,
            marginPercentage: Swift.String? = nil,
            proformaCost: Swift.String? = nil
        )
        {
            self.arn = arn
            self.awsCost = awsCost
            self.currency = currency
            self.margin = margin
            self.marginPercentage = marginPercentage
            self.proformaCost = proformaCost
        }
    }

}

extension BillingconductorClientTypes.BillingGroupListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountGrouping = "AccountGrouping"
        case arn = "Arn"
        case computationPreference = "ComputationPreference"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case primaryAccountId = "PrimaryAccountId"
        case size = "Size"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountGrouping = self.accountGrouping {
            try encodeContainer.encode(accountGrouping, forKey: .accountGrouping)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computationPreference = self.computationPreference {
            try encodeContainer.encode(computationPreference, forKey: .computationPreference)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let primaryAccountId = self.primaryAccountId {
            try encodeContainer.encode(primaryAccountId, forKey: .primaryAccountId)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let primaryAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountId)
        primaryAccountId = primaryAccountIdDecoded
        let computationPreferenceDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ComputationPreference.self, forKey: .computationPreference)
        computationPreference = computationPreferenceDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.BillingGroupStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let accountGroupingDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListBillingGroupAccountGrouping.self, forKey: .accountGrouping)
        accountGrouping = accountGroupingDecoded
    }
}

extension BillingconductorClientTypes.BillingGroupListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BillingGroupListElement(accountGrouping: \(Swift.String(describing: accountGrouping)), arn: \(Swift.String(describing: arn)), computationPreference: \(Swift.String(describing: computationPreference)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), primaryAccountId: \(Swift.String(describing: primaryAccountId)), size: \(Swift.String(describing: size)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a billing group.
    public struct BillingGroupListElement: Swift.Equatable {
        /// Specifies if the billing group has automatic account association (AutoAssociate) enabled.
        public var accountGrouping: BillingconductorClientTypes.ListBillingGroupAccountGrouping?
        /// The Amazon Resource Number (ARN) that can be used to uniquely identify the billing group.
        public var arn: Swift.String?
        /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
        public var computationPreference: BillingconductorClientTypes.ComputationPreference?
        /// The time when the billing group was created.
        public var creationTime: Swift.Int
        /// The description of the billing group.
        public var description: Swift.String?
        /// The most recent time when the billing group was modified.
        public var lastModifiedTime: Swift.Int
        /// The name of the billing group.
        public var name: Swift.String?
        /// The account ID that serves as the main account in a billing group.
        public var primaryAccountId: Swift.String?
        /// The number of accounts in the particular billing group.
        public var size: Swift.Int
        /// The billing group status. Only one of the valid values can be used.
        public var status: BillingconductorClientTypes.BillingGroupStatus?
        /// The reason why the billing group is in its current status.
        public var statusReason: Swift.String?

        public init(
            accountGrouping: BillingconductorClientTypes.ListBillingGroupAccountGrouping? = nil,
            arn: Swift.String? = nil,
            computationPreference: BillingconductorClientTypes.ComputationPreference? = nil,
            creationTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            primaryAccountId: Swift.String? = nil,
            size: Swift.Int = 0,
            status: BillingconductorClientTypes.BillingGroupStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.accountGrouping = accountGrouping
            self.arn = arn
            self.computationPreference = computationPreference
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.primaryAccountId = primaryAccountId
            self.size = size
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension BillingconductorClientTypes {
    public enum BillingGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case primaryAccountMissing
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingGroupStatus] {
            return [
                .active,
                .primaryAccountMissing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .primaryAccountMissing: return "PRIMARY_ACCOUNT_MISSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BillingGroupStatus(rawValue: rawValue) ?? BillingGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.ComputationPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pricingPlanArn = "PricingPlanArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pricingPlanArn = self.pricingPlanArn {
            try encodeContainer.encode(pricingPlanArn, forKey: .pricingPlanArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanArn)
        pricingPlanArn = pricingPlanArnDecoded
    }
}

extension BillingconductorClientTypes {
    /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
    public struct ComputationPreference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the pricing plan that's used to compute the Amazon Web Services charges for a billing group.
        /// This member is required.
        public var pricingPlanArn: Swift.String?

        public init(
            pricingPlanArn: Swift.String? = nil
        )
        {
            self.pricingPlanArn = pricingPlanArn
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.reason = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You can cause an inconsistent state by updating or deleting a resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason for the inconsistent state.
        public internal(set) var reason: BillingconductorClientTypes.ConflictExceptionReason? = nil
        /// Identifier of the resource in use.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource in use.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: BillingconductorClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let reason: BillingconductorClientTypes.ConflictExceptionReason?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension BillingconductorClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pricingPlanAttachedToBillingGroupDeleteConflict
        case pricingRuleAttachedToPricingPlanDeleteConflict
        case pricingRuleInPricingPlanConflict
        case resourceNameConflict
        case writeConflictRetry
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .pricingPlanAttachedToBillingGroupDeleteConflict,
                .pricingRuleAttachedToPricingPlanDeleteConflict,
                .pricingRuleInPricingPlanConflict,
                .resourceNameConflict,
                .writeConflictRetry,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pricingPlanAttachedToBillingGroupDeleteConflict: return "PRICING_PLAN_ATTACHED_TO_BILLING_GROUP_DELETE_CONFLICT"
            case .pricingRuleAttachedToPricingPlanDeleteConflict: return "PRICING_RULE_ATTACHED_TO_PRICING_PLAN_DELETE_CONFLICT"
            case .pricingRuleInPricingPlanConflict: return "PRICING_RULE_IN_PRICING_PLAN_CONFLICT"
            case .resourceNameConflict: return "RESOURCE_NAME_CONFLICT"
            case .writeConflictRetry: return "WRITE_CONFLICT_RETRY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateBillingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBillingGroupInput(accountGrouping: \(Swift.String(describing: accountGrouping)), clientToken: \(Swift.String(describing: clientToken)), computationPreference: \(Swift.String(describing: computationPreference)), primaryAccountId: \(Swift.String(describing: primaryAccountId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountGrouping = "AccountGrouping"
        case computationPreference = "ComputationPreference"
        case description = "Description"
        case name = "Name"
        case primaryAccountId = "PrimaryAccountId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountGrouping = self.accountGrouping {
            try encodeContainer.encode(accountGrouping, forKey: .accountGrouping)
        }
        if let computationPreference = self.computationPreference {
            try encodeContainer.encode(computationPreference, forKey: .computationPreference)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let primaryAccountId = self.primaryAccountId {
            try encodeContainer.encode(primaryAccountId, forKey: .primaryAccountId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateBillingGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-billing-group"
    }
}

public struct CreateBillingGroupInput: Swift.Equatable {
    /// The set of accounts that will be under the billing group. The set of accounts resemble the linked accounts in a consolidated billing family.
    /// This member is required.
    public var accountGrouping: BillingconductorClientTypes.AccountGrouping?
    /// The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
    /// This member is required.
    public var computationPreference: BillingconductorClientTypes.ComputationPreference?
    /// The description of the billing group.
    public var description: Swift.String?
    /// The billing group name. The names must be unique.
    /// This member is required.
    public var name: Swift.String?
    /// The account ID that serves as the main account in a billing group.
    public var primaryAccountId: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a billing group. This feature isn't available during the beta.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accountGrouping: BillingconductorClientTypes.AccountGrouping? = nil,
        clientToken: Swift.String? = nil,
        computationPreference: BillingconductorClientTypes.ComputationPreference? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        primaryAccountId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accountGrouping = accountGrouping
        self.clientToken = clientToken
        self.computationPreference = computationPreference
        self.description = description
        self.name = name
        self.primaryAccountId = primaryAccountId
        self.tags = tags
    }
}

struct CreateBillingGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let accountGrouping: BillingconductorClientTypes.AccountGrouping?
    let computationPreference: BillingconductorClientTypes.ComputationPreference?
    let primaryAccountId: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountGrouping = "AccountGrouping"
        case computationPreference = "ComputationPreference"
        case description = "Description"
        case name = "Name"
        case primaryAccountId = "PrimaryAccountId"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let accountGroupingDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.AccountGrouping.self, forKey: .accountGrouping)
        accountGrouping = accountGroupingDecoded
        let computationPreferenceDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ComputationPreference.self, forKey: .computationPreference)
        computationPreference = computationPreferenceDecoded
        let primaryAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountId)
        primaryAccountId = primaryAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBillingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateBillingGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created billing group.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateBillingGroupOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateBillingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCustomLineItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomLineItemInput(billingGroupArn: \(Swift.String(describing: billingGroupArn)), billingPeriodRange: \(Swift.String(describing: billingPeriodRange)), chargeDetails: \(Swift.String(describing: chargeDetails)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn = "BillingGroupArn"
        case billingPeriodRange = "BillingPeriodRange"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
        if let chargeDetails = self.chargeDetails {
            try encodeContainer.encode(chargeDetails, forKey: .chargeDetails)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCustomLineItemInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-custom-line-item"
    }
}

public struct CreateCustomLineItemInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to.
    /// This member is required.
    public var billingGroupArn: Swift.String?
    /// A time range for which the custom line item is effective.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A CustomLineItemChargeDetails that describes the charge details for a custom line item.
    /// This member is required.
    public var chargeDetails: BillingconductorClientTypes.CustomLineItemChargeDetails?
    /// The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The description of the custom line item. This is shown on the Bills page in association with the charge value.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the custom line item.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a custom line item.
    public var tags: [Swift.String:Swift.String]?

    public init(
        billingGroupArn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        chargeDetails: BillingconductorClientTypes.CustomLineItemChargeDetails? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.billingGroupArn = billingGroupArn
        self.billingPeriodRange = billingPeriodRange
        self.chargeDetails = chargeDetails
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateCustomLineItemInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let billingGroupArn: Swift.String?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    let tags: [Swift.String:Swift.String]?
    let chargeDetails: BillingconductorClientTypes.CustomLineItemChargeDetails?
}

extension CreateCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArn = "BillingGroupArn"
        case billingPeriodRange = "BillingPeriodRange"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
    }
}

extension CreateCustomLineItemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCustomLineItemOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateCustomLineItemOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created custom line item.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateCustomLineItemOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateCustomLineItemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateCustomLineItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.CreateFreeTierConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activated = "Activated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activated = self.activated {
            try encodeContainer.encode(activated, forKey: .activated)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activated)
        activated = activatedDecoded
    }
}

extension BillingconductorClientTypes {
    /// The possible Amazon Web Services Free Tier configurations.
    public struct CreateFreeTierConfig: Swift.Equatable {
        /// Activate or deactivate Amazon Web Services Free Tier.
        /// This member is required.
        public var activated: Swift.Bool?

        public init(
            activated: Swift.Bool? = nil
        )
        {
            self.activated = activated
        }
    }

}

extension CreatePricingPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePricingPlanInput(clientToken: \(Swift.String(describing: clientToken)), pricingRuleArns: \(Swift.String(describing: pricingRuleArns)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreatePricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case pricingRuleArns = "PricingRuleArns"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pricingRuleArns = pricingRuleArns {
            var pricingRuleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pricingRuleArns)
            for pricingrulearn0 in pricingRuleArns {
                try pricingRuleArnsContainer.encode(pricingrulearn0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePricingPlanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreatePricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-pricing-plan"
    }
}

public struct CreatePricingPlanInput: Swift.Equatable {
    /// The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The description of the pricing plan.
    public var description: Swift.String?
    /// The name of the pricing plan. The names must be unique to each pricing plan.
    /// This member is required.
    public var name: Swift.String?
    /// A list of Amazon Resource Names (ARNs) that define the pricing plan parameters.
    public var pricingRuleArns: [Swift.String]?
    /// A map that contains tag keys and tag values that are attached to a pricing plan.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.pricingRuleArns = pricingRuleArns
        self.tags = tags
    }
}

struct CreatePricingPlanInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let pricingRuleArns: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case pricingRuleArns = "PricingRuleArns"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pricingRuleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingRuleArns)
        var pricingRuleArnsDecoded0:[Swift.String]? = nil
        if let pricingRuleArnsContainer = pricingRuleArnsContainer {
            pricingRuleArnsDecoded0 = [Swift.String]()
            for string0 in pricingRuleArnsContainer {
                if let string0 = string0 {
                    pricingRuleArnsDecoded0?.append(string0)
                }
            }
        }
        pricingRuleArns = pricingRuleArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePricingPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePricingPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreatePricingPlanOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created pricing plan.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreatePricingPlanOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreatePricingPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreatePricingPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePricingRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePricingRuleInput(billingEntity: \(Swift.String(describing: billingEntity)), clientToken: \(Swift.String(describing: clientToken)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), operation: \(Swift.String(describing: operation)), scope: \(Swift.String(describing: scope)), service: \(Swift.String(describing: service)), tags: \(Swift.String(describing: tags)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), usageType: \(Swift.String(describing: usageType)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreatePricingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingEntity = "BillingEntity"
        case description = "Description"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case operation = "Operation"
        case scope = "Scope"
        case service = "Service"
        case tags = "Tags"
        case tiering = "Tiering"
        case type = "Type"
        case usageType = "UsageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingEntity = self.billingEntity {
            try encodeContainer.encode(billingEntity, forKey: .billingEntity)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modifierPercentage = self.modifierPercentage {
            try encodeContainer.encode(modifierPercentage, forKey: .modifierPercentage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tiering = self.tiering {
            try encodeContainer.encode(tiering, forKey: .tiering)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }
}

extension CreatePricingRuleInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreatePricingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-pricing-rule"
    }
}

public struct CreatePricingRuleInput: Swift.Equatable {
    /// The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
    public var billingEntity: Swift.String?
    /// The token that's needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The pricing rule description.
    public var description: Swift.String?
    /// A percentage modifier that's applied on the public pricing rates.
    public var modifierPercentage: Swift.Double?
    /// The pricing rule name. The names must be unique to each pricing rule.
    /// This member is required.
    public var name: Swift.String?
    /// Operation is the specific Amazon Web Services action covered by this line item. This describes the specific usage of the line item. If the Scope attribute is set to SKU, this attribute indicates which operation the PricingRule is modifying. For example, a value of RunInstances:0202 indicates the operation of running an Amazon EC2 instance.
    public var operation: Swift.String?
    /// The scope of pricing rule that indicates if it's globally applicable, or it's service-specific.
    /// This member is required.
    public var scope: BillingconductorClientTypes.PricingRuleScope?
    /// If the Scope attribute is set to SERVICE or SKU, the attribute indicates which service the PricingRule is applicable for.
    public var service: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a pricing rule.
    public var tags: [Swift.String:Swift.String]?
    /// The set of tiering configurations for the pricing rule.
    public var tiering: BillingconductorClientTypes.CreateTieringInput?
    /// The type of pricing rule.
    /// This member is required.
    public var type: BillingconductorClientTypes.PricingRuleType?
    /// Usage type is the unit that each service uses to measure the usage of a specific type of resource. If the Scope attribute is set to SKU, this attribute indicates which usage type the PricingRule is modifying. For example, USW2-BoxUsage:m2.2xlarge describes an M2 High Memory Double Extra Large instance in the US West (Oregon) Region.
    public var usageType: Swift.String?

    public init(
        billingEntity: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        modifierPercentage: Swift.Double? = nil,
        name: Swift.String? = nil,
        operation: Swift.String? = nil,
        scope: BillingconductorClientTypes.PricingRuleScope? = nil,
        service: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tiering: BillingconductorClientTypes.CreateTieringInput? = nil,
        type: BillingconductorClientTypes.PricingRuleType? = nil,
        usageType: Swift.String? = nil
    )
    {
        self.billingEntity = billingEntity
        self.clientToken = clientToken
        self.description = description
        self.modifierPercentage = modifierPercentage
        self.name = name
        self.operation = operation
        self.scope = scope
        self.service = service
        self.tags = tags
        self.tiering = tiering
        self.type = type
        self.usageType = usageType
    }
}

struct CreatePricingRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let scope: BillingconductorClientTypes.PricingRuleScope?
    let type: BillingconductorClientTypes.PricingRuleType?
    let modifierPercentage: Swift.Double?
    let service: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let billingEntity: Swift.String?
    let tiering: BillingconductorClientTypes.CreateTieringInput?
    let usageType: Swift.String?
    let operation: Swift.String?
}

extension CreatePricingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingEntity = "BillingEntity"
        case description = "Description"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case operation = "Operation"
        case scope = "Scope"
        case service = "Service"
        case tags = "Tags"
        case tiering = "Tiering"
        case type = "Type"
        case usageType = "UsageType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleScope.self, forKey: .scope)
        scope = scopeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleType.self, forKey: .type)
        type = typeDecoded
        let modifierPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .modifierPercentage)
        modifierPercentage = modifierPercentageDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let billingEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingEntity)
        billingEntity = billingEntityDecoded
        let tieringDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CreateTieringInput.self, forKey: .tiering)
        tiering = tieringDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
    }
}

extension CreatePricingRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePricingRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreatePricingRuleOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created pricing rule.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreatePricingRuleOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreatePricingRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreatePricingRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLimitExceededException": return try await ServiceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.CreateTieringInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTier = "FreeTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let freeTier = self.freeTier {
            try encodeContainer.encode(freeTier, forKey: .freeTier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeTierDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CreateFreeTierConfig.self, forKey: .freeTier)
        freeTier = freeTierDecoded
    }
}

extension BillingconductorClientTypes {
    /// The set of tiering configurations for the pricing rule.
    public struct CreateTieringInput: Swift.Equatable {
        /// The possible Amazon Web Services Free Tier configurations.
        /// This member is required.
        public var freeTier: BillingconductorClientTypes.CreateFreeTierConfig?

        public init(
            freeTier: BillingconductorClientTypes.CreateFreeTierConfig? = nil
        )
        {
            self.freeTier = freeTier
        }
    }

}

extension BillingconductorClientTypes {
    public enum CurrencyCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cny
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .cny,
                .usd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cny: return "CNY"
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CurrencyCode(rawValue: rawValue) ?? CurrencyCode.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.CustomLineItemBillingPeriodRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveEndBillingPeriod = "ExclusiveEndBillingPeriod"
        case inclusiveStartBillingPeriod = "InclusiveStartBillingPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveEndBillingPeriod = self.exclusiveEndBillingPeriod {
            try encodeContainer.encode(exclusiveEndBillingPeriod, forKey: .exclusiveEndBillingPeriod)
        }
        if let inclusiveStartBillingPeriod = self.inclusiveStartBillingPeriod {
            try encodeContainer.encode(inclusiveStartBillingPeriod, forKey: .inclusiveStartBillingPeriod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inclusiveStartBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inclusiveStartBillingPeriod)
        inclusiveStartBillingPeriod = inclusiveStartBillingPeriodDecoded
        let exclusiveEndBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exclusiveEndBillingPeriod)
        exclusiveEndBillingPeriod = exclusiveEndBillingPeriodDecoded
    }
}

extension BillingconductorClientTypes {
    /// The billing period range in which the custom line item request will be applied.
    public struct CustomLineItemBillingPeriodRange: Swift.Equatable {
        /// The inclusive end billing period that defines a billing period range where a custom line is applied.
        public var exclusiveEndBillingPeriod: Swift.String?
        /// The inclusive start billing period that defines a billing period range where a custom line is applied.
        /// This member is required.
        public var inclusiveStartBillingPeriod: Swift.String?

        public init(
            exclusiveEndBillingPeriod: Swift.String? = nil,
            inclusiveStartBillingPeriod: Swift.String? = nil
        )
        {
            self.exclusiveEndBillingPeriod = exclusiveEndBillingPeriod
            self.inclusiveStartBillingPeriod = inclusiveStartBillingPeriod
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flat = "Flat"
        case lineItemFilters = "LineItemFilters"
        case percentage = "Percentage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flat = self.flat {
            try encodeContainer.encode(flat, forKey: .flat)
        }
        if let lineItemFilters = lineItemFilters {
            var lineItemFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineItemFilters)
            for lineitemfilter0 in lineItemFilters {
                try lineItemFiltersContainer.encode(lineitemfilter0)
            }
        }
        if let percentage = self.percentage {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flatDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemFlatChargeDetails.self, forKey: .flat)
        flat = flatDecoded
        let percentageDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemPercentageChargeDetails.self, forKey: .percentage)
        percentage = percentageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemType.self, forKey: .type)
        type = typeDecoded
        let lineItemFiltersContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.LineItemFilter?].self, forKey: .lineItemFilters)
        var lineItemFiltersDecoded0:[BillingconductorClientTypes.LineItemFilter]? = nil
        if let lineItemFiltersContainer = lineItemFiltersContainer {
            lineItemFiltersDecoded0 = [BillingconductorClientTypes.LineItemFilter]()
            for structure0 in lineItemFiltersContainer {
                if let structure0 = structure0 {
                    lineItemFiltersDecoded0?.append(structure0)
                }
            }
        }
        lineItemFilters = lineItemFiltersDecoded0
    }
}

extension BillingconductorClientTypes {
    /// The charge details of a custom line item. It should contain only one of Flat or Percentage.
    public struct CustomLineItemChargeDetails: Swift.Equatable {
        /// A CustomLineItemFlatChargeDetails that describes the charge details of a flat custom line item.
        public var flat: BillingconductorClientTypes.CustomLineItemFlatChargeDetails?
        /// A representation of the line item filter.
        public var lineItemFilters: [BillingconductorClientTypes.LineItemFilter]?
        /// A CustomLineItemPercentageChargeDetails that describes the charge details of a percentage custom line item.
        public var percentage: BillingconductorClientTypes.CustomLineItemPercentageChargeDetails?
        /// The type of the custom line item that indicates whether the charge is a fee or credit.
        /// This member is required.
        public var type: BillingconductorClientTypes.CustomLineItemType?

        public init(
            flat: BillingconductorClientTypes.CustomLineItemFlatChargeDetails? = nil,
            lineItemFilters: [BillingconductorClientTypes.LineItemFilter]? = nil,
            percentage: BillingconductorClientTypes.CustomLineItemPercentageChargeDetails? = nil,
            type: BillingconductorClientTypes.CustomLineItemType? = nil
        )
        {
            self.flat = flat
            self.lineItemFilters = lineItemFilters
            self.percentage = percentage
            self.type = type
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemFlatChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chargeValue = "ChargeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chargeValue = self.chargeValue {
            try encodeContainer.encode(chargeValue, forKey: .chargeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chargeValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .chargeValue)
        chargeValue = chargeValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a flat custom line item.
    public struct CustomLineItemFlatChargeDetails: Swift.Equatable {
        /// The custom line item's fixed charge value in USD.
        /// This member is required.
        public var chargeValue: Swift.Double?

        public init(
            chargeValue: Swift.Double? = nil
        )
        {
            self.chargeValue = chargeValue
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associationSize = "AssociationSize"
        case billingGroupArn = "BillingGroupArn"
        case chargeDetails = "ChargeDetails"
        case creationTime = "CreationTime"
        case currencyCode = "CurrencyCode"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case productCode = "ProductCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if associationSize != 0 {
            try encodeContainer.encode(associationSize, forKey: .associationSize)
        }
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let chargeDetails = self.chargeDetails {
            try encodeContainer.encode(chargeDetails, forKey: .chargeDetails)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode.rawValue, forKey: .currencyCode)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CurrencyCode.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let associationSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associationSize) ?? 0
        associationSize = associationSizeDecoded
    }
}

extension BillingconductorClientTypes.CustomLineItemListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomLineItemListElement(arn: \(Swift.String(describing: arn)), associationSize: \(Swift.String(describing: associationSize)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), chargeDetails: \(Swift.String(describing: chargeDetails)), creationTime: \(Swift.String(describing: creationTime)), currencyCode: \(Swift.String(describing: currencyCode)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), productCode: \(Swift.String(describing: productCode)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a custom line item.
    public struct CustomLineItemListElement: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) for custom line items.
        public var arn: Swift.String?
        /// The number of resources that are associated to the custom line item.
        public var associationSize: Swift.Int
        /// The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to.
        public var billingGroupArn: Swift.String?
        /// A ListCustomLineItemChargeDetails that describes the charge details of a custom line item.
        public var chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
        /// The time created.
        public var creationTime: Swift.Int
        /// The custom line item's charge value currency. Only one of the valid values can be used.
        public var currencyCode: BillingconductorClientTypes.CurrencyCode?
        /// The custom line item's description. This is shown on the Bills page in association with the charge value.
        public var description: Swift.String?
        /// The most recent time when the custom line item was modified.
        public var lastModifiedTime: Swift.Int
        /// The custom line item's name.
        public var name: Swift.String?
        /// The product code that's associated with the custom line item.
        public var productCode: Swift.String?

        public init(
            arn: Swift.String? = nil,
            associationSize: Swift.Int = 0,
            billingGroupArn: Swift.String? = nil,
            chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails? = nil,
            creationTime: Swift.Int = 0,
            currencyCode: BillingconductorClientTypes.CurrencyCode? = nil,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            productCode: Swift.String? = nil
        )
        {
            self.arn = arn
            self.associationSize = associationSize
            self.billingGroupArn = billingGroupArn
            self.chargeDetails = chargeDetails
            self.creationTime = creationTime
            self.currencyCode = currencyCode
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.productCode = productCode
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemPercentageChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedValues = "AssociatedValues"
        case percentageValue = "PercentageValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedValues = associatedValues {
            var associatedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedValues)
            for customlineitemassociationelement0 in associatedValues {
                try associatedValuesContainer.encode(customlineitemassociationelement0)
            }
        }
        if let percentageValue = self.percentageValue {
            try encodeContainer.encode(percentageValue, forKey: .percentageValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentageValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentageValue)
        percentageValue = percentageValueDecoded
        let associatedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedValues)
        var associatedValuesDecoded0:[Swift.String]? = nil
        if let associatedValuesContainer = associatedValuesContainer {
            associatedValuesDecoded0 = [Swift.String]()
            for string0 in associatedValuesContainer {
                if let string0 = string0 {
                    associatedValuesDecoded0?.append(string0)
                }
            }
        }
        associatedValues = associatedValuesDecoded0
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a percentage custom line item.
    public struct CustomLineItemPercentageChargeDetails: Swift.Equatable {
        /// A list of resource ARNs to associate to the percentage custom line item.
        public var associatedValues: [Swift.String]?
        /// The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        /// This member is required.
        public var percentageValue: Swift.Double?

        public init(
            associatedValues: [Swift.String]? = nil,
            percentageValue: Swift.Double? = nil
        )
        {
            self.associatedValues = associatedValues
            self.percentageValue = percentageValue
        }
    }

}

extension BillingconductorClientTypes {
    public enum CustomLineItemRelationship: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case child
        case parent
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomLineItemRelationship] {
            return [
                .child,
                .parent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .child: return "CHILD"
            case .parent: return "PARENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomLineItemRelationship(rawValue: rawValue) ?? CustomLineItemRelationship.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes {
    public enum CustomLineItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case credit
        case fee
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomLineItemType] {
            return [
                .credit,
                .fee,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .credit: return "CREDIT"
            case .fee: return "FEE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomLineItemType(rawValue: rawValue) ?? CustomLineItemType.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.CustomLineItemVersionListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associationSize = "AssociationSize"
        case billingGroupArn = "BillingGroupArn"
        case chargeDetails = "ChargeDetails"
        case creationTime = "CreationTime"
        case currencyCode = "CurrencyCode"
        case description = "Description"
        case endBillingPeriod = "EndBillingPeriod"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case productCode = "ProductCode"
        case startBillingPeriod = "StartBillingPeriod"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if associationSize != 0 {
            try encodeContainer.encode(associationSize, forKey: .associationSize)
        }
        if let billingGroupArn = self.billingGroupArn {
            try encodeContainer.encode(billingGroupArn, forKey: .billingGroupArn)
        }
        if let chargeDetails = self.chargeDetails {
            try encodeContainer.encode(chargeDetails, forKey: .chargeDetails)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode.rawValue, forKey: .currencyCode)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endBillingPeriod = self.endBillingPeriod {
            try encodeContainer.encode(endBillingPeriod, forKey: .endBillingPeriod)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let startBillingPeriod = self.startBillingPeriod {
            try encodeContainer.encode(startBillingPeriod, forKey: .startBillingPeriod)
        }
        if startTime != 0 {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CurrencyCode.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let associationSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associationSize) ?? 0
        associationSize = associationSizeDecoded
        let startBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startBillingPeriod)
        startBillingPeriod = startBillingPeriodDecoded
        let endBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endBillingPeriod)
        endBillingPeriod = endBillingPeriodDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startTime) ?? 0
        startTime = startTimeDecoded
    }
}

extension BillingconductorClientTypes.CustomLineItemVersionListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomLineItemVersionListElement(arn: \(Swift.String(describing: arn)), associationSize: \(Swift.String(describing: associationSize)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), chargeDetails: \(Swift.String(describing: chargeDetails)), creationTime: \(Swift.String(describing: creationTime)), currencyCode: \(Swift.String(describing: currencyCode)), endBillingPeriod: \(Swift.String(describing: endBillingPeriod)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), productCode: \(Swift.String(describing: productCode)), startBillingPeriod: \(Swift.String(describing: startBillingPeriod)), startTime: \(Swift.String(describing: startTime)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a custom line item version.
    public struct CustomLineItemVersionListElement: Swift.Equatable {
        /// A list of custom line item Amazon Resource Names (ARNs) to retrieve information.
        public var arn: Swift.String?
        /// The number of resources that are associated with the custom line item.
        public var associationSize: Swift.Int
        /// The Amazon Resource Name (ARN) of the billing group that the custom line item applies to.
        public var billingGroupArn: Swift.String?
        /// A representation of the charge details of a custom line item.
        public var chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
        /// The time when the custom line item version was created.
        public var creationTime: Swift.Int
        /// The charge value currency of the custom line item.
        public var currencyCode: BillingconductorClientTypes.CurrencyCode?
        /// The description of the custom line item.
        public var description: Swift.String?
        /// The end billing period of the custom line item version.
        public var endBillingPeriod: Swift.String?
        /// The most recent time that the custom line item version was modified.
        public var lastModifiedTime: Swift.Int
        /// The name of the custom line item.
        public var name: Swift.String?
        /// The product code thats associated with the custom line item.
        public var productCode: Swift.String?
        /// The start billing period of the custom line item version.
        public var startBillingPeriod: Swift.String?
        /// The inclusive start time.
        public var startTime: Swift.Int

        public init(
            arn: Swift.String? = nil,
            associationSize: Swift.Int = 0,
            billingGroupArn: Swift.String? = nil,
            chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails? = nil,
            creationTime: Swift.Int = 0,
            currencyCode: BillingconductorClientTypes.CurrencyCode? = nil,
            description: Swift.String? = nil,
            endBillingPeriod: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            productCode: Swift.String? = nil,
            startBillingPeriod: Swift.String? = nil,
            startTime: Swift.Int = 0
        )
        {
            self.arn = arn
            self.associationSize = associationSize
            self.billingGroupArn = billingGroupArn
            self.chargeDetails = chargeDetails
            self.creationTime = creationTime
            self.currencyCode = currencyCode
            self.description = description
            self.endBillingPeriod = endBillingPeriod
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.productCode = productCode
            self.startBillingPeriod = startBillingPeriod
            self.startTime = startTime
        }
    }

}

extension DeleteBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-billing-group"
    }
}

public struct DeleteBillingGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the billing group that you're deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteBillingGroupInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBillingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteBillingGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted billing group.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteBillingGroupOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteBillingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriodRange = "BillingPeriodRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
    }
}

extension DeleteCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-custom-line-item"
    }
}

public struct DeleteCustomLineItemInput: Swift.Equatable {
    /// The ARN of the custom line item to be deleted.
    /// This member is required.
    public var arn: Swift.String?
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?

    public init(
        arn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil
    )
    {
        self.arn = arn
        self.billingPeriodRange = billingPeriodRange
    }
}

struct DeleteCustomLineItemInputBody: Swift.Equatable {
    let arn: Swift.String?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
}

extension DeleteCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriodRange = "BillingPeriodRange"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension DeleteCustomLineItemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteCustomLineItemOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteCustomLineItemOutput: Swift.Equatable {
    /// Then ARN of the deleted custom line item.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteCustomLineItemOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteCustomLineItemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteCustomLineItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeletePricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-pricing-plan"
    }
}

public struct DeletePricingPlanInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing plan that you're deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePricingPlanInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePricingPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePricingPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeletePricingPlanOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted pricing plan.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePricingPlanOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePricingPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeletePricingPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePricingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeletePricingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-pricing-rule"
    }
}

public struct DeletePricingRuleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing rule that you are deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePricingRuleInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePricingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePricingRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePricingRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeletePricingRuleOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted pricing rule.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePricingRuleOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePricingRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeletePricingRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DisassociateAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociate-accounts"
    }
}

public struct DisassociateAccountsInput: Swift.Equatable {
    /// The array of account IDs to disassociate.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the billing group that the array of account IDs will disassociate from.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        arn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.arn = arn
    }
}

struct DisassociateAccountsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let accountIds: [Swift.String]?
}

extension DisassociateAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DisassociateAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DisassociateAccountsOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the billing group that the array of account IDs is disassociated from.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DisassociateAccountsOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DisassociateAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DisassociateAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePricingRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let pricingRuleArns = pricingRuleArns {
            var pricingRuleArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pricingRuleArns)
            for pricingrulearn0 in pricingRuleArns {
                try pricingRuleArnsContainer.encode(pricingrulearn0)
            }
        }
    }
}

extension DisassociatePricingRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociate-pricing-rules"
    }
}

public struct DisassociatePricingRulesInput: Swift.Equatable {
    /// The pricing plan Amazon Resource Name (ARN) to disassociate pricing rules from.
    /// This member is required.
    public var arn: Swift.String?
    /// A list containing the Amazon Resource Name (ARN) of the pricing rules that will be disassociated.
    /// This member is required.
    public var pricingRuleArns: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.pricingRuleArns = pricingRuleArns
    }
}

struct DisassociatePricingRulesInputBody: Swift.Equatable {
    let arn: Swift.String?
    let pricingRuleArns: [Swift.String]?
}

extension DisassociatePricingRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let pricingRuleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingRuleArns)
        var pricingRuleArnsDecoded0:[Swift.String]? = nil
        if let pricingRuleArnsContainer = pricingRuleArnsContainer {
            pricingRuleArnsDecoded0 = [Swift.String]()
            for string0 in pricingRuleArnsContainer {
                if let string0 = string0 {
                    pricingRuleArnsDecoded0?.append(string0)
                }
            }
        }
        pricingRuleArns = pricingRuleArnsDecoded0
    }
}

extension DisassociatePricingRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociatePricingRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DisassociatePricingRulesOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing plan that the pricing rules successfully disassociated from.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DisassociatePricingRulesOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DisassociatePricingRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DisassociatePricingRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.DisassociateResourceResponseElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case error = "Error"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let errorDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.AssociateResourceError.self, forKey: .error)
        error = errorDecoded
    }
}

extension BillingconductorClientTypes {
    /// A resource disassociation result for a percentage custom line item.
    public struct DisassociateResourceResponseElement: Swift.Equatable {
        /// The resource ARN that was disassociated from the custom line item.
        public var arn: Swift.String?
        /// An AssociateResourceError that's shown if the resource disassociation fails.
        public var error: BillingconductorClientTypes.AssociateResourceError?

        public init(
            arn: Swift.String? = nil,
            error: BillingconductorClientTypes.AssociateResourceError? = nil
        )
        {
            self.arn = arn
            self.error = error
        }
    }

}

extension BillingconductorClientTypes.FreeTierConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activated = "Activated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activated = self.activated {
            try encodeContainer.encode(activated, forKey: .activated)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activated)
        activated = activatedDecoded
    }
}

extension BillingconductorClientTypes {
    /// The possible Amazon Web Services Free Tier configurations.
    public struct FreeTierConfig: Swift.Equatable {
        /// Activate or deactivate Amazon Web Services Free Tier application.
        /// This member is required.
        public var activated: Swift.Bool?

        public init(
            activated: Swift.Bool? = nil
        )
        {
            self.activated = activated
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred while processing a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Number of seconds you can retry after the call.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BillingconductorClientTypes.LineItemFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
        case matchOption = "MatchOption"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let matchOption = self.matchOption {
            try encodeContainer.encode(matchOption.rawValue, forKey: .matchOption)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for lineitemfiltervalue0 in values {
                try valuesContainer.encode(lineitemfiltervalue0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.LineItemFilterAttributeName.self, forKey: .attribute)
        attribute = attributeDecoded
        let matchOptionDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.MatchOption.self, forKey: .matchOption)
        matchOption = matchOptionDecoded
        let valuesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.LineItemFilterValue?].self, forKey: .values)
        var valuesDecoded0:[BillingconductorClientTypes.LineItemFilterValue]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [BillingconductorClientTypes.LineItemFilterValue]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension BillingconductorClientTypes {
    /// A representation of the line item filter for your custom line item. You can use line item filters to include or exclude specific resource values from the billing group's total cost. For example, if you create a custom line item and you want to filter out a value, such as Savings Plan discounts, you can update LineItemFilter to exclude it.
    public struct LineItemFilter: Swift.Equatable {
        /// The attribute of the line item filter. This specifies what attribute that you can filter on.
        /// This member is required.
        public var attribute: BillingconductorClientTypes.LineItemFilterAttributeName?
        /// The match criteria of the line item filter. This parameter specifies whether not to include the resource value from the billing group total cost.
        /// This member is required.
        public var matchOption: BillingconductorClientTypes.MatchOption?
        /// The values of the line item filter. This specifies the values to filter on. Currently, you can only exclude Savings Plan discounts.
        /// This member is required.
        public var values: [BillingconductorClientTypes.LineItemFilterValue]?

        public init(
            attribute: BillingconductorClientTypes.LineItemFilterAttributeName? = nil,
            matchOption: BillingconductorClientTypes.MatchOption? = nil,
            values: [BillingconductorClientTypes.LineItemFilterValue]? = nil
        )
        {
            self.attribute = attribute
            self.matchOption = matchOption
            self.values = values
        }
    }

}

extension BillingconductorClientTypes {
    public enum LineItemFilterAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lineItemType
        case sdkUnknown(Swift.String)

        public static var allCases: [LineItemFilterAttributeName] {
            return [
                .lineItemType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lineItemType: return "LINE_ITEM_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LineItemFilterAttributeName(rawValue: rawValue) ?? LineItemFilterAttributeName.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes {
    public enum LineItemFilterValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case savingsPlanNegation
        case sdkUnknown(Swift.String)

        public static var allCases: [LineItemFilterValue] {
            return [
                .savingsPlanNegation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .savingsPlanNegation: return "SAVINGS_PLAN_NEGATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LineItemFilterValue(rawValue: rawValue) ?? LineItemFilterValue.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.ListAccountAssociationsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case accountIds = "AccountIds"
        case association = "Association"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let association = self.association {
            try encodeContainer.encode(association, forKey: .association)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .association)
        association = associationDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// The filter on the account ID of the linked account, or any of the following: MONITORED: linked accounts that are associated to billing groups. UNMONITORED: linked accounts that are not associated to billing groups. Billing Group Arn: linked accounts that are associated to the provided Billing Group Arn.
    public struct ListAccountAssociationsFilter: Swift.Equatable {
        /// The Amazon Web Services account ID to filter on.
        public var accountId: Swift.String?
        /// The list of Amazon Web Services IDs to retrieve their associated billing group for a given time range.
        public var accountIds: [Swift.String]?
        /// MONITORED: linked accounts that are associated to billing groups. UNMONITORED: linked accounts that are not associated to billing groups. Billing Group Arn: linked accounts that are associated to the provided Billing Group Arn.
        public var association: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            accountIds: [Swift.String]? = nil,
            association: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.accountIds = accountIds
            self.association = association
        }
    }

}

extension ListAccountAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccountAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-account-associations"
    }
}

public struct ListAccountAssociationsInput: Swift.Equatable {
    /// The preferred billing period to get account associations.
    public var billingPeriod: Swift.String?
    /// The filter on the account ID of the linked account, or any of the following: MONITORED: linked accounts that are associated to billing groups. UNMONITORED: linked accounts that aren't associated to billing groups. Billing Group Arn: linked accounts that are associated to the provided billing group Arn.
    public var filters: BillingconductorClientTypes.ListAccountAssociationsFilter?
    /// The pagination token that's used on subsequent calls to retrieve accounts.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListAccountAssociationsFilter? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListAccountAssociationsInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let filters: BillingconductorClientTypes.ListAccountAssociationsFilter?
    let nextToken: Swift.String?
}

extension ListAccountAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListAccountAssociationsFilter.self, forKey: .filters)
        filters = filtersDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.linkedAccounts = output.linkedAccounts
            self.nextToken = output.nextToken
        } else {
            self.linkedAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssociationsOutput: Swift.Equatable {
    /// The list of linked accounts in the payer account.
    public var linkedAccounts: [BillingconductorClientTypes.AccountAssociationsListElement]?
    /// The pagination token that's used on subsequent calls to get accounts.
    public var nextToken: Swift.String?

    public init(
        linkedAccounts: [BillingconductorClientTypes.AccountAssociationsListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkedAccounts = linkedAccounts
        self.nextToken = nextToken
    }
}

struct ListAccountAssociationsOutputBody: Swift.Equatable {
    let linkedAccounts: [BillingconductorClientTypes.AccountAssociationsListElement]?
    let nextToken: Swift.String?
}

extension ListAccountAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkedAccounts = "LinkedAccounts"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkedAccountsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.AccountAssociationsListElement?].self, forKey: .linkedAccounts)
        var linkedAccountsDecoded0:[BillingconductorClientTypes.AccountAssociationsListElement]? = nil
        if let linkedAccountsContainer = linkedAccountsContainer {
            linkedAccountsDecoded0 = [BillingconductorClientTypes.AccountAssociationsListElement]()
            for structure0 in linkedAccountsContainer {
                if let structure0 = structure0 {
                    linkedAccountsDecoded0?.append(structure0)
                }
            }
        }
        linkedAccounts = linkedAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.ListBillingGroupAccountGrouping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAssociate = "AutoAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoAssociate = self.autoAssociate {
            try encodeContainer.encode(autoAssociate, forKey: .autoAssociate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssociate)
        autoAssociate = autoAssociateDecoded
    }
}

extension BillingconductorClientTypes {
    /// Specifies if the billing group has the following features enabled.
    public struct ListBillingGroupAccountGrouping: Swift.Equatable {
        /// Specifies if this billing group will automatically associate newly added Amazon Web Services accounts that join your consolidated billing family.
        public var autoAssociate: Swift.Bool?

        public init(
            autoAssociate: Swift.Bool? = nil
        )
        {
            self.autoAssociate = autoAssociate
        }
    }

}

extension BillingconductorClientTypes.ListBillingGroupCostReportsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupArns = "BillingGroupArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingGroupArns = billingGroupArns {
            var billingGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .billingGroupArns)
            for billinggrouparn0 in billingGroupArns {
                try billingGroupArnsContainer.encode(billinggrouparn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .billingGroupArns)
        var billingGroupArnsDecoded0:[Swift.String]? = nil
        if let billingGroupArnsContainer = billingGroupArnsContainer {
            billingGroupArnsDecoded0 = [Swift.String]()
            for string0 in billingGroupArnsContainer {
                if let string0 = string0 {
                    billingGroupArnsDecoded0?.append(string0)
                }
            }
        }
        billingGroupArns = billingGroupArnsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// The filter used to retrieve specific BillingGroupCostReportElements.
    public struct ListBillingGroupCostReportsFilter: Swift.Equatable {
        /// The list of Amazon Resource Names (ARNs) used to filter billing groups to retrieve reports.
        public var billingGroupArns: [Swift.String]?

        public init(
            billingGroupArns: [Swift.String]? = nil
        )
        {
            self.billingGroupArns = billingGroupArns
        }
    }

}

extension ListBillingGroupCostReportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListBillingGroupCostReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-billing-group-cost-reports"
    }
}

public struct ListBillingGroupCostReportsInput: Swift.Equatable {
    /// The preferred billing period for your report.
    public var billingPeriod: Swift.String?
    /// A ListBillingGroupCostReportsFilter to specify billing groups to retrieve reports from.
    public var filters: BillingconductorClientTypes.ListBillingGroupCostReportsFilter?
    /// The maximum number of reports to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to get reports.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListBillingGroupCostReportsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBillingGroupCostReportsInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListBillingGroupCostReportsFilter?
}

extension ListBillingGroupCostReportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListBillingGroupCostReportsFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListBillingGroupCostReportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBillingGroupCostReportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.billingGroupCostReports = output.billingGroupCostReports
            self.nextToken = output.nextToken
        } else {
            self.billingGroupCostReports = nil
            self.nextToken = nil
        }
    }
}

public struct ListBillingGroupCostReportsOutput: Swift.Equatable {
    /// A list of BillingGroupCostReportElement retrieved.
    public var billingGroupCostReports: [BillingconductorClientTypes.BillingGroupCostReportElement]?
    /// The pagination token that's used on subsequent calls to get reports.
    public var nextToken: Swift.String?

    public init(
        billingGroupCostReports: [BillingconductorClientTypes.BillingGroupCostReportElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroupCostReports = billingGroupCostReports
        self.nextToken = nextToken
    }
}

struct ListBillingGroupCostReportsOutputBody: Swift.Equatable {
    let billingGroupCostReports: [BillingconductorClientTypes.BillingGroupCostReportElement]?
    let nextToken: Swift.String?
}

extension ListBillingGroupCostReportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroupCostReports = "BillingGroupCostReports"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupCostReportsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.BillingGroupCostReportElement?].self, forKey: .billingGroupCostReports)
        var billingGroupCostReportsDecoded0:[BillingconductorClientTypes.BillingGroupCostReportElement]? = nil
        if let billingGroupCostReportsContainer = billingGroupCostReportsContainer {
            billingGroupCostReportsDecoded0 = [BillingconductorClientTypes.BillingGroupCostReportElement]()
            for structure0 in billingGroupCostReportsContainer {
                if let structure0 = structure0 {
                    billingGroupCostReportsDecoded0?.append(structure0)
                }
            }
        }
        billingGroupCostReports = billingGroupCostReportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBillingGroupCostReportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.ListBillingGroupsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case autoAssociate = "AutoAssociate"
        case pricingPlan = "PricingPlan"
        case statuses = "Statuses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for billinggrouparn0 in arns {
                try arnsContainer.encode(billinggrouparn0)
            }
        }
        if let autoAssociate = self.autoAssociate {
            try encodeContainer.encode(autoAssociate, forKey: .autoAssociate)
        }
        if let pricingPlan = self.pricingPlan {
            try encodeContainer.encode(pricingPlan, forKey: .pricingPlan)
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statuses)
            for billinggroupstatus0 in statuses {
                try statusesContainer.encode(billinggroupstatus0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let pricingPlanDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlan)
        pricingPlan = pricingPlanDecoded
        let statusesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.BillingGroupStatus?].self, forKey: .statuses)
        var statusesDecoded0:[BillingconductorClientTypes.BillingGroupStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [BillingconductorClientTypes.BillingGroupStatus]()
            for string0 in statusesContainer {
                if let string0 = string0 {
                    statusesDecoded0?.append(string0)
                }
            }
        }
        statuses = statusesDecoded0
        let autoAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssociate)
        autoAssociate = autoAssociateDecoded
    }
}

extension BillingconductorClientTypes {
    /// The filter that specifies the billing groups and pricing plans to retrieve billing group information.
    public struct ListBillingGroupsFilter: Swift.Equatable {
        /// The list of billing group Amazon Resource Names (ARNs) to retrieve information.
        public var arns: [Swift.String]?
        /// Specifies if this billing group will automatically associate newly added Amazon Web Services accounts that join your consolidated billing family.
        public var autoAssociate: Swift.Bool?
        /// The pricing plan Amazon Resource Names (ARNs) to retrieve information.
        public var pricingPlan: Swift.String?
        /// A list of billing groups to retrieve their current status for a specific time range
        public var statuses: [BillingconductorClientTypes.BillingGroupStatus]?

        public init(
            arns: [Swift.String]? = nil,
            autoAssociate: Swift.Bool? = nil,
            pricingPlan: Swift.String? = nil,
            statuses: [BillingconductorClientTypes.BillingGroupStatus]? = nil
        )
        {
            self.arns = arns
            self.autoAssociate = autoAssociate
            self.pricingPlan = pricingPlan
            self.statuses = statuses
        }
    }

}

extension ListBillingGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListBillingGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-billing-groups"
    }
}

public struct ListBillingGroupsInput: Swift.Equatable {
    /// The preferred billing period to get billing groups.
    public var billingPeriod: Swift.String?
    /// A ListBillingGroupsFilter that specifies the billing group and pricing plan to retrieve billing group information.
    public var filters: BillingconductorClientTypes.ListBillingGroupsFilter?
    /// The maximum number of billing groups to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to get billing groups.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListBillingGroupsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBillingGroupsInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListBillingGroupsFilter?
}

extension ListBillingGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListBillingGroupsFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListBillingGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBillingGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.billingGroups = output.billingGroups
            self.nextToken = output.nextToken
        } else {
            self.billingGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListBillingGroupsOutput: Swift.Equatable {
    /// A list of BillingGroupListElement retrieved.
    public var billingGroups: [BillingconductorClientTypes.BillingGroupListElement]?
    /// The pagination token that's used on subsequent calls to get billing groups.
    public var nextToken: Swift.String?

    public init(
        billingGroups: [BillingconductorClientTypes.BillingGroupListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroups = billingGroups
        self.nextToken = nextToken
    }
}

struct ListBillingGroupsOutputBody: Swift.Equatable {
    let billingGroups: [BillingconductorClientTypes.BillingGroupListElement]?
    let nextToken: Swift.String?
}

extension ListBillingGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingGroups = "BillingGroups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingGroupsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.BillingGroupListElement?].self, forKey: .billingGroups)
        var billingGroupsDecoded0:[BillingconductorClientTypes.BillingGroupListElement]? = nil
        if let billingGroupsContainer = billingGroupsContainer {
            billingGroupsDecoded0 = [BillingconductorClientTypes.BillingGroupListElement]()
            for structure0 in billingGroupsContainer {
                if let structure0 = structure0 {
                    billingGroupsDecoded0?.append(structure0)
                }
            }
        }
        billingGroups = billingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBillingGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.ListCustomLineItemChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flat = "Flat"
        case lineItemFilters = "LineItemFilters"
        case percentage = "Percentage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flat = self.flat {
            try encodeContainer.encode(flat, forKey: .flat)
        }
        if let lineItemFilters = lineItemFilters {
            var lineItemFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineItemFilters)
            for lineitemfilter0 in lineItemFilters {
                try lineItemFiltersContainer.encode(lineitemfilter0)
            }
        }
        if let percentage = self.percentage {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flatDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails.self, forKey: .flat)
        flat = flatDecoded
        let percentageDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails.self, forKey: .percentage)
        percentage = percentageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemType.self, forKey: .type)
        type = typeDecoded
        let lineItemFiltersContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.LineItemFilter?].self, forKey: .lineItemFilters)
        var lineItemFiltersDecoded0:[BillingconductorClientTypes.LineItemFilter]? = nil
        if let lineItemFiltersContainer = lineItemFiltersContainer {
            lineItemFiltersDecoded0 = [BillingconductorClientTypes.LineItemFilter]()
            for structure0 in lineItemFiltersContainer {
                if let structure0 = structure0 {
                    lineItemFiltersDecoded0?.append(structure0)
                }
            }
        }
        lineItemFilters = lineItemFiltersDecoded0
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details of a custom line item.
    public struct ListCustomLineItemChargeDetails: Swift.Equatable {
        /// A ListCustomLineItemFlatChargeDetails that describes the charge details of a flat custom line item.
        public var flat: BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails?
        /// A representation of the line item filter.
        public var lineItemFilters: [BillingconductorClientTypes.LineItemFilter]?
        /// A ListCustomLineItemPercentageChargeDetails that describes the charge details of a percentage custom line item.
        public var percentage: BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails?
        /// The type of the custom line item that indicates whether the charge is a fee or credit.
        /// This member is required.
        public var type: BillingconductorClientTypes.CustomLineItemType?

        public init(
            flat: BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails? = nil,
            lineItemFilters: [BillingconductorClientTypes.LineItemFilter]? = nil,
            percentage: BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails? = nil,
            type: BillingconductorClientTypes.CustomLineItemType? = nil
        )
        {
            self.flat = flat
            self.lineItemFilters = lineItemFilters
            self.percentage = percentage
            self.type = type
        }
    }

}

extension BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chargeValue = "ChargeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chargeValue = self.chargeValue {
            try encodeContainer.encode(chargeValue, forKey: .chargeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chargeValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .chargeValue)
        chargeValue = chargeValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a flat custom line item.
    public struct ListCustomLineItemFlatChargeDetails: Swift.Equatable {
        /// The custom line item's fixed charge value in USD.
        /// This member is required.
        public var chargeValue: Swift.Double?

        public init(
            chargeValue: Swift.Double? = nil
        )
        {
            self.chargeValue = chargeValue
        }
    }

}

extension BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentageValue = "PercentageValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentageValue = self.percentageValue {
            try encodeContainer.encode(percentageValue, forKey: .percentageValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentageValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentageValue)
        percentageValue = percentageValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a percentage custom line item.
    public struct ListCustomLineItemPercentageChargeDetails: Swift.Equatable {
        /// The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        /// This member is required.
        public var percentageValue: Swift.Double?

        public init(
            percentageValue: Swift.Double? = nil
        )
        {
            self.percentageValue = percentageValue
        }
    }

}

extension BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endBillingPeriod = "EndBillingPeriod"
        case startBillingPeriod = "StartBillingPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endBillingPeriod = self.endBillingPeriod {
            try encodeContainer.encode(endBillingPeriod, forKey: .endBillingPeriod)
        }
        if let startBillingPeriod = self.startBillingPeriod {
            try encodeContainer.encode(startBillingPeriod, forKey: .startBillingPeriod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startBillingPeriod)
        startBillingPeriod = startBillingPeriodDecoded
        let endBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endBillingPeriod)
        endBillingPeriod = endBillingPeriodDecoded
    }
}

extension BillingconductorClientTypes {
    /// A billing period filter that specifies the custom line item versions to retrieve.
    public struct ListCustomLineItemVersionsBillingPeriodRangeFilter: Swift.Equatable {
        /// The exclusive end billing period that defines a billing period range where a custom line item version is applied.
        public var endBillingPeriod: Swift.String?
        /// The inclusive start billing period that defines a billing period range where a custom line item version is applied.
        public var startBillingPeriod: Swift.String?

        public init(
            endBillingPeriod: Swift.String? = nil,
            startBillingPeriod: Swift.String? = nil
        )
        {
            self.endBillingPeriod = endBillingPeriod
            self.startBillingPeriod = startBillingPeriod
        }
    }

}

extension BillingconductorClientTypes.ListCustomLineItemVersionsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriodRange = "BillingPeriodRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension BillingconductorClientTypes {
    /// A filter that specifies the billing period range where the custom line item versions reside.
    public struct ListCustomLineItemVersionsFilter: Swift.Equatable {
        /// The billing period range in which the custom line item version is applied.
        public var billingPeriodRange: BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter?

        public init(
            billingPeriodRange: BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter? = nil
        )
        {
            self.billingPeriodRange = billingPeriodRange
        }
    }

}

extension ListCustomLineItemVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomLineItemVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-custom-line-item-versions"
    }
}

public struct ListCustomLineItemVersionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the custom line item.
    /// This member is required.
    public var arn: Swift.String?
    /// A ListCustomLineItemVersionsFilter that specifies the billing period range in which the custom line item versions are applied.
    public var filters: BillingconductorClientTypes.ListCustomLineItemVersionsFilter?
    /// The maximum number of custom line item versions to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to retrieve custom line item versions.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListCustomLineItemVersionsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomLineItemVersionsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListCustomLineItemVersionsFilter?
}

extension ListCustomLineItemVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemVersionsFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListCustomLineItemVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomLineItemVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.customLineItemVersions = output.customLineItemVersions
            self.nextToken = output.nextToken
        } else {
            self.customLineItemVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomLineItemVersionsOutput: Swift.Equatable {
    /// A list of CustomLineItemVersionListElements that are received.
    public var customLineItemVersions: [BillingconductorClientTypes.CustomLineItemVersionListElement]?
    /// The pagination token that's used on subsequent calls to retrieve custom line item versions.
    public var nextToken: Swift.String?

    public init(
        customLineItemVersions: [BillingconductorClientTypes.CustomLineItemVersionListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customLineItemVersions = customLineItemVersions
        self.nextToken = nextToken
    }
}

struct ListCustomLineItemVersionsOutputBody: Swift.Equatable {
    let customLineItemVersions: [BillingconductorClientTypes.CustomLineItemVersionListElement]?
    let nextToken: Swift.String?
}

extension ListCustomLineItemVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLineItemVersions = "CustomLineItemVersions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customLineItemVersionsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.CustomLineItemVersionListElement?].self, forKey: .customLineItemVersions)
        var customLineItemVersionsDecoded0:[BillingconductorClientTypes.CustomLineItemVersionListElement]? = nil
        if let customLineItemVersionsContainer = customLineItemVersionsContainer {
            customLineItemVersionsDecoded0 = [BillingconductorClientTypes.CustomLineItemVersionListElement]()
            for structure0 in customLineItemVersionsContainer {
                if let structure0 = structure0 {
                    customLineItemVersionsDecoded0?.append(structure0)
                }
            }
        }
        customLineItemVersions = customLineItemVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomLineItemVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.ListCustomLineItemsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case billingGroups = "BillingGroups"
        case names = "Names"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for customlineitemarn0 in arns {
                try arnsContainer.encode(customlineitemarn0)
            }
        }
        if let billingGroups = billingGroups {
            var billingGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .billingGroups)
            for billinggrouparn0 in billingGroups {
                try billingGroupsContainer.encode(billinggrouparn0)
            }
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for customlineitemname0 in names {
                try namesContainer.encode(customlineitemname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let billingGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .billingGroups)
        var billingGroupsDecoded0:[Swift.String]? = nil
        if let billingGroupsContainer = billingGroupsContainer {
            billingGroupsDecoded0 = [Swift.String]()
            for string0 in billingGroupsContainer {
                if let string0 = string0 {
                    billingGroupsDecoded0?.append(string0)
                }
            }
        }
        billingGroups = billingGroupsDecoded0
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// A filter that specifies the custom line items and billing groups to retrieve FFLI information.
    public struct ListCustomLineItemsFilter: Swift.Equatable {
        /// A list of custom line item ARNs to retrieve information.
        public var arns: [Swift.String]?
        /// The billing group Amazon Resource Names (ARNs) to retrieve information.
        public var billingGroups: [Swift.String]?
        /// A list of custom line items to retrieve information.
        public var names: [Swift.String]?

        public init(
            arns: [Swift.String]? = nil,
            billingGroups: [Swift.String]? = nil,
            names: [Swift.String]? = nil
        )
        {
            self.arns = arns
            self.billingGroups = billingGroups
            self.names = names
        }
    }

}

extension ListCustomLineItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCustomLineItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-custom-line-items"
    }
}

public struct ListCustomLineItemsInput: Swift.Equatable {
    /// The preferred billing period to get custom line items (FFLIs).
    public var billingPeriod: Swift.String?
    /// A ListCustomLineItemsFilter that specifies the custom line item names and/or billing group Amazon Resource Names (ARNs) to retrieve FFLI information.
    public var filters: BillingconductorClientTypes.ListCustomLineItemsFilter?
    /// The maximum number of billing groups to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to get custom line items (FFLIs).
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListCustomLineItemsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCustomLineItemsInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListCustomLineItemsFilter?
}

extension ListCustomLineItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemsFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListCustomLineItemsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomLineItemsOutputBody = try responseDecoder.decode(responseBody: data)
            self.customLineItems = output.customLineItems
            self.nextToken = output.nextToken
        } else {
            self.customLineItems = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomLineItemsOutput: Swift.Equatable {
    /// A list of FreeFormLineItemListElements received.
    public var customLineItems: [BillingconductorClientTypes.CustomLineItemListElement]?
    /// The pagination token that's used on subsequent calls to get custom line items (FFLIs).
    public var nextToken: Swift.String?

    public init(
        customLineItems: [BillingconductorClientTypes.CustomLineItemListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customLineItems = customLineItems
        self.nextToken = nextToken
    }
}

struct ListCustomLineItemsOutputBody: Swift.Equatable {
    let customLineItems: [BillingconductorClientTypes.CustomLineItemListElement]?
    let nextToken: Swift.String?
}

extension ListCustomLineItemsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customLineItems = "CustomLineItems"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customLineItemsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.CustomLineItemListElement?].self, forKey: .customLineItems)
        var customLineItemsDecoded0:[BillingconductorClientTypes.CustomLineItemListElement]? = nil
        if let customLineItemsContainer = customLineItemsContainer {
            customLineItemsDecoded0 = [BillingconductorClientTypes.CustomLineItemListElement]()
            for structure0 in customLineItemsContainer {
                if let structure0 = structure0 {
                    customLineItemsDecoded0?.append(structure0)
                }
            }
        }
        customLineItems = customLineItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomLineItemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPricingPlansAssociatedWithPricingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pricingRuleArn = "PricingRuleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pricingRuleArn = self.pricingRuleArn {
            try encodeContainer.encode(pricingRuleArn, forKey: .pricingRuleArn)
        }
    }
}

extension ListPricingPlansAssociatedWithPricingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-pricing-plans-associated-with-pricing-rule"
    }
}

public struct ListPricingPlansAssociatedWithPricingRuleInput: Swift.Equatable {
    /// The pricing plan billing period for which associations will be listed.
    public var billingPeriod: Swift.String?
    /// The optional maximum number of pricing rule associations to retrieve.
    public var maxResults: Swift.Int?
    /// The optional pagination token returned by a previous call.
    public var nextToken: Swift.String?
    /// The pricing rule Amazon Resource Name (ARN) for which associations will be listed.
    /// This member is required.
    public var pricingRuleArn: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pricingRuleArn: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pricingRuleArn = pricingRuleArn
    }
}

struct ListPricingPlansAssociatedWithPricingRuleInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingRuleArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPricingPlansAssociatedWithPricingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pricingRuleArn = "PricingRuleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingRuleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingRuleArn)
        pricingRuleArn = pricingRuleArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingPlansAssociatedWithPricingRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPricingPlansAssociatedWithPricingRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.billingPeriod = output.billingPeriod
            self.nextToken = output.nextToken
            self.pricingPlanArns = output.pricingPlanArns
            self.pricingRuleArn = output.pricingRuleArn
        } else {
            self.billingPeriod = nil
            self.nextToken = nil
            self.pricingPlanArns = nil
            self.pricingRuleArn = nil
        }
    }
}

public struct ListPricingPlansAssociatedWithPricingRuleOutput: Swift.Equatable {
    /// The pricing plan billing period for which associations will be listed.
    public var billingPeriod: Swift.String?
    /// The pagination token to be used on subsequent calls.
    public var nextToken: Swift.String?
    /// The list containing pricing plans that are associated with the requested pricing rule.
    public var pricingPlanArns: [Swift.String]?
    /// The pricing rule Amazon Resource Name (ARN) for which associations will be listed.
    public var pricingRuleArn: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingPlanArns: [Swift.String]? = nil,
        pricingRuleArn: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingPlanArns = pricingPlanArns
        self.pricingRuleArn = pricingRuleArn
    }
}

struct ListPricingPlansAssociatedWithPricingRuleOutputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingRuleArn: Swift.String?
    let pricingPlanArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPricingPlansAssociatedWithPricingRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case nextToken = "NextToken"
        case pricingPlanArns = "PricingPlanArns"
        case pricingRuleArn = "PricingRuleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingRuleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingRuleArn)
        pricingRuleArn = pricingRuleArnDecoded
        let pricingPlanArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingPlanArns)
        var pricingPlanArnsDecoded0:[Swift.String]? = nil
        if let pricingPlanArnsContainer = pricingPlanArnsContainer {
            pricingPlanArnsDecoded0 = [Swift.String]()
            for string0 in pricingPlanArnsContainer {
                if let string0 = string0 {
                    pricingPlanArnsDecoded0?.append(string0)
                }
            }
        }
        pricingPlanArns = pricingPlanArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPricingPlansAssociatedWithPricingRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.ListPricingPlansFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for pricingplanarn0 in arns {
                try arnsContainer.encode(pricingplanarn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// The filter that specifies the Amazon Resource Names (ARNs) of pricing plans, to retrieve pricing plan information.
    public struct ListPricingPlansFilter: Swift.Equatable {
        /// A list of pricing plan Amazon Resource Names (ARNs) to retrieve information.
        public var arns: [Swift.String]?

        public init(
            arns: [Swift.String]? = nil
        )
        {
            self.arns = arns
        }
    }

}

extension ListPricingPlansInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPricingPlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-pricing-plans"
    }
}

public struct ListPricingPlansInput: Swift.Equatable {
    /// The preferred billing period to get pricing plan.
    public var billingPeriod: Swift.String?
    /// A ListPricingPlansFilter that specifies the Amazon Resource Name (ARNs) of pricing plans to retrieve pricing plans information.
    public var filters: BillingconductorClientTypes.ListPricingPlansFilter?
    /// The maximum number of pricing plans to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent call to get pricing plans.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListPricingPlansFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPricingPlansInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let filters: BillingconductorClientTypes.ListPricingPlansFilter?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPricingPlansInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListPricingPlansFilter.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingPlansOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPricingPlansOutputBody = try responseDecoder.decode(responseBody: data)
            self.billingPeriod = output.billingPeriod
            self.nextToken = output.nextToken
            self.pricingPlans = output.pricingPlans
        } else {
            self.billingPeriod = nil
            self.nextToken = nil
            self.pricingPlans = nil
        }
    }
}

public struct ListPricingPlansOutput: Swift.Equatable {
    /// The billing period for which the described pricing plans are applicable.
    public var billingPeriod: Swift.String?
    /// The pagination token that's used on subsequent calls to get pricing plans.
    public var nextToken: Swift.String?
    /// A list of PricingPlanListElement retrieved.
    public var pricingPlans: [BillingconductorClientTypes.PricingPlanListElement]?

    public init(
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingPlans: [BillingconductorClientTypes.PricingPlanListElement]? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingPlans = pricingPlans
    }
}

struct ListPricingPlansOutputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingPlans: [BillingconductorClientTypes.PricingPlanListElement]?
    let nextToken: Swift.String?
}

extension ListPricingPlansOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case nextToken = "NextToken"
        case pricingPlans = "PricingPlans"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingPlansContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.PricingPlanListElement?].self, forKey: .pricingPlans)
        var pricingPlansDecoded0:[BillingconductorClientTypes.PricingPlanListElement]? = nil
        if let pricingPlansContainer = pricingPlansContainer {
            pricingPlansDecoded0 = [BillingconductorClientTypes.PricingPlanListElement]()
            for structure0 in pricingPlansContainer {
                if let structure0 = structure0 {
                    pricingPlansDecoded0?.append(structure0)
                }
            }
        }
        pricingPlans = pricingPlansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPricingPlansOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPricingRulesAssociatedToPricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pricingPlanArn = "PricingPlanArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pricingPlanArn = self.pricingPlanArn {
            try encodeContainer.encode(pricingPlanArn, forKey: .pricingPlanArn)
        }
    }
}

extension ListPricingRulesAssociatedToPricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-pricing-rules-associated-to-pricing-plan"
    }
}

public struct ListPricingRulesAssociatedToPricingPlanInput: Swift.Equatable {
    /// The billing period for which the pricing rule associations are to be listed.
    public var billingPeriod: Swift.String?
    /// The optional maximum number of pricing rule associations to retrieve.
    public var maxResults: Swift.Int?
    /// The optional pagination token returned by a previous call.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the pricing plan for which associations are to be listed.
    /// This member is required.
    public var pricingPlanArn: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pricingPlanArn: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pricingPlanArn = pricingPlanArn
    }
}

struct ListPricingRulesAssociatedToPricingPlanInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingPlanArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPricingRulesAssociatedToPricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pricingPlanArn = "PricingPlanArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanArn)
        pricingPlanArn = pricingPlanArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingRulesAssociatedToPricingPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPricingRulesAssociatedToPricingPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.billingPeriod = output.billingPeriod
            self.nextToken = output.nextToken
            self.pricingPlanArn = output.pricingPlanArn
            self.pricingRuleArns = output.pricingRuleArns
        } else {
            self.billingPeriod = nil
            self.nextToken = nil
            self.pricingPlanArn = nil
            self.pricingRuleArns = nil
        }
    }
}

public struct ListPricingRulesAssociatedToPricingPlanOutput: Swift.Equatable {
    /// The billing period for which the pricing rule associations are listed.
    public var billingPeriod: Swift.String?
    /// The pagination token to be used on subsequent calls.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the pricing plan for which associations are listed.
    public var pricingPlanArn: Swift.String?
    /// A list containing pricing rules that are associated with the requested pricing plan.
    public var pricingRuleArns: [Swift.String]?

    public init(
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingPlanArn: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingPlanArn = pricingPlanArn
        self.pricingRuleArns = pricingRuleArns
    }
}

struct ListPricingRulesAssociatedToPricingPlanOutputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingPlanArn: Swift.String?
    let pricingRuleArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPricingRulesAssociatedToPricingPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case nextToken = "NextToken"
        case pricingPlanArn = "PricingPlanArn"
        case pricingRuleArns = "PricingRuleArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanArn)
        pricingPlanArn = pricingPlanArnDecoded
        let pricingRuleArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pricingRuleArns)
        var pricingRuleArnsDecoded0:[Swift.String]? = nil
        if let pricingRuleArnsContainer = pricingRuleArnsContainer {
            pricingRuleArnsDecoded0 = [Swift.String]()
            for string0 in pricingRuleArnsContainer {
                if let string0 = string0 {
                    pricingRuleArnsDecoded0?.append(string0)
                }
            }
        }
        pricingRuleArns = pricingRuleArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPricingRulesAssociatedToPricingPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.ListPricingRulesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for pricingrulearn0 in arns {
                try arnsContainer.encode(pricingrulearn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BillingconductorClientTypes {
    /// The filter that specifies criteria that the pricing rules returned by the ListPricingRules API will adhere to.
    public struct ListPricingRulesFilter: Swift.Equatable {
        /// A list containing the pricing rule Amazon Resource Names (ARNs) to include in the API response.
        public var arns: [Swift.String]?

        public init(
            arns: [Swift.String]? = nil
        )
        {
            self.arns = arns
        }
    }

}

extension ListPricingRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPricingRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-pricing-rules"
    }
}

public struct ListPricingRulesInput: Swift.Equatable {
    /// The preferred billing period to get the pricing plan.
    public var billingPeriod: Swift.String?
    /// A DescribePricingRuleFilter that specifies the Amazon Resource Name (ARNs) of pricing rules to retrieve pricing rules information.
    public var filters: BillingconductorClientTypes.ListPricingRulesFilter?
    /// The maximum number of pricing rules to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent call to get pricing rules.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListPricingRulesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPricingRulesInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let filters: BillingconductorClientTypes.ListPricingRulesFilter?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPricingRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListPricingRulesFilter.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPricingRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPricingRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.billingPeriod = output.billingPeriod
            self.nextToken = output.nextToken
            self.pricingRules = output.pricingRules
        } else {
            self.billingPeriod = nil
            self.nextToken = nil
            self.pricingRules = nil
        }
    }
}

public struct ListPricingRulesOutput: Swift.Equatable {
    /// The billing period for which the described pricing rules are applicable.
    public var billingPeriod: Swift.String?
    /// The pagination token that's used on subsequent calls to get pricing rules.
    public var nextToken: Swift.String?
    /// A list containing the described pricing rules.
    public var pricingRules: [BillingconductorClientTypes.PricingRuleListElement]?

    public init(
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingRules: [BillingconductorClientTypes.PricingRuleListElement]? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingRules = pricingRules
    }
}

struct ListPricingRulesOutputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let pricingRules: [BillingconductorClientTypes.PricingRuleListElement]?
    let nextToken: Swift.String?
}

extension ListPricingRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingPeriod = "BillingPeriod"
        case nextToken = "NextToken"
        case pricingRules = "PricingRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let pricingRulesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.PricingRuleListElement?].self, forKey: .pricingRules)
        var pricingRulesDecoded0:[BillingconductorClientTypes.PricingRuleListElement]? = nil
        if let pricingRulesContainer = pricingRulesContainer {
            pricingRulesDecoded0 = [BillingconductorClientTypes.PricingRuleListElement]()
            for structure0 in pricingRulesContainer {
                if let structure0 = structure0 {
                    pricingRulesDecoded0?.append(structure0)
                }
            }
        }
        pricingRules = pricingRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPricingRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relationship = "Relationship"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relationship = self.relationship {
            try encodeContainer.encode(relationship.rawValue, forKey: .relationship)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relationshipDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemRelationship.self, forKey: .relationship)
        relationship = relationshipDecoded
    }
}

extension BillingconductorClientTypes {
    /// A filter that specifies the type of resource associations that should be retrieved for a custom line item.
    public struct ListResourcesAssociatedToCustomLineItemFilter: Swift.Equatable {
        /// The type of relationship between the custom line item and the associated resource.
        public var relationship: BillingconductorClientTypes.CustomLineItemRelationship?

        public init(
            relationship: BillingconductorClientTypes.CustomLineItemRelationship? = nil
        )
        {
            self.relationship = relationship
        }
    }

}

extension ListResourcesAssociatedToCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingPeriod = self.billingPeriod {
            try encodeContainer.encode(billingPeriod, forKey: .billingPeriod)
        }
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListResourcesAssociatedToCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-resources-associated-to-custom-line-item"
    }
}

public struct ListResourcesAssociatedToCustomLineItemInput: Swift.Equatable {
    /// The ARN of the custom line item for which the resource associations will be listed.
    /// This member is required.
    public var arn: Swift.String?
    /// The billing period for which the resource associations will be listed.
    public var billingPeriod: Swift.String?
    /// (Optional) A ListResourcesAssociatedToCustomLineItemFilter that can specify the types of resources that should be retrieved.
    public var filters: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter?
    /// (Optional) The maximum number of resource associations to be retrieved.
    public var maxResults: Swift.Int?
    /// (Optional) The pagination token that's returned by a previous request.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourcesAssociatedToCustomLineItemInputBody: Swift.Equatable {
    let billingPeriod: Swift.String?
    let arn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter?
}

extension ListResourcesAssociatedToCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriod = "BillingPeriod"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingPeriod)
        billingPeriod = billingPeriodDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter.self, forKey: .filters)
        filters = filtersDecoded
    }
}

extension ListResourcesAssociatedToCustomLineItemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourcesAssociatedToCustomLineItemOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatedResources = output.associatedResources
            self.nextToken = output.nextToken
        } else {
            self.arn = nil
            self.associatedResources = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourcesAssociatedToCustomLineItemOutput: Swift.Equatable {
    /// The custom line item ARN for which the resource associations are listed.
    public var arn: Swift.String?
    /// A list of ListResourcesAssociatedToCustomLineItemResponseElement for each resource association retrieved.
    public var associatedResources: [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]?
    /// The pagination token to be used in subsequent requests to retrieve additional results.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        associatedResources: [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.associatedResources = associatedResources
        self.nextToken = nextToken
    }
}

struct ListResourcesAssociatedToCustomLineItemOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let associatedResources: [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]?
    let nextToken: Swift.String?
}

extension ListResourcesAssociatedToCustomLineItemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associatedResources = "AssociatedResources"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let associatedResourcesContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement?].self, forKey: .associatedResources)
        var associatedResourcesDecoded0:[BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]? = nil
        if let associatedResourcesContainer = associatedResourcesContainer {
            associatedResourcesDecoded0 = [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]()
            for structure0 in associatedResourcesContainer {
                if let structure0 = structure0 {
                    associatedResourcesDecoded0?.append(structure0)
                }
            }
        }
        associatedResources = associatedResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourcesAssociatedToCustomLineItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case endBillingPeriod = "EndBillingPeriod"
        case relationship = "Relationship"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let endBillingPeriod = self.endBillingPeriod {
            try encodeContainer.encode(endBillingPeriod, forKey: .endBillingPeriod)
        }
        if let relationship = self.relationship {
            try encodeContainer.encode(relationship.rawValue, forKey: .relationship)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let relationshipDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemRelationship.self, forKey: .relationship)
        relationship = relationshipDecoded
        let endBillingPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endBillingPeriod)
        endBillingPeriod = endBillingPeriodDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of a resource association for a custom line item.
    public struct ListResourcesAssociatedToCustomLineItemResponseElement: Swift.Equatable {
        /// The ARN of the associated resource.
        public var arn: Swift.String?
        /// The end billing period of the associated resource.
        public var endBillingPeriod: Swift.String?
        /// The type of relationship between the custom line item and the associated resource.
        public var relationship: BillingconductorClientTypes.CustomLineItemRelationship?

        public init(
            arn: Swift.String? = nil,
            endBillingPeriod: Swift.String? = nil,
            relationship: BillingconductorClientTypes.CustomLineItemRelationship? = nil
        )
        {
            self.arn = arn
            self.endBillingPeriod = endBillingPeriod
            self.relationship = relationship
        }
    }

}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes {
    public enum MatchOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MatchOption(rawValue: rawValue) ?? MatchOption.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes.PricingPlanListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension BillingconductorClientTypes.PricingPlanListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PricingPlanListElement(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), size: \(Swift.String(describing: size)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a pricing plan.
    public struct PricingPlanListElement: Swift.Equatable {
        /// The pricing plan Amazon Resource Names (ARN). This can be used to uniquely identify a pricing plan.
        public var arn: Swift.String?
        /// The time when the pricing plan was created.
        public var creationTime: Swift.Int
        /// The pricing plan description.
        public var description: Swift.String?
        /// The most recent time when the pricing plan was modified.
        public var lastModifiedTime: Swift.Int
        /// The name of a pricing plan.
        public var name: Swift.String?
        /// The pricing rules count that's currently associated with this pricing plan list element.
        public var size: Swift.Int

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.size = size
        }
    }

}

extension BillingconductorClientTypes.PricingRuleListElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associatedPricingPlanCount = "AssociatedPricingPlanCount"
        case billingEntity = "BillingEntity"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case operation = "Operation"
        case scope = "Scope"
        case service = "Service"
        case tiering = "Tiering"
        case type = "Type"
        case usageType = "UsageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if associatedPricingPlanCount != 0 {
            try encodeContainer.encode(associatedPricingPlanCount, forKey: .associatedPricingPlanCount)
        }
        if let billingEntity = self.billingEntity {
            try encodeContainer.encode(billingEntity, forKey: .billingEntity)
        }
        if creationTime != 0 {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let modifierPercentage = self.modifierPercentage {
            try encodeContainer.encode(modifierPercentage, forKey: .modifierPercentage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let tiering = self.tiering {
            try encodeContainer.encode(tiering, forKey: .tiering)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleScope.self, forKey: .scope)
        scope = scopeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleType.self, forKey: .type)
        type = typeDecoded
        let modifierPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .modifierPercentage)
        modifierPercentage = modifierPercentageDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let associatedPricingPlanCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associatedPricingPlanCount) ?? 0
        associatedPricingPlanCount = associatedPricingPlanCountDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .creationTime) ?? 0
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let billingEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingEntity)
        billingEntity = billingEntityDecoded
        let tieringDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.Tiering.self, forKey: .tiering)
        tiering = tieringDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
    }
}

extension BillingconductorClientTypes.PricingRuleListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PricingRuleListElement(arn: \(Swift.String(describing: arn)), associatedPricingPlanCount: \(Swift.String(describing: associatedPricingPlanCount)), billingEntity: \(Swift.String(describing: billingEntity)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), operation: \(Swift.String(describing: operation)), scope: \(Swift.String(describing: scope)), service: \(Swift.String(describing: service)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), usageType: \(Swift.String(describing: usageType)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A representation of a pricing rule.
    public struct PricingRuleListElement: Swift.Equatable {
        /// The Amazon Resource Name (ARN) used to uniquely identify a pricing rule.
        public var arn: Swift.String?
        /// The pricing plans count that this pricing rule is associated with.
        public var associatedPricingPlanCount: Swift.Int
        /// The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
        public var billingEntity: Swift.String?
        /// The time when the pricing rule was created.
        public var creationTime: Swift.Int
        /// The pricing rule description.
        public var description: Swift.String?
        /// The most recent time when the pricing rule was modified.
        public var lastModifiedTime: Swift.Int
        /// A percentage modifier applied on the public pricing rates.
        public var modifierPercentage: Swift.Double?
        /// The name of a pricing rule.
        public var name: Swift.String?
        /// Operation is the specific Amazon Web Services action covered by this line item. This describes the specific usage of the line item. If the Scope attribute is set to SKU, this attribute indicates which operation the PricingRule is modifying. For example, a value of RunInstances:0202 indicates the operation of running an Amazon EC2 instance.
        public var operation: Swift.String?
        /// The scope of pricing rule that indicates if it is globally applicable, or if it is service-specific.
        public var scope: BillingconductorClientTypes.PricingRuleScope?
        /// If the Scope attribute is SERVICE, this attribute indicates which service the PricingRule is applicable for.
        public var service: Swift.String?
        /// The set of tiering configurations for the pricing rule.
        public var tiering: BillingconductorClientTypes.Tiering?
        /// The type of pricing rule.
        public var type: BillingconductorClientTypes.PricingRuleType?
        /// Usage type is the unit that each service uses to measure the usage of a specific type of resource. If the Scope attribute is set to SKU, this attribute indicates which usage type the PricingRule is modifying. For example, USW2-BoxUsage:m2.2xlarge describes an M2 High Memory Double Extra Large instance in the US West (Oregon) Region.
        public var usageType: Swift.String?

        public init(
            arn: Swift.String? = nil,
            associatedPricingPlanCount: Swift.Int = 0,
            billingEntity: Swift.String? = nil,
            creationTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            modifierPercentage: Swift.Double? = nil,
            name: Swift.String? = nil,
            operation: Swift.String? = nil,
            scope: BillingconductorClientTypes.PricingRuleScope? = nil,
            service: Swift.String? = nil,
            tiering: BillingconductorClientTypes.Tiering? = nil,
            type: BillingconductorClientTypes.PricingRuleType? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.arn = arn
            self.associatedPricingPlanCount = associatedPricingPlanCount
            self.billingEntity = billingEntity
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.modifierPercentage = modifierPercentage
            self.name = name
            self.operation = operation
            self.scope = scope
            self.service = service
            self.tiering = tiering
            self.type = type
            self.usageType = usageType
        }
    }

}

extension BillingconductorClientTypes {
    public enum PricingRuleScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case billingEntity
        case global
        case service
        case sku
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingRuleScope] {
            return [
                .billingEntity,
                .global,
                .service,
                .sku,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .billingEntity: return "BILLING_ENTITY"
            case .global: return "GLOBAL"
            case .service: return "SERVICE"
            case .sku: return "SKU"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingRuleScope(rawValue: rawValue) ?? PricingRuleScope.sdkUnknown(rawValue)
        }
    }
}

extension BillingconductorClientTypes {
    public enum PricingRuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case discount
        case markup
        case tiering
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingRuleType] {
            return [
                .discount,
                .markup,
                .tiering,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .discount: return "DISCOUNT"
            case .markup: return "MARKUP"
            case .tiering: return "TIERING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PricingRuleType(rawValue: rawValue) ?? PricingRuleType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Resource identifier that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Resource type that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.limitCode = output.limitCode
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.limitCode = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service limit to exceed.
public struct ServiceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The unique code identifier of the service limit that is being exceeded.
        /// This member is required.
        public internal(set) var limitCode: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
        /// The unique code for the service of the limit that is being exceeded.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limitCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.limitCode = limitCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let limitCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitCode = "LimitCode"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitCode)
        limitCode = limitCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource as a list of key-value pairs.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Number of seconds you can safely retry after the call.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BillingconductorClientTypes.Tiering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTier = "FreeTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let freeTier = self.freeTier {
            try encodeContainer.encode(freeTier, forKey: .freeTier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeTierDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.FreeTierConfig.self, forKey: .freeTier)
        freeTier = freeTierDecoded
    }
}

extension BillingconductorClientTypes {
    /// The set of tiering configurations for the pricing rule.
    public struct Tiering: Swift.Equatable {
        /// The possible Amazon Web Services Free Tier configurations.
        /// This member is required.
        public var freeTier: BillingconductorClientTypes.FreeTierConfig?

        public init(
            freeTier: BillingconductorClientTypes.FreeTierConfig? = nil
        )
        {
            self.freeTier = freeTier
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which to delete tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to delete from the resource as a list of key-value pairs.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.UpdateBillingGroupAccountGrouping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAssociate = "AutoAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoAssociate = self.autoAssociate {
            try encodeContainer.encode(autoAssociate, forKey: .autoAssociate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAssociate)
        autoAssociate = autoAssociateDecoded
    }
}

extension BillingconductorClientTypes {
    /// Specifies if the billing group has the following features enabled.
    public struct UpdateBillingGroupAccountGrouping: Swift.Equatable {
        /// Specifies if this billing group will automatically associate newly added Amazon Web Services accounts that join your consolidated billing family.
        public var autoAssociate: Swift.Bool?

        public init(
            autoAssociate: Swift.Bool? = nil
        )
        {
            self.autoAssociate = autoAssociate
        }
    }

}

extension UpdateBillingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBillingGroupInput(accountGrouping: \(Swift.String(describing: accountGrouping)), arn: \(Swift.String(describing: arn)), computationPreference: \(Swift.String(describing: computationPreference)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateBillingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountGrouping = "AccountGrouping"
        case arn = "Arn"
        case computationPreference = "ComputationPreference"
        case description = "Description"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountGrouping = self.accountGrouping {
            try encodeContainer.encode(accountGrouping, forKey: .accountGrouping)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computationPreference = self.computationPreference {
            try encodeContainer.encode(computationPreference, forKey: .computationPreference)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateBillingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-billing-group"
    }
}

public struct UpdateBillingGroupInput: Swift.Equatable {
    /// Specifies if the billing group has automatic account association (AutoAssociate) enabled.
    public var accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping?
    /// The Amazon Resource Name (ARN) of the billing group being updated.
    /// This member is required.
    public var arn: Swift.String?
    /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
    public var computationPreference: BillingconductorClientTypes.ComputationPreference?
    /// A description of the billing group.
    public var description: Swift.String?
    /// The name of the billing group. The names must be unique to each billing group.
    public var name: Swift.String?
    /// The status of the billing group. Only one of the valid values can be used.
    public var status: BillingconductorClientTypes.BillingGroupStatus?

    public init(
        accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping? = nil,
        arn: Swift.String? = nil,
        computationPreference: BillingconductorClientTypes.ComputationPreference? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BillingconductorClientTypes.BillingGroupStatus? = nil
    )
    {
        self.accountGrouping = accountGrouping
        self.arn = arn
        self.computationPreference = computationPreference
        self.description = description
        self.name = name
        self.status = status
    }
}

struct UpdateBillingGroupInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let status: BillingconductorClientTypes.BillingGroupStatus?
    let computationPreference: BillingconductorClientTypes.ComputationPreference?
    let description: Swift.String?
    let accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping?
}

extension UpdateBillingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountGrouping = "AccountGrouping"
        case arn = "Arn"
        case computationPreference = "ComputationPreference"
        case description = "Description"
        case name = "Name"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.BillingGroupStatus.self, forKey: .status)
        status = statusDecoded
        let computationPreferenceDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ComputationPreference.self, forKey: .computationPreference)
        computationPreference = computationPreferenceDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let accountGroupingDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateBillingGroupAccountGrouping.self, forKey: .accountGrouping)
        accountGrouping = accountGroupingDecoded
    }
}

extension UpdateBillingGroupOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBillingGroupOutput(accountGrouping: \(Swift.String(describing: accountGrouping)), arn: \(Swift.String(describing: arn)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), pricingPlanArn: \(Swift.String(describing: pricingPlanArn)), primaryAccountId: \(Swift.String(describing: primaryAccountId)), size: \(Swift.String(describing: size)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateBillingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBillingGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountGrouping = output.accountGrouping
            self.arn = output.arn
            self.description = output.description
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.pricingPlanArn = output.pricingPlanArn
            self.primaryAccountId = output.primaryAccountId
            self.size = output.size
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.accountGrouping = nil
            self.arn = nil
            self.description = nil
            self.lastModifiedTime = 0
            self.name = nil
            self.pricingPlanArn = nil
            self.primaryAccountId = nil
            self.size = 0
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct UpdateBillingGroupOutput: Swift.Equatable {
    /// Specifies if the billing group has automatic account association (AutoAssociate) enabled.
    public var accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping?
    /// The Amazon Resource Name (ARN) of the billing group that was updated.
    public var arn: Swift.String?
    /// A description of the billing group.
    public var description: Swift.String?
    /// The most recent time when the billing group was modified.
    public var lastModifiedTime: Swift.Int
    /// The name of the billing group. The names must be unique to each billing group.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the pricing plan to compute Amazon Web Services charges for the billing group.
    public var pricingPlanArn: Swift.String?
    /// The account ID that serves as the main account in a billing group.
    public var primaryAccountId: Swift.String?
    /// The number of accounts in the particular billing group.
    public var size: Swift.Int
    /// The status of the billing group. Only one of the valid values can be used.
    public var status: BillingconductorClientTypes.BillingGroupStatus?
    /// The reason why the billing group is in its current status.
    public var statusReason: Swift.String?

    public init(
        accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        name: Swift.String? = nil,
        pricingPlanArn: Swift.String? = nil,
        primaryAccountId: Swift.String? = nil,
        size: Swift.Int = 0,
        status: BillingconductorClientTypes.BillingGroupStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.accountGrouping = accountGrouping
        self.arn = arn
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.pricingPlanArn = pricingPlanArn
        self.primaryAccountId = primaryAccountId
        self.size = size
        self.status = status
        self.statusReason = statusReason
    }
}

struct UpdateBillingGroupOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let primaryAccountId: Swift.String?
    let pricingPlanArn: Swift.String?
    let size: Swift.Int
    let lastModifiedTime: Swift.Int
    let status: BillingconductorClientTypes.BillingGroupStatus?
    let statusReason: Swift.String?
    let accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping?
}

extension UpdateBillingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountGrouping = "AccountGrouping"
        case arn = "Arn"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case pricingPlanArn = "PricingPlanArn"
        case primaryAccountId = "PrimaryAccountId"
        case size = "Size"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let primaryAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryAccountId)
        primaryAccountId = primaryAccountIdDecoded
        let pricingPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricingPlanArn)
        pricingPlanArn = pricingPlanArnDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.BillingGroupStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let accountGroupingDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateBillingGroupAccountGrouping.self, forKey: .accountGrouping)
        accountGrouping = accountGroupingDecoded
    }
}

enum UpdateBillingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.UpdateCustomLineItemChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flat = "Flat"
        case lineItemFilters = "LineItemFilters"
        case percentage = "Percentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flat = self.flat {
            try encodeContainer.encode(flat, forKey: .flat)
        }
        if let lineItemFilters = lineItemFilters {
            var lineItemFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineItemFilters)
            for lineitemfilter0 in lineItemFilters {
                try lineItemFiltersContainer.encode(lineitemfilter0)
            }
        }
        if let percentage = self.percentage {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flatDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails.self, forKey: .flat)
        flat = flatDecoded
        let percentageDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails.self, forKey: .percentage)
        percentage = percentageDecoded
        let lineItemFiltersContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.LineItemFilter?].self, forKey: .lineItemFilters)
        var lineItemFiltersDecoded0:[BillingconductorClientTypes.LineItemFilter]? = nil
        if let lineItemFiltersContainer = lineItemFiltersContainer {
            lineItemFiltersDecoded0 = [BillingconductorClientTypes.LineItemFilter]()
            for structure0 in lineItemFiltersContainer {
                if let structure0 = structure0 {
                    lineItemFiltersDecoded0?.append(structure0)
                }
            }
        }
        lineItemFilters = lineItemFiltersDecoded0
    }
}

extension BillingconductorClientTypes {
    /// A representation of the new charge details of a custom line item. This should contain only one of Flat or Percentage.
    public struct UpdateCustomLineItemChargeDetails: Swift.Equatable {
        /// An UpdateCustomLineItemFlatChargeDetails that describes the new charge details of a flat custom line item.
        public var flat: BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails?
        /// A representation of the line item filter.
        public var lineItemFilters: [BillingconductorClientTypes.LineItemFilter]?
        /// An UpdateCustomLineItemPercentageChargeDetails that describes the new charge details of a percentage custom line item.
        public var percentage: BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails?

        public init(
            flat: BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails? = nil,
            lineItemFilters: [BillingconductorClientTypes.LineItemFilter]? = nil,
            percentage: BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails? = nil
        )
        {
            self.flat = flat
            self.lineItemFilters = lineItemFilters
            self.percentage = percentage
        }
    }

}

extension BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chargeValue = "ChargeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chargeValue = self.chargeValue {
            try encodeContainer.encode(chargeValue, forKey: .chargeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chargeValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .chargeValue)
        chargeValue = chargeValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the new charge details that are associated with a flat custom line item.
    public struct UpdateCustomLineItemFlatChargeDetails: Swift.Equatable {
        /// The custom line item's new fixed charge value in USD.
        /// This member is required.
        public var chargeValue: Swift.Double?

        public init(
            chargeValue: Swift.Double? = nil
        )
        {
            self.chargeValue = chargeValue
        }
    }

}

extension UpdateCustomLineItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomLineItemInput(arn: \(Swift.String(describing: arn)), billingPeriodRange: \(Swift.String(describing: billingPeriodRange)), chargeDetails: \(Swift.String(describing: chargeDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateCustomLineItemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriodRange = "BillingPeriodRange"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let billingPeriodRange = self.billingPeriodRange {
            try encodeContainer.encode(billingPeriodRange, forKey: .billingPeriodRange)
        }
        if let chargeDetails = self.chargeDetails {
            try encodeContainer.encode(chargeDetails, forKey: .chargeDetails)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCustomLineItemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-custom-line-item"
    }
}

public struct UpdateCustomLineItemInput: Swift.Equatable {
    /// The ARN of the custom line item to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A ListCustomLineItemChargeDetails containing the new charge details for the custom line item.
    public var chargeDetails: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails?
    /// The new line item description of the custom line item.
    public var description: Swift.String?
    /// The new name for the custom line item.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        chargeDetails: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.billingPeriodRange = billingPeriodRange
        self.chargeDetails = chargeDetails
        self.description = description
        self.name = name
    }
}

struct UpdateCustomLineItemInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let chargeDetails: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails?
    let billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
}

extension UpdateCustomLineItemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case billingPeriodRange = "BillingPeriodRange"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateCustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
        let billingPeriodRangeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.CustomLineItemBillingPeriodRange.self, forKey: .billingPeriodRange)
        billingPeriodRange = billingPeriodRangeDecoded
    }
}

extension UpdateCustomLineItemOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomLineItemOutput(arn: \(Swift.String(describing: arn)), associationSize: \(Swift.String(describing: associationSize)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), chargeDetails: \(Swift.String(describing: chargeDetails)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateCustomLineItemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCustomLineItemOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associationSize = output.associationSize
            self.billingGroupArn = output.billingGroupArn
            self.chargeDetails = output.chargeDetails
            self.description = output.description
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
        } else {
            self.arn = nil
            self.associationSize = 0
            self.billingGroupArn = nil
            self.chargeDetails = nil
            self.description = nil
            self.lastModifiedTime = 0
            self.name = nil
        }
    }
}

public struct UpdateCustomLineItemOutput: Swift.Equatable {
    /// The ARN of the successfully updated custom line item.
    public var arn: Swift.String?
    /// The number of resources that are associated to the custom line item.
    public var associationSize: Swift.Int
    /// The ARN of the billing group that the custom line item is applied to.
    public var billingGroupArn: Swift.String?
    /// A ListCustomLineItemChargeDetails containing the charge details of the successfully updated custom line item.
    public var chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
    /// The description of the successfully updated custom line item.
    public var description: Swift.String?
    /// The most recent time when the custom line item was modified.
    public var lastModifiedTime: Swift.Int
    /// The name of the successfully updated custom line item.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        associationSize: Swift.Int = 0,
        billingGroupArn: Swift.String? = nil,
        chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.associationSize = associationSize
        self.billingGroupArn = billingGroupArn
        self.chargeDetails = chargeDetails
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.name = name
    }
}

struct UpdateCustomLineItemOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let billingGroupArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
    let lastModifiedTime: Swift.Int
    let associationSize: Swift.Int
}

extension UpdateCustomLineItemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associationSize = "AssociationSize"
        case billingGroupArn = "BillingGroupArn"
        case chargeDetails = "ChargeDetails"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let billingGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingGroupArn)
        billingGroupArn = billingGroupArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let chargeDetailsDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ListCustomLineItemChargeDetails.self, forKey: .chargeDetails)
        chargeDetails = chargeDetailsDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let associationSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associationSize) ?? 0
        associationSize = associationSizeDecoded
    }
}

enum UpdateCustomLineItemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentageValue = "PercentageValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentageValue = self.percentageValue {
            try encodeContainer.encode(percentageValue, forKey: .percentageValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentageValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentageValue)
        percentageValue = percentageValueDecoded
    }
}

extension BillingconductorClientTypes {
    /// A representation of the new charge details that are associated with a percentage custom line item.
    public struct UpdateCustomLineItemPercentageChargeDetails: Swift.Equatable {
        /// The custom line item's new percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        /// This member is required.
        public var percentageValue: Swift.Double?

        public init(
            percentageValue: Swift.Double? = nil
        )
        {
            self.percentageValue = percentageValue
        }
    }

}

extension BillingconductorClientTypes.UpdateFreeTierConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activated = "Activated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activated = self.activated {
            try encodeContainer.encode(activated, forKey: .activated)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activated)
        activated = activatedDecoded
    }
}

extension BillingconductorClientTypes {
    /// The possible Amazon Web Services Free Tier configurations.
    public struct UpdateFreeTierConfig: Swift.Equatable {
        /// Activate or deactivate application of Amazon Web Services Free Tier.
        /// This member is required.
        public var activated: Swift.Bool?

        public init(
            activated: Swift.Bool? = nil
        )
        {
            self.activated = activated
        }
    }

}

extension UpdatePricingPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingPlanInput(arn: \(Swift.String(describing: arn)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePricingPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdatePricingPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-pricing-plan"
    }
}

public struct UpdatePricingPlanInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing plan that you're updating.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the pricing plan.
    public var description: Swift.String?
    /// The name of the pricing plan. The name must be unique to each pricing plan.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.name = name
    }
}

struct UpdatePricingPlanInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdatePricingPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdatePricingPlanOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingPlanOutput(arn: \(Swift.String(describing: arn)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), size: \(Swift.String(describing: size)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePricingPlanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePricingPlanOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.description = output.description
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.size = output.size
        } else {
            self.arn = nil
            self.description = nil
            self.lastModifiedTime = 0
            self.name = nil
            self.size = 0
        }
    }
}

public struct UpdatePricingPlanOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated pricing plan.
    public var arn: Swift.String?
    /// The new description for the pricing rule.
    public var description: Swift.String?
    /// The most recent time when the pricing plan was modified.
    public var lastModifiedTime: Swift.Int
    /// The name of the pricing plan. The name must be unique to each pricing plan.
    public var name: Swift.String?
    /// The pricing rules count that's currently associated with this pricing plan list.
    public var size: Swift.Int

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        name: Swift.String? = nil,
        size: Swift.Int = 0
    )
    {
        self.arn = arn
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.size = size
    }
}

struct UpdatePricingPlanOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let size: Swift.Int
    let lastModifiedTime: Swift.Int
}

extension UpdatePricingPlanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case size = "Size"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

enum UpdatePricingPlanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePricingRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingRuleInput(arn: \(Swift.String(describing: arn)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePricingRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case tiering = "Tiering"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modifierPercentage = self.modifierPercentage {
            try encodeContainer.encode(modifierPercentage, forKey: .modifierPercentage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tiering = self.tiering {
            try encodeContainer.encode(tiering, forKey: .tiering)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdatePricingRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-pricing-rule"
    }
}

public struct UpdatePricingRuleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the pricing rule to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The new description for the pricing rule.
    public var description: Swift.String?
    /// The new modifier to show pricing plan rates as a percentage.
    public var modifierPercentage: Swift.Double?
    /// The new name of the pricing rule. The name must be unique to each pricing rule.
    public var name: Swift.String?
    /// The set of tiering configurations for the pricing rule.
    public var tiering: BillingconductorClientTypes.UpdateTieringInput?
    /// The new pricing rule type.
    public var type: BillingconductorClientTypes.PricingRuleType?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        modifierPercentage: Swift.Double? = nil,
        name: Swift.String? = nil,
        tiering: BillingconductorClientTypes.UpdateTieringInput? = nil,
        type: BillingconductorClientTypes.PricingRuleType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.modifierPercentage = modifierPercentage
        self.name = name
        self.tiering = tiering
        self.type = type
    }
}

struct UpdatePricingRuleInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let type: BillingconductorClientTypes.PricingRuleType?
    let modifierPercentage: Swift.Double?
    let tiering: BillingconductorClientTypes.UpdateTieringInput?
}

extension UpdatePricingRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case tiering = "Tiering"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleType.self, forKey: .type)
        type = typeDecoded
        let modifierPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .modifierPercentage)
        modifierPercentage = modifierPercentageDecoded
        let tieringDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateTieringInput.self, forKey: .tiering)
        tiering = tieringDecoded
    }
}

extension UpdatePricingRuleOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingRuleOutput(arn: \(Swift.String(describing: arn)), associatedPricingPlanCount: \(Swift.String(describing: associatedPricingPlanCount)), billingEntity: \(Swift.String(describing: billingEntity)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), operation: \(Swift.String(describing: operation)), scope: \(Swift.String(describing: scope)), service: \(Swift.String(describing: service)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), usageType: \(Swift.String(describing: usageType)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePricingRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePricingRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatedPricingPlanCount = output.associatedPricingPlanCount
            self.billingEntity = output.billingEntity
            self.description = output.description
            self.lastModifiedTime = output.lastModifiedTime
            self.modifierPercentage = output.modifierPercentage
            self.name = output.name
            self.operation = output.operation
            self.scope = output.scope
            self.service = output.service
            self.tiering = output.tiering
            self.type = output.type
            self.usageType = output.usageType
        } else {
            self.arn = nil
            self.associatedPricingPlanCount = 0
            self.billingEntity = nil
            self.description = nil
            self.lastModifiedTime = 0
            self.modifierPercentage = nil
            self.name = nil
            self.operation = nil
            self.scope = nil
            self.service = nil
            self.tiering = nil
            self.type = nil
            self.usageType = nil
        }
    }
}

public struct UpdatePricingRuleOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the successfully updated pricing rule.
    public var arn: Swift.String?
    /// The pricing plans count that this pricing rule is associated with.
    public var associatedPricingPlanCount: Swift.Int
    /// The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
    public var billingEntity: Swift.String?
    /// The new description for the pricing rule.
    public var description: Swift.String?
    /// The most recent time the pricing rule was modified.
    public var lastModifiedTime: Swift.Int
    /// The new modifier to show pricing plan rates as a percentage.
    public var modifierPercentage: Swift.Double?
    /// The new name of the pricing rule. The name must be unique to each pricing rule.
    public var name: Swift.String?
    /// Operation refers to the specific Amazon Web Services covered by this line item. This describes the specific usage of the line item. If the Scope attribute is set to SKU, this attribute indicates which operation the PricingRule is modifying. For example, a value of RunInstances:0202 indicates the operation of running an Amazon EC2 instance.
    public var operation: Swift.String?
    /// The scope of pricing rule that indicates if it's globally applicable, or it's service-specific.
    public var scope: BillingconductorClientTypes.PricingRuleScope?
    /// If the Scope attribute is set to SERVICE, the attribute indicates which service the PricingRule is applicable for.
    public var service: Swift.String?
    /// The set of tiering configurations for the pricing rule.
    public var tiering: BillingconductorClientTypes.UpdateTieringInput?
    /// The new pricing rule type.
    public var type: BillingconductorClientTypes.PricingRuleType?
    /// Usage type is the unit that each service uses to measure the usage of a specific type of resource. If the Scope attribute is set to SKU, this attribute indicates which usage type the PricingRule is modifying. For example, USW2-BoxUsage:m2.2xlarge describes an M2 High Memory Double Extra Large instance in the US West (Oregon) Region.
    public var usageType: Swift.String?

    public init(
        arn: Swift.String? = nil,
        associatedPricingPlanCount: Swift.Int = 0,
        billingEntity: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        modifierPercentage: Swift.Double? = nil,
        name: Swift.String? = nil,
        operation: Swift.String? = nil,
        scope: BillingconductorClientTypes.PricingRuleScope? = nil,
        service: Swift.String? = nil,
        tiering: BillingconductorClientTypes.UpdateTieringInput? = nil,
        type: BillingconductorClientTypes.PricingRuleType? = nil,
        usageType: Swift.String? = nil
    )
    {
        self.arn = arn
        self.associatedPricingPlanCount = associatedPricingPlanCount
        self.billingEntity = billingEntity
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.modifierPercentage = modifierPercentage
        self.name = name
        self.operation = operation
        self.scope = scope
        self.service = service
        self.tiering = tiering
        self.type = type
        self.usageType = usageType
    }
}

struct UpdatePricingRuleOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let scope: BillingconductorClientTypes.PricingRuleScope?
    let type: BillingconductorClientTypes.PricingRuleType?
    let modifierPercentage: Swift.Double?
    let service: Swift.String?
    let associatedPricingPlanCount: Swift.Int
    let lastModifiedTime: Swift.Int
    let billingEntity: Swift.String?
    let tiering: BillingconductorClientTypes.UpdateTieringInput?
    let usageType: Swift.String?
    let operation: Swift.String?
}

extension UpdatePricingRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case associatedPricingPlanCount = "AssociatedPricingPlanCount"
        case billingEntity = "BillingEntity"
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case modifierPercentage = "ModifierPercentage"
        case name = "Name"
        case operation = "Operation"
        case scope = "Scope"
        case service = "Service"
        case tiering = "Tiering"
        case type = "Type"
        case usageType = "UsageType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleScope.self, forKey: .scope)
        scope = scopeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.PricingRuleType.self, forKey: .type)
        type = typeDecoded
        let modifierPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .modifierPercentage)
        modifierPercentage = modifierPercentageDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let associatedPricingPlanCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .associatedPricingPlanCount) ?? 0
        associatedPricingPlanCount = associatedPricingPlanCountDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let billingEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingEntity)
        billingEntity = billingEntityDecoded
        let tieringDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateTieringInput.self, forKey: .tiering)
        tiering = tieringDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
    }
}

enum UpdatePricingRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BillingconductorClientTypes.UpdateTieringInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTier = "FreeTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let freeTier = self.freeTier {
            try encodeContainer.encode(freeTier, forKey: .freeTier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeTierDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.UpdateFreeTierConfig.self, forKey: .freeTier)
        freeTier = freeTierDecoded
    }
}

extension BillingconductorClientTypes {
    /// The set of tiering configurations for the pricing rule.
    public struct UpdateTieringInput: Swift.Equatable {
        /// The possible Amazon Web Services Free Tier configurations.
        /// This member is required.
        public var freeTier: BillingconductorClientTypes.UpdateFreeTierConfig?

        public init(
            freeTier: BillingconductorClientTypes.UpdateFreeTierConfig? = nil
        )
        {
            self.freeTier = freeTier
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input doesn't match with the constraints specified by Amazon Web Services.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error, if applicable.
        public internal(set) var fields: [BillingconductorClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the request's validation failed.
        public internal(set) var reason: BillingconductorClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [BillingconductorClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BillingconductorClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: BillingconductorClientTypes.ValidationExceptionReason?
    let fields: [BillingconductorClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(BillingconductorClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([BillingconductorClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[BillingconductorClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [BillingconductorClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension BillingconductorClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BillingconductorClientTypes {
    /// The field's information of a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The field name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension BillingconductorClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountsAlreadyAssociated
        case accountsNotAssociated
        case cannotDeleteAutoAssociateBillingGroup
        case cannotParse
        case customLineItemAssociationExists
        case duplicateAccount
        case duplicatePricingruleArns
        case fieldValidationFailed
        case illegalAccounts
        case illegalBillingEntity
        case illegalBillingPeriod
        case illegalBillingPeriodRange
        case illegalChargeDetails
        case illegalChildAssociateResource
        case illegalCustomlineitem
        case illegalCustomlineitemModification
        case illegalCustomlineitemUpdate
        case illegalEndedBillinggroup
        case illegalExpression
        case illegalModifierPercentage
        case illegalOperation
        case illegalPrimaryAccount
        case illegalResourceArns
        case illegalScope
        case illegalService
        case illegalTieringInput
        case illegalType
        case illegalUpdateChargeDetails
        case illegalUsageType
        case invalidArn
        case invalidBillingviewArn
        case invalidBillingGroup
        case invalidBillingGroupStatus
        case invalidBillingPeriodForOperation
        case invalidFilter
        case invalidSkuCombo
        case invalidTimeRange
        case mismatchedBillinggroupArn
        case mismatchedBillingviewArn
        case mismatchedCustomlineitemArn
        case mismatchedPricingplanArn
        case mismatchedPricingruleArn
        case missingBillinggroup
        case missingCustomlineitem
        case missingLinkedAccountIds
        case missingPricingplan
        case missingPricingPlanArn
        case multipleLinkedAccountIds
        case multiplePricingPlanArn
        case other
        case pricingrulesAlreadyAssociated
        case pricingrulesNotAssociated
        case pricingrulesNotExist
        case primaryCannotDisassociate
        case primaryNotAssociated
        case tooManyAccountsInRequest
        case tooManyAutoAssociateBillingGroups
        case tooManyCustomlineitemsInRequest
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .accountsAlreadyAssociated,
                .accountsNotAssociated,
                .cannotDeleteAutoAssociateBillingGroup,
                .cannotParse,
                .customLineItemAssociationExists,
                .duplicateAccount,
                .duplicatePricingruleArns,
                .fieldValidationFailed,
                .illegalAccounts,
                .illegalBillingEntity,
                .illegalBillingPeriod,
                .illegalBillingPeriodRange,
                .illegalChargeDetails,
                .illegalChildAssociateResource,
                .illegalCustomlineitem,
                .illegalCustomlineitemModification,
                .illegalCustomlineitemUpdate,
                .illegalEndedBillinggroup,
                .illegalExpression,
                .illegalModifierPercentage,
                .illegalOperation,
                .illegalPrimaryAccount,
                .illegalResourceArns,
                .illegalScope,
                .illegalService,
                .illegalTieringInput,
                .illegalType,
                .illegalUpdateChargeDetails,
                .illegalUsageType,
                .invalidArn,
                .invalidBillingviewArn,
                .invalidBillingGroup,
                .invalidBillingGroupStatus,
                .invalidBillingPeriodForOperation,
                .invalidFilter,
                .invalidSkuCombo,
                .invalidTimeRange,
                .mismatchedBillinggroupArn,
                .mismatchedBillingviewArn,
                .mismatchedCustomlineitemArn,
                .mismatchedPricingplanArn,
                .mismatchedPricingruleArn,
                .missingBillinggroup,
                .missingCustomlineitem,
                .missingLinkedAccountIds,
                .missingPricingplan,
                .missingPricingPlanArn,
                .multipleLinkedAccountIds,
                .multiplePricingPlanArn,
                .other,
                .pricingrulesAlreadyAssociated,
                .pricingrulesNotAssociated,
                .pricingrulesNotExist,
                .primaryCannotDisassociate,
                .primaryNotAssociated,
                .tooManyAccountsInRequest,
                .tooManyAutoAssociateBillingGroups,
                .tooManyCustomlineitemsInRequest,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountsAlreadyAssociated: return "ACCOUNTS_ALREADY_ASSOCIATED"
            case .accountsNotAssociated: return "ACCOUNTS_NOT_ASSOCIATED"
            case .cannotDeleteAutoAssociateBillingGroup: return "CANNOT_DELETE_AUTO_ASSOCIATE_BILLING_GROUP"
            case .cannotParse: return "CANNOT_PARSE"
            case .customLineItemAssociationExists: return "CUSTOM_LINE_ITEM_ASSOCIATION_EXISTS"
            case .duplicateAccount: return "DUPLICATE_ACCOUNT"
            case .duplicatePricingruleArns: return "DUPLICATE_PRICINGRULE_ARNS"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .illegalAccounts: return "ILLEGAL_ACCOUNTS"
            case .illegalBillingEntity: return "ILLEGAL_BILLING_ENTITY"
            case .illegalBillingPeriod: return "ILLEGAL_BILLING_PERIOD"
            case .illegalBillingPeriodRange: return "ILLEGAL_BILLING_PERIOD_RANGE"
            case .illegalChargeDetails: return "ILLEGAL_CHARGE_DETAILS"
            case .illegalChildAssociateResource: return "ILLEGAL_CHILD_ASSOCIATE_RESOURCE"
            case .illegalCustomlineitem: return "ILLEGAL_CUSTOMLINEITEM"
            case .illegalCustomlineitemModification: return "ILLEGAL_CUSTOMLINEITEM_MODIFICATION"
            case .illegalCustomlineitemUpdate: return "ILLEGAL_CUSTOMLINEITEM_UPDATE"
            case .illegalEndedBillinggroup: return "ILLEGAL_ENDED_BILLINGGROUP"
            case .illegalExpression: return "ILLEGAL_EXPRESSION"
            case .illegalModifierPercentage: return "ILLEGAL_MODIFIER_PERCENTAGE"
            case .illegalOperation: return "ILLEGAL_OPERATION"
            case .illegalPrimaryAccount: return "ILLEGAL_PRIMARY_ACCOUNT"
            case .illegalResourceArns: return "ILLEGAL_RESOURCE_ARNS"
            case .illegalScope: return "ILLEGAL_SCOPE"
            case .illegalService: return "ILLEGAL_SERVICE"
            case .illegalTieringInput: return "ILLEGAL_TIERING_INPUT"
            case .illegalType: return "ILLEGAL_TYPE"
            case .illegalUpdateChargeDetails: return "ILLEGAL_UPDATE_CHARGE_DETAILS"
            case .illegalUsageType: return "ILLEGAL_USAGE_TYPE"
            case .invalidArn: return "INVALID_ARN"
            case .invalidBillingviewArn: return "INVALID_BILLINGVIEW_ARN"
            case .invalidBillingGroup: return "INVALID_BILLING_GROUP"
            case .invalidBillingGroupStatus: return "INVALID_BILLING_GROUP_STATUS"
            case .invalidBillingPeriodForOperation: return "INVALID_BILLING_PERIOD_FOR_OPERATION"
            case .invalidFilter: return "INVALID_FILTER"
            case .invalidSkuCombo: return "INVALID_SKU_COMBO"
            case .invalidTimeRange: return "INVALID_TIME_RANGE"
            case .mismatchedBillinggroupArn: return "MISMATCHED_BILLINGGROUP_ARN"
            case .mismatchedBillingviewArn: return "MISMATCHED_BILLINGVIEW_ARN"
            case .mismatchedCustomlineitemArn: return "MISMATCHED_CUSTOMLINEITEM_ARN"
            case .mismatchedPricingplanArn: return "MISMATCHED_PRICINGPLAN_ARN"
            case .mismatchedPricingruleArn: return "MISMATCHED_PRICINGRULE_ARN"
            case .missingBillinggroup: return "MISSING_BILLINGGROUP"
            case .missingCustomlineitem: return "MISSING_CUSTOMLINEITEM"
            case .missingLinkedAccountIds: return "MISSING_LINKED_ACCOUNT_IDS"
            case .missingPricingplan: return "MISSING_PRICINGPLAN"
            case .missingPricingPlanArn: return "MISSING_PRICING_PLAN_ARN"
            case .multipleLinkedAccountIds: return "MULTIPLE_LINKED_ACCOUNT_IDS"
            case .multiplePricingPlanArn: return "MULTIPLE_PRICING_PLAN_ARN"
            case .other: return "OTHER"
            case .pricingrulesAlreadyAssociated: return "PRICINGRULES_ALREADY_ASSOCIATED"
            case .pricingrulesNotAssociated: return "PRICINGRULES_NOT_ASSOCIATED"
            case .pricingrulesNotExist: return "PRICINGRULES_NOT_EXIST"
            case .primaryCannotDisassociate: return "PRIMARY_CANNOT_DISASSOCIATE"
            case .primaryNotAssociated: return "PRIMARY_NOT_ASSOCIATED"
            case .tooManyAccountsInRequest: return "TOO_MANY_ACCOUNTS_IN_REQUEST"
            case .tooManyAutoAssociateBillingGroups: return "TOO_MANY_AUTO_ASSOCIATE_BILLING_GROUPS"
            case .tooManyCustomlineitemsInRequest: return "TOO_MANY_CUSTOMLINEITEMS_IN_REQUEST"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
