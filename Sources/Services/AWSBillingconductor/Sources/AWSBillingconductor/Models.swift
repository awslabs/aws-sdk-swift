//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BillingconductorClientTypes {
    /// A representation of a linked account.
    public struct AccountAssociationsListElement {
        /// The Amazon Web Services account email.
        public var accountEmail: Swift.String?
        /// The associating array of account IDs.
        public var accountId: Swift.String?
        /// The Amazon Web Services account name.
        public var accountName: Swift.String?
        /// The Billing Group Arn that the linked account is associated to.
        public var billingGroupArn: Swift.String?

        public init(
            accountEmail: Swift.String? = nil,
            accountId: Swift.String? = nil,
            accountName: Swift.String? = nil,
            billingGroupArn: Swift.String? = nil
        )
        {
            self.accountEmail = accountEmail
            self.accountId = accountId
            self.accountName = accountName
            self.billingGroupArn = billingGroupArn
        }
    }

}

extension BillingconductorClientTypes.AccountAssociationsListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountAssociationsListElement(accountId: \(Swift.String(describing: accountId)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), accountEmail: \"CONTENT_REDACTED\", accountName: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// The set of accounts that will be under the billing group. The set of accounts resemble the linked accounts in a consolidated billing family.
    public struct AccountGrouping {
        /// Specifies if this billing group will automatically associate newly added Amazon Web Services accounts that join your consolidated billing family.
        public var autoAssociate: Swift.Bool?
        /// The account IDs that make up the billing group. Account IDs must be a part of the consolidated billing family, and not associated with another billing group.
        /// This member is required.
        public var linkedAccountIds: [Swift.String]?

        public init(
            autoAssociate: Swift.Bool? = nil,
            linkedAccountIds: [Swift.String]? = nil
        )
        {
            self.autoAssociate = autoAssociate
            self.linkedAccountIds = linkedAccountIds
        }
    }

}

extension BillingconductorClientTypes {

    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pricingPlanAttachedToBillingGroupDeleteConflict
        case pricingRuleAttachedToPricingPlanDeleteConflict
        case pricingRuleInPricingPlanConflict
        case resourceNameConflict
        case writeConflictRetry
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .pricingPlanAttachedToBillingGroupDeleteConflict,
                .pricingRuleAttachedToPricingPlanDeleteConflict,
                .pricingRuleInPricingPlanConflict,
                .resourceNameConflict,
                .writeConflictRetry
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pricingPlanAttachedToBillingGroupDeleteConflict: return "PRICING_PLAN_ATTACHED_TO_BILLING_GROUP_DELETE_CONFLICT"
            case .pricingRuleAttachedToPricingPlanDeleteConflict: return "PRICING_RULE_ATTACHED_TO_PRICING_PLAN_DELETE_CONFLICT"
            case .pricingRuleInPricingPlanConflict: return "PRICING_RULE_IN_PRICING_PLAN_CONFLICT"
            case .resourceNameConflict: return "RESOURCE_NAME_CONFLICT"
            case .writeConflictRetry: return "WRITE_CONFLICT_RETRY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// You can cause an inconsistent state by updating or deleting a resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason for the inconsistent state.
        public internal(set) var reason: BillingconductorClientTypes.ConflictExceptionReason? = nil
        /// Identifier of the resource in use.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource in use.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: BillingconductorClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An unexpected error occurred while processing a request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Number of seconds you can retry after the call.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The request references a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Resource identifier that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Resource type that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request would cause a service limit to exceed.
public struct ServiceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The unique code identifier of the service limit that is being exceeded.
        /// This member is required.
        public internal(set) var limitCode: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource affected.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected.
        public internal(set) var resourceType: Swift.String? = nil
        /// The unique code for the service of the limit that is being exceeded.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limitCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.limitCode = limitCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Number of seconds you can safely retry after the call.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension BillingconductorClientTypes {
    /// The field's information of a request that resulted in an exception.
    public struct ValidationExceptionField {
        /// The message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The field name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension BillingconductorClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountsAlreadyAssociated
        case accountsNotAssociated
        case cannotDeleteAutoAssociateBillingGroup
        case cannotParse
        case customLineItemAssociationExists
        case duplicateAccount
        case duplicatePricingruleArns
        case fieldValidationFailed
        case illegalAccounts
        case illegalAccountId
        case illegalBillingEntity
        case illegalBillingPeriod
        case illegalBillingPeriodRange
        case illegalChargeDetails
        case illegalChildAssociateResource
        case illegalCustomlineitem
        case illegalCustomlineitemModification
        case illegalCustomlineitemUpdate
        case illegalEndedBillinggroup
        case illegalExpression
        case illegalModifierPercentage
        case illegalOperation
        case illegalPrimaryAccount
        case illegalResourceArns
        case illegalScope
        case illegalService
        case illegalTieringInput
        case illegalType
        case illegalUpdateChargeDetails
        case illegalUsageType
        case invalidArn
        case invalidBillingviewArn
        case invalidBillingGroup
        case invalidBillingGroupStatus
        case invalidBillingPeriodForOperation
        case invalidFilter
        case invalidSkuCombo
        case invalidTimeRange
        case mismatchedBillinggroupArn
        case mismatchedBillingviewArn
        case mismatchedCustomlineitemArn
        case mismatchedPricingplanArn
        case mismatchedPricingruleArn
        case missingBillinggroup
        case missingCustomlineitem
        case missingLinkedAccountIds
        case missingPricingplan
        case missingPricingPlanArn
        case multipleLinkedAccountIds
        case multiplePricingPlanArn
        case other
        case pricingrulesAlreadyAssociated
        case pricingrulesNotAssociated
        case pricingrulesNotExist
        case primaryCannotDisassociate
        case primaryNotAssociated
        case tooManyAccountsInRequest
        case tooManyAutoAssociateBillingGroups
        case tooManyCustomlineitemsInRequest
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .accountsAlreadyAssociated,
                .accountsNotAssociated,
                .cannotDeleteAutoAssociateBillingGroup,
                .cannotParse,
                .customLineItemAssociationExists,
                .duplicateAccount,
                .duplicatePricingruleArns,
                .fieldValidationFailed,
                .illegalAccounts,
                .illegalAccountId,
                .illegalBillingEntity,
                .illegalBillingPeriod,
                .illegalBillingPeriodRange,
                .illegalChargeDetails,
                .illegalChildAssociateResource,
                .illegalCustomlineitem,
                .illegalCustomlineitemModification,
                .illegalCustomlineitemUpdate,
                .illegalEndedBillinggroup,
                .illegalExpression,
                .illegalModifierPercentage,
                .illegalOperation,
                .illegalPrimaryAccount,
                .illegalResourceArns,
                .illegalScope,
                .illegalService,
                .illegalTieringInput,
                .illegalType,
                .illegalUpdateChargeDetails,
                .illegalUsageType,
                .invalidArn,
                .invalidBillingviewArn,
                .invalidBillingGroup,
                .invalidBillingGroupStatus,
                .invalidBillingPeriodForOperation,
                .invalidFilter,
                .invalidSkuCombo,
                .invalidTimeRange,
                .mismatchedBillinggroupArn,
                .mismatchedBillingviewArn,
                .mismatchedCustomlineitemArn,
                .mismatchedPricingplanArn,
                .mismatchedPricingruleArn,
                .missingBillinggroup,
                .missingCustomlineitem,
                .missingLinkedAccountIds,
                .missingPricingplan,
                .missingPricingPlanArn,
                .multipleLinkedAccountIds,
                .multiplePricingPlanArn,
                .other,
                .pricingrulesAlreadyAssociated,
                .pricingrulesNotAssociated,
                .pricingrulesNotExist,
                .primaryCannotDisassociate,
                .primaryNotAssociated,
                .tooManyAccountsInRequest,
                .tooManyAutoAssociateBillingGroups,
                .tooManyCustomlineitemsInRequest,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountsAlreadyAssociated: return "ACCOUNTS_ALREADY_ASSOCIATED"
            case .accountsNotAssociated: return "ACCOUNTS_NOT_ASSOCIATED"
            case .cannotDeleteAutoAssociateBillingGroup: return "CANNOT_DELETE_AUTO_ASSOCIATE_BILLING_GROUP"
            case .cannotParse: return "CANNOT_PARSE"
            case .customLineItemAssociationExists: return "CUSTOM_LINE_ITEM_ASSOCIATION_EXISTS"
            case .duplicateAccount: return "DUPLICATE_ACCOUNT"
            case .duplicatePricingruleArns: return "DUPLICATE_PRICINGRULE_ARNS"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .illegalAccounts: return "ILLEGAL_ACCOUNTS"
            case .illegalAccountId: return "ILLEGAL_ACCOUNT_ID"
            case .illegalBillingEntity: return "ILLEGAL_BILLING_ENTITY"
            case .illegalBillingPeriod: return "ILLEGAL_BILLING_PERIOD"
            case .illegalBillingPeriodRange: return "ILLEGAL_BILLING_PERIOD_RANGE"
            case .illegalChargeDetails: return "ILLEGAL_CHARGE_DETAILS"
            case .illegalChildAssociateResource: return "ILLEGAL_CHILD_ASSOCIATE_RESOURCE"
            case .illegalCustomlineitem: return "ILLEGAL_CUSTOMLINEITEM"
            case .illegalCustomlineitemModification: return "ILLEGAL_CUSTOMLINEITEM_MODIFICATION"
            case .illegalCustomlineitemUpdate: return "ILLEGAL_CUSTOMLINEITEM_UPDATE"
            case .illegalEndedBillinggroup: return "ILLEGAL_ENDED_BILLINGGROUP"
            case .illegalExpression: return "ILLEGAL_EXPRESSION"
            case .illegalModifierPercentage: return "ILLEGAL_MODIFIER_PERCENTAGE"
            case .illegalOperation: return "ILLEGAL_OPERATION"
            case .illegalPrimaryAccount: return "ILLEGAL_PRIMARY_ACCOUNT"
            case .illegalResourceArns: return "ILLEGAL_RESOURCE_ARNS"
            case .illegalScope: return "ILLEGAL_SCOPE"
            case .illegalService: return "ILLEGAL_SERVICE"
            case .illegalTieringInput: return "ILLEGAL_TIERING_INPUT"
            case .illegalType: return "ILLEGAL_TYPE"
            case .illegalUpdateChargeDetails: return "ILLEGAL_UPDATE_CHARGE_DETAILS"
            case .illegalUsageType: return "ILLEGAL_USAGE_TYPE"
            case .invalidArn: return "INVALID_ARN"
            case .invalidBillingviewArn: return "INVALID_BILLINGVIEW_ARN"
            case .invalidBillingGroup: return "INVALID_BILLING_GROUP"
            case .invalidBillingGroupStatus: return "INVALID_BILLING_GROUP_STATUS"
            case .invalidBillingPeriodForOperation: return "INVALID_BILLING_PERIOD_FOR_OPERATION"
            case .invalidFilter: return "INVALID_FILTER"
            case .invalidSkuCombo: return "INVALID_SKU_COMBO"
            case .invalidTimeRange: return "INVALID_TIME_RANGE"
            case .mismatchedBillinggroupArn: return "MISMATCHED_BILLINGGROUP_ARN"
            case .mismatchedBillingviewArn: return "MISMATCHED_BILLINGVIEW_ARN"
            case .mismatchedCustomlineitemArn: return "MISMATCHED_CUSTOMLINEITEM_ARN"
            case .mismatchedPricingplanArn: return "MISMATCHED_PRICINGPLAN_ARN"
            case .mismatchedPricingruleArn: return "MISMATCHED_PRICINGRULE_ARN"
            case .missingBillinggroup: return "MISSING_BILLINGGROUP"
            case .missingCustomlineitem: return "MISSING_CUSTOMLINEITEM"
            case .missingLinkedAccountIds: return "MISSING_LINKED_ACCOUNT_IDS"
            case .missingPricingplan: return "MISSING_PRICINGPLAN"
            case .missingPricingPlanArn: return "MISSING_PRICING_PLAN_ARN"
            case .multipleLinkedAccountIds: return "MULTIPLE_LINKED_ACCOUNT_IDS"
            case .multiplePricingPlanArn: return "MULTIPLE_PRICING_PLAN_ARN"
            case .other: return "OTHER"
            case .pricingrulesAlreadyAssociated: return "PRICINGRULES_ALREADY_ASSOCIATED"
            case .pricingrulesNotAssociated: return "PRICINGRULES_NOT_ASSOCIATED"
            case .pricingrulesNotExist: return "PRICINGRULES_NOT_EXIST"
            case .primaryCannotDisassociate: return "PRIMARY_CANNOT_DISASSOCIATE"
            case .primaryNotAssociated: return "PRIMARY_NOT_ASSOCIATED"
            case .tooManyAccountsInRequest: return "TOO_MANY_ACCOUNTS_IN_REQUEST"
            case .tooManyAutoAssociateBillingGroups: return "TOO_MANY_AUTO_ASSOCIATE_BILLING_GROUPS"
            case .tooManyCustomlineitemsInRequest: return "TOO_MANY_CUSTOMLINEITEMS_IN_REQUEST"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input doesn't match with the constraints specified by Amazon Web Services.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error, if applicable.
        public internal(set) var fields: [BillingconductorClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the request's validation failed.
        public internal(set) var reason: BillingconductorClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [BillingconductorClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BillingconductorClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateAccountsInput {
    /// The associating array of account IDs.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the billing group that associates the array of account IDs.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        arn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.arn = arn
    }
}

public struct AssociateAccountsOutput {
    /// The Amazon Resource Name (ARN) of the billing group that associates the array of account IDs.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct AssociatePricingRulesInput {
    /// The PricingPlanArn that the PricingRuleArns are associated with.
    /// This member is required.
    public var arn: Swift.String?
    /// The PricingRuleArns that are associated with the Pricing Plan.
    /// This member is required.
    public var pricingRuleArns: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.pricingRuleArns = pricingRuleArns
    }
}

public struct AssociatePricingRulesOutput {
    /// The PricingPlanArn that the PricingRuleArns are associated with.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension BillingconductorClientTypes {

    public enum AssociateResourceErrorReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case illegalCustomlineitem
        case internalServerException
        case invalidArn
        case invalidBillingPeriodRange
        case serviceLimitExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociateResourceErrorReason] {
            return [
                .illegalCustomlineitem,
                .internalServerException,
                .invalidArn,
                .invalidBillingPeriodRange,
                .serviceLimitExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .illegalCustomlineitem: return "ILLEGAL_CUSTOMLINEITEM"
            case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
            case .invalidArn: return "INVALID_ARN"
            case .invalidBillingPeriodRange: return "INVALID_BILLING_PERIOD_RANGE"
            case .serviceLimitExceeded: return "SERVICE_LIMIT_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingconductorClientTypes {
    /// A representation of a resource association error.
    public struct AssociateResourceError {
        /// The reason why the resource association failed.
        public var message: Swift.String?
        /// A static error code that's used to classify the type of failure.
        public var reason: BillingconductorClientTypes.AssociateResourceErrorReason?

        public init(
            message: Swift.String? = nil,
            reason: BillingconductorClientTypes.AssociateResourceErrorReason? = nil
        )
        {
            self.message = message
            self.reason = reason
        }
    }

}

extension BillingconductorClientTypes {
    /// A resource association result for a percentage custom line item.
    public struct AssociateResourceResponseElement {
        /// The resource ARN that was associated to the custom line item.
        public var arn: Swift.String?
        /// An AssociateResourceError that will populate if the resource association fails.
        public var error: BillingconductorClientTypes.AssociateResourceError?

        public init(
            arn: Swift.String? = nil,
            error: BillingconductorClientTypes.AssociateResourceError? = nil
        )
        {
            self.arn = arn
            self.error = error
        }
    }

}

extension BillingconductorClientTypes {
    /// The key-value pair that represents the attribute by which the BillingGroupCostReportResults are grouped. For example, if you want a service-level breakdown for Amazon Simple Storage Service (Amazon S3) of the billing group, the attribute will be a key-value pair of "PRODUCT_NAME" and "S3".
    public struct Attribute {
        /// The key in a key-value pair that describes the margin summary.
        public var key: Swift.String?
        /// The value in a key-value pair that describes the margin summary.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension BillingconductorClientTypes {
    /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
    public struct ComputationPreference {
        /// The Amazon Resource Name (ARN) of the pricing plan that's used to compute the Amazon Web Services charges for a billing group.
        /// This member is required.
        public var pricingPlanArn: Swift.String?

        public init(
            pricingPlanArn: Swift.String? = nil
        )
        {
            self.pricingPlanArn = pricingPlanArn
        }
    }

}

public struct CreateBillingGroupInput {
    /// The set of accounts that will be under the billing group. The set of accounts resemble the linked accounts in a consolidated billing family.
    /// This member is required.
    public var accountGrouping: BillingconductorClientTypes.AccountGrouping?
    /// The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
    /// This member is required.
    public var computationPreference: BillingconductorClientTypes.ComputationPreference?
    /// The description of the billing group.
    public var description: Swift.String?
    /// The billing group name. The names must be unique.
    /// This member is required.
    public var name: Swift.String?
    /// The account ID that serves as the main account in a billing group.
    public var primaryAccountId: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a billing group. This feature isn't available during the beta.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountGrouping: BillingconductorClientTypes.AccountGrouping? = nil,
        clientToken: Swift.String? = nil,
        computationPreference: BillingconductorClientTypes.ComputationPreference? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        primaryAccountId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accountGrouping = accountGrouping
        self.clientToken = clientToken
        self.computationPreference = computationPreference
        self.description = description
        self.name = name
        self.primaryAccountId = primaryAccountId
        self.tags = tags
    }
}

extension CreateBillingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBillingGroupInput(accountGrouping: \(Swift.String(describing: accountGrouping)), clientToken: \(Swift.String(describing: clientToken)), computationPreference: \(Swift.String(describing: computationPreference)), primaryAccountId: \(Swift.String(describing: primaryAccountId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateBillingGroupOutput {
    /// The Amazon Resource Name (ARN) of the created billing group.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteBillingGroupInput {
    /// The Amazon Resource Name (ARN) of the billing group that you're deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteBillingGroupOutput {
    /// The Amazon Resource Name (ARN) of the deleted billing group.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DisassociateAccountsInput {
    /// The array of account IDs to disassociate.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the billing group that the array of account IDs will disassociate from.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        arn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.arn = arn
    }
}

public struct DisassociateAccountsOutput {
    /// The Amazon Resource Name (ARN) of the billing group that the array of account IDs is disassociated from.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension BillingconductorClientTypes {

    public enum BillingGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case primaryAccountMissing
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingGroupStatus] {
            return [
                .active,
                .primaryAccountMissing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .primaryAccountMissing: return "PRIMARY_ACCOUNT_MISSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingconductorClientTypes {
    /// The filter that specifies the billing groups and pricing plans to retrieve billing group information.
    public struct ListBillingGroupsFilter {
        /// The list of billing group Amazon Resource Names (ARNs) to retrieve information.
        public var arns: [Swift.String]?
        /// Specifies if this billing group will automatically associate newly added Amazon Web Services accounts that join your consolidated billing family.
        public var autoAssociate: Swift.Bool?
        /// The pricing plan Amazon Resource Names (ARNs) to retrieve information.
        public var pricingPlan: Swift.String?
        /// A list of billing groups to retrieve their current status for a specific time range
        public var statuses: [BillingconductorClientTypes.BillingGroupStatus]?

        public init(
            arns: [Swift.String]? = nil,
            autoAssociate: Swift.Bool? = nil,
            pricingPlan: Swift.String? = nil,
            statuses: [BillingconductorClientTypes.BillingGroupStatus]? = nil
        )
        {
            self.arns = arns
            self.autoAssociate = autoAssociate
            self.pricingPlan = pricingPlan
            self.statuses = statuses
        }
    }

}

public struct ListBillingGroupsInput {
    /// The preferred billing period to get billing groups.
    public var billingPeriod: Swift.String?
    /// A ListBillingGroupsFilter that specifies the billing group and pricing plan to retrieve billing group information.
    public var filters: BillingconductorClientTypes.ListBillingGroupsFilter?
    /// The maximum number of billing groups to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to get billing groups.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListBillingGroupsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// Specifies if the billing group has the following features enabled.
    public struct ListBillingGroupAccountGrouping {
        /// Specifies if this billing group will automatically associate newly added Amazon Web Services accounts that join your consolidated billing family.
        public var autoAssociate: Swift.Bool?

        public init(
            autoAssociate: Swift.Bool? = nil
        )
        {
            self.autoAssociate = autoAssociate
        }
    }

}

extension BillingconductorClientTypes {
    /// A representation of a billing group.
    public struct BillingGroupListElement {
        /// Specifies if the billing group has automatic account association (AutoAssociate) enabled.
        public var accountGrouping: BillingconductorClientTypes.ListBillingGroupAccountGrouping?
        /// The Amazon Resource Number (ARN) that can be used to uniquely identify the billing group.
        public var arn: Swift.String?
        /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
        public var computationPreference: BillingconductorClientTypes.ComputationPreference?
        /// The time when the billing group was created.
        public var creationTime: Swift.Int
        /// The description of the billing group.
        public var description: Swift.String?
        /// The most recent time when the billing group was modified.
        public var lastModifiedTime: Swift.Int
        /// The name of the billing group.
        public var name: Swift.String?
        /// The account ID that serves as the main account in a billing group.
        public var primaryAccountId: Swift.String?
        /// The number of accounts in the particular billing group.
        public var size: Swift.Int
        /// The billing group status. Only one of the valid values can be used.
        public var status: BillingconductorClientTypes.BillingGroupStatus?
        /// The reason why the billing group is in its current status.
        public var statusReason: Swift.String?

        public init(
            accountGrouping: BillingconductorClientTypes.ListBillingGroupAccountGrouping? = nil,
            arn: Swift.String? = nil,
            computationPreference: BillingconductorClientTypes.ComputationPreference? = nil,
            creationTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            primaryAccountId: Swift.String? = nil,
            size: Swift.Int = 0,
            status: BillingconductorClientTypes.BillingGroupStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.accountGrouping = accountGrouping
            self.arn = arn
            self.computationPreference = computationPreference
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.primaryAccountId = primaryAccountId
            self.size = size
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension BillingconductorClientTypes.BillingGroupListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BillingGroupListElement(accountGrouping: \(Swift.String(describing: accountGrouping)), arn: \(Swift.String(describing: arn)), computationPreference: \(Swift.String(describing: computationPreference)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), primaryAccountId: \(Swift.String(describing: primaryAccountId)), size: \(Swift.String(describing: size)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListBillingGroupsOutput {
    /// A list of BillingGroupListElement retrieved.
    public var billingGroups: [BillingconductorClientTypes.BillingGroupListElement]?
    /// The pagination token that's used on subsequent calls to get billing groups.
    public var nextToken: Swift.String?

    public init(
        billingGroups: [BillingconductorClientTypes.BillingGroupListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroups = billingGroups
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// Specifies if the billing group has the following features enabled.
    public struct UpdateBillingGroupAccountGrouping {
        /// Specifies if this billing group will automatically associate newly added Amazon Web Services accounts that join your consolidated billing family.
        public var autoAssociate: Swift.Bool?

        public init(
            autoAssociate: Swift.Bool? = nil
        )
        {
            self.autoAssociate = autoAssociate
        }
    }

}

public struct UpdateBillingGroupInput {
    /// Specifies if the billing group has automatic account association (AutoAssociate) enabled.
    public var accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping?
    /// The Amazon Resource Name (ARN) of the billing group being updated.
    /// This member is required.
    public var arn: Swift.String?
    /// The preferences and settings that will be used to compute the Amazon Web Services charges for a billing group.
    public var computationPreference: BillingconductorClientTypes.ComputationPreference?
    /// A description of the billing group.
    public var description: Swift.String?
    /// The name of the billing group. The names must be unique to each billing group.
    public var name: Swift.String?
    /// The status of the billing group. Only one of the valid values can be used.
    public var status: BillingconductorClientTypes.BillingGroupStatus?

    public init(
        accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping? = nil,
        arn: Swift.String? = nil,
        computationPreference: BillingconductorClientTypes.ComputationPreference? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BillingconductorClientTypes.BillingGroupStatus? = nil
    )
    {
        self.accountGrouping = accountGrouping
        self.arn = arn
        self.computationPreference = computationPreference
        self.description = description
        self.name = name
        self.status = status
    }
}

extension UpdateBillingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBillingGroupInput(accountGrouping: \(Swift.String(describing: accountGrouping)), arn: \(Swift.String(describing: arn)), computationPreference: \(Swift.String(describing: computationPreference)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateBillingGroupOutput {
    /// Specifies if the billing group has automatic account association (AutoAssociate) enabled.
    public var accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping?
    /// The Amazon Resource Name (ARN) of the billing group that was updated.
    public var arn: Swift.String?
    /// A description of the billing group.
    public var description: Swift.String?
    /// The most recent time when the billing group was modified.
    public var lastModifiedTime: Swift.Int
    /// The name of the billing group. The names must be unique to each billing group.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the pricing plan to compute Amazon Web Services charges for the billing group.
    public var pricingPlanArn: Swift.String?
    /// The account ID that serves as the main account in a billing group.
    public var primaryAccountId: Swift.String?
    /// The number of accounts in the particular billing group.
    public var size: Swift.Int
    /// The status of the billing group. Only one of the valid values can be used.
    public var status: BillingconductorClientTypes.BillingGroupStatus?
    /// The reason why the billing group is in its current status.
    public var statusReason: Swift.String?

    public init(
        accountGrouping: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        name: Swift.String? = nil,
        pricingPlanArn: Swift.String? = nil,
        primaryAccountId: Swift.String? = nil,
        size: Swift.Int = 0,
        status: BillingconductorClientTypes.BillingGroupStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.accountGrouping = accountGrouping
        self.arn = arn
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.pricingPlanArn = pricingPlanArn
        self.primaryAccountId = primaryAccountId
        self.size = size
        self.status = status
        self.statusReason = statusReason
    }
}

extension UpdateBillingGroupOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBillingGroupOutput(accountGrouping: \(Swift.String(describing: accountGrouping)), arn: \(Swift.String(describing: arn)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), pricingPlanArn: \(Swift.String(describing: pricingPlanArn)), primaryAccountId: \(Swift.String(describing: primaryAccountId)), size: \(Swift.String(describing: size)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// The billing period range in which the custom line item request will be applied.
    public struct CustomLineItemBillingPeriodRange {
        /// The inclusive end billing period that defines a billing period range where a custom line is applied.
        public var exclusiveEndBillingPeriod: Swift.String?
        /// The inclusive start billing period that defines a billing period range where a custom line is applied.
        /// This member is required.
        public var inclusiveStartBillingPeriod: Swift.String?

        public init(
            exclusiveEndBillingPeriod: Swift.String? = nil,
            inclusiveStartBillingPeriod: Swift.String? = nil
        )
        {
            self.exclusiveEndBillingPeriod = exclusiveEndBillingPeriod
            self.inclusiveStartBillingPeriod = inclusiveStartBillingPeriod
        }
    }

}

public struct BatchAssociateResourcesToCustomLineItemInput {
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A list containing the ARNs of the resources to be associated.
    /// This member is required.
    public var resourceArns: [Swift.String]?
    /// A percentage custom line item ARN to associate the resources to.
    /// This member is required.
    public var targetArn: Swift.String?

    public init(
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        resourceArns: [Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.billingPeriodRange = billingPeriodRange
        self.resourceArns = resourceArns
        self.targetArn = targetArn
    }
}

public struct BatchAssociateResourcesToCustomLineItemOutput {
    /// A list of AssociateResourceResponseElement for each resource that failed association to a percentage custom line item.
    public var failedAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?
    /// A list of AssociateResourceResponseElement for each resource that's been associated to a percentage custom line item successfully.
    public var successfullyAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]?

    public init(
        failedAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]? = nil,
        successfullyAssociatedResources: [BillingconductorClientTypes.AssociateResourceResponseElement]? = nil
    )
    {
        self.failedAssociatedResources = failedAssociatedResources
        self.successfullyAssociatedResources = successfullyAssociatedResources
    }
}

public struct BatchDisassociateResourcesFromCustomLineItemInput {
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A list containing the ARNs of resources to be disassociated.
    /// This member is required.
    public var resourceArns: [Swift.String]?
    /// A percentage custom line item ARN to disassociate the resources from.
    /// This member is required.
    public var targetArn: Swift.String?

    public init(
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        resourceArns: [Swift.String]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.billingPeriodRange = billingPeriodRange
        self.resourceArns = resourceArns
        self.targetArn = targetArn
    }
}

extension BillingconductorClientTypes {
    /// A resource disassociation result for a percentage custom line item.
    public struct DisassociateResourceResponseElement {
        /// The resource ARN that was disassociated from the custom line item.
        public var arn: Swift.String?
        /// An AssociateResourceError that's shown if the resource disassociation fails.
        public var error: BillingconductorClientTypes.AssociateResourceError?

        public init(
            arn: Swift.String? = nil,
            error: BillingconductorClientTypes.AssociateResourceError? = nil
        )
        {
            self.arn = arn
            self.error = error
        }
    }

}

public struct BatchDisassociateResourcesFromCustomLineItemOutput {
    /// A list of DisassociateResourceResponseElement for each resource that failed disassociation from a percentage custom line item.
    public var failedDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?
    /// A list of DisassociateResourceResponseElement for each resource that's been disassociated from a percentage custom line item successfully.
    public var successfullyDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]?

    public init(
        failedDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil,
        successfullyDisassociatedResources: [BillingconductorClientTypes.DisassociateResourceResponseElement]? = nil
    )
    {
        self.failedDisassociatedResources = failedDisassociatedResources
        self.successfullyDisassociatedResources = successfullyDisassociatedResources
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a flat custom line item.
    public struct CustomLineItemFlatChargeDetails {
        /// The custom line item's fixed charge value in USD.
        /// This member is required.
        public var chargeValue: Swift.Double?

        public init(
            chargeValue: Swift.Double? = nil
        )
        {
            self.chargeValue = chargeValue
        }
    }

}

extension BillingconductorClientTypes {

    public enum LineItemFilterAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lineItemType
        case sdkUnknown(Swift.String)

        public static var allCases: [LineItemFilterAttributeName] {
            return [
                .lineItemType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lineItemType: return "LINE_ITEM_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingconductorClientTypes {

    public enum MatchOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingconductorClientTypes {

    public enum LineItemFilterValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case savingsPlanNegation
        case sdkUnknown(Swift.String)

        public static var allCases: [LineItemFilterValue] {
            return [
                .savingsPlanNegation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .savingsPlanNegation: return "SAVINGS_PLAN_NEGATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingconductorClientTypes {
    /// A representation of the line item filter for your custom line item. You can use line item filters to include or exclude specific resource values from the billing group's total cost. For example, if you create a custom line item and you want to filter out a value, such as Savings Plan discounts, you can update LineItemFilter to exclude it.
    public struct LineItemFilter {
        /// The attribute of the line item filter. This specifies what attribute that you can filter on.
        /// This member is required.
        public var attribute: BillingconductorClientTypes.LineItemFilterAttributeName?
        /// The match criteria of the line item filter. This parameter specifies whether not to include the resource value from the billing group total cost.
        /// This member is required.
        public var matchOption: BillingconductorClientTypes.MatchOption?
        /// The values of the line item filter. This specifies the values to filter on. Currently, you can only exclude Savings Plan discounts.
        /// This member is required.
        public var values: [BillingconductorClientTypes.LineItemFilterValue]?

        public init(
            attribute: BillingconductorClientTypes.LineItemFilterAttributeName? = nil,
            matchOption: BillingconductorClientTypes.MatchOption? = nil,
            values: [BillingconductorClientTypes.LineItemFilterValue]? = nil
        )
        {
            self.attribute = attribute
            self.matchOption = matchOption
            self.values = values
        }
    }

}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a percentage custom line item.
    public struct CustomLineItemPercentageChargeDetails {
        /// A list of resource ARNs to associate to the percentage custom line item.
        public var associatedValues: [Swift.String]?
        /// The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        /// This member is required.
        public var percentageValue: Swift.Double?

        public init(
            associatedValues: [Swift.String]? = nil,
            percentageValue: Swift.Double? = nil
        )
        {
            self.associatedValues = associatedValues
            self.percentageValue = percentageValue
        }
    }

}

extension BillingconductorClientTypes {

    public enum CustomLineItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case credit
        case fee
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomLineItemType] {
            return [
                .credit,
                .fee
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .credit: return "CREDIT"
            case .fee: return "FEE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingconductorClientTypes {
    /// The charge details of a custom line item. It should contain only one of Flat or Percentage.
    public struct CustomLineItemChargeDetails {
        /// A CustomLineItemFlatChargeDetails that describes the charge details of a flat custom line item.
        public var flat: BillingconductorClientTypes.CustomLineItemFlatChargeDetails?
        /// A representation of the line item filter.
        public var lineItemFilters: [BillingconductorClientTypes.LineItemFilter]?
        /// A CustomLineItemPercentageChargeDetails that describes the charge details of a percentage custom line item.
        public var percentage: BillingconductorClientTypes.CustomLineItemPercentageChargeDetails?
        /// The type of the custom line item that indicates whether the charge is a fee or credit.
        /// This member is required.
        public var type: BillingconductorClientTypes.CustomLineItemType?

        public init(
            flat: BillingconductorClientTypes.CustomLineItemFlatChargeDetails? = nil,
            lineItemFilters: [BillingconductorClientTypes.LineItemFilter]? = nil,
            percentage: BillingconductorClientTypes.CustomLineItemPercentageChargeDetails? = nil,
            type: BillingconductorClientTypes.CustomLineItemType? = nil
        )
        {
            self.flat = flat
            self.lineItemFilters = lineItemFilters
            self.percentage = percentage
            self.type = type
        }
    }

}

public struct CreateCustomLineItemInput {
    /// The Amazon Web Services account in which this custom line item will be applied to.
    public var accountId: Swift.String?
    /// The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to.
    /// This member is required.
    public var billingGroupArn: Swift.String?
    /// A time range for which the custom line item is effective.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A CustomLineItemChargeDetails that describes the charge details for a custom line item.
    /// This member is required.
    public var chargeDetails: BillingconductorClientTypes.CustomLineItemChargeDetails?
    /// The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The description of the custom line item. This is shown on the Bills page in association with the charge value.
    /// This member is required.
    public var description: Swift.String?
    /// The name of the custom line item.
    /// This member is required.
    public var name: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a custom line item.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accountId: Swift.String? = nil,
        billingGroupArn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        chargeDetails: BillingconductorClientTypes.CustomLineItemChargeDetails? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accountId = accountId
        self.billingGroupArn = billingGroupArn
        self.billingPeriodRange = billingPeriodRange
        self.chargeDetails = chargeDetails
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

extension CreateCustomLineItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomLineItemInput(accountId: \(Swift.String(describing: accountId)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), billingPeriodRange: \(Swift.String(describing: billingPeriodRange)), chargeDetails: \(Swift.String(describing: chargeDetails)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateCustomLineItemOutput {
    /// The Amazon Resource Name (ARN) of the created custom line item.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteCustomLineItemInput {
    /// The ARN of the custom line item to be deleted.
    /// This member is required.
    public var arn: Swift.String?
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?

    public init(
        arn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil
    )
    {
        self.arn = arn
        self.billingPeriodRange = billingPeriodRange
    }
}

public struct DeleteCustomLineItemOutput {
    /// The ARN of the deleted custom line item.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension BillingconductorClientTypes {
    /// A filter that specifies the custom line items and billing groups to retrieve FFLI information.
    public struct ListCustomLineItemsFilter {
        /// The Amazon Web Services accounts in which this custom line item will be applied to.
        public var accountIds: [Swift.String]?
        /// A list of custom line item ARNs to retrieve information.
        public var arns: [Swift.String]?
        /// The billing group Amazon Resource Names (ARNs) to retrieve information.
        public var billingGroups: [Swift.String]?
        /// A list of custom line items to retrieve information.
        public var names: [Swift.String]?

        public init(
            accountIds: [Swift.String]? = nil,
            arns: [Swift.String]? = nil,
            billingGroups: [Swift.String]? = nil,
            names: [Swift.String]? = nil
        )
        {
            self.accountIds = accountIds
            self.arns = arns
            self.billingGroups = billingGroups
            self.names = names
        }
    }

}

extension BillingconductorClientTypes.ListCustomLineItemsFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCustomLineItemsFilter(accountIds: \(Swift.String(describing: accountIds)), arns: \(Swift.String(describing: arns)), billingGroups: \(Swift.String(describing: billingGroups)), names: \"CONTENT_REDACTED\")"}
}

public struct ListCustomLineItemsInput {
    /// The preferred billing period to get custom line items (FFLIs).
    public var billingPeriod: Swift.String?
    /// A ListCustomLineItemsFilter that specifies the custom line item names and/or billing group Amazon Resource Names (ARNs) to retrieve FFLI information.
    public var filters: BillingconductorClientTypes.ListCustomLineItemsFilter?
    /// The maximum number of billing groups to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to get custom line items (FFLIs).
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListCustomLineItemsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a flat custom line item.
    public struct ListCustomLineItemFlatChargeDetails {
        /// The custom line item's fixed charge value in USD.
        /// This member is required.
        public var chargeValue: Swift.Double?

        public init(
            chargeValue: Swift.Double? = nil
        )
        {
            self.chargeValue = chargeValue
        }
    }

}

extension BillingconductorClientTypes {
    /// A representation of the charge details that are associated with a percentage custom line item.
    public struct ListCustomLineItemPercentageChargeDetails {
        /// The custom line item's percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        /// This member is required.
        public var percentageValue: Swift.Double?

        public init(
            percentageValue: Swift.Double? = nil
        )
        {
            self.percentageValue = percentageValue
        }
    }

}

extension BillingconductorClientTypes {
    /// A representation of the charge details of a custom line item.
    public struct ListCustomLineItemChargeDetails {
        /// A ListCustomLineItemFlatChargeDetails that describes the charge details of a flat custom line item.
        public var flat: BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails?
        /// A representation of the line item filter.
        public var lineItemFilters: [BillingconductorClientTypes.LineItemFilter]?
        /// A ListCustomLineItemPercentageChargeDetails that describes the charge details of a percentage custom line item.
        public var percentage: BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails?
        /// The type of the custom line item that indicates whether the charge is a fee or credit.
        /// This member is required.
        public var type: BillingconductorClientTypes.CustomLineItemType?

        public init(
            flat: BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails? = nil,
            lineItemFilters: [BillingconductorClientTypes.LineItemFilter]? = nil,
            percentage: BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails? = nil,
            type: BillingconductorClientTypes.CustomLineItemType? = nil
        )
        {
            self.flat = flat
            self.lineItemFilters = lineItemFilters
            self.percentage = percentage
            self.type = type
        }
    }

}

extension BillingconductorClientTypes {

    public enum CurrencyCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cny
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .cny,
                .usd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cny: return "CNY"
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingconductorClientTypes {
    /// A representation of a custom line item.
    public struct CustomLineItemListElement {
        /// The Amazon Web Services account in which this custom line item will be applied to.
        public var accountId: Swift.String?
        /// The Amazon Resource Names (ARNs) for custom line items.
        public var arn: Swift.String?
        /// The number of resources that are associated to the custom line item.
        public var associationSize: Swift.Int
        /// The Amazon Resource Name (ARN) that references the billing group where the custom line item applies to.
        public var billingGroupArn: Swift.String?
        /// A ListCustomLineItemChargeDetails that describes the charge details of a custom line item.
        public var chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
        /// The time created.
        public var creationTime: Swift.Int
        /// The custom line item's charge value currency. Only one of the valid values can be used.
        public var currencyCode: BillingconductorClientTypes.CurrencyCode?
        /// The custom line item's description. This is shown on the Bills page in association with the charge value.
        public var description: Swift.String?
        /// The most recent time when the custom line item was modified.
        public var lastModifiedTime: Swift.Int
        /// The custom line item's name.
        public var name: Swift.String?
        /// The product code that's associated with the custom line item.
        public var productCode: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            associationSize: Swift.Int = 0,
            billingGroupArn: Swift.String? = nil,
            chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails? = nil,
            creationTime: Swift.Int = 0,
            currencyCode: BillingconductorClientTypes.CurrencyCode? = nil,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            productCode: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.associationSize = associationSize
            self.billingGroupArn = billingGroupArn
            self.chargeDetails = chargeDetails
            self.creationTime = creationTime
            self.currencyCode = currencyCode
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.productCode = productCode
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomLineItemListElement(accountId: \(Swift.String(describing: accountId)), arn: \(Swift.String(describing: arn)), associationSize: \(Swift.String(describing: associationSize)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), chargeDetails: \(Swift.String(describing: chargeDetails)), creationTime: \(Swift.String(describing: creationTime)), currencyCode: \(Swift.String(describing: currencyCode)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), productCode: \(Swift.String(describing: productCode)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListCustomLineItemsOutput {
    /// A list of FreeFormLineItemListElements received.
    public var customLineItems: [BillingconductorClientTypes.CustomLineItemListElement]?
    /// The pagination token that's used on subsequent calls to get custom line items (FFLIs).
    public var nextToken: Swift.String?

    public init(
        customLineItems: [BillingconductorClientTypes.CustomLineItemListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customLineItems = customLineItems
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// A billing period filter that specifies the custom line item versions to retrieve.
    public struct ListCustomLineItemVersionsBillingPeriodRangeFilter {
        /// The exclusive end billing period that defines a billing period range where a custom line item version is applied.
        public var endBillingPeriod: Swift.String?
        /// The inclusive start billing period that defines a billing period range where a custom line item version is applied.
        public var startBillingPeriod: Swift.String?

        public init(
            endBillingPeriod: Swift.String? = nil,
            startBillingPeriod: Swift.String? = nil
        )
        {
            self.endBillingPeriod = endBillingPeriod
            self.startBillingPeriod = startBillingPeriod
        }
    }

}

extension BillingconductorClientTypes {
    /// A filter that specifies the billing period range where the custom line item versions reside.
    public struct ListCustomLineItemVersionsFilter {
        /// The billing period range in which the custom line item version is applied.
        public var billingPeriodRange: BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter?

        public init(
            billingPeriodRange: BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter? = nil
        )
        {
            self.billingPeriodRange = billingPeriodRange
        }
    }

}

public struct ListCustomLineItemVersionsInput {
    /// The Amazon Resource Name (ARN) for the custom line item.
    /// This member is required.
    public var arn: Swift.String?
    /// A ListCustomLineItemVersionsFilter that specifies the billing period range in which the custom line item versions are applied.
    public var filters: BillingconductorClientTypes.ListCustomLineItemVersionsFilter?
    /// The maximum number of custom line item versions to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to retrieve custom line item versions.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListCustomLineItemVersionsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// A representation of a custom line item version.
    public struct CustomLineItemVersionListElement {
        /// The Amazon Web Services account in which this custom line item will be applied to.
        public var accountId: Swift.String?
        /// A list of custom line item Amazon Resource Names (ARNs) to retrieve information.
        public var arn: Swift.String?
        /// The number of resources that are associated with the custom line item.
        public var associationSize: Swift.Int
        /// The Amazon Resource Name (ARN) of the billing group that the custom line item applies to.
        public var billingGroupArn: Swift.String?
        /// A representation of the charge details of a custom line item.
        public var chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
        /// The time when the custom line item version was created.
        public var creationTime: Swift.Int
        /// The charge value currency of the custom line item.
        public var currencyCode: BillingconductorClientTypes.CurrencyCode?
        /// The description of the custom line item.
        public var description: Swift.String?
        /// The end billing period of the custom line item version.
        public var endBillingPeriod: Swift.String?
        /// The most recent time that the custom line item version was modified.
        public var lastModifiedTime: Swift.Int
        /// The name of the custom line item.
        public var name: Swift.String?
        /// The product code that’s associated with the custom line item.
        public var productCode: Swift.String?
        /// The start billing period of the custom line item version.
        public var startBillingPeriod: Swift.String?
        /// The inclusive start time.
        public var startTime: Swift.Int

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            associationSize: Swift.Int = 0,
            billingGroupArn: Swift.String? = nil,
            chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails? = nil,
            creationTime: Swift.Int = 0,
            currencyCode: BillingconductorClientTypes.CurrencyCode? = nil,
            description: Swift.String? = nil,
            endBillingPeriod: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            productCode: Swift.String? = nil,
            startBillingPeriod: Swift.String? = nil,
            startTime: Swift.Int = 0
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.associationSize = associationSize
            self.billingGroupArn = billingGroupArn
            self.chargeDetails = chargeDetails
            self.creationTime = creationTime
            self.currencyCode = currencyCode
            self.description = description
            self.endBillingPeriod = endBillingPeriod
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.productCode = productCode
            self.startBillingPeriod = startBillingPeriod
            self.startTime = startTime
        }
    }

}

extension BillingconductorClientTypes.CustomLineItemVersionListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomLineItemVersionListElement(accountId: \(Swift.String(describing: accountId)), arn: \(Swift.String(describing: arn)), associationSize: \(Swift.String(describing: associationSize)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), chargeDetails: \(Swift.String(describing: chargeDetails)), creationTime: \(Swift.String(describing: creationTime)), currencyCode: \(Swift.String(describing: currencyCode)), endBillingPeriod: \(Swift.String(describing: endBillingPeriod)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), productCode: \(Swift.String(describing: productCode)), startBillingPeriod: \(Swift.String(describing: startBillingPeriod)), startTime: \(Swift.String(describing: startTime)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListCustomLineItemVersionsOutput {
    /// A list of CustomLineItemVersionListElements that are received.
    public var customLineItemVersions: [BillingconductorClientTypes.CustomLineItemVersionListElement]?
    /// The pagination token that's used on subsequent calls to retrieve custom line item versions.
    public var nextToken: Swift.String?

    public init(
        customLineItemVersions: [BillingconductorClientTypes.CustomLineItemVersionListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customLineItemVersions = customLineItemVersions
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {

    public enum CustomLineItemRelationship: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case child
        case parent
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomLineItemRelationship] {
            return [
                .child,
                .parent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .child: return "CHILD"
            case .parent: return "PARENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingconductorClientTypes {
    /// A filter that specifies the type of resource associations that should be retrieved for a custom line item.
    public struct ListResourcesAssociatedToCustomLineItemFilter {
        /// The type of relationship between the custom line item and the associated resource.
        public var relationship: BillingconductorClientTypes.CustomLineItemRelationship?

        public init(
            relationship: BillingconductorClientTypes.CustomLineItemRelationship? = nil
        )
        {
            self.relationship = relationship
        }
    }

}

public struct ListResourcesAssociatedToCustomLineItemInput {
    /// The ARN of the custom line item for which the resource associations will be listed.
    /// This member is required.
    public var arn: Swift.String?
    /// The billing period for which the resource associations will be listed.
    public var billingPeriod: Swift.String?
    /// (Optional) A ListResourcesAssociatedToCustomLineItemFilter that can specify the types of resources that should be retrieved.
    public var filters: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter?
    /// (Optional) The maximum number of resource associations to be retrieved.
    public var maxResults: Swift.Int?
    /// (Optional) The pagination token that's returned by a previous request.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// A representation of a resource association for a custom line item.
    public struct ListResourcesAssociatedToCustomLineItemResponseElement {
        /// The ARN of the associated resource.
        public var arn: Swift.String?
        /// The end billing period of the associated resource.
        public var endBillingPeriod: Swift.String?
        /// The type of relationship between the custom line item and the associated resource.
        public var relationship: BillingconductorClientTypes.CustomLineItemRelationship?

        public init(
            arn: Swift.String? = nil,
            endBillingPeriod: Swift.String? = nil,
            relationship: BillingconductorClientTypes.CustomLineItemRelationship? = nil
        )
        {
            self.arn = arn
            self.endBillingPeriod = endBillingPeriod
            self.relationship = relationship
        }
    }

}

public struct ListResourcesAssociatedToCustomLineItemOutput {
    /// The custom line item ARN for which the resource associations are listed.
    public var arn: Swift.String?
    /// A list of ListResourcesAssociatedToCustomLineItemResponseElement for each resource association retrieved.
    public var associatedResources: [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]?
    /// The pagination token to be used in subsequent requests to retrieve additional results.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        associatedResources: [BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.associatedResources = associatedResources
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// A representation of the new charge details that are associated with a flat custom line item.
    public struct UpdateCustomLineItemFlatChargeDetails {
        /// The custom line item's new fixed charge value in USD.
        /// This member is required.
        public var chargeValue: Swift.Double?

        public init(
            chargeValue: Swift.Double? = nil
        )
        {
            self.chargeValue = chargeValue
        }
    }

}

extension BillingconductorClientTypes {
    /// A representation of the new charge details that are associated with a percentage custom line item.
    public struct UpdateCustomLineItemPercentageChargeDetails {
        /// The custom line item's new percentage value. This will be multiplied against the combined value of its associated resources to determine its charge value.
        /// This member is required.
        public var percentageValue: Swift.Double?

        public init(
            percentageValue: Swift.Double? = nil
        )
        {
            self.percentageValue = percentageValue
        }
    }

}

extension BillingconductorClientTypes {
    /// A representation of the new charge details of a custom line item. This should contain only one of Flat or Percentage.
    public struct UpdateCustomLineItemChargeDetails {
        /// An UpdateCustomLineItemFlatChargeDetails that describes the new charge details of a flat custom line item.
        public var flat: BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails?
        /// A representation of the line item filter.
        public var lineItemFilters: [BillingconductorClientTypes.LineItemFilter]?
        /// An UpdateCustomLineItemPercentageChargeDetails that describes the new charge details of a percentage custom line item.
        public var percentage: BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails?

        public init(
            flat: BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails? = nil,
            lineItemFilters: [BillingconductorClientTypes.LineItemFilter]? = nil,
            percentage: BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails? = nil
        )
        {
            self.flat = flat
            self.lineItemFilters = lineItemFilters
            self.percentage = percentage
        }
    }

}

public struct UpdateCustomLineItemInput {
    /// The ARN of the custom line item to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// The billing period range in which the custom line item request will be applied.
    public var billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?
    /// A ListCustomLineItemChargeDetails containing the new charge details for the custom line item.
    public var chargeDetails: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails?
    /// The new line item description of the custom line item.
    public var description: Swift.String?
    /// The new name for the custom line item.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.CustomLineItemBillingPeriodRange? = nil,
        chargeDetails: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.billingPeriodRange = billingPeriodRange
        self.chargeDetails = chargeDetails
        self.description = description
        self.name = name
    }
}

extension UpdateCustomLineItemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomLineItemInput(arn: \(Swift.String(describing: arn)), billingPeriodRange: \(Swift.String(describing: billingPeriodRange)), chargeDetails: \(Swift.String(describing: chargeDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateCustomLineItemOutput {
    /// The ARN of the successfully updated custom line item.
    public var arn: Swift.String?
    /// The number of resources that are associated to the custom line item.
    public var associationSize: Swift.Int
    /// The ARN of the billing group that the custom line item is applied to.
    public var billingGroupArn: Swift.String?
    /// A ListCustomLineItemChargeDetails containing the charge details of the successfully updated custom line item.
    public var chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails?
    /// The description of the successfully updated custom line item.
    public var description: Swift.String?
    /// The most recent time when the custom line item was modified.
    public var lastModifiedTime: Swift.Int
    /// The name of the successfully updated custom line item.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        associationSize: Swift.Int = 0,
        billingGroupArn: Swift.String? = nil,
        chargeDetails: BillingconductorClientTypes.ListCustomLineItemChargeDetails? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.associationSize = associationSize
        self.billingGroupArn = billingGroupArn
        self.chargeDetails = chargeDetails
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.name = name
    }
}

extension UpdateCustomLineItemOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCustomLineItemOutput(arn: \(Swift.String(describing: arn)), associationSize: \(Swift.String(describing: associationSize)), billingGroupArn: \(Swift.String(describing: billingGroupArn)), chargeDetails: \(Swift.String(describing: chargeDetails)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {
    /// A time range for which the margin summary is effective. The time range can be up to 12 months.
    public struct BillingPeriodRange {
        /// The exclusive end billing period that defines a billing period range for the margin summary. For example, if you choose a billing period that starts in October 2023 and ends in December 2023, the margin summary will only include data from October 2023 and November 2023.
        /// This member is required.
        public var exclusiveEndBillingPeriod: Swift.String?
        /// The inclusive start billing period that defines a billing period range for the margin summary.
        /// This member is required.
        public var inclusiveStartBillingPeriod: Swift.String?

        public init(
            exclusiveEndBillingPeriod: Swift.String? = nil,
            inclusiveStartBillingPeriod: Swift.String? = nil
        )
        {
            self.exclusiveEndBillingPeriod = exclusiveEndBillingPeriod
            self.inclusiveStartBillingPeriod = inclusiveStartBillingPeriod
        }
    }

}

extension BillingconductorClientTypes {

    public enum GroupByAttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case billingPeriod
        case productName
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupByAttributeName] {
            return [
                .billingPeriod,
                .productName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .billingPeriod: return "BILLING_PERIOD"
            case .productName: return "PRODUCT_NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetBillingGroupCostReportInput {
    /// The Amazon Resource Number (ARN) that uniquely identifies the billing group.
    /// This member is required.
    public var arn: Swift.String?
    /// A time range for which the margin summary is effective. You can specify up to 12 months.
    public var billingPeriodRange: BillingconductorClientTypes.BillingPeriodRange?
    /// A list of strings that specify the attributes that are used to break down costs in the margin summary reports for the billing group. For example, you can view your costs by the Amazon Web Service name or the billing period.
    public var groupBy: [BillingconductorClientTypes.GroupByAttributeName]?
    /// The maximum number of margin summary reports to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token used on subsequent calls to get reports.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        billingPeriodRange: BillingconductorClientTypes.BillingPeriodRange? = nil,
        groupBy: [BillingconductorClientTypes.GroupByAttributeName]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.billingPeriodRange = billingPeriodRange
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// A paginated call to retrieve a list of summary reports of actual Amazon Web Services charges and the calculated Amazon Web Services charges, broken down by attributes.
    public struct BillingGroupCostReportResultElement {
        /// The Amazon Resource Number (ARN) that uniquely identifies the billing group.
        public var arn: Swift.String?
        /// The list of key-value pairs that represent the attributes by which the BillingGroupCostReportResults are grouped. For example, if you want the Amazon S3 service-level breakdown of a billing group for November 2023, the attributes list will contain a key-value pair of "PRODUCT_NAME" and "S3" and a key-value pair of "BILLING_PERIOD" and "Nov 2023".
        public var attributes: [BillingconductorClientTypes.Attribute]?
        /// The actual Amazon Web Services charges for the billing group.
        public var awsCost: Swift.String?
        /// The displayed currency.
        public var currency: Swift.String?
        /// The billing group margin.
        public var margin: Swift.String?
        /// The percentage of the billing group margin.
        public var marginPercentage: Swift.String?
        /// The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group.
        public var proformaCost: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attributes: [BillingconductorClientTypes.Attribute]? = nil,
            awsCost: Swift.String? = nil,
            currency: Swift.String? = nil,
            margin: Swift.String? = nil,
            marginPercentage: Swift.String? = nil,
            proformaCost: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.awsCost = awsCost
            self.currency = currency
            self.margin = margin
            self.marginPercentage = marginPercentage
            self.proformaCost = proformaCost
        }
    }

}

public struct GetBillingGroupCostReportOutput {
    /// The list of margin summary reports.
    public var billingGroupCostReportResults: [BillingconductorClientTypes.BillingGroupCostReportResultElement]?
    /// The pagination token used on subsequent calls to get reports.
    public var nextToken: Swift.String?

    public init(
        billingGroupCostReportResults: [BillingconductorClientTypes.BillingGroupCostReportResultElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroupCostReportResults = billingGroupCostReportResults
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// The filter on the account ID of the linked account, or any of the following: MONITORED: linked accounts that are associated to billing groups. UNMONITORED: linked accounts that are not associated to billing groups. Billing Group Arn: linked accounts that are associated to the provided Billing Group Arn.
    public struct ListAccountAssociationsFilter {
        /// The Amazon Web Services account ID to filter on.
        public var accountId: Swift.String?
        /// The list of Amazon Web Services IDs to retrieve their associated billing group for a given time range.
        public var accountIds: [Swift.String]?
        /// MONITORED: linked accounts that are associated to billing groups. UNMONITORED: linked accounts that are not associated to billing groups. Billing Group Arn: linked accounts that are associated to the provided Billing Group Arn.
        public var association: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            accountIds: [Swift.String]? = nil,
            association: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.accountIds = accountIds
            self.association = association
        }
    }

}

public struct ListAccountAssociationsInput {
    /// The preferred billing period to get account associations.
    public var billingPeriod: Swift.String?
    /// The filter on the account ID of the linked account, or any of the following: MONITORED: linked accounts that are associated to billing groups. UNMONITORED: linked accounts that aren't associated to billing groups. Billing Group Arn: linked accounts that are associated to the provided billing group Arn.
    public var filters: BillingconductorClientTypes.ListAccountAssociationsFilter?
    /// The pagination token that's used on subsequent calls to retrieve accounts.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListAccountAssociationsFilter? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.nextToken = nextToken
    }
}

public struct ListAccountAssociationsOutput {
    /// The list of linked accounts in the payer account.
    public var linkedAccounts: [BillingconductorClientTypes.AccountAssociationsListElement]?
    /// The pagination token that's used on subsequent calls to get accounts.
    public var nextToken: Swift.String?

    public init(
        linkedAccounts: [BillingconductorClientTypes.AccountAssociationsListElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkedAccounts = linkedAccounts
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// The filter used to retrieve specific BillingGroupCostReportElements.
    public struct ListBillingGroupCostReportsFilter {
        /// The list of Amazon Resource Names (ARNs) used to filter billing groups to retrieve reports.
        public var billingGroupArns: [Swift.String]?

        public init(
            billingGroupArns: [Swift.String]? = nil
        )
        {
            self.billingGroupArns = billingGroupArns
        }
    }

}

public struct ListBillingGroupCostReportsInput {
    /// The preferred billing period for your report.
    public var billingPeriod: Swift.String?
    /// A ListBillingGroupCostReportsFilter to specify billing groups to retrieve reports from.
    public var filters: BillingconductorClientTypes.ListBillingGroupCostReportsFilter?
    /// The maximum number of reports to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent calls to get reports.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListBillingGroupCostReportsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// A summary report of actual Amazon Web Services charges and calculated Amazon Web Services charges, based on the associated pricing plan of a billing group.
    public struct BillingGroupCostReportElement {
        /// The Amazon Resource Name (ARN) of a billing group.
        public var arn: Swift.String?
        /// The actual Amazon Web Services charges for the billing group.
        public var awsCost: Swift.String?
        /// The displayed currency.
        public var currency: Swift.String?
        /// The billing group margin.
        public var margin: Swift.String?
        /// The percentage of billing group margin.
        public var marginPercentage: Swift.String?
        /// The hypothetical Amazon Web Services charges based on the associated pricing plan of a billing group.
        public var proformaCost: Swift.String?

        public init(
            arn: Swift.String? = nil,
            awsCost: Swift.String? = nil,
            currency: Swift.String? = nil,
            margin: Swift.String? = nil,
            marginPercentage: Swift.String? = nil,
            proformaCost: Swift.String? = nil
        )
        {
            self.arn = arn
            self.awsCost = awsCost
            self.currency = currency
            self.margin = margin
            self.marginPercentage = marginPercentage
            self.proformaCost = proformaCost
        }
    }

}

public struct ListBillingGroupCostReportsOutput {
    /// A list of BillingGroupCostReportElement retrieved.
    public var billingGroupCostReports: [BillingconductorClientTypes.BillingGroupCostReportElement]?
    /// The pagination token that's used on subsequent calls to get reports.
    public var nextToken: Swift.String?

    public init(
        billingGroupCostReports: [BillingconductorClientTypes.BillingGroupCostReportElement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingGroupCostReports = billingGroupCostReports
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) that identifies the resource to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The tags for the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct CreatePricingPlanInput {
    /// The token that is needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The description of the pricing plan.
    public var description: Swift.String?
    /// The name of the pricing plan. The names must be unique to each pricing plan.
    /// This member is required.
    public var name: Swift.String?
    /// A list of Amazon Resource Names (ARNs) that define the pricing plan parameters.
    public var pricingRuleArns: [Swift.String]?
    /// A map that contains tag keys and tag values that are attached to a pricing plan.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.pricingRuleArns = pricingRuleArns
        self.tags = tags
    }
}

extension CreatePricingPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePricingPlanInput(clientToken: \(Swift.String(describing: clientToken)), pricingRuleArns: \(Swift.String(describing: pricingRuleArns)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreatePricingPlanOutput {
    /// The Amazon Resource Name (ARN) of the created pricing plan.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeletePricingPlanInput {
    /// The Amazon Resource Name (ARN) of the pricing plan that you're deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeletePricingPlanOutput {
    /// The Amazon Resource Name (ARN) of the deleted pricing plan.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DisassociatePricingRulesInput {
    /// The pricing plan Amazon Resource Name (ARN) to disassociate pricing rules from.
    /// This member is required.
    public var arn: Swift.String?
    /// A list containing the Amazon Resource Name (ARN) of the pricing rules that will be disassociated.
    /// This member is required.
    public var pricingRuleArns: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.pricingRuleArns = pricingRuleArns
    }
}

public struct DisassociatePricingRulesOutput {
    /// The Amazon Resource Name (ARN) of the pricing plan that the pricing rules successfully disassociated from.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension BillingconductorClientTypes {
    /// The filter that specifies the Amazon Resource Names (ARNs) of pricing plans, to retrieve pricing plan information.
    public struct ListPricingPlansFilter {
        /// A list of pricing plan Amazon Resource Names (ARNs) to retrieve information.
        public var arns: [Swift.String]?

        public init(
            arns: [Swift.String]? = nil
        )
        {
            self.arns = arns
        }
    }

}

public struct ListPricingPlansInput {
    /// The preferred billing period to get pricing plan.
    public var billingPeriod: Swift.String?
    /// A ListPricingPlansFilter that specifies the Amazon Resource Name (ARNs) of pricing plans to retrieve pricing plans information.
    public var filters: BillingconductorClientTypes.ListPricingPlansFilter?
    /// The maximum number of pricing plans to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent call to get pricing plans.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListPricingPlansFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// A representation of a pricing plan.
    public struct PricingPlanListElement {
        /// The pricing plan Amazon Resource Names (ARN). This can be used to uniquely identify a pricing plan.
        public var arn: Swift.String?
        /// The time when the pricing plan was created.
        public var creationTime: Swift.Int
        /// The pricing plan description.
        public var description: Swift.String?
        /// The most recent time when the pricing plan was modified.
        public var lastModifiedTime: Swift.Int
        /// The name of a pricing plan.
        public var name: Swift.String?
        /// The pricing rules count that's currently associated with this pricing plan list element.
        public var size: Swift.Int

        public init(
            arn: Swift.String? = nil,
            creationTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            name: Swift.String? = nil,
            size: Swift.Int = 0
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.size = size
        }
    }

}

extension BillingconductorClientTypes.PricingPlanListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PricingPlanListElement(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), size: \(Swift.String(describing: size)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListPricingPlansOutput {
    /// The billing period for which the described pricing plans are applicable.
    public var billingPeriod: Swift.String?
    /// The pagination token that's used on subsequent calls to get pricing plans.
    public var nextToken: Swift.String?
    /// A list of PricingPlanListElement retrieved.
    public var pricingPlans: [BillingconductorClientTypes.PricingPlanListElement]?

    public init(
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingPlans: [BillingconductorClientTypes.PricingPlanListElement]? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingPlans = pricingPlans
    }
}

public struct ListPricingPlansAssociatedWithPricingRuleInput {
    /// The pricing plan billing period for which associations will be listed.
    public var billingPeriod: Swift.String?
    /// The optional maximum number of pricing rule associations to retrieve.
    public var maxResults: Swift.Int?
    /// The optional pagination token returned by a previous call.
    public var nextToken: Swift.String?
    /// The pricing rule Amazon Resource Name (ARN) for which associations will be listed.
    /// This member is required.
    public var pricingRuleArn: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pricingRuleArn: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pricingRuleArn = pricingRuleArn
    }
}

public struct ListPricingPlansAssociatedWithPricingRuleOutput {
    /// The pricing plan billing period for which associations will be listed.
    public var billingPeriod: Swift.String?
    /// The pagination token to be used on subsequent calls.
    public var nextToken: Swift.String?
    /// The list containing pricing plans that are associated with the requested pricing rule.
    public var pricingPlanArns: [Swift.String]?
    /// The pricing rule Amazon Resource Name (ARN) for which associations will be listed.
    public var pricingRuleArn: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingPlanArns: [Swift.String]? = nil,
        pricingRuleArn: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingPlanArns = pricingPlanArns
        self.pricingRuleArn = pricingRuleArn
    }
}

public struct UpdatePricingPlanInput {
    /// The Amazon Resource Name (ARN) of the pricing plan that you're updating.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the pricing plan.
    public var description: Swift.String?
    /// The name of the pricing plan. The name must be unique to each pricing plan.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.name = name
    }
}

extension UpdatePricingPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingPlanInput(arn: \(Swift.String(describing: arn)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdatePricingPlanOutput {
    /// The Amazon Resource Name (ARN) of the updated pricing plan.
    public var arn: Swift.String?
    /// The new description for the pricing rule.
    public var description: Swift.String?
    /// The most recent time when the pricing plan was modified.
    public var lastModifiedTime: Swift.Int
    /// The name of the pricing plan. The name must be unique to each pricing plan.
    public var name: Swift.String?
    /// The pricing rules count that's currently associated with this pricing plan list.
    public var size: Swift.Int

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        name: Swift.String? = nil,
        size: Swift.Int = 0
    )
    {
        self.arn = arn
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.size = size
    }
}

extension UpdatePricingPlanOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingPlanOutput(arn: \(Swift.String(describing: arn)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), size: \(Swift.String(describing: size)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BillingconductorClientTypes {

    public enum PricingRuleScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case billingEntity
        case global
        case service
        case sku
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingRuleScope] {
            return [
                .billingEntity,
                .global,
                .service,
                .sku
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .billingEntity: return "BILLING_ENTITY"
            case .global: return "GLOBAL"
            case .service: return "SERVICE"
            case .sku: return "SKU"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BillingconductorClientTypes {
    /// The possible Amazon Web Services Free Tier configurations.
    public struct CreateFreeTierConfig {
        /// Activate or deactivate Amazon Web Services Free Tier.
        /// This member is required.
        public var activated: Swift.Bool?

        public init(
            activated: Swift.Bool? = nil
        )
        {
            self.activated = activated
        }
    }

}

extension BillingconductorClientTypes {
    /// The set of tiering configurations for the pricing rule.
    public struct CreateTieringInput {
        /// The possible Amazon Web Services Free Tier configurations.
        /// This member is required.
        public var freeTier: BillingconductorClientTypes.CreateFreeTierConfig?

        public init(
            freeTier: BillingconductorClientTypes.CreateFreeTierConfig? = nil
        )
        {
            self.freeTier = freeTier
        }
    }

}

extension BillingconductorClientTypes {

    public enum PricingRuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case discount
        case markup
        case tiering
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingRuleType] {
            return [
                .discount,
                .markup,
                .tiering
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .discount: return "DISCOUNT"
            case .markup: return "MARKUP"
            case .tiering: return "TIERING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePricingRuleInput {
    /// The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
    public var billingEntity: Swift.String?
    /// The token that's needed to support idempotency. Idempotency isn't currently supported, but will be implemented in a future update.
    public var clientToken: Swift.String?
    /// The pricing rule description.
    public var description: Swift.String?
    /// A percentage modifier that's applied on the public pricing rates.
    public var modifierPercentage: Swift.Double?
    /// The pricing rule name. The names must be unique to each pricing rule.
    /// This member is required.
    public var name: Swift.String?
    /// Operation is the specific Amazon Web Services action covered by this line item. This describes the specific usage of the line item. If the Scope attribute is set to SKU, this attribute indicates which operation the PricingRule is modifying. For example, a value of RunInstances:0202 indicates the operation of running an Amazon EC2 instance.
    public var operation: Swift.String?
    /// The scope of pricing rule that indicates if it's globally applicable, or it's service-specific.
    /// This member is required.
    public var scope: BillingconductorClientTypes.PricingRuleScope?
    /// If the Scope attribute is set to SERVICE or SKU, the attribute indicates which service the PricingRule is applicable for.
    public var service: Swift.String?
    /// A map that contains tag keys and tag values that are attached to a pricing rule.
    public var tags: [Swift.String: Swift.String]?
    /// The set of tiering configurations for the pricing rule.
    public var tiering: BillingconductorClientTypes.CreateTieringInput?
    /// The type of pricing rule.
    /// This member is required.
    public var type: BillingconductorClientTypes.PricingRuleType?
    /// Usage type is the unit that each service uses to measure the usage of a specific type of resource. If the Scope attribute is set to SKU, this attribute indicates which usage type the PricingRule is modifying. For example, USW2-BoxUsage:m2.2xlarge describes an M2 High Memory Double Extra Large instance in the US West (Oregon) Region.
    public var usageType: Swift.String?

    public init(
        billingEntity: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        modifierPercentage: Swift.Double? = nil,
        name: Swift.String? = nil,
        operation: Swift.String? = nil,
        scope: BillingconductorClientTypes.PricingRuleScope? = nil,
        service: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        tiering: BillingconductorClientTypes.CreateTieringInput? = nil,
        type: BillingconductorClientTypes.PricingRuleType? = nil,
        usageType: Swift.String? = nil
    )
    {
        self.billingEntity = billingEntity
        self.clientToken = clientToken
        self.description = description
        self.modifierPercentage = modifierPercentage
        self.name = name
        self.operation = operation
        self.scope = scope
        self.service = service
        self.tags = tags
        self.tiering = tiering
        self.type = type
        self.usageType = usageType
    }
}

extension CreatePricingRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePricingRuleInput(billingEntity: \(Swift.String(describing: billingEntity)), clientToken: \(Swift.String(describing: clientToken)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), operation: \(Swift.String(describing: operation)), scope: \(Swift.String(describing: scope)), service: \(Swift.String(describing: service)), tags: \(Swift.String(describing: tags)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), usageType: \(Swift.String(describing: usageType)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreatePricingRuleOutput {
    /// The Amazon Resource Name (ARN) of the created pricing rule.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeletePricingRuleInput {
    /// The Amazon Resource Name (ARN) of the pricing rule that you are deleting.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeletePricingRuleOutput {
    /// The Amazon Resource Name (ARN) of the deleted pricing rule.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension BillingconductorClientTypes {
    /// The filter that specifies criteria that the pricing rules returned by the ListPricingRules API will adhere to.
    public struct ListPricingRulesFilter {
        /// A list containing the pricing rule Amazon Resource Names (ARNs) to include in the API response.
        public var arns: [Swift.String]?

        public init(
            arns: [Swift.String]? = nil
        )
        {
            self.arns = arns
        }
    }

}

public struct ListPricingRulesInput {
    /// The preferred billing period to get the pricing plan.
    public var billingPeriod: Swift.String?
    /// A DescribePricingRuleFilter that specifies the Amazon Resource Name (ARNs) of pricing rules to retrieve pricing rules information.
    public var filters: BillingconductorClientTypes.ListPricingRulesFilter?
    /// The maximum number of pricing rules to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token that's used on subsequent call to get pricing rules.
    public var nextToken: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        filters: BillingconductorClientTypes.ListPricingRulesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BillingconductorClientTypes {
    /// The possible Amazon Web Services Free Tier configurations.
    public struct FreeTierConfig {
        /// Activate or deactivate Amazon Web Services Free Tier application.
        /// This member is required.
        public var activated: Swift.Bool?

        public init(
            activated: Swift.Bool? = nil
        )
        {
            self.activated = activated
        }
    }

}

extension BillingconductorClientTypes {
    /// The set of tiering configurations for the pricing rule.
    public struct Tiering {
        /// The possible Amazon Web Services Free Tier configurations.
        /// This member is required.
        public var freeTier: BillingconductorClientTypes.FreeTierConfig?

        public init(
            freeTier: BillingconductorClientTypes.FreeTierConfig? = nil
        )
        {
            self.freeTier = freeTier
        }
    }

}

extension BillingconductorClientTypes {
    /// A representation of a pricing rule.
    public struct PricingRuleListElement {
        /// The Amazon Resource Name (ARN) used to uniquely identify a pricing rule.
        public var arn: Swift.String?
        /// The pricing plans count that this pricing rule is associated with.
        public var associatedPricingPlanCount: Swift.Int
        /// The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
        public var billingEntity: Swift.String?
        /// The time when the pricing rule was created.
        public var creationTime: Swift.Int
        /// The pricing rule description.
        public var description: Swift.String?
        /// The most recent time when the pricing rule was modified.
        public var lastModifiedTime: Swift.Int
        /// A percentage modifier applied on the public pricing rates.
        public var modifierPercentage: Swift.Double?
        /// The name of a pricing rule.
        public var name: Swift.String?
        /// Operation is the specific Amazon Web Services action covered by this line item. This describes the specific usage of the line item. If the Scope attribute is set to SKU, this attribute indicates which operation the PricingRule is modifying. For example, a value of RunInstances:0202 indicates the operation of running an Amazon EC2 instance.
        public var operation: Swift.String?
        /// The scope of pricing rule that indicates if it is globally applicable, or if it is service-specific.
        public var scope: BillingconductorClientTypes.PricingRuleScope?
        /// If the Scope attribute is SERVICE, this attribute indicates which service the PricingRule is applicable for.
        public var service: Swift.String?
        /// The set of tiering configurations for the pricing rule.
        public var tiering: BillingconductorClientTypes.Tiering?
        /// The type of pricing rule.
        public var type: BillingconductorClientTypes.PricingRuleType?
        /// Usage type is the unit that each service uses to measure the usage of a specific type of resource. If the Scope attribute is set to SKU, this attribute indicates which usage type the PricingRule is modifying. For example, USW2-BoxUsage:m2.2xlarge describes an M2 High Memory Double Extra Large instance in the US West (Oregon) Region.
        public var usageType: Swift.String?

        public init(
            arn: Swift.String? = nil,
            associatedPricingPlanCount: Swift.Int = 0,
            billingEntity: Swift.String? = nil,
            creationTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            modifierPercentage: Swift.Double? = nil,
            name: Swift.String? = nil,
            operation: Swift.String? = nil,
            scope: BillingconductorClientTypes.PricingRuleScope? = nil,
            service: Swift.String? = nil,
            tiering: BillingconductorClientTypes.Tiering? = nil,
            type: BillingconductorClientTypes.PricingRuleType? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.arn = arn
            self.associatedPricingPlanCount = associatedPricingPlanCount
            self.billingEntity = billingEntity
            self.creationTime = creationTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.modifierPercentage = modifierPercentage
            self.name = name
            self.operation = operation
            self.scope = scope
            self.service = service
            self.tiering = tiering
            self.type = type
            self.usageType = usageType
        }
    }

}

extension BillingconductorClientTypes.PricingRuleListElement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PricingRuleListElement(arn: \(Swift.String(describing: arn)), associatedPricingPlanCount: \(Swift.String(describing: associatedPricingPlanCount)), billingEntity: \(Swift.String(describing: billingEntity)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), operation: \(Swift.String(describing: operation)), scope: \(Swift.String(describing: scope)), service: \(Swift.String(describing: service)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), usageType: \(Swift.String(describing: usageType)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListPricingRulesOutput {
    /// The billing period for which the described pricing rules are applicable.
    public var billingPeriod: Swift.String?
    /// The pagination token that's used on subsequent calls to get pricing rules.
    public var nextToken: Swift.String?
    /// A list containing the described pricing rules.
    public var pricingRules: [BillingconductorClientTypes.PricingRuleListElement]?

    public init(
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingRules: [BillingconductorClientTypes.PricingRuleListElement]? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingRules = pricingRules
    }
}

public struct ListPricingRulesAssociatedToPricingPlanInput {
    /// The billing period for which the pricing rule associations are to be listed.
    public var billingPeriod: Swift.String?
    /// The optional maximum number of pricing rule associations to retrieve.
    public var maxResults: Swift.Int?
    /// The optional pagination token returned by a previous call.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the pricing plan for which associations are to be listed.
    /// This member is required.
    public var pricingPlanArn: Swift.String?

    public init(
        billingPeriod: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pricingPlanArn: Swift.String? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pricingPlanArn = pricingPlanArn
    }
}

public struct ListPricingRulesAssociatedToPricingPlanOutput {
    /// The billing period for which the pricing rule associations are listed.
    public var billingPeriod: Swift.String?
    /// The pagination token to be used on subsequent calls.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the pricing plan for which associations are listed.
    public var pricingPlanArn: Swift.String?
    /// A list containing pricing rules that are associated with the requested pricing plan.
    public var pricingRuleArns: [Swift.String]?

    public init(
        billingPeriod: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        pricingPlanArn: Swift.String? = nil,
        pricingRuleArns: [Swift.String]? = nil
    )
    {
        self.billingPeriod = billingPeriod
        self.nextToken = nextToken
        self.pricingPlanArn = pricingPlanArn
        self.pricingRuleArns = pricingRuleArns
    }
}

extension BillingconductorClientTypes {
    /// The possible Amazon Web Services Free Tier configurations.
    public struct UpdateFreeTierConfig {
        /// Activate or deactivate application of Amazon Web Services Free Tier.
        /// This member is required.
        public var activated: Swift.Bool?

        public init(
            activated: Swift.Bool? = nil
        )
        {
            self.activated = activated
        }
    }

}

extension BillingconductorClientTypes {
    /// The set of tiering configurations for the pricing rule.
    public struct UpdateTieringInput {
        /// The possible Amazon Web Services Free Tier configurations.
        /// This member is required.
        public var freeTier: BillingconductorClientTypes.UpdateFreeTierConfig?

        public init(
            freeTier: BillingconductorClientTypes.UpdateFreeTierConfig? = nil
        )
        {
            self.freeTier = freeTier
        }
    }

}

public struct UpdatePricingRuleInput {
    /// The Amazon Resource Name (ARN) of the pricing rule to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The new description for the pricing rule.
    public var description: Swift.String?
    /// The new modifier to show pricing plan rates as a percentage.
    public var modifierPercentage: Swift.Double?
    /// The new name of the pricing rule. The name must be unique to each pricing rule.
    public var name: Swift.String?
    /// The set of tiering configurations for the pricing rule.
    public var tiering: BillingconductorClientTypes.UpdateTieringInput?
    /// The new pricing rule type.
    public var type: BillingconductorClientTypes.PricingRuleType?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        modifierPercentage: Swift.Double? = nil,
        name: Swift.String? = nil,
        tiering: BillingconductorClientTypes.UpdateTieringInput? = nil,
        type: BillingconductorClientTypes.PricingRuleType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.modifierPercentage = modifierPercentage
        self.name = name
        self.tiering = tiering
        self.type = type
    }
}

extension UpdatePricingRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingRuleInput(arn: \(Swift.String(describing: arn)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdatePricingRuleOutput {
    /// The Amazon Resource Name (ARN) of the successfully updated pricing rule.
    public var arn: Swift.String?
    /// The pricing plans count that this pricing rule is associated with.
    public var associatedPricingPlanCount: Swift.Int
    /// The seller of services provided by Amazon Web Services, their affiliates, or third-party providers selling services via Amazon Web Services Marketplace.
    public var billingEntity: Swift.String?
    /// The new description for the pricing rule.
    public var description: Swift.String?
    /// The most recent time the pricing rule was modified.
    public var lastModifiedTime: Swift.Int
    /// The new modifier to show pricing plan rates as a percentage.
    public var modifierPercentage: Swift.Double?
    /// The new name of the pricing rule. The name must be unique to each pricing rule.
    public var name: Swift.String?
    /// Operation refers to the specific Amazon Web Services covered by this line item. This describes the specific usage of the line item. If the Scope attribute is set to SKU, this attribute indicates which operation the PricingRule is modifying. For example, a value of RunInstances:0202 indicates the operation of running an Amazon EC2 instance.
    public var operation: Swift.String?
    /// The scope of pricing rule that indicates if it's globally applicable, or it's service-specific.
    public var scope: BillingconductorClientTypes.PricingRuleScope?
    /// If the Scope attribute is set to SERVICE, the attribute indicates which service the PricingRule is applicable for.
    public var service: Swift.String?
    /// The set of tiering configurations for the pricing rule.
    public var tiering: BillingconductorClientTypes.UpdateTieringInput?
    /// The new pricing rule type.
    public var type: BillingconductorClientTypes.PricingRuleType?
    /// Usage type is the unit that each service uses to measure the usage of a specific type of resource. If the Scope attribute is set to SKU, this attribute indicates which usage type the PricingRule is modifying. For example, USW2-BoxUsage:m2.2xlarge describes an M2 High Memory Double Extra Large instance in the US West (Oregon) Region.
    public var usageType: Swift.String?

    public init(
        arn: Swift.String? = nil,
        associatedPricingPlanCount: Swift.Int = 0,
        billingEntity: Swift.String? = nil,
        description: Swift.String? = nil,
        lastModifiedTime: Swift.Int = 0,
        modifierPercentage: Swift.Double? = nil,
        name: Swift.String? = nil,
        operation: Swift.String? = nil,
        scope: BillingconductorClientTypes.PricingRuleScope? = nil,
        service: Swift.String? = nil,
        tiering: BillingconductorClientTypes.UpdateTieringInput? = nil,
        type: BillingconductorClientTypes.PricingRuleType? = nil,
        usageType: Swift.String? = nil
    )
    {
        self.arn = arn
        self.associatedPricingPlanCount = associatedPricingPlanCount
        self.billingEntity = billingEntity
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.modifierPercentage = modifierPercentage
        self.name = name
        self.operation = operation
        self.scope = scope
        self.service = service
        self.tiering = tiering
        self.type = type
        self.usageType = usageType
    }
}

extension UpdatePricingRuleOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePricingRuleOutput(arn: \(Swift.String(describing: arn)), associatedPricingPlanCount: \(Swift.String(describing: associatedPricingPlanCount)), billingEntity: \(Swift.String(describing: billingEntity)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modifierPercentage: \(Swift.String(describing: modifierPercentage)), operation: \(Swift.String(describing: operation)), scope: \(Swift.String(describing: scope)), service: \(Swift.String(describing: service)), tiering: \(Swift.String(describing: tiering)), type: \(Swift.String(describing: type)), usageType: \(Swift.String(describing: usageType)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource as a list of key-value pairs.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to which to delete tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to delete from the resource as a list of key-value pairs.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension AssociateAccountsInput {

    static func urlPathProvider(_ value: AssociateAccountsInput) -> Swift.String? {
        return "/associate-accounts"
    }
}

extension AssociatePricingRulesInput {

    static func urlPathProvider(_ value: AssociatePricingRulesInput) -> Swift.String? {
        return "/associate-pricing-rules"
    }
}

extension BatchAssociateResourcesToCustomLineItemInput {

    static func urlPathProvider(_ value: BatchAssociateResourcesToCustomLineItemInput) -> Swift.String? {
        return "/batch-associate-resources-to-custom-line-item"
    }
}

extension BatchDisassociateResourcesFromCustomLineItemInput {

    static func urlPathProvider(_ value: BatchDisassociateResourcesFromCustomLineItemInput) -> Swift.String? {
        return "/batch-disassociate-resources-from-custom-line-item"
    }
}

extension CreateBillingGroupInput {

    static func urlPathProvider(_ value: CreateBillingGroupInput) -> Swift.String? {
        return "/create-billing-group"
    }
}

extension CreateBillingGroupInput {

    static func headerProvider(_ value: CreateBillingGroupInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateCustomLineItemInput {

    static func urlPathProvider(_ value: CreateCustomLineItemInput) -> Swift.String? {
        return "/create-custom-line-item"
    }
}

extension CreateCustomLineItemInput {

    static func headerProvider(_ value: CreateCustomLineItemInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreatePricingPlanInput {

    static func urlPathProvider(_ value: CreatePricingPlanInput) -> Swift.String? {
        return "/create-pricing-plan"
    }
}

extension CreatePricingPlanInput {

    static func headerProvider(_ value: CreatePricingPlanInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreatePricingRuleInput {

    static func urlPathProvider(_ value: CreatePricingRuleInput) -> Swift.String? {
        return "/create-pricing-rule"
    }
}

extension CreatePricingRuleInput {

    static func headerProvider(_ value: CreatePricingRuleInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteBillingGroupInput {

    static func urlPathProvider(_ value: DeleteBillingGroupInput) -> Swift.String? {
        return "/delete-billing-group"
    }
}

extension DeleteCustomLineItemInput {

    static func urlPathProvider(_ value: DeleteCustomLineItemInput) -> Swift.String? {
        return "/delete-custom-line-item"
    }
}

extension DeletePricingPlanInput {

    static func urlPathProvider(_ value: DeletePricingPlanInput) -> Swift.String? {
        return "/delete-pricing-plan"
    }
}

extension DeletePricingRuleInput {

    static func urlPathProvider(_ value: DeletePricingRuleInput) -> Swift.String? {
        return "/delete-pricing-rule"
    }
}

extension DisassociateAccountsInput {

    static func urlPathProvider(_ value: DisassociateAccountsInput) -> Swift.String? {
        return "/disassociate-accounts"
    }
}

extension DisassociatePricingRulesInput {

    static func urlPathProvider(_ value: DisassociatePricingRulesInput) -> Swift.String? {
        return "/disassociate-pricing-rules"
    }
}

extension GetBillingGroupCostReportInput {

    static func urlPathProvider(_ value: GetBillingGroupCostReportInput) -> Swift.String? {
        return "/get-billing-group-cost-report"
    }
}

extension ListAccountAssociationsInput {

    static func urlPathProvider(_ value: ListAccountAssociationsInput) -> Swift.String? {
        return "/list-account-associations"
    }
}

extension ListBillingGroupCostReportsInput {

    static func urlPathProvider(_ value: ListBillingGroupCostReportsInput) -> Swift.String? {
        return "/list-billing-group-cost-reports"
    }
}

extension ListBillingGroupsInput {

    static func urlPathProvider(_ value: ListBillingGroupsInput) -> Swift.String? {
        return "/list-billing-groups"
    }
}

extension ListCustomLineItemsInput {

    static func urlPathProvider(_ value: ListCustomLineItemsInput) -> Swift.String? {
        return "/list-custom-line-items"
    }
}

extension ListCustomLineItemVersionsInput {

    static func urlPathProvider(_ value: ListCustomLineItemVersionsInput) -> Swift.String? {
        return "/list-custom-line-item-versions"
    }
}

extension ListPricingPlansInput {

    static func urlPathProvider(_ value: ListPricingPlansInput) -> Swift.String? {
        return "/list-pricing-plans"
    }
}

extension ListPricingPlansAssociatedWithPricingRuleInput {

    static func urlPathProvider(_ value: ListPricingPlansAssociatedWithPricingRuleInput) -> Swift.String? {
        return "/list-pricing-plans-associated-with-pricing-rule"
    }
}

extension ListPricingRulesInput {

    static func urlPathProvider(_ value: ListPricingRulesInput) -> Swift.String? {
        return "/list-pricing-rules"
    }
}

extension ListPricingRulesAssociatedToPricingPlanInput {

    static func urlPathProvider(_ value: ListPricingRulesAssociatedToPricingPlanInput) -> Swift.String? {
        return "/list-pricing-rules-associated-to-pricing-plan"
    }
}

extension ListResourcesAssociatedToCustomLineItemInput {

    static func urlPathProvider(_ value: ListResourcesAssociatedToCustomLineItemInput) -> Swift.String? {
        return "/list-resources-associated-to-custom-line-item"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateBillingGroupInput {

    static func urlPathProvider(_ value: UpdateBillingGroupInput) -> Swift.String? {
        return "/update-billing-group"
    }
}

extension UpdateCustomLineItemInput {

    static func urlPathProvider(_ value: UpdateCustomLineItemInput) -> Swift.String? {
        return "/update-custom-line-item"
    }
}

extension UpdatePricingPlanInput {

    static func urlPathProvider(_ value: UpdatePricingPlanInput) -> Swift.String? {
        return "/update-pricing-plan"
    }
}

extension UpdatePricingRuleInput {

    static func urlPathProvider(_ value: UpdatePricingRuleInput) -> Swift.String? {
        return "/update-pricing-rule"
    }
}

extension AssociateAccountsInput {

    static func write(value: AssociateAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Arn"].write(value.arn)
    }
}

extension AssociatePricingRulesInput {

    static func write(value: AssociatePricingRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["PricingRuleArns"].writeList(value.pricingRuleArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchAssociateResourcesToCustomLineItemInput {

    static func write(value: BatchAssociateResourcesToCustomLineItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriodRange"].write(value.billingPeriodRange, with: BillingconductorClientTypes.CustomLineItemBillingPeriodRange.write(value:to:))
        try writer["ResourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetArn"].write(value.targetArn)
    }
}

extension BatchDisassociateResourcesFromCustomLineItemInput {

    static func write(value: BatchDisassociateResourcesFromCustomLineItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriodRange"].write(value.billingPeriodRange, with: BillingconductorClientTypes.CustomLineItemBillingPeriodRange.write(value:to:))
        try writer["ResourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetArn"].write(value.targetArn)
    }
}

extension CreateBillingGroupInput {

    static func write(value: CreateBillingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountGrouping"].write(value.accountGrouping, with: BillingconductorClientTypes.AccountGrouping.write(value:to:))
        try writer["ComputationPreference"].write(value.computationPreference, with: BillingconductorClientTypes.ComputationPreference.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["PrimaryAccountId"].write(value.primaryAccountId)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateCustomLineItemInput {

    static func write(value: CreateCustomLineItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BillingGroupArn"].write(value.billingGroupArn)
        try writer["BillingPeriodRange"].write(value.billingPeriodRange, with: BillingconductorClientTypes.CustomLineItemBillingPeriodRange.write(value:to:))
        try writer["ChargeDetails"].write(value.chargeDetails, with: BillingconductorClientTypes.CustomLineItemChargeDetails.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePricingPlanInput {

    static func write(value: CreatePricingPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["PricingRuleArns"].writeList(value.pricingRuleArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePricingRuleInput {

    static func write(value: CreatePricingRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingEntity"].write(value.billingEntity)
        try writer["Description"].write(value.description)
        try writer["ModifierPercentage"].write(value.modifierPercentage)
        try writer["Name"].write(value.name)
        try writer["Operation"].write(value.operation)
        try writer["Scope"].write(value.scope)
        try writer["Service"].write(value.service)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Tiering"].write(value.tiering, with: BillingconductorClientTypes.CreateTieringInput.write(value:to:))
        try writer["Type"].write(value.type)
        try writer["UsageType"].write(value.usageType)
    }
}

extension DeleteBillingGroupInput {

    static func write(value: DeleteBillingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

extension DeleteCustomLineItemInput {

    static func write(value: DeleteCustomLineItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["BillingPeriodRange"].write(value.billingPeriodRange, with: BillingconductorClientTypes.CustomLineItemBillingPeriodRange.write(value:to:))
    }
}

extension DeletePricingPlanInput {

    static func write(value: DeletePricingPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

extension DeletePricingRuleInput {

    static func write(value: DeletePricingRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

extension DisassociateAccountsInput {

    static func write(value: DisassociateAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Arn"].write(value.arn)
    }
}

extension DisassociatePricingRulesInput {

    static func write(value: DisassociatePricingRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["PricingRuleArns"].writeList(value.pricingRuleArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetBillingGroupCostReportInput {

    static func write(value: GetBillingGroupCostReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["BillingPeriodRange"].write(value.billingPeriodRange, with: BillingconductorClientTypes.BillingPeriodRange.write(value:to:))
        try writer["GroupBy"].writeList(value.groupBy, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BillingconductorClientTypes.GroupByAttributeName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListAccountAssociationsInput {

    static func write(value: ListAccountAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod)
        try writer["Filters"].write(value.filters, with: BillingconductorClientTypes.ListAccountAssociationsFilter.write(value:to:))
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListBillingGroupCostReportsInput {

    static func write(value: ListBillingGroupCostReportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod)
        try writer["Filters"].write(value.filters, with: BillingconductorClientTypes.ListBillingGroupCostReportsFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListBillingGroupsInput {

    static func write(value: ListBillingGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod)
        try writer["Filters"].write(value.filters, with: BillingconductorClientTypes.ListBillingGroupsFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCustomLineItemsInput {

    static func write(value: ListCustomLineItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod)
        try writer["Filters"].write(value.filters, with: BillingconductorClientTypes.ListCustomLineItemsFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCustomLineItemVersionsInput {

    static func write(value: ListCustomLineItemVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Filters"].write(value.filters, with: BillingconductorClientTypes.ListCustomLineItemVersionsFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPricingPlansInput {

    static func write(value: ListPricingPlansInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod)
        try writer["Filters"].write(value.filters, with: BillingconductorClientTypes.ListPricingPlansFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPricingPlansAssociatedWithPricingRuleInput {

    static func write(value: ListPricingPlansAssociatedWithPricingRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PricingRuleArn"].write(value.pricingRuleArn)
    }
}

extension ListPricingRulesInput {

    static func write(value: ListPricingRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod)
        try writer["Filters"].write(value.filters, with: BillingconductorClientTypes.ListPricingRulesFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPricingRulesAssociatedToPricingPlanInput {

    static func write(value: ListPricingRulesAssociatedToPricingPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriod"].write(value.billingPeriod)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PricingPlanArn"].write(value.pricingPlanArn)
    }
}

extension ListResourcesAssociatedToCustomLineItemInput {

    static func write(value: ListResourcesAssociatedToCustomLineItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["BillingPeriod"].write(value.billingPeriod)
        try writer["Filters"].write(value.filters, with: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateBillingGroupInput {

    static func write(value: UpdateBillingGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountGrouping"].write(value.accountGrouping, with: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping.write(value:to:))
        try writer["Arn"].write(value.arn)
        try writer["ComputationPreference"].write(value.computationPreference, with: BillingconductorClientTypes.ComputationPreference.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
    }
}

extension UpdateCustomLineItemInput {

    static func write(value: UpdateCustomLineItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["BillingPeriodRange"].write(value.billingPeriodRange, with: BillingconductorClientTypes.CustomLineItemBillingPeriodRange.write(value:to:))
        try writer["ChargeDetails"].write(value.chargeDetails, with: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdatePricingPlanInput {

    static func write(value: UpdatePricingPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdatePricingRuleInput {

    static func write(value: UpdatePricingRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Description"].write(value.description)
        try writer["ModifierPercentage"].write(value.modifierPercentage)
        try writer["Name"].write(value.name)
        try writer["Tiering"].write(value.tiering, with: BillingconductorClientTypes.UpdateTieringInput.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension AssociateAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateAccountsOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension AssociatePricingRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociatePricingRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociatePricingRulesOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension BatchAssociateResourcesToCustomLineItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAssociateResourcesToCustomLineItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateResourcesToCustomLineItemOutput()
        value.failedAssociatedResources = try reader["FailedAssociatedResources"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.AssociateResourceResponseElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successfullyAssociatedResources = try reader["SuccessfullyAssociatedResources"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.AssociateResourceResponseElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDisassociateResourcesFromCustomLineItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisassociateResourcesFromCustomLineItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateResourcesFromCustomLineItemOutput()
        value.failedDisassociatedResources = try reader["FailedDisassociatedResources"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.DisassociateResourceResponseElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successfullyDisassociatedResources = try reader["SuccessfullyDisassociatedResources"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.DisassociateResourceResponseElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBillingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBillingGroupOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension CreateCustomLineItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomLineItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomLineItemOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension CreatePricingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePricingPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePricingPlanOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension CreatePricingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePricingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePricingRuleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension DeleteBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBillingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBillingGroupOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension DeleteCustomLineItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomLineItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCustomLineItemOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension DeletePricingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePricingPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePricingPlanOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension DeletePricingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePricingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePricingRuleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension DisassociateAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateAccountsOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension DisassociatePricingRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociatePricingRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociatePricingRulesOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension GetBillingGroupCostReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBillingGroupCostReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBillingGroupCostReportOutput()
        value.billingGroupCostReportResults = try reader["BillingGroupCostReportResults"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.BillingGroupCostReportResultElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAccountAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountAssociationsOutput()
        value.linkedAccounts = try reader["LinkedAccounts"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.AccountAssociationsListElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBillingGroupCostReportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillingGroupCostReportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillingGroupCostReportsOutput()
        value.billingGroupCostReports = try reader["BillingGroupCostReports"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.BillingGroupCostReportElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBillingGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillingGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillingGroupsOutput()
        value.billingGroups = try reader["BillingGroups"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.BillingGroupListElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCustomLineItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomLineItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomLineItemsOutput()
        value.customLineItems = try reader["CustomLineItems"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.CustomLineItemListElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCustomLineItemVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomLineItemVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomLineItemVersionsOutput()
        value.customLineItemVersions = try reader["CustomLineItemVersions"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.CustomLineItemVersionListElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPricingPlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPricingPlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPricingPlansOutput()
        value.billingPeriod = try reader["BillingPeriod"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pricingPlans = try reader["PricingPlans"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.PricingPlanListElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPricingPlansAssociatedWithPricingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPricingPlansAssociatedWithPricingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPricingPlansAssociatedWithPricingRuleOutput()
        value.billingPeriod = try reader["BillingPeriod"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pricingPlanArns = try reader["PricingPlanArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.pricingRuleArn = try reader["PricingRuleArn"].readIfPresent()
        return value
    }
}

extension ListPricingRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPricingRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPricingRulesOutput()
        value.billingPeriod = try reader["BillingPeriod"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pricingRules = try reader["PricingRules"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.PricingRuleListElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPricingRulesAssociatedToPricingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPricingRulesAssociatedToPricingPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPricingRulesAssociatedToPricingPlanOutput()
        value.billingPeriod = try reader["BillingPeriod"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pricingPlanArn = try reader["PricingPlanArn"].readIfPresent()
        value.pricingRuleArns = try reader["PricingRuleArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourcesAssociatedToCustomLineItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourcesAssociatedToCustomLineItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourcesAssociatedToCustomLineItemOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.associatedResources = try reader["AssociatedResources"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBillingGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBillingGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBillingGroupOutput()
        value.accountGrouping = try reader["AccountGrouping"].readIfPresent(with: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? 0
        value.name = try reader["Name"].readIfPresent()
        value.pricingPlanArn = try reader["PricingPlanArn"].readIfPresent()
        value.primaryAccountId = try reader["PrimaryAccountId"].readIfPresent()
        value.size = try reader["Size"].readIfPresent() ?? 0
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension UpdateCustomLineItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCustomLineItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCustomLineItemOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.associationSize = try reader["AssociationSize"].readIfPresent() ?? 0
        value.billingGroupArn = try reader["BillingGroupArn"].readIfPresent()
        value.chargeDetails = try reader["ChargeDetails"].readIfPresent(with: BillingconductorClientTypes.ListCustomLineItemChargeDetails.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? 0
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension UpdatePricingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePricingPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePricingPlanOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? 0
        value.name = try reader["Name"].readIfPresent()
        value.size = try reader["Size"].readIfPresent() ?? 0
        return value
    }
}

extension UpdatePricingRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePricingRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePricingRuleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.associatedPricingPlanCount = try reader["AssociatedPricingPlanCount"].readIfPresent() ?? 0
        value.billingEntity = try reader["BillingEntity"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? 0
        value.modifierPercentage = try reader["ModifierPercentage"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.operation = try reader["Operation"].readIfPresent()
        value.scope = try reader["Scope"].readIfPresent()
        value.service = try reader["Service"].readIfPresent()
        value.tiering = try reader["Tiering"].readIfPresent(with: BillingconductorClientTypes.UpdateTieringInput.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.usageType = try reader["UsageType"].readIfPresent()
        return value
    }
}

enum AssociateAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceLimitExceededException": return try ServiceLimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociatePricingRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceLimitExceededException": return try ServiceLimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchAssociateResourcesToCustomLineItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceLimitExceededException": return try ServiceLimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisassociateResourcesFromCustomLineItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceLimitExceededException": return try ServiceLimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomLineItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceLimitExceededException": return try ServiceLimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePricingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceLimitExceededException": return try ServiceLimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePricingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceLimitExceededException": return try ServiceLimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomLineItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePricingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePricingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociatePricingRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBillingGroupCostReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillingGroupCostReportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillingGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomLineItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomLineItemVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPricingPlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPricingPlansAssociatedWithPricingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPricingRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPricingRulesAssociatedToPricingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourcesAssociatedToCustomLineItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBillingGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCustomLineItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePricingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePricingRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceLimitExceededException()
        value.properties.limitCode = try reader["LimitCode"].readIfPresent() ?? ""
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BillingconductorClientTypes.AssociateResourceResponseElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.AssociateResourceResponseElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.AssociateResourceResponseElement()
        value.arn = try reader["Arn"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: BillingconductorClientTypes.AssociateResourceError.read(from:))
        return value
    }
}

extension BillingconductorClientTypes.AssociateResourceError {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.AssociateResourceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.AssociateResourceError()
        value.message = try reader["Message"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.DisassociateResourceResponseElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.DisassociateResourceResponseElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.DisassociateResourceResponseElement()
        value.arn = try reader["Arn"].readIfPresent()
        value.error = try reader["Error"].readIfPresent(with: BillingconductorClientTypes.AssociateResourceError.read(from:))
        return value
    }
}

extension BillingconductorClientTypes.BillingGroupCostReportResultElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.BillingGroupCostReportResultElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.BillingGroupCostReportResultElement()
        value.arn = try reader["Arn"].readIfPresent()
        value.awsCost = try reader["AWSCost"].readIfPresent()
        value.proformaCost = try reader["ProformaCost"].readIfPresent()
        value.margin = try reader["Margin"].readIfPresent()
        value.marginPercentage = try reader["MarginPercentage"].readIfPresent()
        value.currency = try reader["Currency"].readIfPresent()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.Attribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BillingconductorClientTypes.Attribute {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.Attribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.Attribute()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.AccountAssociationsListElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.AccountAssociationsListElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.AccountAssociationsListElement()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.billingGroupArn = try reader["BillingGroupArn"].readIfPresent()
        value.accountName = try reader["AccountName"].readIfPresent()
        value.accountEmail = try reader["AccountEmail"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.BillingGroupCostReportElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.BillingGroupCostReportElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.BillingGroupCostReportElement()
        value.arn = try reader["Arn"].readIfPresent()
        value.awsCost = try reader["AWSCost"].readIfPresent()
        value.proformaCost = try reader["ProformaCost"].readIfPresent()
        value.margin = try reader["Margin"].readIfPresent()
        value.marginPercentage = try reader["MarginPercentage"].readIfPresent()
        value.currency = try reader["Currency"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.BillingGroupListElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.BillingGroupListElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.BillingGroupListElement()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.primaryAccountId = try reader["PrimaryAccountId"].readIfPresent()
        value.computationPreference = try reader["ComputationPreference"].readIfPresent(with: BillingconductorClientTypes.ComputationPreference.read(from:))
        value.size = try reader["Size"].readIfPresent() ?? 0
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? 0
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? 0
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.accountGrouping = try reader["AccountGrouping"].readIfPresent(with: BillingconductorClientTypes.ListBillingGroupAccountGrouping.read(from:))
        return value
    }
}

extension BillingconductorClientTypes.ListBillingGroupAccountGrouping {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.ListBillingGroupAccountGrouping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.ListBillingGroupAccountGrouping()
        value.autoAssociate = try reader["AutoAssociate"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.ComputationPreference {

    static func write(value: BillingconductorClientTypes.ComputationPreference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PricingPlanArn"].write(value.pricingPlanArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.ComputationPreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.ComputationPreference()
        value.pricingPlanArn = try reader["PricingPlanArn"].readIfPresent() ?? ""
        return value
    }
}

extension BillingconductorClientTypes.CustomLineItemListElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.CustomLineItemListElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.CustomLineItemListElement()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.chargeDetails = try reader["ChargeDetails"].readIfPresent(with: BillingconductorClientTypes.ListCustomLineItemChargeDetails.read(from:))
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.productCode = try reader["ProductCode"].readIfPresent()
        value.billingGroupArn = try reader["BillingGroupArn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? 0
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? 0
        value.associationSize = try reader["AssociationSize"].readIfPresent() ?? 0
        value.accountId = try reader["AccountId"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.ListCustomLineItemChargeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.ListCustomLineItemChargeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.ListCustomLineItemChargeDetails()
        value.flat = try reader["Flat"].readIfPresent(with: BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails.read(from:))
        value.percentage = try reader["Percentage"].readIfPresent(with: BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails.read(from:))
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.lineItemFilters = try reader["LineItemFilters"].readListIfPresent(memberReadingClosure: BillingconductorClientTypes.LineItemFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BillingconductorClientTypes.LineItemFilter {

    static func write(value: BillingconductorClientTypes.LineItemFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attribute"].write(value.attribute)
        try writer["MatchOption"].write(value.matchOption)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BillingconductorClientTypes.LineItemFilterValue>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.LineItemFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.LineItemFilter()
        value.attribute = try reader["Attribute"].readIfPresent() ?? .sdkUnknown("")
        value.matchOption = try reader["MatchOption"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BillingconductorClientTypes.LineItemFilterValue>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.ListCustomLineItemPercentageChargeDetails()
        value.percentageValue = try reader["PercentageValue"].readIfPresent() ?? 0.0
        return value
    }
}

extension BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.ListCustomLineItemFlatChargeDetails()
        value.chargeValue = try reader["ChargeValue"].readIfPresent() ?? 0.0
        return value
    }
}

extension BillingconductorClientTypes.CustomLineItemVersionListElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.CustomLineItemVersionListElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.CustomLineItemVersionListElement()
        value.name = try reader["Name"].readIfPresent()
        value.chargeDetails = try reader["ChargeDetails"].readIfPresent(with: BillingconductorClientTypes.ListCustomLineItemChargeDetails.read(from:))
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.productCode = try reader["ProductCode"].readIfPresent()
        value.billingGroupArn = try reader["BillingGroupArn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? 0
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? 0
        value.associationSize = try reader["AssociationSize"].readIfPresent() ?? 0
        value.startBillingPeriod = try reader["StartBillingPeriod"].readIfPresent()
        value.endBillingPeriod = try reader["EndBillingPeriod"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.startTime = try reader["StartTime"].readIfPresent() ?? 0
        value.accountId = try reader["AccountId"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.PricingPlanListElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.PricingPlanListElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.PricingPlanListElement()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.size = try reader["Size"].readIfPresent() ?? 0
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? 0
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? 0
        return value
    }
}

extension BillingconductorClientTypes.PricingRuleListElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.PricingRuleListElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.PricingRuleListElement()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.scope = try reader["Scope"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.modifierPercentage = try reader["ModifierPercentage"].readIfPresent()
        value.service = try reader["Service"].readIfPresent()
        value.associatedPricingPlanCount = try reader["AssociatedPricingPlanCount"].readIfPresent() ?? 0
        value.creationTime = try reader["CreationTime"].readIfPresent() ?? 0
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent() ?? 0
        value.billingEntity = try reader["BillingEntity"].readIfPresent()
        value.tiering = try reader["Tiering"].readIfPresent(with: BillingconductorClientTypes.Tiering.read(from:))
        value.usageType = try reader["UsageType"].readIfPresent()
        value.operation = try reader["Operation"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.Tiering {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.Tiering {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.Tiering()
        value.freeTier = try reader["FreeTier"].readIfPresent(with: BillingconductorClientTypes.FreeTierConfig.read(from:))
        return value
    }
}

extension BillingconductorClientTypes.FreeTierConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.FreeTierConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.FreeTierConfig()
        value.activated = try reader["Activated"].readIfPresent() ?? false
        return value
    }
}

extension BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemResponseElement()
        value.arn = try reader["Arn"].readIfPresent()
        value.relationship = try reader["Relationship"].readIfPresent()
        value.endBillingPeriod = try reader["EndBillingPeriod"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.UpdateBillingGroupAccountGrouping {

    static func write(value: BillingconductorClientTypes.UpdateBillingGroupAccountGrouping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoAssociate"].write(value.autoAssociate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.UpdateBillingGroupAccountGrouping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.UpdateBillingGroupAccountGrouping()
        value.autoAssociate = try reader["AutoAssociate"].readIfPresent()
        return value
    }
}

extension BillingconductorClientTypes.UpdateTieringInput {

    static func write(value: BillingconductorClientTypes.UpdateTieringInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FreeTier"].write(value.freeTier, with: BillingconductorClientTypes.UpdateFreeTierConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.UpdateTieringInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.UpdateTieringInput()
        value.freeTier = try reader["FreeTier"].readIfPresent(with: BillingconductorClientTypes.UpdateFreeTierConfig.read(from:))
        return value
    }
}

extension BillingconductorClientTypes.UpdateFreeTierConfig {

    static func write(value: BillingconductorClientTypes.UpdateFreeTierConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Activated"].write(value.activated)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.UpdateFreeTierConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.UpdateFreeTierConfig()
        value.activated = try reader["Activated"].readIfPresent() ?? false
        return value
    }
}

extension BillingconductorClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BillingconductorClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BillingconductorClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension BillingconductorClientTypes.CustomLineItemBillingPeriodRange {

    static func write(value: BillingconductorClientTypes.CustomLineItemBillingPeriodRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExclusiveEndBillingPeriod"].write(value.exclusiveEndBillingPeriod)
        try writer["InclusiveStartBillingPeriod"].write(value.inclusiveStartBillingPeriod)
    }
}

extension BillingconductorClientTypes.AccountGrouping {

    static func write(value: BillingconductorClientTypes.AccountGrouping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoAssociate"].write(value.autoAssociate)
        try writer["LinkedAccountIds"].writeList(value.linkedAccountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BillingconductorClientTypes.CustomLineItemChargeDetails {

    static func write(value: BillingconductorClientTypes.CustomLineItemChargeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Flat"].write(value.flat, with: BillingconductorClientTypes.CustomLineItemFlatChargeDetails.write(value:to:))
        try writer["LineItemFilters"].writeList(value.lineItemFilters, memberWritingClosure: BillingconductorClientTypes.LineItemFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Percentage"].write(value.percentage, with: BillingconductorClientTypes.CustomLineItemPercentageChargeDetails.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension BillingconductorClientTypes.CustomLineItemPercentageChargeDetails {

    static func write(value: BillingconductorClientTypes.CustomLineItemPercentageChargeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociatedValues"].writeList(value.associatedValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PercentageValue"].write(value.percentageValue)
    }
}

extension BillingconductorClientTypes.CustomLineItemFlatChargeDetails {

    static func write(value: BillingconductorClientTypes.CustomLineItemFlatChargeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChargeValue"].write(value.chargeValue)
    }
}

extension BillingconductorClientTypes.CreateTieringInput {

    static func write(value: BillingconductorClientTypes.CreateTieringInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FreeTier"].write(value.freeTier, with: BillingconductorClientTypes.CreateFreeTierConfig.write(value:to:))
    }
}

extension BillingconductorClientTypes.CreateFreeTierConfig {

    static func write(value: BillingconductorClientTypes.CreateFreeTierConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Activated"].write(value.activated)
    }
}

extension BillingconductorClientTypes.BillingPeriodRange {

    static func write(value: BillingconductorClientTypes.BillingPeriodRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExclusiveEndBillingPeriod"].write(value.exclusiveEndBillingPeriod)
        try writer["InclusiveStartBillingPeriod"].write(value.inclusiveStartBillingPeriod)
    }
}

extension BillingconductorClientTypes.ListAccountAssociationsFilter {

    static func write(value: BillingconductorClientTypes.ListAccountAssociationsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Association"].write(value.association)
    }
}

extension BillingconductorClientTypes.ListBillingGroupCostReportsFilter {

    static func write(value: BillingconductorClientTypes.ListBillingGroupCostReportsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingGroupArns"].writeList(value.billingGroupArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BillingconductorClientTypes.ListBillingGroupsFilter {

    static func write(value: BillingconductorClientTypes.ListBillingGroupsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AutoAssociate"].write(value.autoAssociate)
        try writer["PricingPlan"].write(value.pricingPlan)
        try writer["Statuses"].writeList(value.statuses, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BillingconductorClientTypes.BillingGroupStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BillingconductorClientTypes.ListCustomLineItemsFilter {

    static func write(value: BillingconductorClientTypes.ListCustomLineItemsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BillingGroups"].writeList(value.billingGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BillingconductorClientTypes.ListCustomLineItemVersionsFilter {

    static func write(value: BillingconductorClientTypes.ListCustomLineItemVersionsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingPeriodRange"].write(value.billingPeriodRange, with: BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter.write(value:to:))
    }
}

extension BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter {

    static func write(value: BillingconductorClientTypes.ListCustomLineItemVersionsBillingPeriodRangeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndBillingPeriod"].write(value.endBillingPeriod)
        try writer["StartBillingPeriod"].write(value.startBillingPeriod)
    }
}

extension BillingconductorClientTypes.ListPricingPlansFilter {

    static func write(value: BillingconductorClientTypes.ListPricingPlansFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BillingconductorClientTypes.ListPricingRulesFilter {

    static func write(value: BillingconductorClientTypes.ListPricingRulesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter {

    static func write(value: BillingconductorClientTypes.ListResourcesAssociatedToCustomLineItemFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Relationship"].write(value.relationship)
    }
}

extension BillingconductorClientTypes.UpdateCustomLineItemChargeDetails {

    static func write(value: BillingconductorClientTypes.UpdateCustomLineItemChargeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Flat"].write(value.flat, with: BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails.write(value:to:))
        try writer["LineItemFilters"].writeList(value.lineItemFilters, memberWritingClosure: BillingconductorClientTypes.LineItemFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Percentage"].write(value.percentage, with: BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails.write(value:to:))
    }
}

extension BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails {

    static func write(value: BillingconductorClientTypes.UpdateCustomLineItemPercentageChargeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PercentageValue"].write(value.percentageValue)
    }
}

extension BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails {

    static func write(value: BillingconductorClientTypes.UpdateCustomLineItemFlatChargeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChargeValue"].write(value.chargeValue)
    }
}

public enum BillingconductorClientTypes {}
