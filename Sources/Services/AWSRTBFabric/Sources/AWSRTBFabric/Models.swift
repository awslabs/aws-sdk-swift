//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The request could not be completed because you do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request could not be completed because of a conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request could not be completed because of an internal server error. Try your call again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request could not be completed because the resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request could not be completed because it fails satisfy the constraints specified by the service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension RTBFabricClientTypes {

    public enum ResponderErrorMaskingAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noBid
        case passthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponderErrorMaskingAction] {
            return [
                .noBid,
                .passthrough
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noBid: return "NO_BID"
            case .passthrough: return "PASSTHROUGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RTBFabricClientTypes {

    public enum ResponderErrorMaskingLoggingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case metric
        case `none`
        case response
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponderErrorMaskingLoggingType] {
            return [
                .metric,
                .none,
                .response
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .metric: return "METRIC"
            case .none: return "NONE"
            case .response: return "RESPONSE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the masking for HTTP error codes.
    public struct ResponderErrorMaskingForHttpCode: Swift.Sendable {
        /// The action for the error..
        /// This member is required.
        public var action: RTBFabricClientTypes.ResponderErrorMaskingAction?
        /// The HTTP error code.
        /// This member is required.
        public var httpCode: Swift.String?
        /// The error log type.
        /// This member is required.
        public var loggingTypes: [RTBFabricClientTypes.ResponderErrorMaskingLoggingType]?
        /// The percentage of response logging.
        public var responseLoggingPercentage: Swift.Float?

        public init(
            action: RTBFabricClientTypes.ResponderErrorMaskingAction? = nil,
            httpCode: Swift.String? = nil,
            loggingTypes: [RTBFabricClientTypes.ResponderErrorMaskingLoggingType]? = nil,
            responseLoggingPercentage: Swift.Float? = nil
        ) {
            self.action = action
            self.httpCode = httpCode
            self.loggingTypes = loggingTypes
            self.responseLoggingPercentage = responseLoggingPercentage
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the attributes of a link.
    public struct LinkAttributes: Swift.Sendable {
        /// The customer-provided unique identifier of the link.
        public var customerProvidedId: Swift.String?
        /// Describes the masking for HTTP error codes.
        public var responderErrorMasking: [RTBFabricClientTypes.ResponderErrorMaskingForHttpCode]?

        public init(
            customerProvidedId: Swift.String? = nil,
            responderErrorMasking: [RTBFabricClientTypes.ResponderErrorMaskingForHttpCode]? = nil
        ) {
            self.customerProvidedId = customerProvidedId
            self.responderErrorMasking = responderErrorMasking
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes a link application log sample.
    public struct LinkApplicationLogSampling: Swift.Sendable {
        /// An error log entry.
        /// This member is required.
        public var errorLog: Swift.Double?
        /// A filter log entry.
        /// This member is required.
        public var filterLog: Swift.Double?

        public init(
            errorLog: Swift.Double? = nil,
            filterLog: Swift.Double? = nil
        ) {
            self.errorLog = errorLog
            self.filterLog = filterLog
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the configuration of a link application log.
    public struct LinkApplicationLogConfiguration: Swift.Sendable {
        /// Describes a link application log sample.
        /// This member is required.
        public var sampling: RTBFabricClientTypes.LinkApplicationLogSampling?

        public init(
            sampling: RTBFabricClientTypes.LinkApplicationLogSampling? = nil
        ) {
            self.sampling = sampling
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the settings for a link log.
    public struct LinkLogSettings: Swift.Sendable {
        /// Describes the configuration of a link application log.
        /// This member is required.
        public var applicationLogs: RTBFabricClientTypes.LinkApplicationLogConfiguration?

        public init(
            applicationLogs: RTBFabricClientTypes.LinkApplicationLogConfiguration? = nil
        ) {
            self.applicationLogs = applicationLogs
        }
    }
}

public struct AcceptLinkInput: Swift.Sendable {
    /// Attributes of the link.
    public var attributes: RTBFabricClientTypes.LinkAttributes?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// Settings for the application logs.
    /// This member is required.
    public var logSettings: RTBFabricClientTypes.LinkLogSettings?

    public init(
        attributes: RTBFabricClientTypes.LinkAttributes? = nil,
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        logSettings: RTBFabricClientTypes.LinkLogSettings? = nil
    ) {
        self.attributes = attributes
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.logSettings = logSettings
    }
}

extension RTBFabricClientTypes {

    public enum LinkDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case request
        case response
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkDirection] {
            return [
                .request,
                .response
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .request: return "REQUEST"
            case .response: return "RESPONSE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the parameters of a no bid module.
    public struct NoBidModuleParameters: Swift.Sendable {
        /// The pass through percentage.
        public var passThroughPercentage: Swift.Float?
        /// The reason description.
        public var reason: Swift.String?
        /// The reason code.
        public var reasonCode: Swift.Int?

        public init(
            passThroughPercentage: Swift.Float? = nil,
            reason: Swift.String? = nil,
            reasonCode: Swift.Int? = nil
        ) {
            self.passThroughPercentage = passThroughPercentage
            self.reason = reason
            self.reasonCode = reasonCode
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the header tag for a bid action.
    public struct HeaderTagAction: Swift.Sendable {
        /// The name of the bid action.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the bid action.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.name = name
            self.value = value
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes a no bid action.
    public struct NoBidAction: Swift.Sendable {
        /// The reason code for the no bid action.
        public var noBidReasonCode: Swift.Int?

        public init(
            noBidReasonCode: Swift.Int? = nil
        ) {
            self.noBidReasonCode = noBidReasonCode
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes a bid action.
    public enum Action: Swift.Sendable {
        /// Describes a no bid action.
        case nobid(RTBFabricClientTypes.NoBidAction)
        /// Describes the header tag for a bid action.
        case headertag(RTBFabricClientTypes.HeaderTagAction)
        case sdkUnknown(Swift.String)
    }
}

extension RTBFabricClientTypes {

    /// Describes the criteria for a filter.
    public struct FilterCriterion: Swift.Sendable {
        /// The path to filter.
        /// This member is required.
        public var path: Swift.String?
        /// The value to filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        ) {
            self.path = path
            self.values = values
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the configuration of a filter.
    public struct Filter: Swift.Sendable {
        /// Describes the criteria for a filter.
        /// This member is required.
        public var criteria: [RTBFabricClientTypes.FilterCriterion]?

        public init(
            criteria: [RTBFabricClientTypes.FilterCriterion]? = nil
        ) {
            self.criteria = criteria
        }
    }
}

extension RTBFabricClientTypes {

    public enum FilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exclude
        case include
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterType] {
            return [
                .exclude,
                .include
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exclude: return "EXCLUDE"
            case .include: return "INCLUDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the parameters of an open RTB attribute module.
    public struct OpenRtbAttributeModuleParameters: Swift.Sendable {
        /// Describes a bid action.
        /// This member is required.
        public var action: RTBFabricClientTypes.Action?
        /// Describes the configuration of a filter.
        /// This member is required.
        public var filterConfiguration: [RTBFabricClientTypes.Filter]?
        /// The filter type.
        /// This member is required.
        public var filterType: RTBFabricClientTypes.FilterType?
        /// The hold back percentage.
        /// This member is required.
        public var holdbackPercentage: Swift.Float?

        public init(
            action: RTBFabricClientTypes.Action? = nil,
            filterConfiguration: [RTBFabricClientTypes.Filter]? = nil,
            filterType: RTBFabricClientTypes.FilterType? = nil,
            holdbackPercentage: Swift.Float? = nil
        ) {
            self.action = action
            self.filterConfiguration = filterConfiguration
            self.filterType = filterType
            self.holdbackPercentage = holdbackPercentage
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the parameters of a rate limit.
    public struct RateLimiterModuleParameters: Swift.Sendable {
        /// The transactions per second rate limit.
        public var tps: Swift.Float?

        public init(
            tps: Swift.Float? = nil
        ) {
            self.tps = tps
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the parameters of a module.
    public enum ModuleParameters: Swift.Sendable {
        /// Describes the parameters of a no bid module.
        case nobid(RTBFabricClientTypes.NoBidModuleParameters)
        /// Describes the parameters of an open RTB attribute module.
        case openrtbattribute(RTBFabricClientTypes.OpenRtbAttributeModuleParameters)
        /// Describes the parameters of a rate limit.
        case ratelimiter(RTBFabricClientTypes.RateLimiterModuleParameters)
        case sdkUnknown(Swift.String)
    }
}

extension RTBFabricClientTypes {

    /// Describes the configuration of a module.
    public struct ModuleConfiguration: Swift.Sendable {
        /// The dependencies of the module.
        public var dependsOn: [Swift.String]?
        /// Describes the parameters of a module.
        public var moduleParameters: RTBFabricClientTypes.ModuleParameters?
        /// The name of the module.
        /// This member is required.
        public var name: Swift.String?
        /// The version of the module.
        public var version: Swift.String?

        public init(
            dependsOn: [Swift.String]? = nil,
            moduleParameters: RTBFabricClientTypes.ModuleParameters? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        ) {
            self.dependsOn = dependsOn
            self.moduleParameters = moduleParameters
            self.name = name
            self.version = version
        }
    }
}

extension RTBFabricClientTypes {

    public enum LinkStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case active
        case deleted
        case failed
        case isolated
        case pendingCreation
        case pendingDeletion
        case pendingIsolation
        case pendingRequest
        case pendingRestoration
        case pendingUpdate
        case rejected
        case requested
        case sdkUnknown(Swift.String)

        public static var allCases: [LinkStatus] {
            return [
                .accepted,
                .active,
                .deleted,
                .failed,
                .isolated,
                .pendingCreation,
                .pendingDeletion,
                .pendingIsolation,
                .pendingRequest,
                .pendingRestoration,
                .pendingUpdate,
                .rejected,
                .requested
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case .isolated: return "ISOLATED"
            case .pendingCreation: return "PENDING_CREATION"
            case .pendingDeletion: return "PENDING_DELETION"
            case .pendingIsolation: return "PENDING_ISOLATION"
            case .pendingRequest: return "PENDING_REQUEST"
            case .pendingRestoration: return "PENDING_RESTORATION"
            case .pendingUpdate: return "PENDING_UPDATE"
            case .rejected: return "REJECTED"
            case .requested: return "REQUESTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AcceptLinkOutput: Swift.Sendable {
    /// Attributes of the link.
    public var attributes: RTBFabricClientTypes.LinkAttributes?
    /// The timestamp of when the link was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The direction of the link.
    public var direction: RTBFabricClientTypes.LinkDirection?
    /// The configuration of flow modules.
    public var flowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The unique identifier of the peer gateway.
    /// This member is required.
    public var peerGatewayId: Swift.String?
    /// The configuration of pending flow modules.
    public var pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The status of the link.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?
    /// The timestamp of when the link was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        attributes: RTBFabricClientTypes.LinkAttributes? = nil,
        createdAt: Foundation.Date? = nil,
        direction: RTBFabricClientTypes.LinkDirection? = nil,
        flowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        peerGatewayId: Swift.String? = nil,
        pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.attributes = attributes
        self.createdAt = createdAt
        self.direction = direction
        self.flowModules = flowModules
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.peerGatewayId = peerGatewayId
        self.pendingFlowModules = pendingFlowModules
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension RTBFabricClientTypes {

    /// Describes the configuration of an auto scaling group.
    public struct AutoScalingGroupsConfiguration: Swift.Sendable {
        /// The names of the auto scaling group.
        /// This member is required.
        public var autoScalingGroupNames: [Swift.String]?
        /// The role ARN of the auto scaling group.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            autoScalingGroupNames: [Swift.String]? = nil,
            roleArn: Swift.String? = nil
        ) {
            self.autoScalingGroupNames = autoScalingGroupNames
            self.roleArn = roleArn
        }
    }
}

/// The request could not be completed because you exceeded a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateInboundExternalLinkInput: Swift.Sendable {
    /// Attributes of the link.
    public var attributes: RTBFabricClientTypes.LinkAttributes?
    /// The unique client token.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// Describes the settings for a link log.
    /// This member is required.
    public var logSettings: RTBFabricClientTypes.LinkLogSettings?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        attributes: RTBFabricClientTypes.LinkAttributes? = nil,
        clientToken: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        logSettings: RTBFabricClientTypes.LinkLogSettings? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.attributes = attributes
        self.clientToken = clientToken
        self.gatewayId = gatewayId
        self.logSettings = logSettings
        self.tags = tags
    }
}

public struct CreateInboundExternalLinkOutput: Swift.Sendable {
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?

    public init(
        domainName: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil
    ) {
        self.domainName = domainName
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.status = status
    }
}

public struct CreateLinkInput: Swift.Sendable {
    /// Attributes of the link.
    public var attributes: RTBFabricClientTypes.LinkAttributes?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// Boolean to specify if an HTTP responder is allowed.
    public var httpResponderAllowed: Swift.Bool?
    /// Settings for the application logs.
    /// This member is required.
    public var logSettings: RTBFabricClientTypes.LinkLogSettings?
    /// The unique identifier of the peer gateway.
    /// This member is required.
    public var peerGatewayId: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        attributes: RTBFabricClientTypes.LinkAttributes? = nil,
        gatewayId: Swift.String? = nil,
        httpResponderAllowed: Swift.Bool? = nil,
        logSettings: RTBFabricClientTypes.LinkLogSettings? = nil,
        peerGatewayId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.attributes = attributes
        self.gatewayId = gatewayId
        self.httpResponderAllowed = httpResponderAllowed
        self.logSettings = logSettings
        self.peerGatewayId = peerGatewayId
        self.tags = tags
    }
}

public struct CreateLinkOutput: Swift.Sendable {
    /// Attributes of the link.
    public var attributes: RTBFabricClientTypes.LinkAttributes?
    /// The timestamp of when the link was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The customer-provided unique identifier of the link.
    public var customerProvidedId: Swift.String?
    /// The direction of the link.
    public var direction: RTBFabricClientTypes.LinkDirection?
    /// The configuration of flow modules.
    public var flowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The unique identifier of the peer gateway.
    /// This member is required.
    public var peerGatewayId: Swift.String?
    /// The configuration of pending flow modules.
    public var pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?
    /// The timestamp of when the link was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        attributes: RTBFabricClientTypes.LinkAttributes? = nil,
        createdAt: Foundation.Date? = nil,
        customerProvidedId: Swift.String? = nil,
        direction: RTBFabricClientTypes.LinkDirection? = nil,
        flowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        peerGatewayId: Swift.String? = nil,
        pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.attributes = attributes
        self.createdAt = createdAt
        self.customerProvidedId = customerProvidedId
        self.direction = direction
        self.flowModules = flowModules
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.peerGatewayId = peerGatewayId
        self.pendingFlowModules = pendingFlowModules
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct CreateOutboundExternalLinkInput: Swift.Sendable {
    /// Describes the attributes of a link.
    public var attributes: RTBFabricClientTypes.LinkAttributes?
    /// The unique client token.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// Describes the settings for a link log.
    /// This member is required.
    public var logSettings: RTBFabricClientTypes.LinkLogSettings?
    /// The public endpoint of the link.
    /// This member is required.
    public var publicEndpoint: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        attributes: RTBFabricClientTypes.LinkAttributes? = nil,
        clientToken: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        logSettings: RTBFabricClientTypes.LinkLogSettings? = nil,
        publicEndpoint: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.attributes = attributes
        self.clientToken = clientToken
        self.gatewayId = gatewayId
        self.logSettings = logSettings
        self.publicEndpoint = publicEndpoint
        self.tags = tags
    }
}

public struct CreateOutboundExternalLinkOutput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.status = status
    }
}

public struct CreateRequesterGatewayInput: Swift.Sendable {
    /// The unique client token.
    /// This member is required.
    public var clientToken: Swift.String?
    /// An optional description for the requester gateway.
    public var description: Swift.String?
    /// The unique identifiers of the security groups.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The unique identifiers of the subnets.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [Swift.String: Swift.String]?
    /// The unique identifier of the Virtual Private Cloud (VPC).
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

extension RTBFabricClientTypes {

    public enum RequesterGatewayStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case error
        case isolated
        case pendingCreation
        case pendingDeletion
        case pendingIsolation
        case pendingRestoration
        case pendingUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [RequesterGatewayStatus] {
            return [
                .active,
                .deleted,
                .error,
                .isolated,
                .pendingCreation,
                .pendingDeletion,
                .pendingIsolation,
                .pendingRestoration,
                .pendingUpdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .error: return "ERROR"
            case .isolated: return "ISOLATED"
            case .pendingCreation: return "PENDING_CREATION"
            case .pendingDeletion: return "PENDING_DELETION"
            case .pendingIsolation: return "PENDING_ISOLATION"
            case .pendingRestoration: return "PENDING_RESTORATION"
            case .pendingUpdate: return "PENDING_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateRequesterGatewayOutput: Swift.Sendable {
    /// The domain name of the requester gateway.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.RequesterGatewayStatus?

    public init(
        domainName: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        status: RTBFabricClientTypes.RequesterGatewayStatus? = nil
    ) {
        self.domainName = domainName
        self.gatewayId = gatewayId
        self.status = status
    }
}

extension RTBFabricClientTypes {

    /// Describes the configuration of an Amazon Elastic Kubernetes Service endpoint.
    public struct EksEndpointsConfiguration: Swift.Sendable {
        /// The CA certificate chain of the cluster API server.
        /// This member is required.
        public var clusterApiServerCaCertificateChain: Swift.String?
        /// The URI of the cluster API server endpoint.
        /// This member is required.
        public var clusterApiServerEndpointUri: Swift.String?
        /// The name of the cluster.
        /// This member is required.
        public var clusterName: Swift.String?
        /// The name of the endpoint resource.
        /// This member is required.
        public var endpointsResourceName: Swift.String?
        /// The namespace of the endpoint resource.
        /// This member is required.
        public var endpointsResourceNamespace: Swift.String?
        /// The role ARN for the cluster.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            clusterApiServerCaCertificateChain: Swift.String? = nil,
            clusterApiServerEndpointUri: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            endpointsResourceName: Swift.String? = nil,
            endpointsResourceNamespace: Swift.String? = nil,
            roleArn: Swift.String? = nil
        ) {
            self.clusterApiServerCaCertificateChain = clusterApiServerCaCertificateChain
            self.clusterApiServerEndpointUri = clusterApiServerEndpointUri
            self.clusterName = clusterName
            self.endpointsResourceName = endpointsResourceName
            self.endpointsResourceNamespace = endpointsResourceNamespace
            self.roleArn = roleArn
        }
    }
}

extension RTBFabricClientTypes.EksEndpointsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EksEndpointsConfiguration(clusterApiServerEndpointUri: \(Swift.String(describing: clusterApiServerEndpointUri)), clusterName: \(Swift.String(describing: clusterName)), endpointsResourceName: \(Swift.String(describing: endpointsResourceName)), endpointsResourceNamespace: \(Swift.String(describing: endpointsResourceNamespace)), roleArn: \(Swift.String(describing: roleArn)), clusterApiServerCaCertificateChain: \"CONTENT_REDACTED\")"}
}

extension RTBFabricClientTypes {

    /// Describes the configuration of a managed endpoint.
    public enum ManagedEndpointConfiguration: Swift.Sendable {
        /// Describes the configuration of an auto scaling group.
        case autoscalinggroups(RTBFabricClientTypes.AutoScalingGroupsConfiguration)
        /// Describes the configuration of an Amazon Elastic Kubernetes Service endpoint.
        case eksendpoints(RTBFabricClientTypes.EksEndpointsConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension RTBFabricClientTypes {

    public enum ModelProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .http,
                .https
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RTBFabricClientTypes {

    /// Describes the configuration of a trust store.
    public struct TrustStoreConfiguration: Swift.Sendable {
        /// The certificate authority certificate.
        /// This member is required.
        public var certificateAuthorityCertificates: [Swift.String]?

        public init(
            certificateAuthorityCertificates: [Swift.String]? = nil
        ) {
            self.certificateAuthorityCertificates = certificateAuthorityCertificates
        }
    }
}

extension RTBFabricClientTypes.TrustStoreConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustStoreConfiguration(certificateAuthorityCertificates: \"CONTENT_REDACTED\")"}
}

public struct CreateResponderGatewayInput: Swift.Sendable {
    /// The unique client token.
    /// This member is required.
    public var clientToken: Swift.String?
    /// An optional description for the responder gateway.
    public var description: Swift.String?
    /// The domain name for the responder gateway.
    public var domainName: Swift.String?
    /// The configuration for the managed endpoint.
    public var managedEndpointConfiguration: RTBFabricClientTypes.ManagedEndpointConfiguration?
    /// The networking port to use.
    /// This member is required.
    public var port: Swift.Int?
    /// The networking protocol to use.
    /// This member is required.
    public var `protocol`: RTBFabricClientTypes.ModelProtocol?
    /// The unique identifiers of the security groups.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The unique identifiers of the subnets.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [Swift.String: Swift.String]?
    /// The configuration of the trust store.
    public var trustStoreConfiguration: RTBFabricClientTypes.TrustStoreConfiguration?
    /// The unique identifier of the Virtual Private Cloud (VPC).
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        managedEndpointConfiguration: RTBFabricClientTypes.ManagedEndpointConfiguration? = nil,
        port: Swift.Int? = nil,
        `protocol`: RTBFabricClientTypes.ModelProtocol? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        trustStoreConfiguration: RTBFabricClientTypes.TrustStoreConfiguration? = nil,
        vpcId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.domainName = domainName
        self.managedEndpointConfiguration = managedEndpointConfiguration
        self.port = port
        self.`protocol` = `protocol`
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.trustStoreConfiguration = trustStoreConfiguration
        self.vpcId = vpcId
    }
}

extension RTBFabricClientTypes {

    public enum ResponderGatewayStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case error
        case isolated
        case pendingCreation
        case pendingDeletion
        case pendingIsolation
        case pendingRestoration
        case pendingUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponderGatewayStatus] {
            return [
                .active,
                .deleted,
                .error,
                .isolated,
                .pendingCreation,
                .pendingDeletion,
                .pendingIsolation,
                .pendingRestoration,
                .pendingUpdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .error: return "ERROR"
            case .isolated: return "ISOLATED"
            case .pendingCreation: return "PENDING_CREATION"
            case .pendingDeletion: return "PENDING_DELETION"
            case .pendingIsolation: return "PENDING_ISOLATION"
            case .pendingRestoration: return "PENDING_RESTORATION"
            case .pendingUpdate: return "PENDING_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateResponderGatewayOutput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.ResponderGatewayStatus?

    public init(
        gatewayId: Swift.String? = nil,
        status: RTBFabricClientTypes.ResponderGatewayStatus? = nil
    ) {
        self.gatewayId = gatewayId
        self.status = status
    }
}

public struct DeleteInboundExternalLinkInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
    }
}

public struct DeleteInboundExternalLinkOutput: Swift.Sendable {
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?

    public init(
        linkId: Swift.String? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil
    ) {
        self.linkId = linkId
        self.status = status
    }
}

public struct DeleteLinkInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
    }
}

public struct DeleteLinkOutput: Swift.Sendable {
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The status of the link.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?

    public init(
        linkId: Swift.String? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil
    ) {
        self.linkId = linkId
        self.status = status
    }
}

public struct DeleteOutboundExternalLinkInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
    }
}

public struct DeleteOutboundExternalLinkOutput: Swift.Sendable {
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?

    public init(
        linkId: Swift.String? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil
    ) {
        self.linkId = linkId
        self.status = status
    }
}

public struct DeleteRequesterGatewayInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
    }
}

public struct DeleteRequesterGatewayOutput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.RequesterGatewayStatus?

    public init(
        gatewayId: Swift.String? = nil,
        status: RTBFabricClientTypes.RequesterGatewayStatus? = nil
    ) {
        self.gatewayId = gatewayId
        self.status = status
    }
}

public struct DeleteResponderGatewayInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
    }
}

public struct DeleteResponderGatewayOutput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.ResponderGatewayStatus?

    public init(
        gatewayId: Swift.String? = nil,
        status: RTBFabricClientTypes.ResponderGatewayStatus? = nil
    ) {
        self.gatewayId = gatewayId
        self.status = status
    }
}

public struct GetLinkInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
    }
}

public struct GetLinkOutput: Swift.Sendable {
    /// Attributes of the link.
    public var attributes: RTBFabricClientTypes.LinkAttributes?
    /// The timestamp of when the link was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The direction of the link.
    public var direction: RTBFabricClientTypes.LinkDirection?
    /// The configuration of flow modules.
    public var flowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// Settings for the application logs.
    public var logSettings: RTBFabricClientTypes.LinkLogSettings?
    /// The unique identifier of the peer gateway.
    /// This member is required.
    public var peerGatewayId: Swift.String?
    /// The configuration of pending flow modules.
    public var pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The status of the link.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp of when the link was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        attributes: RTBFabricClientTypes.LinkAttributes? = nil,
        createdAt: Foundation.Date? = nil,
        direction: RTBFabricClientTypes.LinkDirection? = nil,
        flowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        logSettings: RTBFabricClientTypes.LinkLogSettings? = nil,
        peerGatewayId: Swift.String? = nil,
        pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.attributes = attributes
        self.createdAt = createdAt
        self.direction = direction
        self.flowModules = flowModules
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.logSettings = logSettings
        self.peerGatewayId = peerGatewayId
        self.pendingFlowModules = pendingFlowModules
        self.status = status
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

public struct ListLinksInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension RTBFabricClientTypes {

    /// Describes a link.
    public struct ListLinksResponseStructure: Swift.Sendable {
        /// Describes attributes of a link.
        public var attributes: RTBFabricClientTypes.LinkAttributes?
        /// The timestamp of when the link was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The direction of the link.
        public var direction: RTBFabricClientTypes.LinkDirection?
        /// Describes the configuration of flow modules.
        public var flowModules: [RTBFabricClientTypes.ModuleConfiguration]?
        /// The unique identifier of the gateway.
        /// This member is required.
        public var gatewayId: Swift.String?
        /// The unique identifier of the link.
        /// This member is required.
        public var linkId: Swift.String?
        /// The unique identifier of the peer gateway.
        /// This member is required.
        public var peerGatewayId: Swift.String?
        /// Describes the configuration of pending flow modules.
        public var pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]?
        /// The status of the link.
        /// This member is required.
        public var status: RTBFabricClientTypes.LinkStatus?
        /// A map of the key-value pairs of the tag or tags to assign to the resource.
        public var tags: [Swift.String: Swift.String]?
        /// The timestamp of when the link was updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            attributes: RTBFabricClientTypes.LinkAttributes? = nil,
            createdAt: Foundation.Date? = nil,
            direction: RTBFabricClientTypes.LinkDirection? = nil,
            flowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
            gatewayId: Swift.String? = nil,
            linkId: Swift.String? = nil,
            peerGatewayId: Swift.String? = nil,
            pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
            status: RTBFabricClientTypes.LinkStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.attributes = attributes
            self.createdAt = createdAt
            self.direction = direction
            self.flowModules = flowModules
            self.gatewayId = gatewayId
            self.linkId = linkId
            self.peerGatewayId = peerGatewayId
            self.pendingFlowModules = pendingFlowModules
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }
}

public struct ListLinksOutput: Swift.Sendable {
    /// Information about created links.
    public var links: [RTBFabricClientTypes.ListLinksResponseStructure]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        links: [RTBFabricClientTypes.ListLinksResponseStructure]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.links = links
        self.nextToken = nextToken
    }
}

public struct RejectLinkInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
    }
}

public struct RejectLinkOutput: Swift.Sendable {
    /// Attributes of the link.
    public var attributes: RTBFabricClientTypes.LinkAttributes?
    /// The timestamp of when the link was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The direction of the link.
    public var direction: RTBFabricClientTypes.LinkDirection?
    /// The configuration of flow modules.
    public var flowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The unique identifier of the peer gateway.
    /// This member is required.
    public var peerGatewayId: Swift.String?
    /// The configuration of pending flow modules.
    public var pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The status of the link.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?
    /// The timestamp of when the link was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        attributes: RTBFabricClientTypes.LinkAttributes? = nil,
        createdAt: Foundation.Date? = nil,
        direction: RTBFabricClientTypes.LinkDirection? = nil,
        flowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        peerGatewayId: Swift.String? = nil,
        pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.attributes = attributes
        self.createdAt = createdAt
        self.direction = direction
        self.flowModules = flowModules
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.peerGatewayId = peerGatewayId
        self.pendingFlowModules = pendingFlowModules
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct UpdateLinkInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// Settings for the application logs.
    public var logSettings: RTBFabricClientTypes.LinkLogSettings?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        logSettings: RTBFabricClientTypes.LinkLogSettings? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.logSettings = logSettings
    }
}

public struct UpdateLinkOutput: Swift.Sendable {
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?

    public init(
        linkId: Swift.String? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil
    ) {
        self.linkId = linkId
        self.status = status
    }
}

public struct UpdateLinkModuleFlowInput: Swift.Sendable {
    /// The unique client token.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The configuration of a module.
    /// This member is required.
    public var modules: [RTBFabricClientTypes.ModuleConfiguration]?

    public init(
        clientToken: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        modules: [RTBFabricClientTypes.ModuleConfiguration]? = nil
    ) {
        self.clientToken = clientToken
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.modules = modules
    }
}

public struct UpdateLinkModuleFlowOutput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.status = status
    }
}

public struct GetInboundExternalLinkInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
    }
}

public struct GetInboundExternalLinkOutput: Swift.Sendable {
    /// Attributes of the link.
    public var attributes: RTBFabricClientTypes.LinkAttributes?
    /// The timestamp of when the inbound external link was created.
    public var createdAt: Foundation.Date?
    /// The domain name.
    /// This member is required.
    public var domainName: Swift.String?
    /// The configuration of flow modules.
    public var flowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// Describes the settings for a link log.
    public var logSettings: RTBFabricClientTypes.LinkLogSettings?
    /// The configuration of pending flow modules.
    public var pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp of when the inbound external link was updated.
    public var updatedAt: Foundation.Date?

    public init(
        attributes: RTBFabricClientTypes.LinkAttributes? = nil,
        createdAt: Foundation.Date? = nil,
        domainName: Swift.String? = nil,
        flowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        logSettings: RTBFabricClientTypes.LinkLogSettings? = nil,
        pendingFlowModules: [RTBFabricClientTypes.ModuleConfiguration]? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.attributes = attributes
        self.createdAt = createdAt
        self.domainName = domainName
        self.flowModules = flowModules
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.logSettings = logSettings
        self.pendingFlowModules = pendingFlowModules
        self.status = status
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

public struct GetOutboundExternalLinkInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
        self.linkId = linkId
    }
}

public struct GetOutboundExternalLinkOutput: Swift.Sendable {
    /// The timestamp of when the outbound external link was created.
    public var createdAt: Foundation.Date?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifier of the link.
    /// This member is required.
    public var linkId: Swift.String?
    /// Describes the settings for a link log.
    public var logSettings: RTBFabricClientTypes.LinkLogSettings?
    /// The public endpoint for the link.
    /// This member is required.
    public var publicEndpoint: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.LinkStatus?
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [Swift.String: Swift.String]?
    /// The timestamp of when the outbound external link was updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        gatewayId: Swift.String? = nil,
        linkId: Swift.String? = nil,
        logSettings: RTBFabricClientTypes.LinkLogSettings? = nil,
        publicEndpoint: Swift.String? = nil,
        status: RTBFabricClientTypes.LinkStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.gatewayId = gatewayId
        self.linkId = linkId
        self.logSettings = logSettings
        self.publicEndpoint = publicEndpoint
        self.status = status
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

public struct GetRequesterGatewayInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
    }
}

public struct GetRequesterGatewayOutput: Swift.Sendable {
    /// The count of active links for the requester gateway.
    public var activeLinksCount: Swift.Int?
    /// The timestamp of when the requester gateway was created.
    public var createdAt: Foundation.Date?
    /// The description of the requester gateway.
    public var description: Swift.String?
    /// The domain name of the requester gateway.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The unique identifiers of the security groups.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.RequesterGatewayStatus?
    /// The unique identifiers of the subnets.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [Swift.String: Swift.String]?
    /// The total count of links for the requester gateway.
    public var totalLinksCount: Swift.Int?
    /// The timestamp of when the requester gateway was updated.
    public var updatedAt: Foundation.Date?
    /// The unique identifier of the Virtual Private Cloud (VPC).
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        activeLinksCount: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: RTBFabricClientTypes.RequesterGatewayStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        totalLinksCount: Swift.Int? = nil,
        updatedAt: Foundation.Date? = nil,
        vpcId: Swift.String? = nil
    ) {
        self.activeLinksCount = activeLinksCount
        self.createdAt = createdAt
        self.description = description
        self.domainName = domainName
        self.gatewayId = gatewayId
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.subnetIds = subnetIds
        self.tags = tags
        self.totalLinksCount = totalLinksCount
        self.updatedAt = updatedAt
        self.vpcId = vpcId
    }
}

public struct GetResponderGatewayInput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil
    ) {
        self.gatewayId = gatewayId
    }
}

public struct GetResponderGatewayOutput: Swift.Sendable {
    /// The count of active links for the responder gateway.
    public var activeLinksCount: Swift.Int?
    /// The timestamp of when the responder gateway was created.
    public var createdAt: Foundation.Date?
    /// The description of the responder gateway.
    public var description: Swift.String?
    /// The domain name of the responder gateway.
    public var domainName: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The count of inbound links for the responder gateway.
    public var inboundLinksCount: Swift.Int?
    /// The configuration of the managed endpoint.
    public var managedEndpointConfiguration: RTBFabricClientTypes.ManagedEndpointConfiguration?
    /// The networking port.
    /// This member is required.
    public var port: Swift.Int?
    /// The networking protocol.
    /// This member is required.
    public var `protocol`: RTBFabricClientTypes.ModelProtocol?
    /// The unique identifiers of the security groups.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.ResponderGatewayStatus?
    /// The unique identifiers of the subnets.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [Swift.String: Swift.String]?
    /// The total count of links for the responder gateway.
    public var totalLinksCount: Swift.Int?
    /// The configuration of the trust store.
    public var trustStoreConfiguration: RTBFabricClientTypes.TrustStoreConfiguration?
    /// The timestamp of when the responder gateway was updated.
    public var updatedAt: Foundation.Date?
    /// The unique identifier of the Virtual Private Cloud (VPC).
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        activeLinksCount: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        inboundLinksCount: Swift.Int? = nil,
        managedEndpointConfiguration: RTBFabricClientTypes.ManagedEndpointConfiguration? = nil,
        port: Swift.Int? = nil,
        `protocol`: RTBFabricClientTypes.ModelProtocol? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: RTBFabricClientTypes.ResponderGatewayStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        totalLinksCount: Swift.Int? = nil,
        trustStoreConfiguration: RTBFabricClientTypes.TrustStoreConfiguration? = nil,
        updatedAt: Foundation.Date? = nil,
        vpcId: Swift.String? = nil
    ) {
        self.activeLinksCount = activeLinksCount
        self.createdAt = createdAt
        self.description = description
        self.domainName = domainName
        self.gatewayId = gatewayId
        self.inboundLinksCount = inboundLinksCount
        self.managedEndpointConfiguration = managedEndpointConfiguration
        self.port = port
        self.`protocol` = `protocol`
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.subnetIds = subnetIds
        self.tags = tags
        self.totalLinksCount = totalLinksCount
        self.trustStoreConfiguration = trustStoreConfiguration
        self.updatedAt = updatedAt
        self.vpcId = vpcId
    }
}

public struct ListRequesterGatewaysInput: Swift.Sendable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListRequesterGatewaysOutput: Swift.Sendable {
    /// The unique identifier of the gateways.
    public var gatewayIds: [Swift.String]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        gatewayIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.gatewayIds = gatewayIds
        self.nextToken = nextToken
    }
}

public struct ListResponderGatewaysInput: Swift.Sendable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResponderGatewaysOutput: Swift.Sendable {
    /// The unique identifier of the gateways.
    public var gatewayIds: [Swift.String]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        gatewayIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.gatewayIds = gatewayIds
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct UpdateRequesterGatewayInput: Swift.Sendable {
    /// The unique client token.
    /// This member is required.
    public var clientToken: Swift.String?
    /// An optional description for the requester gateway.
    public var description: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.gatewayId = gatewayId
    }
}

public struct UpdateRequesterGatewayOutput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.RequesterGatewayStatus?

    public init(
        gatewayId: Swift.String? = nil,
        status: RTBFabricClientTypes.RequesterGatewayStatus? = nil
    ) {
        self.gatewayId = gatewayId
        self.status = status
    }
}

public struct UpdateResponderGatewayInput: Swift.Sendable {
    /// The unique client token.
    /// This member is required.
    public var clientToken: Swift.String?
    /// An optional description for the responder gateway.
    public var description: Swift.String?
    /// The domain name for the responder gateway.
    public var domainName: Swift.String?
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The configuration for the managed endpoint.
    public var managedEndpointConfiguration: RTBFabricClientTypes.ManagedEndpointConfiguration?
    /// The networking port to use.
    /// This member is required.
    public var port: Swift.Int?
    /// The networking protocol to use.
    /// This member is required.
    public var `protocol`: RTBFabricClientTypes.ModelProtocol?
    /// The configuration of the trust store.
    public var trustStoreConfiguration: RTBFabricClientTypes.TrustStoreConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        managedEndpointConfiguration: RTBFabricClientTypes.ManagedEndpointConfiguration? = nil,
        port: Swift.Int? = nil,
        `protocol`: RTBFabricClientTypes.ModelProtocol? = nil,
        trustStoreConfiguration: RTBFabricClientTypes.TrustStoreConfiguration? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.domainName = domainName
        self.gatewayId = gatewayId
        self.managedEndpointConfiguration = managedEndpointConfiguration
        self.port = port
        self.`protocol` = `protocol`
        self.trustStoreConfiguration = trustStoreConfiguration
    }
}

public struct UpdateResponderGatewayOutput: Swift.Sendable {
    /// The unique identifier of the gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The status of the request.
    /// This member is required.
    public var status: RTBFabricClientTypes.ResponderGatewayStatus?

    public init(
        gatewayId: Swift.String? = nil,
        status: RTBFabricClientTypes.ResponderGatewayStatus? = nil
    ) {
        self.gatewayId = gatewayId
        self.status = status
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AcceptLinkInput {

    static func urlPathProvider(_ value: AcceptLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/gateway/\(gatewayId.urlPercentEncoding())/link/\(linkId.urlPercentEncoding())/accept"
    }
}

extension CreateInboundExternalLinkInput {

    static func urlPathProvider(_ value: CreateInboundExternalLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/responder-gateway/\(gatewayId.urlPercentEncoding())/inbound-external-link"
    }
}

extension CreateLinkInput {

    static func urlPathProvider(_ value: CreateLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/gateway/\(gatewayId.urlPercentEncoding())/create-link"
    }
}

extension CreateOutboundExternalLinkInput {

    static func urlPathProvider(_ value: CreateOutboundExternalLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/requester-gateway/\(gatewayId.urlPercentEncoding())/outbound-external-link"
    }
}

extension CreateRequesterGatewayInput {

    static func urlPathProvider(_ value: CreateRequesterGatewayInput) -> Swift.String? {
        return "/requester-gateway"
    }
}

extension CreateResponderGatewayInput {

    static func urlPathProvider(_ value: CreateResponderGatewayInput) -> Swift.String? {
        return "/responder-gateway"
    }
}

extension DeleteInboundExternalLinkInput {

    static func urlPathProvider(_ value: DeleteInboundExternalLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/responder-gateway/\(gatewayId.urlPercentEncoding())/inbound-external-link/\(linkId.urlPercentEncoding())"
    }
}

extension DeleteLinkInput {

    static func urlPathProvider(_ value: DeleteLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/gateway/\(gatewayId.urlPercentEncoding())/link/\(linkId.urlPercentEncoding())"
    }
}

extension DeleteOutboundExternalLinkInput {

    static func urlPathProvider(_ value: DeleteOutboundExternalLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/requester-gateway/\(gatewayId.urlPercentEncoding())/outbound-external-link/\(linkId.urlPercentEncoding())"
    }
}

extension DeleteRequesterGatewayInput {

    static func urlPathProvider(_ value: DeleteRequesterGatewayInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/requester-gateway/\(gatewayId.urlPercentEncoding())"
    }
}

extension DeleteResponderGatewayInput {

    static func urlPathProvider(_ value: DeleteResponderGatewayInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/responder-gateway/\(gatewayId.urlPercentEncoding())"
    }
}

extension GetInboundExternalLinkInput {

    static func urlPathProvider(_ value: GetInboundExternalLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/responder-gateway/\(gatewayId.urlPercentEncoding())/inbound-external-link/\(linkId.urlPercentEncoding())"
    }
}

extension GetLinkInput {

    static func urlPathProvider(_ value: GetLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/gateway/\(gatewayId.urlPercentEncoding())/link/\(linkId.urlPercentEncoding())"
    }
}

extension GetOutboundExternalLinkInput {

    static func urlPathProvider(_ value: GetOutboundExternalLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/requester-gateway/\(gatewayId.urlPercentEncoding())/outbound-external-link/\(linkId.urlPercentEncoding())"
    }
}

extension GetRequesterGatewayInput {

    static func urlPathProvider(_ value: GetRequesterGatewayInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/requester-gateway/\(gatewayId.urlPercentEncoding())"
    }
}

extension GetResponderGatewayInput {

    static func urlPathProvider(_ value: GetResponderGatewayInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/responder-gateway/\(gatewayId.urlPercentEncoding())"
    }
}

extension ListLinksInput {

    static func urlPathProvider(_ value: ListLinksInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/gateway/\(gatewayId.urlPercentEncoding())/links"
    }
}

extension ListLinksInput {

    static func queryItemProvider(_ value: ListLinksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRequesterGatewaysInput {

    static func urlPathProvider(_ value: ListRequesterGatewaysInput) -> Swift.String? {
        return "/requester-gateways"
    }
}

extension ListRequesterGatewaysInput {

    static func queryItemProvider(_ value: ListRequesterGatewaysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListResponderGatewaysInput {

    static func urlPathProvider(_ value: ListResponderGatewaysInput) -> Swift.String? {
        return "/responder-gateways"
    }
}

extension ListResponderGatewaysInput {

    static func queryItemProvider(_ value: ListResponderGatewaysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension RejectLinkInput {

    static func urlPathProvider(_ value: RejectLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/gateway/\(gatewayId.urlPercentEncoding())/link/\(linkId.urlPercentEncoding())/reject"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateLinkInput {

    static func urlPathProvider(_ value: UpdateLinkInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/gateway/\(gatewayId.urlPercentEncoding())/link/\(linkId.urlPercentEncoding())"
    }
}

extension UpdateLinkModuleFlowInput {

    static func urlPathProvider(_ value: UpdateLinkModuleFlowInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let linkId = value.linkId else {
            return nil
        }
        return "/gateway/\(gatewayId.urlPercentEncoding())/link/\(linkId.urlPercentEncoding())/module-flow"
    }
}

extension UpdateRequesterGatewayInput {

    static func urlPathProvider(_ value: UpdateRequesterGatewayInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/requester-gateway/\(gatewayId.urlPercentEncoding())/update"
    }
}

extension UpdateResponderGatewayInput {

    static func urlPathProvider(_ value: UpdateResponderGatewayInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/responder-gateway/\(gatewayId.urlPercentEncoding())/update"
    }
}

extension AcceptLinkInput {

    static func write(value: AcceptLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes, with: RTBFabricClientTypes.LinkAttributes.write(value:to:))
        try writer["logSettings"].write(value.logSettings, with: RTBFabricClientTypes.LinkLogSettings.write(value:to:))
    }
}

extension CreateInboundExternalLinkInput {

    static func write(value: CreateInboundExternalLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes, with: RTBFabricClientTypes.LinkAttributes.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["logSettings"].write(value.logSettings, with: RTBFabricClientTypes.LinkLogSettings.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateLinkInput {

    static func write(value: CreateLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes, with: RTBFabricClientTypes.LinkAttributes.write(value:to:))
        try writer["httpResponderAllowed"].write(value.httpResponderAllowed)
        try writer["logSettings"].write(value.logSettings, with: RTBFabricClientTypes.LinkLogSettings.write(value:to:))
        try writer["peerGatewayId"].write(value.peerGatewayId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateOutboundExternalLinkInput {

    static func write(value: CreateOutboundExternalLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].write(value.attributes, with: RTBFabricClientTypes.LinkAttributes.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["logSettings"].write(value.logSettings, with: RTBFabricClientTypes.LinkLogSettings.write(value:to:))
        try writer["publicEndpoint"].write(value.publicEndpoint)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRequesterGatewayInput {

    static func write(value: CreateRequesterGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
    }
}

extension CreateResponderGatewayInput {

    static func write(value: CreateResponderGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["domainName"].write(value.domainName)
        try writer["managedEndpointConfiguration"].write(value.managedEndpointConfiguration, with: RTBFabricClientTypes.ManagedEndpointConfiguration.write(value:to:))
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["trustStoreConfiguration"].write(value.trustStoreConfiguration, with: RTBFabricClientTypes.TrustStoreConfiguration.write(value:to:))
        try writer["vpcId"].write(value.vpcId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateLinkInput {

    static func write(value: UpdateLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logSettings"].write(value.logSettings, with: RTBFabricClientTypes.LinkLogSettings.write(value:to:))
    }
}

extension UpdateLinkModuleFlowInput {

    static func write(value: UpdateLinkModuleFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["modules"].writeList(value.modules, memberWritingClosure: RTBFabricClientTypes.ModuleConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateRequesterGatewayInput {

    static func write(value: UpdateRequesterGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
    }
}

extension UpdateResponderGatewayInput {

    static func write(value: UpdateResponderGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["domainName"].write(value.domainName)
        try writer["managedEndpointConfiguration"].write(value.managedEndpointConfiguration, with: RTBFabricClientTypes.ManagedEndpointConfiguration.write(value:to:))
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["trustStoreConfiguration"].write(value.trustStoreConfiguration, with: RTBFabricClientTypes.TrustStoreConfiguration.write(value:to:))
    }
}

extension AcceptLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptLinkOutput()
        value.attributes = try reader["attributes"].readIfPresent(with: RTBFabricClientTypes.LinkAttributes.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.direction = try reader["direction"].readIfPresent()
        value.flowModules = try reader["flowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.peerGatewayId = try reader["peerGatewayId"].readIfPresent() ?? ""
        value.pendingFlowModules = try reader["pendingFlowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateInboundExternalLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInboundExternalLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInboundExternalLinkOutput()
        value.domainName = try reader["domainName"].readIfPresent() ?? ""
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLinkOutput()
        value.attributes = try reader["attributes"].readIfPresent(with: RTBFabricClientTypes.LinkAttributes.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerProvidedId = try reader["customerProvidedId"].readIfPresent()
        value.direction = try reader["direction"].readIfPresent()
        value.flowModules = try reader["flowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.peerGatewayId = try reader["peerGatewayId"].readIfPresent() ?? ""
        value.pendingFlowModules = try reader["pendingFlowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateOutboundExternalLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOutboundExternalLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOutboundExternalLinkOutput()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateRequesterGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRequesterGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRequesterGatewayOutput()
        value.domainName = try reader["domainName"].readIfPresent() ?? ""
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateResponderGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResponderGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResponderGatewayOutput()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteInboundExternalLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInboundExternalLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInboundExternalLinkOutput()
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteLinkOutput()
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteOutboundExternalLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOutboundExternalLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteOutboundExternalLinkOutput()
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteRequesterGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRequesterGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRequesterGatewayOutput()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteResponderGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResponderGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteResponderGatewayOutput()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetInboundExternalLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInboundExternalLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInboundExternalLinkOutput()
        value.attributes = try reader["attributes"].readIfPresent(with: RTBFabricClientTypes.LinkAttributes.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.domainName = try reader["domainName"].readIfPresent() ?? ""
        value.flowModules = try reader["flowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.logSettings = try reader["logSettings"].readIfPresent(with: RTBFabricClientTypes.LinkLogSettings.read(from:))
        value.pendingFlowModules = try reader["pendingFlowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLinkOutput()
        value.attributes = try reader["attributes"].readIfPresent(with: RTBFabricClientTypes.LinkAttributes.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.direction = try reader["direction"].readIfPresent()
        value.flowModules = try reader["flowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.logSettings = try reader["logSettings"].readIfPresent(with: RTBFabricClientTypes.LinkLogSettings.read(from:))
        value.peerGatewayId = try reader["peerGatewayId"].readIfPresent() ?? ""
        value.pendingFlowModules = try reader["pendingFlowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetOutboundExternalLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOutboundExternalLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOutboundExternalLinkOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.logSettings = try reader["logSettings"].readIfPresent(with: RTBFabricClientTypes.LinkLogSettings.read(from:))
        value.publicEndpoint = try reader["publicEndpoint"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetRequesterGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRequesterGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRequesterGatewayOutput()
        value.activeLinksCount = try reader["activeLinksCount"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent() ?? ""
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.totalLinksCount = try reader["totalLinksCount"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        return value
    }
}

extension GetResponderGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResponderGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResponderGatewayOutput()
        value.activeLinksCount = try reader["activeLinksCount"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.domainName = try reader["domainName"].readIfPresent()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.inboundLinksCount = try reader["inboundLinksCount"].readIfPresent()
        value.managedEndpointConfiguration = try reader["managedEndpointConfiguration"].readIfPresent(with: RTBFabricClientTypes.ManagedEndpointConfiguration.read(from:))
        value.port = try reader["port"].readIfPresent() ?? 0
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.totalLinksCount = try reader["totalLinksCount"].readIfPresent()
        value.trustStoreConfiguration = try reader["trustStoreConfiguration"].readIfPresent(with: RTBFabricClientTypes.TrustStoreConfiguration.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        return value
    }
}

extension ListLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLinksOutput()
        value.links = try reader["links"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ListLinksResponseStructure.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRequesterGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRequesterGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRequesterGatewaysOutput()
        value.gatewayIds = try reader["gatewayIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListResponderGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResponderGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResponderGatewaysOutput()
        value.gatewayIds = try reader["gatewayIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RejectLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectLinkOutput()
        value.attributes = try reader["attributes"].readIfPresent(with: RTBFabricClientTypes.LinkAttributes.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.direction = try reader["direction"].readIfPresent()
        value.flowModules = try reader["flowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.peerGatewayId = try reader["peerGatewayId"].readIfPresent() ?? ""
        value.pendingFlowModules = try reader["pendingFlowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLinkOutput()
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdateLinkModuleFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLinkModuleFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLinkModuleFlowOutput()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdateRequesterGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRequesterGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRequesterGatewayOutput()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdateResponderGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResponderGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResponderGatewayOutput()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

enum AcceptLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInboundExternalLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOutboundExternalLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRequesterGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResponderGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInboundExternalLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOutboundExternalLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRequesterGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResponderGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInboundExternalLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOutboundExternalLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRequesterGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResponderGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRequesterGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResponderGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLinkModuleFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRequesterGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResponderGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RTBFabricClientTypes.Action {

    static func write(value: RTBFabricClientTypes.Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .headertag(headertag):
                try writer["headerTag"].write(headertag, with: RTBFabricClientTypes.HeaderTagAction.write(value:to:))
            case let .nobid(nobid):
                try writer["noBid"].write(nobid, with: RTBFabricClientTypes.NoBidAction.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "noBid":
                return .nobid(try reader["noBid"].read(with: RTBFabricClientTypes.NoBidAction.read(from:)))
            case "headerTag":
                return .headertag(try reader["headerTag"].read(with: RTBFabricClientTypes.HeaderTagAction.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RTBFabricClientTypes.AutoScalingGroupsConfiguration {

    static func write(value: RTBFabricClientTypes.AutoScalingGroupsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoScalingGroupNames"].writeList(value.autoScalingGroupNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.AutoScalingGroupsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.AutoScalingGroupsConfiguration()
        value.autoScalingGroupNames = try reader["autoScalingGroupNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension RTBFabricClientTypes.EksEndpointsConfiguration {

    static func write(value: RTBFabricClientTypes.EksEndpointsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clusterApiServerCaCertificateChain"].write(value.clusterApiServerCaCertificateChain)
        try writer["clusterApiServerEndpointUri"].write(value.clusterApiServerEndpointUri)
        try writer["clusterName"].write(value.clusterName)
        try writer["endpointsResourceName"].write(value.endpointsResourceName)
        try writer["endpointsResourceNamespace"].write(value.endpointsResourceNamespace)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.EksEndpointsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.EksEndpointsConfiguration()
        value.endpointsResourceName = try reader["endpointsResourceName"].readIfPresent() ?? ""
        value.endpointsResourceNamespace = try reader["endpointsResourceNamespace"].readIfPresent() ?? ""
        value.clusterApiServerEndpointUri = try reader["clusterApiServerEndpointUri"].readIfPresent() ?? ""
        value.clusterApiServerCaCertificateChain = try reader["clusterApiServerCaCertificateChain"].readIfPresent() ?? ""
        value.clusterName = try reader["clusterName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension RTBFabricClientTypes.Filter {

    static func write(value: RTBFabricClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["criteria"].writeList(value.criteria, memberWritingClosure: RTBFabricClientTypes.FilterCriterion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.Filter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.Filter()
        value.criteria = try reader["criteria"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.FilterCriterion.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension RTBFabricClientTypes.FilterCriterion {

    static func write(value: RTBFabricClientTypes.FilterCriterion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["path"].write(value.path)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.FilterCriterion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.FilterCriterion()
        value.path = try reader["path"].readIfPresent() ?? ""
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension RTBFabricClientTypes.HeaderTagAction {

    static func write(value: RTBFabricClientTypes.HeaderTagAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.HeaderTagAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.HeaderTagAction()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension RTBFabricClientTypes.LinkApplicationLogConfiguration {

    static func write(value: RTBFabricClientTypes.LinkApplicationLogConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sampling"].write(value.sampling, with: RTBFabricClientTypes.LinkApplicationLogSampling.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.LinkApplicationLogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.LinkApplicationLogConfiguration()
        value.sampling = try reader["sampling"].readIfPresent(with: RTBFabricClientTypes.LinkApplicationLogSampling.read(from:))
        return value
    }
}

extension RTBFabricClientTypes.LinkApplicationLogSampling {

    static func write(value: RTBFabricClientTypes.LinkApplicationLogSampling?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["errorLog"].write(value.errorLog)
        try writer["filterLog"].write(value.filterLog)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.LinkApplicationLogSampling {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.LinkApplicationLogSampling()
        value.errorLog = try reader["errorLog"].readIfPresent() ?? 0.0
        value.filterLog = try reader["filterLog"].readIfPresent() ?? 0.0
        return value
    }
}

extension RTBFabricClientTypes.LinkAttributes {

    static func write(value: RTBFabricClientTypes.LinkAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customerProvidedId"].write(value.customerProvidedId)
        try writer["responderErrorMasking"].writeList(value.responderErrorMasking, memberWritingClosure: RTBFabricClientTypes.ResponderErrorMaskingForHttpCode.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.LinkAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.LinkAttributes()
        value.responderErrorMasking = try reader["responderErrorMasking"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ResponderErrorMaskingForHttpCode.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customerProvidedId = try reader["customerProvidedId"].readIfPresent()
        return value
    }
}

extension RTBFabricClientTypes.LinkLogSettings {

    static func write(value: RTBFabricClientTypes.LinkLogSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationLogs"].write(value.applicationLogs, with: RTBFabricClientTypes.LinkApplicationLogConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.LinkLogSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.LinkLogSettings()
        value.applicationLogs = try reader["applicationLogs"].readIfPresent(with: RTBFabricClientTypes.LinkApplicationLogConfiguration.read(from:))
        return value
    }
}

extension RTBFabricClientTypes.ListLinksResponseStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.ListLinksResponseStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.ListLinksResponseStructure()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.peerGatewayId = try reader["peerGatewayId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.direction = try reader["direction"].readIfPresent()
        value.flowModules = try reader["flowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.pendingFlowModules = try reader["pendingFlowModules"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.ModuleConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attributes = try reader["attributes"].readIfPresent(with: RTBFabricClientTypes.LinkAttributes.read(from:))
        value.linkId = try reader["linkId"].readIfPresent() ?? ""
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RTBFabricClientTypes.ManagedEndpointConfiguration {

    static func write(value: RTBFabricClientTypes.ManagedEndpointConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .autoscalinggroups(autoscalinggroups):
                try writer["autoScalingGroups"].write(autoscalinggroups, with: RTBFabricClientTypes.AutoScalingGroupsConfiguration.write(value:to:))
            case let .eksendpoints(eksendpoints):
                try writer["eksEndpoints"].write(eksendpoints, with: RTBFabricClientTypes.EksEndpointsConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.ManagedEndpointConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "autoScalingGroups":
                return .autoscalinggroups(try reader["autoScalingGroups"].read(with: RTBFabricClientTypes.AutoScalingGroupsConfiguration.read(from:)))
            case "eksEndpoints":
                return .eksendpoints(try reader["eksEndpoints"].read(with: RTBFabricClientTypes.EksEndpointsConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RTBFabricClientTypes.ModuleConfiguration {

    static func write(value: RTBFabricClientTypes.ModuleConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dependsOn"].writeList(value.dependsOn, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["moduleParameters"].write(value.moduleParameters, with: RTBFabricClientTypes.ModuleParameters.write(value:to:))
        try writer["name"].write(value.name)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.ModuleConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.ModuleConfiguration()
        value.version = try reader["version"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.dependsOn = try reader["dependsOn"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.moduleParameters = try reader["moduleParameters"].readIfPresent(with: RTBFabricClientTypes.ModuleParameters.read(from:))
        return value
    }
}

extension RTBFabricClientTypes.ModuleParameters {

    static func write(value: RTBFabricClientTypes.ModuleParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .nobid(nobid):
                try writer["noBid"].write(nobid, with: RTBFabricClientTypes.NoBidModuleParameters.write(value:to:))
            case let .openrtbattribute(openrtbattribute):
                try writer["openRtbAttribute"].write(openrtbattribute, with: RTBFabricClientTypes.OpenRtbAttributeModuleParameters.write(value:to:))
            case let .ratelimiter(ratelimiter):
                try writer["rateLimiter"].write(ratelimiter, with: RTBFabricClientTypes.RateLimiterModuleParameters.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.ModuleParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "noBid":
                return .nobid(try reader["noBid"].read(with: RTBFabricClientTypes.NoBidModuleParameters.read(from:)))
            case "openRtbAttribute":
                return .openrtbattribute(try reader["openRtbAttribute"].read(with: RTBFabricClientTypes.OpenRtbAttributeModuleParameters.read(from:)))
            case "rateLimiter":
                return .ratelimiter(try reader["rateLimiter"].read(with: RTBFabricClientTypes.RateLimiterModuleParameters.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RTBFabricClientTypes.NoBidAction {

    static func write(value: RTBFabricClientTypes.NoBidAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["noBidReasonCode"].write(value.noBidReasonCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.NoBidAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.NoBidAction()
        value.noBidReasonCode = try reader["noBidReasonCode"].readIfPresent()
        return value
    }
}

extension RTBFabricClientTypes.NoBidModuleParameters {

    static func write(value: RTBFabricClientTypes.NoBidModuleParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["passThroughPercentage"].write(value.passThroughPercentage)
        try writer["reason"].write(value.reason)
        try writer["reasonCode"].write(value.reasonCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.NoBidModuleParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.NoBidModuleParameters()
        value.reason = try reader["reason"].readIfPresent()
        value.reasonCode = try reader["reasonCode"].readIfPresent()
        value.passThroughPercentage = try reader["passThroughPercentage"].readIfPresent()
        return value
    }
}

extension RTBFabricClientTypes.OpenRtbAttributeModuleParameters {

    static func write(value: RTBFabricClientTypes.OpenRtbAttributeModuleParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: RTBFabricClientTypes.Action.write(value:to:))
        try writer["filterConfiguration"].writeList(value.filterConfiguration, memberWritingClosure: RTBFabricClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filterType"].write(value.filterType)
        try writer["holdbackPercentage"].write(value.holdbackPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.OpenRtbAttributeModuleParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.OpenRtbAttributeModuleParameters()
        value.filterType = try reader["filterType"].readIfPresent() ?? .sdkUnknown("")
        value.filterConfiguration = try reader["filterConfiguration"].readListIfPresent(memberReadingClosure: RTBFabricClientTypes.Filter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.action = try reader["action"].readIfPresent(with: RTBFabricClientTypes.Action.read(from:))
        value.holdbackPercentage = try reader["holdbackPercentage"].readIfPresent() ?? 0.0
        return value
    }
}

extension RTBFabricClientTypes.RateLimiterModuleParameters {

    static func write(value: RTBFabricClientTypes.RateLimiterModuleParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tps"].write(value.tps)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.RateLimiterModuleParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.RateLimiterModuleParameters()
        value.tps = try reader["tps"].readIfPresent()
        return value
    }
}

extension RTBFabricClientTypes.ResponderErrorMaskingForHttpCode {

    static func write(value: RTBFabricClientTypes.ResponderErrorMaskingForHttpCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["httpCode"].write(value.httpCode)
        try writer["loggingTypes"].writeList(value.loggingTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<RTBFabricClientTypes.ResponderErrorMaskingLoggingType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["responseLoggingPercentage"].write(value.responseLoggingPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.ResponderErrorMaskingForHttpCode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.ResponderErrorMaskingForHttpCode()
        value.httpCode = try reader["httpCode"].readIfPresent() ?? ""
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.loggingTypes = try reader["loggingTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<RTBFabricClientTypes.ResponderErrorMaskingLoggingType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.responseLoggingPercentage = try reader["responseLoggingPercentage"].readIfPresent()
        return value
    }
}

extension RTBFabricClientTypes.TrustStoreConfiguration {

    static func write(value: RTBFabricClientTypes.TrustStoreConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateAuthorityCertificates"].writeList(value.certificateAuthorityCertificates, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RTBFabricClientTypes.TrustStoreConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RTBFabricClientTypes.TrustStoreConfiguration()
        value.certificateAuthorityCertificates = try reader["certificateAuthorityCertificates"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

public enum RTBFabricClientTypes {}
