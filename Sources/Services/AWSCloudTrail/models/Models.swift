// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountHasOngoingImportException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccountHasOngoingImportExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when you start a new import and a previous import is still in progress.
public struct AccountHasOngoingImportException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountHasOngoingImport" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccountHasOngoingImportExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountHasOngoingImportExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccountNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified account is not found or not part of an organization.
public struct AccountNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccountNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountNotRegisteredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccountNotRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified account is not registered as the CloudTrail delegated administrator.
public struct AccountNotRegisteredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountNotRegistered" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccountNotRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountNotRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountRegisteredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccountRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the account is already registered as the CloudTrail delegated administrator.
public struct AccountRegisteredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountRegistered" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccountRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
    }
}

extension AddTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies the tags to add to a trail, event data store, or channel.
public struct AddTagsInput: Swift.Equatable {
    /// Specifies the ARN of the trail, event data store, or channel to which one or more tags will be added. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail The format of an event data store ARN is: arn:aws:cloudtrail:us-east-2:123456789012:eventdatastore/EXAMPLE-f852-4e8f-8bd1-bcf6cEXAMPLE The format of a channel ARN is: arn:aws:cloudtrail:us-east-2:123456789012:channel/01234567890
    /// This member is required.
    public var resourceId: Swift.String?
    /// Contains a list of tags, up to a limit of 50
    /// This member is required.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

struct AddTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagsList: [CloudTrailClientTypes.Tag]?
}

extension AddTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension AddTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Returns the objects or data if successful. Otherwise, returns an error.
public struct AddTagsOutput: Swift.Equatable {

    public init() { }
}

enum AddTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ChannelARNInvalid": return try await ChannelARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelNotFound": return try await ChannelNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagParameter": return try await InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceTypeNotSupported": return try await ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagsLimitExceeded": return try await TagsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudTrailClientTypes.AdvancedEventSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldSelectors = "FieldSelectors"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldSelectors = fieldSelectors {
            var fieldSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldSelectors)
            for advancedfieldselector0 in fieldSelectors {
                try fieldSelectorsContainer.encode(advancedfieldselector0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fieldSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedFieldSelector?].self, forKey: .fieldSelectors)
        var fieldSelectorsDecoded0:[CloudTrailClientTypes.AdvancedFieldSelector]? = nil
        if let fieldSelectorsContainer = fieldSelectorsContainer {
            fieldSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedFieldSelector]()
            for structure0 in fieldSelectorsContainer {
                if let structure0 = structure0 {
                    fieldSelectorsDecoded0?.append(structure0)
                }
            }
        }
        fieldSelectors = fieldSelectorsDecoded0
    }
}

extension CloudTrailClientTypes {
    /// Advanced event selectors let you create fine-grained selectors for the following CloudTrail event record ﬁelds. They help you control costs by logging only those events that are important to you. For more information about advanced event selectors, see [Logging data events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) in the CloudTrail User Guide.
    ///
    /// * readOnly
    ///
    /// * eventSource
    ///
    /// * eventName
    ///
    /// * eventCategory
    ///
    /// * resources.type
    ///
    /// * resources.ARN
    ///
    ///
    /// You cannot apply both event selectors and advanced event selectors to a trail.
    public struct AdvancedEventSelector: Swift.Equatable {
        /// Contains all selector statements in an advanced event selector.
        /// This member is required.
        public var fieldSelectors: [CloudTrailClientTypes.AdvancedFieldSelector]?
        /// An optional, descriptive name for an advanced event selector, such as "Log data events for only two S3 buckets".
        public var name: Swift.String?

        public init(
            fieldSelectors: [CloudTrailClientTypes.AdvancedFieldSelector]? = nil,
            name: Swift.String? = nil
        )
        {
            self.fieldSelectors = fieldSelectors
            self.name = name
        }
    }

}

extension CloudTrailClientTypes.AdvancedFieldSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endsWith = "EndsWith"
        case equals = "Equals"
        case field = "Field"
        case notEndsWith = "NotEndsWith"
        case notEquals = "NotEquals"
        case notStartsWith = "NotStartsWith"
        case startsWith = "StartsWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endsWith = endsWith {
            var endsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endsWith)
            for operatorvalue0 in endsWith {
                try endsWithContainer.encode(operatorvalue0)
            }
        }
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for operatorvalue0 in equals {
                try equalsContainer.encode(operatorvalue0)
            }
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let notEndsWith = notEndsWith {
            var notEndsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEndsWith)
            for operatorvalue0 in notEndsWith {
                try notEndsWithContainer.encode(operatorvalue0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for operatorvalue0 in notEquals {
                try notEqualsContainer.encode(operatorvalue0)
            }
        }
        if let notStartsWith = notStartsWith {
            var notStartsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notStartsWith)
            for operatorvalue0 in notStartsWith {
                try notStartsWithContainer.encode(operatorvalue0)
            }
        }
        if let startsWith = startsWith {
            var startsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startsWith)
            for operatorvalue0 in startsWith {
                try startsWithContainer.encode(operatorvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let equalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .equals)
        var equalsDecoded0:[Swift.String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [Swift.String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let startsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startsWith)
        var startsWithDecoded0:[Swift.String]? = nil
        if let startsWithContainer = startsWithContainer {
            startsWithDecoded0 = [Swift.String]()
            for string0 in startsWithContainer {
                if let string0 = string0 {
                    startsWithDecoded0?.append(string0)
                }
            }
        }
        startsWith = startsWithDecoded0
        let endsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endsWith)
        var endsWithDecoded0:[Swift.String]? = nil
        if let endsWithContainer = endsWithContainer {
            endsWithDecoded0 = [Swift.String]()
            for string0 in endsWithContainer {
                if let string0 = string0 {
                    endsWithDecoded0?.append(string0)
                }
            }
        }
        endsWith = endsWithDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[Swift.String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [Swift.String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
        let notStartsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notStartsWith)
        var notStartsWithDecoded0:[Swift.String]? = nil
        if let notStartsWithContainer = notStartsWithContainer {
            notStartsWithDecoded0 = [Swift.String]()
            for string0 in notStartsWithContainer {
                if let string0 = string0 {
                    notStartsWithDecoded0?.append(string0)
                }
            }
        }
        notStartsWith = notStartsWithDecoded0
        let notEndsWithContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEndsWith)
        var notEndsWithDecoded0:[Swift.String]? = nil
        if let notEndsWithContainer = notEndsWithContainer {
            notEndsWithDecoded0 = [Swift.String]()
            for string0 in notEndsWithContainer {
                if let string0 = string0 {
                    notEndsWithDecoded0?.append(string0)
                }
            }
        }
        notEndsWith = notEndsWithDecoded0
    }
}

extension CloudTrailClientTypes {
    /// A single selector statement in an advanced event selector.
    public struct AdvancedFieldSelector: Swift.Equatable {
        /// An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        public var endsWith: [Swift.String]?
        /// An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
        public var equals: [Swift.String]?
        /// A field in a CloudTrail event record on which to filter events to be logged. For event data stores for Config configuration items, Audit Manager evidence, or non-Amazon Web Services events, the field is used only for selecting events as filtering is not supported. For CloudTrail event records, supported fields include readOnly, eventCategory, eventSource (for management events), eventName, resources.type, and resources.ARN. For event data stores for Config configuration items, Audit Manager evidence, or non-Amazon Web Services events, the only supported field is eventCategory.
        ///
        /// * readOnly - Optional. Can be set to Equals a value of true or false. If you do not add this field, CloudTrail logs both read and write events. A value of true logs only read events. A value of false logs only write events.
        ///
        /// * eventSource - For filtering management events only. This can be set only to NotEqualskms.amazonaws.com.
        ///
        /// * eventName - Can use any operator. You can use it to ﬁlter in or ﬁlter out any data event logged to CloudTrail, such as PutBucket or GetSnapshotBlock. You can have multiple values for this ﬁeld, separated by commas.
        ///
        /// * eventCategory - This is required and must be set to Equals.
        ///
        /// * For CloudTrail event records, the value must be Management or Data.
        ///
        /// * For Config configuration items, the value must be ConfigurationItem.
        ///
        /// * For Audit Manager evidence, the value must be Evidence.
        ///
        /// * For non-Amazon Web Services events, the value must be ActivityAuditLog.
        ///
        ///
        ///
        ///
        /// * resources.type - This ﬁeld is required for CloudTrail data events. resources.type can only use the Equals operator, and the value can be one of the following:
        ///
        /// * AWS::DynamoDB::Table
        ///
        /// * AWS::Lambda::Function
        ///
        /// * AWS::S3::Object
        ///
        /// * AWS::CloudTrail::Channel
        ///
        /// * AWS::CodeWhisperer::Profile
        ///
        /// * AWS::Cognito::IdentityPool
        ///
        /// * AWS::DynamoDB::Stream
        ///
        /// * AWS::EC2::Snapshot
        ///
        /// * AWS::EMRWAL::Workspace
        ///
        /// * AWS::FinSpace::Environment
        ///
        /// * AWS::Glue::Table
        ///
        /// * AWS::GuardDuty::Detector
        ///
        /// * AWS::KendraRanking::ExecutionPlan
        ///
        /// * AWS::ManagedBlockchain::Network
        ///
        /// * AWS::ManagedBlockchain::Node
        ///
        /// * AWS::MedicalImaging::Datastore
        ///
        /// * AWS::SageMaker::ExperimentTrialComponent
        ///
        /// * AWS::SageMaker::FeatureGroup
        ///
        /// * AWS::S3::AccessPoint
        ///
        /// * AWS::S3ObjectLambda::AccessPoint
        ///
        /// * AWS::S3Outposts::Object
        ///
        /// * AWS::SSMMessages::ControlChannel
        ///
        /// * AWS::VerifiedPermissions::PolicyStore
        ///
        ///
        /// You can have only one resources.type ﬁeld per selector. To log data events on more than one resource type, add another selector.
        ///
        /// * resources.ARN - You can use any operator with resources.ARN, but if you use Equals or NotEquals, the value must exactly match the ARN of a valid resource of the type you've speciﬁed in the template as the value of resources.type. For example, if resources.type equals AWS::S3::Object, the ARN must be in one of the following formats. To log all data events for all objects in a specific S3 bucket, use the StartsWith operator, and include only the bucket ARN as the matching value. The trailing slash is intentional; do not exclude it. Replace the text between less than and greater than symbols (<>) with resource-specific information.
        ///
        /// * arn::s3:::/
        ///
        /// * arn::s3::://
        ///
        ///
        /// When resources.type equals AWS::DynamoDB::Table, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::dynamodb:::table/
        ///
        ///
        /// When resources.type equals AWS::Lambda::Function, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::lambda:::function:
        ///
        ///
        /// When resources.type equals AWS::CloudTrail::Channel, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::cloudtrail:::channel/
        ///
        ///
        /// When resources.type equals AWS::CodeWhisperer::Profile, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::codewhisperer:::profile/
        ///
        ///
        /// When resources.type equals AWS::Cognito::IdentityPool, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::cognito-identity:::identitypool/
        ///
        ///
        /// When resources.type equals AWS::DynamoDB::Stream, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::dynamodb:::table//stream/
        ///
        ///
        /// When resources.type equals AWS::EC2::Snapshot, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::ec2:::snapshot/
        ///
        ///
        /// When resources.type equals AWS::EMRWAL::Workspace, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::emrwal:::workspace/
        ///
        ///
        /// When resources.type equals AWS::FinSpace::Environment, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::finspace:::environment/
        ///
        ///
        /// When resources.type equals AWS::Glue::Table, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::glue:::table//
        ///
        ///
        /// When resources.type equals AWS::GuardDuty::Detector, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::guardduty:::detector/
        ///
        ///
        /// When resources.type equals AWS::KendraRanking::ExecutionPlan, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::kendra-ranking:::rescore-execution-plan/
        ///
        ///
        /// When resources.type equals AWS::ManagedBlockchain::Network, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::managedblockchain:::networks/
        ///
        ///
        /// When resources.type equals AWS::ManagedBlockchain::Node, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::managedblockchain:::nodes/
        ///
        ///
        /// When resources.type equals AWS::MedicalImaging::Datastore, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::medical-imaging:::datastore/
        ///
        ///
        /// When resources.type equals AWS::SageMaker::ExperimentTrialComponent, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::sagemaker:::experiment-trial-component/
        ///
        ///
        /// When resources.type equals AWS::SageMaker::FeatureGroup, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::sagemaker:::feature-group/
        ///
        ///
        /// When resources.type equals AWS::S3::AccessPoint, and the operator is set to Equals or NotEquals, the ARN must be in one of the following formats. To log events on all objects in an S3 access point, we recommend that you use only the access point ARN, don’t include the object path, and use the StartsWith or NotStartsWith operators.
        ///
        /// * arn::s3:::accesspoint/
        ///
        /// * arn::s3:::accesspoint//object/
        ///
        ///
        /// When resources.type equals AWS::S3ObjectLambda::AccessPoint, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::s3-object-lambda:::accesspoint/
        ///
        ///
        /// When resources.type equals AWS::S3Outposts::Object, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::s3-outposts:::
        ///
        ///
        /// When resources.type equals AWS::SSMMessages::ControlChannel, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::ssmmessages:::control-channel/
        ///
        ///
        /// When resources.type equals AWS::VerifiedPermissions::PolicyStore, and the operator is set to Equals or NotEquals, the ARN must be in the following format:
        ///
        /// * arn::verifiedpermissions:::policy-store/
        /// This member is required.
        public var field: Swift.String?
        /// An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        public var notEndsWith: [Swift.String]?
        /// An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        public var notEquals: [Swift.String]?
        /// An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        public var notStartsWith: [Swift.String]?
        /// An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        public var startsWith: [Swift.String]?

        public init(
            endsWith: [Swift.String]? = nil,
            equals: [Swift.String]? = nil,
            field: Swift.String? = nil,
            notEndsWith: [Swift.String]? = nil,
            notEquals: [Swift.String]? = nil,
            notStartsWith: [Swift.String]? = nil,
            startsWith: [Swift.String]? = nil
        )
        {
            self.endsWith = endsWith
            self.equals = equals
            self.field = field
            self.notEndsWith = notEndsWith
            self.notEquals = notEquals
            self.notStartsWith = notStartsWith
            self.startsWith = startsWith
        }
    }

}

extension CancelQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension CancelQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelQueryInput: Swift.Equatable {
    /// The ARN (or the ID suffix of the ARN) of an event data store on which the specified query is running.
    @available(*, deprecated, message: "EventDataStore is no longer required by CancelQueryRequest")
    public var eventDataStore: Swift.String?
    /// The ID of the query that you want to cancel. The QueryId comes from the response of a StartQuery operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.queryId = queryId
    }
}

struct CancelQueryInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let queryId: Swift.String?
}

extension CancelQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case queryId = "QueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

extension CancelQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.queryId = output.queryId
            self.queryStatus = output.queryStatus
        } else {
            self.queryId = nil
            self.queryStatus = nil
        }
    }
}

public struct CancelQueryOutput: Swift.Equatable {
    /// The ID of the canceled query.
    /// This member is required.
    public var queryId: Swift.String?
    /// Shows the status of a query after a CancelQuery request. Typically, the values shown are either RUNNING or CANCELLED.
    /// This member is required.
    public var queryStatus: CloudTrailClientTypes.QueryStatus?

    public init(
        queryId: Swift.String? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil
    )
    {
        self.queryId = queryId
        self.queryStatus = queryStatus
    }
}

struct CancelQueryOutputBody: Swift.Equatable {
    let queryId: Swift.String?
    let queryStatus: CloudTrailClientTypes.QueryStatus?
}

extension CancelQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
        case queryStatus = "QueryStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
    }
}

enum CancelQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveQuery": return try await InactiveQueryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryIdNotFound": return try await QueryIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CannotDelegateManagementAccountException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CannotDelegateManagementAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the management account of an organization is registered as the CloudTrail delegated administrator.
public struct CannotDelegateManagementAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotDelegateManagementAccount" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CannotDelegateManagementAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotDelegateManagementAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.Channel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about a returned CloudTrail channel.
    public struct Channel: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a channel.
        public var channelArn: Swift.String?
        /// The name of the CloudTrail channel. For service-linked channels, the name is aws-service-channel/service-name/custom-suffix where service-name represents the name of the Amazon Web Services service that created the channel and custom-suffix represents the suffix created by the Amazon Web Services service.
        public var name: Swift.String?

        public init(
            channelArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.channelArn = channelArn
            self.name = name
        }
    }

}

extension ChannelARNInvalidException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ChannelARNInvalidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified value of ChannelARN is not valid.
public struct ChannelARNInvalidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelARNInvalid" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ChannelARNInvalidExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ChannelARNInvalidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChannelAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ChannelAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the provided channel already exists.
public struct ChannelAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ChannelAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ChannelAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChannelExistsForEDSException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ChannelExistsForEDSExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified event data store cannot yet be deleted because it is in use by a channel.
public struct ChannelExistsForEDSException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelExistsForEDS" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ChannelExistsForEDSExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ChannelExistsForEDSExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChannelMaxLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ChannelMaxLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the maximum number of channels limit is exceeded.
public struct ChannelMaxLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelMaxLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ChannelMaxLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ChannelMaxLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChannelNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ChannelNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when CloudTrail cannot find the specified channel.
public struct ChannelNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ChannelNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ChannelNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailARNInvalidException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudTrailARNInvalidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when an operation is called with a trail ARN that is not valid. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail This exception is also thrown when you call AddTags or RemoveTags on a trail, event data store, or channel with a resource ARN that is not valid. The following is the format of an event data store ARN: arn:aws:cloudtrail:us-east-2:123456789012:eventdatastore/EXAMPLE-f852-4e8f-8bd1-bcf6cEXAMPLE The following is the format of a channel ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/01234567890
public struct CloudTrailARNInvalidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudTrailARNInvalid" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudTrailARNInvalidExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudTrailARNInvalidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailAccessNotEnabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudTrailAccessNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when trusted access has not been enabled between CloudTrail and Organizations. For more information, see [Enabling Trusted Access with Other Amazon Web Services Services](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_integrate_services.html) and [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html).
public struct CloudTrailAccessNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudTrailAccessNotEnabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudTrailAccessNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudTrailAccessNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailInvalidClientTokenIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudTrailInvalidClientTokenIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a call results in the InvalidClientTokenId error code. This can occur when you are creating or updating a trail to send notifications to an Amazon SNS topic that is in a suspended Amazon Web Services account.
public struct CloudTrailInvalidClientTokenIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudTrailInvalidClientTokenId" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudTrailInvalidClientTokenIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudTrailInvalidClientTokenIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchLogsDeliveryUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CloudWatchLogsDeliveryUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot set a CloudWatch Logs delivery for this Region.
public struct CloudWatchLogsDeliveryUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudWatchLogsDeliveryUnavailable" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CloudWatchLogsDeliveryUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CloudWatchLogsDeliveryUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified resource is not ready for an operation. This can occur when you try to run an operation on a resource before CloudTrail has time to fully load the resource, or because another operation is modifying the resource. If this exception occurs, wait a few minutes, and then try the operation again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
        case name = "Name"
        case source = "Source"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for destination0 in destinations {
                try destinationsContainer.encode(destination0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateChannelInput: Swift.Equatable {
    /// One or more event data stores to which events arriving through a channel will be logged.
    /// This member is required.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the partner or external event source. You cannot change this name after you create the channel. A maximum of one channel is allowed per source. A source can be either Custom for all valid non-Amazon Web Services events, or the name of a partner event source. For information about the source names for available partners, see [Additional information about integration partners](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-event-data-store-integration.html#cloudtrail-lake-partner-information) in the CloudTrail User Guide.
    /// This member is required.
    public var source: Swift.String?
    /// A list of tags.
    public var tags: [CloudTrailClientTypes.Tag]?

    public init(
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        name: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.destinations = destinations
        self.name = name
        self.source = source
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let name: Swift.String?
    let source: Swift.String?
    let destinations: [CloudTrailClientTypes.Destination]?
    let tags: [CloudTrailClientTypes.Tag]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
        case name = "Name"
        case source = "Source"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[CloudTrailClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [CloudTrailClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.destinations = output.destinations
            self.name = output.name
            self.source = output.source
            self.tags = output.tags
        } else {
            self.channelArn = nil
            self.destinations = nil
            self.name = nil
            self.source = nil
            self.tags = nil
        }
    }
}

public struct CreateChannelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new channel.
    public var channelArn: Swift.String?
    /// The event data stores that log the events arriving through the channel.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// The name of the new channel.
    public var name: Swift.String?
    /// The partner or external event source name.
    public var source: Swift.String?
    /// A list of tags.
    public var tags: [CloudTrailClientTypes.Tag]?

    public init(
        channelArn: Swift.String? = nil,
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        name: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.channelArn = channelArn
        self.destinations = destinations
        self.name = name
        self.source = source
        self.tags = tags
    }
}

struct CreateChannelOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let name: Swift.String?
    let source: Swift.String?
    let destinations: [CloudTrailClientTypes.Destination]?
    let tags: [CloudTrailClientTypes.Tag]?
}

extension CreateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case destinations = "Destinations"
        case name = "Name"
        case source = "Source"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[CloudTrailClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [CloudTrailClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ChannelAlreadyExists": return try await ChannelAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelMaxLimitExceeded": return try await ChannelMaxLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventDataStoreCategory": return try await InvalidEventDataStoreCategoryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSource": return try await InvalidSourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagParameter": return try await InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagsLimitExceeded": return try await TagsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case startIngestion = "StartIngestion"
        case tagsList = "TagsList"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let multiRegionEnabled = self.multiRegionEnabled {
            try encodeContainer.encode(multiRegionEnabled, forKey: .multiRegionEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationEnabled = self.organizationEnabled {
            try encodeContainer.encode(organizationEnabled, forKey: .organizationEnabled)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let startIngestion = self.startIngestion {
            try encodeContainer.encode(startIngestion, forKey: .startIngestion)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
        if let terminationProtectionEnabled = self.terminationProtectionEnabled {
            try encodeContainer.encode(terminationProtectionEnabled, forKey: .terminationProtectionEnabled)
        }
    }
}

extension CreateEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEventDataStoreInput: Swift.Equatable {
    /// The advanced event selectors to use to select the events for the data store. You can configure up to five advanced event selectors for each event data store. For more information about how to use advanced event selectors to log CloudTrail events, see [Log events by using advanced event selectors](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html#creating-data-event-selectors-advanced) in the CloudTrail User Guide. For more information about how to use advanced event selectors to include Config configuration items in your event data store, see [Create an event data store for Config configuration items](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-lake-cli.html#lake-cli-create-eds-config) in the CloudTrail User Guide. For more information about how to use advanced event selectors to include non-Amazon Web Services events in your event data store, see [Create an integration to log events from outside Amazon Web Services](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-lake-cli.html#lake-cli-create-integration) in the CloudTrail User Guide.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the KMS key ID to use to encrypt the events delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. Disabling or deleting the KMS key, or removing CloudTrail permissions on the key, prevents CloudTrail from logging events to the event data store, and prevents users from querying the data in the event data store that was encrypted with the key. After you associate an event data store with a KMS key, the KMS key cannot be removed or changed. Before you disable or delete a KMS key that you are using with an event data store, delete or back up your event data store. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether the event data store includes events from all Regions, or only from the Region in which the event data store is created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether an event data store collects events logged for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of the event data store, in days. You can set a retention period of up to 2557 days, the equivalent of seven years. CloudTrail Lake determines whether to retain an event by checking if the eventTime of the event is within the specified retention period. For example, if you set a retention period of 90 days, CloudTrail will remove events when the eventTime is older than 90 days. If you plan to copy trail events to this event data store, we recommend that you consider both the age of the events that you want to copy as well as how long you want to keep the copied events in your event data store. For example, if you copy trail events that are 5 years old and specify a retention period of 7 years, the event data store will retain those events for two years.
    public var retentionPeriod: Swift.Int?
    /// Specifies whether the event data store should start ingesting live events. The default is true.
    public var startIngestion: Swift.Bool?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?
    /// Specifies whether termination protection is enabled for the event data store. If termination protection is enabled, you cannot delete the event data store until termination protection is disabled.
    public var terminationProtectionEnabled: Swift.Bool?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        startIngestion: Swift.Bool? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.startIngestion = startIngestion
        self.tagsList = tagsList
        self.terminationProtectionEnabled = terminationProtectionEnabled
    }
}

struct CreateEventDataStoreInputBody: Swift.Equatable {
    let name: Swift.String?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let tagsList: [CloudTrailClientTypes.Tag]?
    let kmsKeyId: Swift.String?
    let startIngestion: Swift.Bool?
}

extension CreateEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case startIngestion = "StartIngestion"
        case tagsList = "TagsList"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let startIngestionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .startIngestion)
        startIngestion = startIngestionDecoded
    }
}

extension CreateEventDataStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEventDataStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.createdTimestamp = output.createdTimestamp
            self.eventDataStoreArn = output.eventDataStoreArn
            self.kmsKeyId = output.kmsKeyId
            self.multiRegionEnabled = output.multiRegionEnabled
            self.name = output.name
            self.organizationEnabled = output.organizationEnabled
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.tagsList = output.tagsList
            self.terminationProtectionEnabled = output.terminationProtectionEnabled
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.advancedEventSelectors = nil
            self.createdTimestamp = nil
            self.eventDataStoreArn = nil
            self.kmsKeyId = nil
            self.multiRegionEnabled = nil
            self.name = nil
            self.organizationEnabled = nil
            self.retentionPeriod = nil
            self.status = nil
            self.tagsList = nil
            self.terminationProtectionEnabled = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct CreateEventDataStoreOutput: Swift.Equatable {
    /// The advanced event selectors that were used to select the events for the data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The timestamp that shows when the event data store was created.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the event data store.
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store collects events from all Regions, or only from the Region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of an event data store, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of event data store creation.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?
    /// Indicates whether termination protection is enabled for the event data store.
    public var terminationProtectionEnabled: Swift.Bool?
    /// The timestamp that shows when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: ClientRuntime.Date?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.tagsList = tagsList
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

struct CreateEventDataStoreOutputBody: Swift.Equatable {
    let eventDataStoreArn: Swift.String?
    let name: Swift.String?
    let status: CloudTrailClientTypes.EventDataStoreStatus?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let tagsList: [CloudTrailClientTypes.Tag]?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
}

extension CreateEventDataStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case tagsList = "TagsList"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

enum CreateEventDataStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailAccessNotEnabled": return try await CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreAlreadyExists": return try await EventDataStoreAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreMaxLimitExceeded": return try await EventDataStoreMaxLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientEncryptionPolicy": return try await InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventSelectors": return try await InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidKmsKeyId": return try await InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagParameter": return try await InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsKeyNotFound": return try await KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotInAllFeaturesMode": return try await OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationsNotInUse": return try await OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = self.cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let enableLogFileValidation = self.enableLogFileValidation {
            try encodeContainer.encode(enableLogFileValidation, forKey: .enableLogFileValidation)
        }
        if let includeGlobalServiceEvents = self.includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = self.isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = self.isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicName = self.snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
    }
}

extension CreateTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies the settings for each trail.
public struct CreateTrailInput: Swift.Equatable {
    /// Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered. You must use a log group that exists in your account. Not required unless you specify CloudWatchLogsRoleArn.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group. You must use a role that exists in your account.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether log file integrity validation is enabled. The default is false. When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail does not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.
    public var enableLogFileValidation: Swift.Bool?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail is created in the current Region or in all Regions. The default is false, which creates a trail only in the Region where you are signed in. As a best practice, consider creating trails that log events in all Regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account. The default is false, and cannot be true unless the call is made on behalf of an Amazon Web Services account that is the management account or delegated administrator account for an organization in Organizations.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies the name of the trail. The name must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files. See [Amazon S3 Bucket Naming Requirements](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html).
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html). The maximum length is 200 characters.
    public var s3KeyPrefix: Swift.String?
    /// Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
    public var snsTopicName: Swift.String?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init(
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        enableLogFileValidation: Swift.Bool? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
        self.tagsList = tagsList
    }
}

struct CreateTrailInputBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let enableLogFileValidation: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
    let tagsList: [CloudTrailClientTypes.Tag]?
}

extension CreateTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
        case tagsList = "TagsList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let enableLogFileValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableLogFileValidation)
        enableLogFileValidation = enableLogFileValidationDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension CreateTrailOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTrailOutputBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogsLogGroupArn = output.cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = output.cloudWatchLogsRoleArn
            self.includeGlobalServiceEvents = output.includeGlobalServiceEvents
            self.isMultiRegionTrail = output.isMultiRegionTrail
            self.isOrganizationTrail = output.isOrganizationTrail
            self.kmsKeyId = output.kmsKeyId
            self.logFileValidationEnabled = output.logFileValidationEnabled
            self.name = output.name
            self.s3BucketName = output.s3BucketName
            self.s3KeyPrefix = output.s3KeyPrefix
            self.snsTopicARN = output.snsTopicARN
            self.snsTopicName = output.snsTopicName
            self.trailARN = output.trailARN
        } else {
            self.cloudWatchLogsLogGroupArn = nil
            self.cloudWatchLogsRoleArn = nil
            self.includeGlobalServiceEvents = nil
            self.isMultiRegionTrail = nil
            self.isOrganizationTrail = nil
            self.kmsKeyId = nil
            self.logFileValidationEnabled = nil
            self.name = nil
            self.s3BucketName = nil
            self.s3KeyPrefix = nil
            self.snsTopicARN = nil
            self.snsTopicName = nil
            self.trailARN = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct CreateTrailOutput: Swift.Equatable {
    /// Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs will be delivered.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail exists in one Region or in all Regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is an organization trail.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether log file integrity validation is enabled.
    public var logFileValidationEnabled: Swift.Bool?
    /// Specifies the name of the trail.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html).
    public var s3KeyPrefix: Swift.String?
    /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The format of a topic ARN is: arn:aws:sns:us-east-2:123456789012:MyTopic
    public var snsTopicARN: Swift.String?
    /// This field is no longer in use. Use SnsTopicARN.
    @available(*, deprecated)
    public var snsTopicName: Swift.String?
    /// Specifies the ARN of the trail that was created. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init(
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        logFileValidationEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicARN: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

struct CreateTrailOutputBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let snsTopicARN: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let trailARN: Swift.String?
    let logFileValidationEnabled: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
}

extension CreateTrailOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

enum CreateTrailOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailAccessNotEnabled": return try await CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudTrailInvalidClientTokenId": return try await CloudTrailInvalidClientTokenIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudWatchLogsDeliveryUnavailable": return try await CloudWatchLogsDeliveryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientEncryptionPolicy": return try await InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientS3BucketPolicy": return try await InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientSnsTopicPolicy": return try await InsufficientSnsTopicPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCloudWatchLogsLogGroupArn": return try await InvalidCloudWatchLogsLogGroupArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCloudWatchLogsRoleArn": return try await InvalidCloudWatchLogsRoleArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidKmsKeyId": return try await InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationError": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidS3BucketName": return try await InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidS3Prefix": return try await InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSnsTopicName": return try await InvalidSnsTopicNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagParameter": return try await InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsKeyDisabled": return try await KmsKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsKeyNotFound": return try await KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaximumNumberOfTrailsExceeded": return try await MaximumNumberOfTrailsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotInAllFeaturesMode": return try await OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationsNotInUse": return try await OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3BucketDoesNotExist": return try await S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagsLimitExceeded": return try await TagsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailAlreadyExists": return try await TrailAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotProvided": return try await TrailNotProvidedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudTrailClientTypes.DataResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CloudTrailClientTypes {
    /// The Amazon S3 buckets, Lambda functions, or Amazon DynamoDB tables that you specify in your event selectors for your trail to log data events. Data events provide information about the resource operations performed on or within a resource itself. These are also known as data plane operations. You can specify up to 250 data resources for a trail. The total number of allowed data resources is 250. This number can be distributed between 1 and 5 event selectors, but the total cannot exceed 250 across all selectors for the trail. If you are using advanced event selectors, the maximum total number of values for all conditions, across all advanced event selectors for the trail, is 500. The following example demonstrates how logging works when you configure logging of all data events for an S3 bucket named bucket-1. In this example, the CloudTrail user specified an empty prefix, and the option to log both Read and Write data events.
    ///
    /// * A user uploads an image file to bucket-1.
    ///
    /// * The PutObject API operation is an Amazon S3 object-level API. It is recorded as a data event in CloudTrail. Because the CloudTrail user specified an S3 bucket with an empty prefix, events that occur on any object in that bucket are logged. The trail processes and logs the event.
    ///
    /// * A user uploads an object to an Amazon S3 bucket named arn:aws:s3:::bucket-2.
    ///
    /// * The PutObject API operation occurred for an object in an S3 bucket that the CloudTrail user didn't specify for the trail. The trail doesn’t log the event.
    ///
    ///
    /// The following example demonstrates how logging works when you configure logging of Lambda data events for a Lambda function named MyLambdaFunction, but not for all Lambda functions.
    ///
    /// * A user runs a script that includes a call to the MyLambdaFunction function and the MyOtherLambdaFunction function.
    ///
    /// * The Invoke API operation on MyLambdaFunction is an Lambda API. It is recorded as a data event in CloudTrail. Because the CloudTrail user specified logging data events for MyLambdaFunction, any invocations of that function are logged. The trail processes and logs the event.
    ///
    /// * The Invoke API operation on MyOtherLambdaFunction is an Lambda API. Because the CloudTrail user did not specify logging data events for all Lambda functions, the Invoke operation for MyOtherLambdaFunction does not match the function specified for the trail. The trail doesn’t log the event.
    public struct DataResource: Swift.Equatable {
        /// The resource type in which you want to log data events. You can specify the following basic event selector resource types:
        ///
        /// * AWS::DynamoDB::Table
        ///
        /// * AWS::Lambda::Function
        ///
        /// * AWS::S3::Object
        ///
        ///
        /// The following resource types are also available through advanced event selectors. Basic event selector resource types are valid in advanced event selectors, but advanced event selector resource types are not valid in basic event selectors. For more information, see [AdvancedFieldSelector](https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_AdvancedFieldSelector.html).
        ///
        /// * AWS::CloudTrail::Channel
        ///
        /// * AWS::CodeWhisperer::Profile
        ///
        /// * AWS::Cognito::IdentityPool
        ///
        /// * AWS::DynamoDB::Stream
        ///
        /// * AWS::EC2::Snapshot
        ///
        /// * AWS::EMRWAL::Workspace
        ///
        /// * AWS::FinSpace::Environment
        ///
        /// * AWS::Glue::Table
        ///
        /// * AWS::GuardDuty::Detector
        ///
        /// * AWS::KendraRanking::ExecutionPlan
        ///
        /// * AWS::ManagedBlockchain::Network
        ///
        /// * AWS::ManagedBlockchain::Node
        ///
        /// * AWS::MedicalImaging::Datastore
        ///
        /// * AWS::SageMaker::ExperimentTrialComponent
        ///
        /// * AWS::SageMaker::FeatureGroup
        ///
        /// * AWS::S3::AccessPoint
        ///
        /// * AWS::S3ObjectLambda::AccessPoint
        ///
        /// * AWS::S3Outposts::Object
        ///
        /// * AWS::SSMMessages::ControlChannel
        ///
        /// * AWS::VerifiedPermissions::PolicyStore
        public var type: Swift.String?
        /// An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified objects.
        ///
        /// * To log data events for all objects in all S3 buckets in your Amazon Web Services account, specify the prefix as arn:aws:s3. This also enables logging of data event activity performed by any user or role in your Amazon Web Services account, even if that activity is performed on a bucket that belongs to another Amazon Web Services account.
        ///
        /// * To log data events for all objects in an S3 bucket, specify the bucket and an empty object prefix such as arn:aws:s3:::bucket-1/. The trail logs data events for all objects in this S3 bucket.
        ///
        /// * To log data events for specific objects, specify the S3 bucket and object prefix such as arn:aws:s3:::bucket-1/example-images. The trail logs data events for objects in this S3 bucket that match the prefix.
        ///
        /// * To log data events for all Lambda functions in your Amazon Web Services account, specify the prefix as arn:aws:lambda. This also enables logging of Invoke activity performed by any user or role in your Amazon Web Services account, even if that activity is performed on a function that belongs to another Amazon Web Services account.
        ///
        /// * To log data events for a specific Lambda function, specify the function ARN. Lambda function ARNs are exact. For example, if you specify a function ARN arn:aws:lambda:us-west-2:111111111111:function:helloworld, data events will only be logged for arn:aws:lambda:us-west-2:111111111111:function:helloworld. They will not be logged for arn:aws:lambda:us-west-2:111111111111:function:helloworld2.
        ///
        /// * To log data events for all DynamoDB tables in your Amazon Web Services account, specify the prefix as arn:aws:dynamodb.
        public var values: [Swift.String]?

        public init(
            type: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.type = type
            self.values = values
        }
    }

}

extension DelegatedAdminAccountLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DelegatedAdminAccountLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the maximum number of CloudTrail delegated administrators is reached.
public struct DelegatedAdminAccountLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DelegatedAdminAccountLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DelegatedAdminAccountLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DelegatedAdminAccountLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
    }
}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The ARN or the UUID value of the channel that you want to delete.
    /// This member is required.
    public var channel: Swift.String?

    public init(
        channel: Swift.String? = nil
    )
    {
        self.channel = channel
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
    let channel: Swift.String?
}

extension DeleteChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension DeleteChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ChannelARNInvalid": return try await ChannelARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelNotFound": return try await ChannelNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
    }
}

extension DeleteEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventDataStoreInput: Swift.Equatable {
    /// The ARN (or the ID suffix of the ARN) of the event data store to delete.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

struct DeleteEventDataStoreInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
}

extension DeleteEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
    }
}

extension DeleteEventDataStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEventDataStoreOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEventDataStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ChannelExistsForEDS": return try await ChannelExistsForEDSException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreHasOngoingImport": return try await EventDataStoreHasOngoingImportException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreTerminationProtectedException": return try await EventDataStoreTerminationProtectedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel you're deleting the resource-based policy from. The following is the format of a resource ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/MyChannel.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceARNNotValid": return try await ResourceARNNotValidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePolicyNotFound": return try await ResourcePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceTypeNotSupported": return try await ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request that specifies the name of a trail to delete.
public struct DeleteTrailInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail to be deleted. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteTrailInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTrailOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct DeleteTrailOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTrailOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidHomeRegion": return try await InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudTrailClientTypes {
    public enum DeliveryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case accessDeniedSigningFile
        case cancelled
        case failed
        case failedSigningFile
        case pending
        case resourceNotFound
        case success
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryStatus] {
            return [
                .accessDenied,
                .accessDeniedSigningFile,
                .cancelled,
                .failed,
                .failedSigningFile,
                .pending,
                .resourceNotFound,
                .success,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .accessDeniedSigningFile: return "ACCESS_DENIED_SIGNING_FILE"
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .failedSigningFile: return "FAILED_SIGNING_FILE"
            case .pending: return "PENDING"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .success: return "SUCCESS"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeliveryStatus(rawValue: rawValue) ?? DeliveryStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeregisterOrganizationDelegatedAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId = "DelegatedAdminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegatedAdminAccountId = self.delegatedAdminAccountId {
            try encodeContainer.encode(delegatedAdminAccountId, forKey: .delegatedAdminAccountId)
        }
    }
}

extension DeregisterOrganizationDelegatedAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Removes CloudTrail delegated administrator permissions from a specified member account in an organization that is currently designated as a delegated administrator.
public struct DeregisterOrganizationDelegatedAdminInput: Swift.Equatable {
    /// A delegated administrator account ID. This is a member account in an organization that is currently designated as a delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct DeregisterOrganizationDelegatedAdminInputBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
}

extension DeregisterOrganizationDelegatedAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId = "DelegatedAdminAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
    }
}

extension DeregisterOrganizationDelegatedAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Returns the following response if successful. Otherwise, returns an error.
public struct DeregisterOrganizationDelegatedAdminOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterOrganizationDelegatedAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccountNotFound": return try await AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AccountNotRegistered": return try await AccountNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudTrailAccessNotEnabled": return try await CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationManagementAccount": return try await NotOrganizationManagementAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotInAllFeaturesMode": return try await OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationsNotInUse": return try await OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case queryAlias = "QueryAlias"
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let queryAlias = self.queryAlias {
            try encodeContainer.encode(queryAlias, forKey: .queryAlias)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension DescribeQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeQueryInput: Swift.Equatable {
    /// The ARN (or the ID suffix of the ARN) of an event data store on which the specified query was run.
    @available(*, deprecated, message: "EventDataStore is no longer required by DescribeQueryRequest")
    public var eventDataStore: Swift.String?
    /// The alias that identifies a query template.
    public var queryAlias: Swift.String?
    /// The query ID.
    public var queryId: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil,
        queryAlias: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.queryAlias = queryAlias
        self.queryId = queryId
    }
}

struct DescribeQueryInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let queryId: Swift.String?
    let queryAlias: Swift.String?
}

extension DescribeQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case queryAlias = "QueryAlias"
        case queryId = "QueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryAlias)
        queryAlias = queryAliasDecoded
    }
}

extension DescribeQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.deliveryS3Uri = output.deliveryS3Uri
            self.deliveryStatus = output.deliveryStatus
            self.errorMessage = output.errorMessage
            self.queryId = output.queryId
            self.queryStatistics = output.queryStatistics
            self.queryStatus = output.queryStatus
            self.queryString = output.queryString
        } else {
            self.deliveryS3Uri = nil
            self.deliveryStatus = nil
            self.errorMessage = nil
            self.queryId = nil
            self.queryStatistics = nil
            self.queryStatus = nil
            self.queryString = nil
        }
    }
}

public struct DescribeQueryOutput: Swift.Equatable {
    /// The URI for the S3 bucket where CloudTrail delivered query results, if applicable.
    public var deliveryS3Uri: Swift.String?
    /// The delivery status.
    public var deliveryStatus: CloudTrailClientTypes.DeliveryStatus?
    /// The error message returned if a query failed.
    public var errorMessage: Swift.String?
    /// The ID of the query.
    public var queryId: Swift.String?
    /// Metadata about a query, including the number of events that were matched, the total number of events scanned, the query run time in milliseconds, and the query's creation time.
    public var queryStatistics: CloudTrailClientTypes.QueryStatisticsForDescribeQuery?
    /// The status of a query. Values for QueryStatus include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED
    public var queryStatus: CloudTrailClientTypes.QueryStatus?
    /// The SQL code of a query.
    public var queryString: Swift.String?

    public init(
        deliveryS3Uri: Swift.String? = nil,
        deliveryStatus: CloudTrailClientTypes.DeliveryStatus? = nil,
        errorMessage: Swift.String? = nil,
        queryId: Swift.String? = nil,
        queryStatistics: CloudTrailClientTypes.QueryStatisticsForDescribeQuery? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.deliveryS3Uri = deliveryS3Uri
        self.deliveryStatus = deliveryStatus
        self.errorMessage = errorMessage
        self.queryId = queryId
        self.queryStatistics = queryStatistics
        self.queryStatus = queryStatus
        self.queryString = queryString
    }
}

struct DescribeQueryOutputBody: Swift.Equatable {
    let queryId: Swift.String?
    let queryString: Swift.String?
    let queryStatus: CloudTrailClientTypes.QueryStatus?
    let queryStatistics: CloudTrailClientTypes.QueryStatisticsForDescribeQuery?
    let errorMessage: Swift.String?
    let deliveryS3Uri: Swift.String?
    let deliveryStatus: CloudTrailClientTypes.DeliveryStatus?
}

extension DescribeQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryS3Uri = "DeliveryS3Uri"
        case deliveryStatus = "DeliveryStatus"
        case errorMessage = "ErrorMessage"
        case queryId = "QueryId"
        case queryStatistics = "QueryStatistics"
        case queryStatus = "QueryStatus"
        case queryString = "QueryString"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
        let queryStatisticsDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatisticsForDescribeQuery.self, forKey: .queryStatistics)
        queryStatistics = queryStatisticsDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let deliveryS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3Uri)
        deliveryS3Uri = deliveryS3UriDecoded
        let deliveryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.DeliveryStatus.self, forKey: .deliveryStatus)
        deliveryStatus = deliveryStatusDecoded
    }
}

enum DescribeQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryIdNotFound": return try await QueryIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTrailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeShadowTrails
        case trailNameList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeShadowTrails = self.includeShadowTrails {
            try encodeContainer.encode(includeShadowTrails, forKey: .includeShadowTrails)
        }
        if let trailNameList = trailNameList {
            var trailNameListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trailNameList)
            for string0 in trailNameList {
                try trailNameListContainer.encode(string0)
            }
        }
    }
}

extension DescribeTrailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Returns information about the trail.
public struct DescribeTrailsInput: Swift.Equatable {
    /// Specifies whether to include shadow trails in the response. A shadow trail is the replication in a Region of a trail that was created in a different Region, or in the case of an organization trail, the replication of an organization trail in member accounts. If you do not include shadow trails, organization trails in a member account and Region replication trails will not be returned. The default is true.
    public var includeShadowTrails: Swift.Bool?
    /// Specifies a list of trail names, trail ARNs, or both, of the trails to describe. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail If an empty list is specified, information for the trail in the current Region is returned.
    ///
    /// * If an empty list is specified and IncludeShadowTrails is false, then information for all trails in the current Region is returned.
    ///
    /// * If an empty list is specified and IncludeShadowTrails is null or true, then information for all trails in the current Region and any associated shadow trails in other Regions is returned.
    ///
    ///
    /// If one or more trail names are specified, information is returned only if the names match the names of trails belonging only to the current Region and current account. To return information about a trail in another Region, you must specify its trail ARN.
    public var trailNameList: [Swift.String]?

    public init(
        includeShadowTrails: Swift.Bool? = nil,
        trailNameList: [Swift.String]? = nil
    )
    {
        self.includeShadowTrails = includeShadowTrails
        self.trailNameList = trailNameList
    }
}

struct DescribeTrailsInputBody: Swift.Equatable {
    let trailNameList: [Swift.String]?
    let includeShadowTrails: Swift.Bool?
}

extension DescribeTrailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeShadowTrails
        case trailNameList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trailNameList)
        var trailNameListDecoded0:[Swift.String]? = nil
        if let trailNameListContainer = trailNameListContainer {
            trailNameListDecoded0 = [Swift.String]()
            for string0 in trailNameListContainer {
                if let string0 = string0 {
                    trailNameListDecoded0?.append(string0)
                }
            }
        }
        trailNameList = trailNameListDecoded0
        let includeShadowTrailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeShadowTrails)
        includeShadowTrails = includeShadowTrailsDecoded
    }
}

extension DescribeTrailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTrailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.trailList = output.trailList
        } else {
            self.trailList = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct DescribeTrailsOutput: Swift.Equatable {
    /// The list of trail objects. Trail objects with string values are only returned if values for the objects exist in a trail's configuration. For example, SNSTopicName and SNSTopicARN are only returned in results if a trail is configured to send SNS notifications. Similarly, KMSKeyId only appears in results if a trail's log files are encrypted with KMS customer managed keys.
    public var trailList: [CloudTrailClientTypes.Trail]?

    public init(
        trailList: [CloudTrailClientTypes.Trail]? = nil
    )
    {
        self.trailList = trailList
    }
}

struct DescribeTrailsOutputBody: Swift.Equatable {
    let trailList: [CloudTrailClientTypes.Trail]?
}

extension DescribeTrailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Trail?].self, forKey: .trailList)
        var trailListDecoded0:[CloudTrailClientTypes.Trail]? = nil
        if let trailListContainer = trailListContainer {
            trailListDecoded0 = [CloudTrailClientTypes.Trail]()
            for structure0 in trailListContainer {
                if let structure0 = structure0 {
                    trailListDecoded0?.append(structure0)
                }
            }
        }
        trailList = trailListDecoded0
    }
}

enum DescribeTrailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudTrailClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location = "Location"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.DestinationType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about the destination receiving events.
    public struct Destination: Swift.Equatable {
        /// For channels used for a CloudTrail Lake integration, the location is the ARN of an event data store that receives events from a channel. For service-linked channels, the location is the name of the Amazon Web Services service.
        /// This member is required.
        public var location: Swift.String?
        /// The type of destination for events arriving from a channel. For channels used for a CloudTrail Lake integration, the value is EventDataStore. For service-linked channels, the value is AWS_SERVICE.
        /// This member is required.
        public var type: CloudTrailClientTypes.DestinationType?

        public init(
            location: Swift.String? = nil,
            type: CloudTrailClientTypes.DestinationType? = nil
        )
        {
            self.location = location
            self.type = type
        }
    }

}

extension CloudTrailClientTypes {
    public enum DestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsService
        case eventDataStore
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .awsService,
                .eventDataStore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsService: return "AWS_SERVICE"
            case .eventDataStore: return "EVENT_DATA_STORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationType(rawValue: rawValue) ?? DestinationType.sdkUnknown(rawValue)
        }
    }
}

extension CloudTrailClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case cloudTrailEvent = "CloudTrailEvent"
        case eventId = "EventId"
        case eventName = "EventName"
        case eventSource = "EventSource"
        case eventTime = "EventTime"
        case readOnly = "ReadOnly"
        case resources = "Resources"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let cloudTrailEvent = self.cloudTrailEvent {
            try encodeContainer.encode(cloudTrailEvent, forKey: .cloudTrailEvent)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventName = self.eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let eventSource = self.eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .epochSeconds, forKey: .eventTime)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[CloudTrailClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [CloudTrailClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let cloudTrailEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudTrailEvent)
        cloudTrailEvent = cloudTrailEventDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about an event that was returned by a lookup request. The result includes a representation of a CloudTrail event.
    public struct Event: Swift.Equatable {
        /// The Amazon Web Services access key ID that was used to sign the request. If the request was made with temporary security credentials, this is the access key ID of the temporary credentials.
        public var accessKeyId: Swift.String?
        /// A JSON string that contains a representation of the event returned.
        public var cloudTrailEvent: Swift.String?
        /// The CloudTrail ID of the event returned.
        public var eventId: Swift.String?
        /// The name of the event returned.
        public var eventName: Swift.String?
        /// The Amazon Web Services service to which the request was made.
        public var eventSource: Swift.String?
        /// The date and time of the event returned.
        public var eventTime: ClientRuntime.Date?
        /// Information about whether the event is a write event or a read event.
        public var readOnly: Swift.String?
        /// A list of resources referenced by the event returned.
        public var resources: [CloudTrailClientTypes.Resource]?
        /// A user name or role name of the requester that called the API in the event returned.
        public var username: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            cloudTrailEvent: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventName: Swift.String? = nil,
            eventSource: Swift.String? = nil,
            eventTime: ClientRuntime.Date? = nil,
            readOnly: Swift.String? = nil,
            resources: [CloudTrailClientTypes.Resource]? = nil,
            username: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.cloudTrailEvent = cloudTrailEvent
            self.eventId = eventId
            self.eventName = eventName
            self.eventSource = eventSource
            self.eventTime = eventTime
            self.readOnly = readOnly
            self.resources = resources
            self.username = username
        }
    }

}

extension CloudTrailClientTypes {
    public enum EventCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insight
        case sdkUnknown(Swift.String)

        public static var allCases: [EventCategory] {
            return [
                .insight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insight: return "insight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventCategory(rawValue: rawValue) ?? EventCategory.sdkUnknown(rawValue)
        }
    }
}

extension CloudTrailClientTypes.EventDataStore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let eventDataStoreArn = self.eventDataStoreArn {
            try encodeContainer.encode(eventDataStoreArn, forKey: .eventDataStoreArn)
        }
        if let multiRegionEnabled = self.multiRegionEnabled {
            try encodeContainer.encode(multiRegionEnabled, forKey: .multiRegionEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationEnabled = self.organizationEnabled {
            try encodeContainer.encode(organizationEnabled, forKey: .organizationEnabled)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let terminationProtectionEnabled = self.terminationProtectionEnabled {
            try encodeContainer.encode(terminationProtectionEnabled, forKey: .terminationProtectionEnabled)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .epochSeconds, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension CloudTrailClientTypes {
    /// A storage lake of event data against which you can run complex SQL-based queries. An event data store can include events that you have logged on your account from the last 90 to 2557 days (about three months to up to seven years). To select events for an event data store, use [advanced event selectors](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html#creating-data-event-selectors-advanced).
    public struct EventDataStore: Swift.Equatable {
        /// The advanced event selectors that were used to select events for the data store.
        @available(*, deprecated, message: "AdvancedEventSelectors is no longer returned by ListEventDataStores")
        public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
        /// The timestamp of the event data store's creation.
        @available(*, deprecated, message: "CreatedTimestamp is no longer returned by ListEventDataStores")
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the event data store.
        public var eventDataStoreArn: Swift.String?
        /// Indicates whether the event data store includes events from all Regions, or only from the Region in which it was created.
        @available(*, deprecated, message: "MultiRegionEnabled is no longer returned by ListEventDataStores")
        public var multiRegionEnabled: Swift.Bool?
        /// The name of the event data store.
        public var name: Swift.String?
        /// Indicates that an event data store is collecting logged events for an organization.
        @available(*, deprecated, message: "OrganizationEnabled is no longer returned by ListEventDataStores")
        public var organizationEnabled: Swift.Bool?
        /// The retention period, in days.
        @available(*, deprecated, message: "RetentionPeriod is no longer returned by ListEventDataStores")
        public var retentionPeriod: Swift.Int?
        /// The status of an event data store.
        @available(*, deprecated, message: "Status is no longer returned by ListEventDataStores")
        public var status: CloudTrailClientTypes.EventDataStoreStatus?
        /// Indicates whether the event data store is protected from termination.
        @available(*, deprecated, message: "TerminationProtectionEnabled is no longer returned by ListEventDataStores")
        public var terminationProtectionEnabled: Swift.Bool?
        /// The timestamp showing when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
        @available(*, deprecated, message: "UpdatedTimestamp is no longer returned by ListEventDataStores")
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            eventDataStoreArn: Swift.String? = nil,
            multiRegionEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            organizationEnabled: Swift.Bool? = nil,
            retentionPeriod: Swift.Int? = nil,
            status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
            terminationProtectionEnabled: Swift.Bool? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.advancedEventSelectors = advancedEventSelectors
            self.createdTimestamp = createdTimestamp
            self.eventDataStoreArn = eventDataStoreArn
            self.multiRegionEnabled = multiRegionEnabled
            self.name = name
            self.organizationEnabled = organizationEnabled
            self.retentionPeriod = retentionPeriod
            self.status = status
            self.terminationProtectionEnabled = terminationProtectionEnabled
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension EventDataStoreARNInvalidException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EventDataStoreARNInvalidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified event data store ARN is not valid or does not map to an event data store in your account.
public struct EventDataStoreARNInvalidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreARNInvalid" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EventDataStoreARNInvalidExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreARNInvalidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventDataStoreAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EventDataStoreAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An event data store with that name already exists.
public struct EventDataStoreAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EventDataStoreAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventDataStoreHasOngoingImportException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EventDataStoreHasOngoingImportExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when you try to update or delete an event data store that currently has an import in progress.
public struct EventDataStoreHasOngoingImportException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreHasOngoingImport" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EventDataStoreHasOngoingImportExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreHasOngoingImportExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventDataStoreMaxLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EventDataStoreMaxLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your account has used the maximum number of event data stores.
public struct EventDataStoreMaxLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreMaxLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EventDataStoreMaxLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreMaxLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventDataStoreNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EventDataStoreNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified event data store was not found.
public struct EventDataStoreNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EventDataStoreNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes {
    public enum EventDataStoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case enabled
        case pendingDeletion
        case startingIngestion
        case stoppedIngestion
        case stoppingIngestion
        case sdkUnknown(Swift.String)

        public static var allCases: [EventDataStoreStatus] {
            return [
                .created,
                .enabled,
                .pendingDeletion,
                .startingIngestion,
                .stoppedIngestion,
                .stoppingIngestion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .enabled: return "ENABLED"
            case .pendingDeletion: return "PENDING_DELETION"
            case .startingIngestion: return "STARTING_INGESTION"
            case .stoppedIngestion: return "STOPPED_INGESTION"
            case .stoppingIngestion: return "STOPPING_INGESTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventDataStoreStatus(rawValue: rawValue) ?? EventDataStoreStatus.sdkUnknown(rawValue)
        }
    }
}

extension EventDataStoreTerminationProtectedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EventDataStoreTerminationProtectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The event data store cannot be deleted because termination protection is enabled for it.
public struct EventDataStoreTerminationProtectedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreTerminationProtectedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EventDataStoreTerminationProtectedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EventDataStoreTerminationProtectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.EventSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataResources = "DataResources"
        case excludeManagementEventSources = "ExcludeManagementEventSources"
        case includeManagementEvents = "IncludeManagementEvents"
        case readWriteType = "ReadWriteType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataResources = dataResources {
            var dataResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataResources)
            for dataresource0 in dataResources {
                try dataResourcesContainer.encode(dataresource0)
            }
        }
        if let excludeManagementEventSources = excludeManagementEventSources {
            var excludeManagementEventSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeManagementEventSources)
            for string0 in excludeManagementEventSources {
                try excludeManagementEventSourcesContainer.encode(string0)
            }
        }
        if let includeManagementEvents = self.includeManagementEvents {
            try encodeContainer.encode(includeManagementEvents, forKey: .includeManagementEvents)
        }
        if let readWriteType = self.readWriteType {
            try encodeContainer.encode(readWriteType.rawValue, forKey: .readWriteType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readWriteTypeDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ReadWriteType.self, forKey: .readWriteType)
        readWriteType = readWriteTypeDecoded
        let includeManagementEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeManagementEvents)
        includeManagementEvents = includeManagementEventsDecoded
        let dataResourcesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.DataResource?].self, forKey: .dataResources)
        var dataResourcesDecoded0:[CloudTrailClientTypes.DataResource]? = nil
        if let dataResourcesContainer = dataResourcesContainer {
            dataResourcesDecoded0 = [CloudTrailClientTypes.DataResource]()
            for structure0 in dataResourcesContainer {
                if let structure0 = structure0 {
                    dataResourcesDecoded0?.append(structure0)
                }
            }
        }
        dataResources = dataResourcesDecoded0
        let excludeManagementEventSourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludeManagementEventSources)
        var excludeManagementEventSourcesDecoded0:[Swift.String]? = nil
        if let excludeManagementEventSourcesContainer = excludeManagementEventSourcesContainer {
            excludeManagementEventSourcesDecoded0 = [Swift.String]()
            for string0 in excludeManagementEventSourcesContainer {
                if let string0 = string0 {
                    excludeManagementEventSourcesDecoded0?.append(string0)
                }
            }
        }
        excludeManagementEventSources = excludeManagementEventSourcesDecoded0
    }
}

extension CloudTrailClientTypes {
    /// Use event selectors to further specify the management and data event settings for your trail. By default, trails created without specific event selectors will be configured to log all read and write management events, and no data events. When an event occurs in your account, CloudTrail evaluates the event selector for all trails. For each trail, if the event matches any event selector, the trail processes and logs the event. If the event doesn't match any event selector, the trail doesn't log the event. You can configure up to five event selectors for a trail. You cannot apply both event selectors and advanced event selectors to a trail.
    public struct EventSelector: Swift.Equatable {
        /// CloudTrail supports data event logging for Amazon S3 objects, Lambda functions, and Amazon DynamoDB tables with basic event selectors. You can specify up to 250 resources for an individual event selector, but the total number of data resources cannot exceed 250 across all event selectors in a trail. This limit does not apply if you configure resource logging for all data events. For more information, see [Data Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) and [Limits in CloudTrail](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/WhatIsCloudTrail-Limits.html) in the CloudTrail User Guide.
        public var dataResources: [CloudTrailClientTypes.DataResource]?
        /// An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out Key Management Service or Amazon RDS Data API events by containing kms.amazonaws.com or rdsdata.amazonaws.com. By default, ExcludeManagementEventSources is empty, and KMS and Amazon RDS Data API events are logged to your trail. You can exclude management event sources only in Regions that support the event source.
        public var excludeManagementEventSources: [Swift.String]?
        /// Specify if you want your event selector to include management events for your trail. For more information, see [Management Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-management-events-with-cloudtrail.html) in the CloudTrail User Guide. By default, the value is true. The first copy of management events is free. You are charged for additional copies of management events that you are logging on any subsequent trail in the same Region. For more information about CloudTrail pricing, see [CloudTrail Pricing](http://aws.amazon.com/cloudtrail/pricing/).
        public var includeManagementEvents: Swift.Bool?
        /// Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation. By default, the value is All.
        public var readWriteType: CloudTrailClientTypes.ReadWriteType?

        public init(
            dataResources: [CloudTrailClientTypes.DataResource]? = nil,
            excludeManagementEventSources: [Swift.String]? = nil,
            includeManagementEvents: Swift.Bool? = nil,
            readWriteType: CloudTrailClientTypes.ReadWriteType? = nil
        )
        {
            self.dataResources = dataResources
            self.excludeManagementEventSources = excludeManagementEventSources
            self.includeManagementEvents = includeManagementEvents
            self.readWriteType = readWriteType
        }
    }

}

extension GetChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
    }
}

extension GetChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetChannelInput: Swift.Equatable {
    /// The ARN or UUID of a channel.
    /// This member is required.
    public var channel: Swift.String?

    public init(
        channel: Swift.String? = nil
    )
    {
        self.channel = channel
    }
}

struct GetChannelInputBody: Swift.Equatable {
    let channel: Swift.String?
}

extension GetChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension GetChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.destinations = output.destinations
            self.ingestionStatus = output.ingestionStatus
            self.name = output.name
            self.source = output.source
            self.sourceConfig = output.sourceConfig
        } else {
            self.channelArn = nil
            self.destinations = nil
            self.ingestionStatus = nil
            self.name = nil
            self.source = nil
            self.sourceConfig = nil
        }
    }
}

public struct GetChannelOutput: Swift.Equatable {
    /// The ARN of an channel returned by a GetChannel request.
    public var channelArn: Swift.String?
    /// The destinations for the channel. For channels created for integrations, the destinations are the event data stores that log events arriving through the channel. For service-linked channels, the destination is the Amazon Web Services service that created the service-linked channel to receive events.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// A table showing information about the most recent successful and failed attempts to ingest events.
    public var ingestionStatus: CloudTrailClientTypes.IngestionStatus?
    /// The name of the CloudTrail channel. For service-linked channels, the name is aws-service-channel/service-name/custom-suffix where service-name represents the name of the Amazon Web Services service that created the channel and custom-suffix represents the suffix generated by the Amazon Web Services service.
    public var name: Swift.String?
    /// The source for the CloudTrail channel.
    public var source: Swift.String?
    /// Provides information about the advanced event selectors configured for the channel, and whether the channel applies to all Regions or a single Region.
    public var sourceConfig: CloudTrailClientTypes.SourceConfig?

    public init(
        channelArn: Swift.String? = nil,
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        ingestionStatus: CloudTrailClientTypes.IngestionStatus? = nil,
        name: Swift.String? = nil,
        source: Swift.String? = nil,
        sourceConfig: CloudTrailClientTypes.SourceConfig? = nil
    )
    {
        self.channelArn = channelArn
        self.destinations = destinations
        self.ingestionStatus = ingestionStatus
        self.name = name
        self.source = source
        self.sourceConfig = sourceConfig
    }
}

struct GetChannelOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let name: Swift.String?
    let source: Swift.String?
    let sourceConfig: CloudTrailClientTypes.SourceConfig?
    let destinations: [CloudTrailClientTypes.Destination]?
    let ingestionStatus: CloudTrailClientTypes.IngestionStatus?
}

extension GetChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case destinations = "Destinations"
        case ingestionStatus = "IngestionStatus"
        case name = "Name"
        case source = "Source"
        case sourceConfig = "SourceConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let sourceConfigDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.SourceConfig.self, forKey: .sourceConfig)
        sourceConfig = sourceConfigDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[CloudTrailClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [CloudTrailClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let ingestionStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.IngestionStatus.self, forKey: .ingestionStatus)
        ingestionStatus = ingestionStatusDecoded
    }
}

enum GetChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ChannelARNInvalid": return try await ChannelARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelNotFound": return try await ChannelNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
    }
}

extension GetEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEventDataStoreInput: Swift.Equatable {
    /// The ARN (or ID suffix of the ARN) of the event data store about which you want information.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

struct GetEventDataStoreInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
}

extension GetEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
    }
}

extension GetEventDataStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventDataStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.createdTimestamp = output.createdTimestamp
            self.eventDataStoreArn = output.eventDataStoreArn
            self.kmsKeyId = output.kmsKeyId
            self.multiRegionEnabled = output.multiRegionEnabled
            self.name = output.name
            self.organizationEnabled = output.organizationEnabled
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.terminationProtectionEnabled = output.terminationProtectionEnabled
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.advancedEventSelectors = nil
            self.createdTimestamp = nil
            self.eventDataStoreArn = nil
            self.kmsKeyId = nil
            self.multiRegionEnabled = nil
            self.name = nil
            self.organizationEnabled = nil
            self.retentionPeriod = nil
            self.status = nil
            self.terminationProtectionEnabled = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct GetEventDataStoreOutput: Swift.Equatable {
    /// The advanced event selectors used to select events for the data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The timestamp of the event data store's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The event data store Amazon Resource Number (ARN).
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store includes events from all Regions, or only from the Region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of the event data store, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of an event data store.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// Indicates that termination protection is enabled.
    public var terminationProtectionEnabled: Swift.Bool?
    /// Shows the time that an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: ClientRuntime.Date?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

struct GetEventDataStoreOutputBody: Swift.Equatable {
    let eventDataStoreArn: Swift.String?
    let name: Swift.String?
    let status: CloudTrailClientTypes.EventDataStoreStatus?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
}

extension GetEventDataStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

enum GetEventDataStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trailName = self.trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension GetEventSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEventSelectorsInput: Swift.Equatable {
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init(
        trailName: Swift.String? = nil
    )
    {
        self.trailName = trailName
    }
}

struct GetEventSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
}

extension GetEventSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
    }
}

extension GetEventSelectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventSelectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.eventSelectors = output.eventSelectors
            self.trailARN = output.trailARN
        } else {
            self.advancedEventSelectors = nil
            self.eventSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct GetEventSelectorsOutput: Swift.Equatable {
    /// The advanced event selectors that are configured for the trail.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The event selectors that are configured for the trail.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// The specified trail ARN that has the event selectors.
    public var trailARN: Swift.String?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

struct GetEventSelectorsOutputBody: Swift.Equatable {
    let trailARN: Swift.String?
    let eventSelectors: [CloudTrailClientTypes.EventSelector]?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
}

extension GetEventSelectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailARN = "TrailARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[CloudTrailClientTypes.EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [CloudTrailClientTypes.EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

enum GetEventSelectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
    }
}

extension GetImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetImportInput: Swift.Equatable {
    /// The ID for the import.
    /// This member is required.
    public var importId: Swift.String?

    public init(
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

struct GetImportInputBody: Swift.Equatable {
    let importId: Swift.String?
}

extension GetImportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

extension GetImportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImportOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.destinations = output.destinations
            self.endEventTime = output.endEventTime
            self.importId = output.importId
            self.importSource = output.importSource
            self.importStatistics = output.importStatistics
            self.importStatus = output.importStatus
            self.startEventTime = output.startEventTime
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.createdTimestamp = nil
            self.destinations = nil
            self.endEventTime = nil
            self.importId = nil
            self.importSource = nil
            self.importStatistics = nil
            self.importStatus = nil
            self.startEventTime = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct GetImportOutput: Swift.Equatable {
    /// The timestamp of the import's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the destination event data store.
    public var destinations: [Swift.String]?
    /// Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var endEventTime: ClientRuntime.Date?
    /// The ID of the import.
    public var importId: Swift.String?
    /// The source S3 bucket.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Provides statistics for the import. CloudTrail does not update import statistics in real-time. Returned values for parameters such as EventsCompleted may be lower than the actual value, because CloudTrail updates statistics incrementally over the course of the import.
    public var importStatistics: CloudTrailClientTypes.ImportStatistics?
    /// The status of the import.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var startEventTime: ClientRuntime.Date?
    /// The timestamp of when the import was updated.
    public var updatedTimestamp: ClientRuntime.Date?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        destinations: [Swift.String]? = nil,
        endEventTime: ClientRuntime.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        importStatistics: CloudTrailClientTypes.ImportStatistics? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        startEventTime: ClientRuntime.Date? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.importStatistics = importStatistics
        self.importStatus = importStatus
        self.startEventTime = startEventTime
        self.updatedTimestamp = updatedTimestamp
    }
}

struct GetImportOutputBody: Swift.Equatable {
    let importId: Swift.String?
    let destinations: [Swift.String]?
    let importSource: CloudTrailClientTypes.ImportSource?
    let startEventTime: ClientRuntime.Date?
    let endEventTime: ClientRuntime.Date?
    let importStatus: CloudTrailClientTypes.ImportStatus?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let importStatistics: CloudTrailClientTypes.ImportStatistics?
}

extension GetImportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case importStatistics = "ImportStatistics"
        case importStatus = "ImportStatus"
        case startEventTime = "StartEventTime"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let importSourceDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportSource.self, forKey: .importSource)
        importSource = importSourceDecoded
        let startEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startEventTime)
        startEventTime = startEventTimeDecoded
        let endEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endEventTime)
        endEventTime = endEventTimeDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let importStatisticsDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatistics.self, forKey: .importStatistics)
        importStatistics = importStatisticsDecoded
    }
}

enum GetImportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ImportNotFound": return try await ImportNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInsightSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trailName = self.trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension GetInsightSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInsightSelectorsInput: Swift.Equatable {
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init(
        trailName: Swift.String? = nil
    )
    {
        self.trailName = trailName
    }
}

struct GetInsightSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
}

extension GetInsightSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trailName = "TrailName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
    }
}

extension GetInsightSelectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInsightSelectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.insightSelectors = output.insightSelectors
            self.trailARN = output.trailARN
        } else {
            self.insightSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct GetInsightSelectorsOutput: Swift.Equatable {
    /// A JSON string that contains the insight types you want to log on a trail. In this release, ApiErrorRateInsight and ApiCallRateInsight are supported as insight types.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The Amazon Resource Name (ARN) of a trail for which you want to get Insights selectors.
    public var trailARN: Swift.String?

    public init(
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailARN = trailARN
    }
}

struct GetInsightSelectorsOutputBody: Swift.Equatable {
    let trailARN: Swift.String?
    let insightSelectors: [CloudTrailClientTypes.InsightSelector]?
}

extension GetInsightSelectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailARN = "TrailARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[CloudTrailClientTypes.InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [CloudTrailClientTypes.InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

enum GetInsightSelectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsightNotEnabled": return try await InsightNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetQueryResultsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case maxQueryResults = "MaxQueryResults"
        case nextToken = "NextToken"
        case queryId = "QueryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let maxQueryResults = self.maxQueryResults {
            try encodeContainer.encode(maxQueryResults, forKey: .maxQueryResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
    }
}

extension GetQueryResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetQueryResultsInput: Swift.Equatable {
    /// The ARN (or ID suffix of the ARN) of the event data store against which the query was run.
    @available(*, deprecated, message: "EventDataStore is no longer required by GetQueryResultsRequest")
    public var eventDataStore: Swift.String?
    /// The maximum number of query results to display on a single page.
    public var maxQueryResults: Swift.Int?
    /// A token you can use to get the next page of query results.
    public var nextToken: Swift.String?
    /// The ID of the query for which you want to get results.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil,
        maxQueryResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.maxQueryResults = maxQueryResults
        self.nextToken = nextToken
        self.queryId = queryId
    }
}

struct GetQueryResultsInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let queryId: Swift.String?
    let nextToken: Swift.String?
    let maxQueryResults: Swift.Int?
}

extension GetQueryResultsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
        case maxQueryResults = "MaxQueryResults"
        case nextToken = "NextToken"
        case queryId = "QueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxQueryResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxQueryResults)
        maxQueryResults = maxQueryResultsDecoded
    }
}

extension GetQueryResultsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetQueryResultsOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorMessage = output.errorMessage
            self.nextToken = output.nextToken
            self.queryResultRows = output.queryResultRows
            self.queryStatistics = output.queryStatistics
            self.queryStatus = output.queryStatus
        } else {
            self.errorMessage = nil
            self.nextToken = nil
            self.queryResultRows = nil
            self.queryStatistics = nil
            self.queryStatus = nil
        }
    }
}

public struct GetQueryResultsOutput: Swift.Equatable {
    /// The error message returned if a query failed.
    public var errorMessage: Swift.String?
    /// A token you can use to get the next page of query results.
    public var nextToken: Swift.String?
    /// Contains the individual event results of the query.
    public var queryResultRows: [[[Swift.String:Swift.String]]]?
    /// Shows the count of query results.
    public var queryStatistics: CloudTrailClientTypes.QueryStatistics?
    /// The status of the query. Values include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.
    public var queryStatus: CloudTrailClientTypes.QueryStatus?

    public init(
        errorMessage: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        queryResultRows: [[[Swift.String:Swift.String]]]? = nil,
        queryStatistics: CloudTrailClientTypes.QueryStatistics? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil
    )
    {
        self.errorMessage = errorMessage
        self.nextToken = nextToken
        self.queryResultRows = queryResultRows
        self.queryStatistics = queryStatistics
        self.queryStatus = queryStatus
    }
}

struct GetQueryResultsOutputBody: Swift.Equatable {
    let queryStatus: CloudTrailClientTypes.QueryStatus?
    let queryStatistics: CloudTrailClientTypes.QueryStatistics?
    let queryResultRows: [[[Swift.String:Swift.String]]]?
    let nextToken: Swift.String?
    let errorMessage: Swift.String?
}

extension GetQueryResultsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case nextToken = "NextToken"
        case queryResultRows = "QueryResultRows"
        case queryStatistics = "QueryStatistics"
        case queryStatus = "QueryStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
        let queryStatisticsDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatistics.self, forKey: .queryStatistics)
        queryStatistics = queryStatisticsDecoded
        let queryResultRowsContainer = try containerValues.decodeIfPresent([[[Swift.String: Swift.String?]?]?].self, forKey: .queryResultRows)
        var queryResultRowsDecoded0:[[[Swift.String:Swift.String]]]? = nil
        if let queryResultRowsContainer = queryResultRowsContainer {
            queryResultRowsDecoded0 = [[[Swift.String:Swift.String]]]()
            for list0 in queryResultRowsContainer {
                var list0Decoded0: [[Swift.String: Swift.String]]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [[Swift.String: Swift.String]]()
                    for map1 in list0 {
                        var list0Decoded1: [Swift.String: Swift.String]? = nil
                        if let map1 = map1 {
                            list0Decoded1 = [Swift.String: Swift.String]()
                            for (key2, queryresultvalue2) in map1 {
                                if let queryresultvalue2 = queryresultvalue2 {
                                    list0Decoded1?[key2] = queryresultvalue2
                                }
                            }
                        }
                        if let list0Decoded1 = list0Decoded1 {
                            list0Decoded0?.append(list0Decoded1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    queryResultRowsDecoded0?.append(list0Decoded0)
                }
            }
        }
        queryResultRows = queryResultRowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

enum GetQueryResultsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientEncryptionPolicy": return try await InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResults": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "QueryIdNotFound": return try await QueryIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel attached to the resource-based policy. The following is the format of a resource ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/MyChannel.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension GetResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.resourceArn = nil
            self.resourcePolicy = nil
        }
    }
}

public struct GetResourcePolicyOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel attached to resource-based policy.
    public var resourceArn: Swift.String?
    /// A JSON-formatted string that contains the resource-based policy attached to the CloudTrail channel.
    public var resourcePolicy: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourcePolicy = resourcePolicy
    }
}

struct GetResourcePolicyOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourcePolicy: Swift.String?
}

extension GetResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourcePolicy = "ResourcePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

enum GetResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceARNNotValid": return try await ResourceARNNotValidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePolicyNotFound": return try await ResourcePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceTypeNotSupported": return try await ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTrailInput: Swift.Equatable {
    /// The name or the Amazon Resource Name (ARN) of the trail for which you want to retrieve settings information.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetTrailInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTrailOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTrailOutputBody = try responseDecoder.decode(responseBody: data)
            self.trail = output.trail
        } else {
            self.trail = nil
        }
    }
}

public struct GetTrailOutput: Swift.Equatable {
    /// The settings for a trail.
    public var trail: CloudTrailClientTypes.Trail?

    public init(
        trail: CloudTrailClientTypes.Trail? = nil
    )
    {
        self.trail = trail
    }
}

struct GetTrailOutputBody: Swift.Equatable {
    let trail: CloudTrailClientTypes.Trail?
}

extension GetTrailOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trail = "Trail"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.Trail.self, forKey: .trail)
        trail = trailDecoded
    }
}

enum GetTrailOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTrailStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetTrailStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The name of a trail about which you want the current status.
public struct GetTrailStatusInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail for which you are requesting status. To get the status of a shadow trail (a replication of the trail in another Region), you must specify its ARN. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetTrailStatusInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetTrailStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTrailStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTrailStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.isLogging = output.isLogging
            self.latestCloudWatchLogsDeliveryError = output.latestCloudWatchLogsDeliveryError
            self.latestCloudWatchLogsDeliveryTime = output.latestCloudWatchLogsDeliveryTime
            self.latestDeliveryAttemptSucceeded = output.latestDeliveryAttemptSucceeded
            self.latestDeliveryAttemptTime = output.latestDeliveryAttemptTime
            self.latestDeliveryError = output.latestDeliveryError
            self.latestDeliveryTime = output.latestDeliveryTime
            self.latestDigestDeliveryError = output.latestDigestDeliveryError
            self.latestDigestDeliveryTime = output.latestDigestDeliveryTime
            self.latestNotificationAttemptSucceeded = output.latestNotificationAttemptSucceeded
            self.latestNotificationAttemptTime = output.latestNotificationAttemptTime
            self.latestNotificationError = output.latestNotificationError
            self.latestNotificationTime = output.latestNotificationTime
            self.startLoggingTime = output.startLoggingTime
            self.stopLoggingTime = output.stopLoggingTime
            self.timeLoggingStarted = output.timeLoggingStarted
            self.timeLoggingStopped = output.timeLoggingStopped
        } else {
            self.isLogging = nil
            self.latestCloudWatchLogsDeliveryError = nil
            self.latestCloudWatchLogsDeliveryTime = nil
            self.latestDeliveryAttemptSucceeded = nil
            self.latestDeliveryAttemptTime = nil
            self.latestDeliveryError = nil
            self.latestDeliveryTime = nil
            self.latestDigestDeliveryError = nil
            self.latestDigestDeliveryTime = nil
            self.latestNotificationAttemptSucceeded = nil
            self.latestNotificationAttemptTime = nil
            self.latestNotificationError = nil
            self.latestNotificationTime = nil
            self.startLoggingTime = nil
            self.stopLoggingTime = nil
            self.timeLoggingStarted = nil
            self.timeLoggingStopped = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct GetTrailStatusOutput: Swift.Equatable {
    /// Whether the CloudTrail trail is currently logging Amazon Web Services API calls.
    public var isLogging: Swift.Bool?
    /// Displays any CloudWatch Logs error that CloudTrail encountered when attempting to deliver logs to CloudWatch Logs.
    public var latestCloudWatchLogsDeliveryError: Swift.String?
    /// Displays the most recent date and time when CloudTrail delivered logs to CloudWatch Logs.
    public var latestCloudWatchLogsDeliveryTime: ClientRuntime.Date?
    /// This field is no longer in use.
    public var latestDeliveryAttemptSucceeded: Swift.String?
    /// This field is no longer in use.
    public var latestDeliveryAttemptTime: Swift.String?
    /// Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver log files to the designated bucket. For more information, see [Error Responses](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html) in the Amazon S3 API Reference. This error occurs only when there is a problem with the destination S3 bucket, and does not occur for requests that time out. To resolve the issue, create a new bucket, and then call UpdateTrail to specify the new bucket; or fix the existing objects so that CloudTrail can again write to the bucket.
    public var latestDeliveryError: Swift.String?
    /// Specifies the date and time that CloudTrail last delivered log files to an account's Amazon S3 bucket.
    public var latestDeliveryTime: ClientRuntime.Date?
    /// Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver a digest file to the designated bucket. For more information, see [Error Responses](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html) in the Amazon S3 API Reference. This error occurs only when there is a problem with the destination S3 bucket, and does not occur for requests that time out. To resolve the issue, create a new bucket, and then call UpdateTrail to specify the new bucket; or fix the existing objects so that CloudTrail can again write to the bucket.
    public var latestDigestDeliveryError: Swift.String?
    /// Specifies the date and time that CloudTrail last delivered a digest file to an account's Amazon S3 bucket.
    public var latestDigestDeliveryTime: ClientRuntime.Date?
    /// This field is no longer in use.
    public var latestNotificationAttemptSucceeded: Swift.String?
    /// This field is no longer in use.
    public var latestNotificationAttemptTime: Swift.String?
    /// Displays any Amazon SNS error that CloudTrail encountered when attempting to send a notification. For more information about Amazon SNS errors, see the [Amazon SNS Developer Guide](https://docs.aws.amazon.com/sns/latest/dg/welcome.html).
    public var latestNotificationError: Swift.String?
    /// Specifies the date and time of the most recent Amazon SNS notification that CloudTrail has written a new log file to an account's Amazon S3 bucket.
    public var latestNotificationTime: ClientRuntime.Date?
    /// Specifies the most recent date and time when CloudTrail started recording API calls for an Amazon Web Services account.
    public var startLoggingTime: ClientRuntime.Date?
    /// Specifies the most recent date and time when CloudTrail stopped recording API calls for an Amazon Web Services account.
    public var stopLoggingTime: ClientRuntime.Date?
    /// This field is no longer in use.
    public var timeLoggingStarted: Swift.String?
    /// This field is no longer in use.
    public var timeLoggingStopped: Swift.String?

    public init(
        isLogging: Swift.Bool? = nil,
        latestCloudWatchLogsDeliveryError: Swift.String? = nil,
        latestCloudWatchLogsDeliveryTime: ClientRuntime.Date? = nil,
        latestDeliveryAttemptSucceeded: Swift.String? = nil,
        latestDeliveryAttemptTime: Swift.String? = nil,
        latestDeliveryError: Swift.String? = nil,
        latestDeliveryTime: ClientRuntime.Date? = nil,
        latestDigestDeliveryError: Swift.String? = nil,
        latestDigestDeliveryTime: ClientRuntime.Date? = nil,
        latestNotificationAttemptSucceeded: Swift.String? = nil,
        latestNotificationAttemptTime: Swift.String? = nil,
        latestNotificationError: Swift.String? = nil,
        latestNotificationTime: ClientRuntime.Date? = nil,
        startLoggingTime: ClientRuntime.Date? = nil,
        stopLoggingTime: ClientRuntime.Date? = nil,
        timeLoggingStarted: Swift.String? = nil,
        timeLoggingStopped: Swift.String? = nil
    )
    {
        self.isLogging = isLogging
        self.latestCloudWatchLogsDeliveryError = latestCloudWatchLogsDeliveryError
        self.latestCloudWatchLogsDeliveryTime = latestCloudWatchLogsDeliveryTime
        self.latestDeliveryAttemptSucceeded = latestDeliveryAttemptSucceeded
        self.latestDeliveryAttemptTime = latestDeliveryAttemptTime
        self.latestDeliveryError = latestDeliveryError
        self.latestDeliveryTime = latestDeliveryTime
        self.latestDigestDeliveryError = latestDigestDeliveryError
        self.latestDigestDeliveryTime = latestDigestDeliveryTime
        self.latestNotificationAttemptSucceeded = latestNotificationAttemptSucceeded
        self.latestNotificationAttemptTime = latestNotificationAttemptTime
        self.latestNotificationError = latestNotificationError
        self.latestNotificationTime = latestNotificationTime
        self.startLoggingTime = startLoggingTime
        self.stopLoggingTime = stopLoggingTime
        self.timeLoggingStarted = timeLoggingStarted
        self.timeLoggingStopped = timeLoggingStopped
    }
}

struct GetTrailStatusOutputBody: Swift.Equatable {
    let isLogging: Swift.Bool?
    let latestDeliveryError: Swift.String?
    let latestNotificationError: Swift.String?
    let latestDeliveryTime: ClientRuntime.Date?
    let latestNotificationTime: ClientRuntime.Date?
    let startLoggingTime: ClientRuntime.Date?
    let stopLoggingTime: ClientRuntime.Date?
    let latestCloudWatchLogsDeliveryError: Swift.String?
    let latestCloudWatchLogsDeliveryTime: ClientRuntime.Date?
    let latestDigestDeliveryTime: ClientRuntime.Date?
    let latestDigestDeliveryError: Swift.String?
    let latestDeliveryAttemptTime: Swift.String?
    let latestNotificationAttemptTime: Swift.String?
    let latestNotificationAttemptSucceeded: Swift.String?
    let latestDeliveryAttemptSucceeded: Swift.String?
    let timeLoggingStarted: Swift.String?
    let timeLoggingStopped: Swift.String?
}

extension GetTrailStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLogging = "IsLogging"
        case latestCloudWatchLogsDeliveryError = "LatestCloudWatchLogsDeliveryError"
        case latestCloudWatchLogsDeliveryTime = "LatestCloudWatchLogsDeliveryTime"
        case latestDeliveryAttemptSucceeded = "LatestDeliveryAttemptSucceeded"
        case latestDeliveryAttemptTime = "LatestDeliveryAttemptTime"
        case latestDeliveryError = "LatestDeliveryError"
        case latestDeliveryTime = "LatestDeliveryTime"
        case latestDigestDeliveryError = "LatestDigestDeliveryError"
        case latestDigestDeliveryTime = "LatestDigestDeliveryTime"
        case latestNotificationAttemptSucceeded = "LatestNotificationAttemptSucceeded"
        case latestNotificationAttemptTime = "LatestNotificationAttemptTime"
        case latestNotificationError = "LatestNotificationError"
        case latestNotificationTime = "LatestNotificationTime"
        case startLoggingTime = "StartLoggingTime"
        case stopLoggingTime = "StopLoggingTime"
        case timeLoggingStarted = "TimeLoggingStarted"
        case timeLoggingStopped = "TimeLoggingStopped"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isLoggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLogging)
        isLogging = isLoggingDecoded
        let latestDeliveryErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDeliveryError)
        latestDeliveryError = latestDeliveryErrorDecoded
        let latestNotificationErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestNotificationError)
        latestNotificationError = latestNotificationErrorDecoded
        let latestDeliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestDeliveryTime)
        latestDeliveryTime = latestDeliveryTimeDecoded
        let latestNotificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestNotificationTime)
        latestNotificationTime = latestNotificationTimeDecoded
        let startLoggingTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startLoggingTime)
        startLoggingTime = startLoggingTimeDecoded
        let stopLoggingTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopLoggingTime)
        stopLoggingTime = stopLoggingTimeDecoded
        let latestCloudWatchLogsDeliveryErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestCloudWatchLogsDeliveryError)
        latestCloudWatchLogsDeliveryError = latestCloudWatchLogsDeliveryErrorDecoded
        let latestCloudWatchLogsDeliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestCloudWatchLogsDeliveryTime)
        latestCloudWatchLogsDeliveryTime = latestCloudWatchLogsDeliveryTimeDecoded
        let latestDigestDeliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestDigestDeliveryTime)
        latestDigestDeliveryTime = latestDigestDeliveryTimeDecoded
        let latestDigestDeliveryErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDigestDeliveryError)
        latestDigestDeliveryError = latestDigestDeliveryErrorDecoded
        let latestDeliveryAttemptTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDeliveryAttemptTime)
        latestDeliveryAttemptTime = latestDeliveryAttemptTimeDecoded
        let latestNotificationAttemptTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestNotificationAttemptTime)
        latestNotificationAttemptTime = latestNotificationAttemptTimeDecoded
        let latestNotificationAttemptSucceededDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestNotificationAttemptSucceeded)
        latestNotificationAttemptSucceeded = latestNotificationAttemptSucceededDecoded
        let latestDeliveryAttemptSucceededDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDeliveryAttemptSucceeded)
        latestDeliveryAttemptSucceeded = latestDeliveryAttemptSucceededDecoded
        let timeLoggingStartedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeLoggingStarted)
        timeLoggingStarted = timeLoggingStartedDecoded
        let timeLoggingStoppedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeLoggingStopped)
        timeLoggingStopped = timeLoggingStoppedDecoded
    }
}

enum GetTrailStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudTrailClientTypes.ImportFailureListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case errorType = "ErrorType"
        case lastUpdatedTime = "LastUpdatedTime"
        case location = "Location"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType, forKey: .errorType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportFailureStatus.self, forKey: .status)
        status = statusDecoded
        let errorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension CloudTrailClientTypes {
    /// Provides information about an import failure.
    public struct ImportFailureListItem: Swift.Equatable {
        /// Provides the reason the import failed.
        public var errorMessage: Swift.String?
        /// The type of import error.
        public var errorType: Swift.String?
        /// When the import was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The location of the failure in the S3 bucket.
        public var location: Swift.String?
        /// The status of the import.
        public var status: CloudTrailClientTypes.ImportFailureStatus?

        public init(
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            location: Swift.String? = nil,
            status: CloudTrailClientTypes.ImportFailureStatus? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.lastUpdatedTime = lastUpdatedTime
            self.location = location
            self.status = status
        }
    }

}

extension CloudTrailClientTypes {
    public enum ImportFailureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case retry
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportFailureStatus] {
            return [
                .failed,
                .retry,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .retry: return "RETRY"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportFailureStatus(rawValue: rawValue) ?? ImportFailureStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImportNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified import was not found.
public struct ImportNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ImportNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ImportNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImportNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.ImportSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3 = "S3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.S3ImportSource.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension CloudTrailClientTypes {
    /// The import source.
    public struct ImportSource: Swift.Equatable {
        /// The source S3 bucket.
        /// This member is required.
        public var s3: CloudTrailClientTypes.S3ImportSource?

        public init(
            s3: CloudTrailClientTypes.S3ImportSource? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension CloudTrailClientTypes.ImportStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventsCompleted = "EventsCompleted"
        case failedEntries = "FailedEntries"
        case filesCompleted = "FilesCompleted"
        case prefixesCompleted = "PrefixesCompleted"
        case prefixesFound = "PrefixesFound"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventsCompleted = self.eventsCompleted {
            try encodeContainer.encode(eventsCompleted, forKey: .eventsCompleted)
        }
        if let failedEntries = self.failedEntries {
            try encodeContainer.encode(failedEntries, forKey: .failedEntries)
        }
        if let filesCompleted = self.filesCompleted {
            try encodeContainer.encode(filesCompleted, forKey: .filesCompleted)
        }
        if let prefixesCompleted = self.prefixesCompleted {
            try encodeContainer.encode(prefixesCompleted, forKey: .prefixesCompleted)
        }
        if let prefixesFound = self.prefixesFound {
            try encodeContainer.encode(prefixesFound, forKey: .prefixesFound)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixesFoundDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .prefixesFound)
        prefixesFound = prefixesFoundDecoded
        let prefixesCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .prefixesCompleted)
        prefixesCompleted = prefixesCompletedDecoded
        let filesCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .filesCompleted)
        filesCompleted = filesCompletedDecoded
        let eventsCompletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsCompleted)
        eventsCompleted = eventsCompletedDecoded
        let failedEntriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedEntries)
        failedEntries = failedEntriesDecoded
    }
}

extension CloudTrailClientTypes {
    /// Provides statistics for the specified ImportID. CloudTrail does not update import statistics in real-time. Returned values for parameters such as EventsCompleted may be lower than the actual value, because CloudTrail updates statistics incrementally over the course of the import.
    public struct ImportStatistics: Swift.Equatable {
        /// The number of trail events imported into the event data store.
        public var eventsCompleted: Swift.Int?
        /// The number of failed entries.
        public var failedEntries: Swift.Int?
        /// The number of log files that completed import.
        public var filesCompleted: Swift.Int?
        /// The number of S3 prefixes that completed import.
        public var prefixesCompleted: Swift.Int?
        /// The number of S3 prefixes found for the import.
        public var prefixesFound: Swift.Int?

        public init(
            eventsCompleted: Swift.Int? = nil,
            failedEntries: Swift.Int? = nil,
            filesCompleted: Swift.Int? = nil,
            prefixesCompleted: Swift.Int? = nil,
            prefixesFound: Swift.Int? = nil
        )
        {
            self.eventsCompleted = eventsCompleted
            self.failedEntries = failedEntries
            self.filesCompleted = filesCompleted
            self.prefixesCompleted = prefixesCompleted
            self.prefixesFound = prefixesFound
        }
    }

}

extension CloudTrailClientTypes {
    public enum ImportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case initializing
        case inProgress
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportStatus] {
            return [
                .completed,
                .failed,
                .initializing,
                .inProgress,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .initializing: return "INITIALIZING"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportStatus(rawValue: rawValue) ?? ImportStatus.sdkUnknown(rawValue)
        }
    }
}

extension CloudTrailClientTypes.ImportsListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinations = "Destinations"
        case importId = "ImportId"
        case importStatus = "ImportStatus"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for eventdatastorearn0 in destinations {
                try destinationsContainer.encode(eventdatastorearn0)
            }
        }
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let importStatus = self.importStatus {
            try encodeContainer.encode(importStatus.rawValue, forKey: .importStatus)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .epochSeconds, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about an import that was returned by a lookup request.
    public struct ImportsListItem: Swift.Equatable {
        /// The timestamp of the import's creation.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of the destination event data store.
        public var destinations: [Swift.String]?
        /// The ID of the import.
        public var importId: Swift.String?
        /// The status of the import.
        public var importStatus: CloudTrailClientTypes.ImportStatus?
        /// The timestamp of the import's last update.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            destinations: [Swift.String]? = nil,
            importId: Swift.String? = nil,
            importStatus: CloudTrailClientTypes.ImportStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.destinations = destinations
            self.importId = importId
            self.importStatus = importStatus
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension InactiveEventDataStoreException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InactiveEventDataStoreExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The event data store is inactive.
public struct InactiveEventDataStoreException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InactiveEventDataStore" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InactiveEventDataStoreExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InactiveEventDataStoreExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InactiveQueryException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InactiveQueryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified query cannot be canceled because it is in the FINISHED, FAILED, TIMED_OUT, or CANCELLED state.
public struct InactiveQueryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InactiveQuery" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InactiveQueryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InactiveQueryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.IngestionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestIngestionAttemptEventID = "LatestIngestionAttemptEventID"
        case latestIngestionAttemptTime = "LatestIngestionAttemptTime"
        case latestIngestionErrorCode = "LatestIngestionErrorCode"
        case latestIngestionSuccessEventID = "LatestIngestionSuccessEventID"
        case latestIngestionSuccessTime = "LatestIngestionSuccessTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestIngestionAttemptEventID = self.latestIngestionAttemptEventID {
            try encodeContainer.encode(latestIngestionAttemptEventID, forKey: .latestIngestionAttemptEventID)
        }
        if let latestIngestionAttemptTime = self.latestIngestionAttemptTime {
            try encodeContainer.encodeTimestamp(latestIngestionAttemptTime, format: .epochSeconds, forKey: .latestIngestionAttemptTime)
        }
        if let latestIngestionErrorCode = self.latestIngestionErrorCode {
            try encodeContainer.encode(latestIngestionErrorCode, forKey: .latestIngestionErrorCode)
        }
        if let latestIngestionSuccessEventID = self.latestIngestionSuccessEventID {
            try encodeContainer.encode(latestIngestionSuccessEventID, forKey: .latestIngestionSuccessEventID)
        }
        if let latestIngestionSuccessTime = self.latestIngestionSuccessTime {
            try encodeContainer.encodeTimestamp(latestIngestionSuccessTime, format: .epochSeconds, forKey: .latestIngestionSuccessTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestIngestionSuccessTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestIngestionSuccessTime)
        latestIngestionSuccessTime = latestIngestionSuccessTimeDecoded
        let latestIngestionSuccessEventIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestIngestionSuccessEventID)
        latestIngestionSuccessEventID = latestIngestionSuccessEventIDDecoded
        let latestIngestionErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestIngestionErrorCode)
        latestIngestionErrorCode = latestIngestionErrorCodeDecoded
        let latestIngestionAttemptTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestIngestionAttemptTime)
        latestIngestionAttemptTime = latestIngestionAttemptTimeDecoded
        let latestIngestionAttemptEventIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestIngestionAttemptEventID)
        latestIngestionAttemptEventID = latestIngestionAttemptEventIDDecoded
    }
}

extension CloudTrailClientTypes {
    /// A table showing information about the most recent successful and failed attempts to ingest events.
    public struct IngestionStatus: Swift.Equatable {
        /// The event ID of the most recent attempt to ingest events.
        public var latestIngestionAttemptEventID: Swift.String?
        /// The time stamp of the most recent attempt to ingest events on the channel.
        public var latestIngestionAttemptTime: ClientRuntime.Date?
        /// The error code for the most recent failure to ingest events.
        public var latestIngestionErrorCode: Swift.String?
        /// The event ID of the most recent successful ingestion of events.
        public var latestIngestionSuccessEventID: Swift.String?
        /// The time stamp of the most recent successful ingestion of events for the channel.
        public var latestIngestionSuccessTime: ClientRuntime.Date?

        public init(
            latestIngestionAttemptEventID: Swift.String? = nil,
            latestIngestionAttemptTime: ClientRuntime.Date? = nil,
            latestIngestionErrorCode: Swift.String? = nil,
            latestIngestionSuccessEventID: Swift.String? = nil,
            latestIngestionSuccessTime: ClientRuntime.Date? = nil
        )
        {
            self.latestIngestionAttemptEventID = latestIngestionAttemptEventID
            self.latestIngestionAttemptTime = latestIngestionAttemptTime
            self.latestIngestionErrorCode = latestIngestionErrorCode
            self.latestIngestionSuccessEventID = latestIngestionSuccessEventID
            self.latestIngestionSuccessTime = latestIngestionSuccessTime
        }
    }

}

extension InsightNotEnabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsightNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// If you run GetInsightSelectors on a trail that does not have Insights events enabled, the operation throws the exception InsightNotEnabledException.
public struct InsightNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsightNotEnabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InsightNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsightNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.InsightSelector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightType = "InsightType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightType = self.insightType {
            try encodeContainer.encode(insightType.rawValue, forKey: .insightType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightTypeDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.InsightType.self, forKey: .insightType)
        insightType = insightTypeDecoded
    }
}

extension CloudTrailClientTypes {
    /// A JSON string that contains a list of Insights types that are logged on a trail.
    public struct InsightSelector: Swift.Equatable {
        /// The type of Insights events to log on a trail. ApiCallRateInsight and ApiErrorRateInsight are valid Insight types. The ApiCallRateInsight Insights type analyzes write-only management API calls that are aggregated per minute against a baseline API call volume. The ApiErrorRateInsight Insights type analyzes management API calls that result in error codes. The error is shown if the API call is unsuccessful.
        public var insightType: CloudTrailClientTypes.InsightType?

        public init(
            insightType: CloudTrailClientTypes.InsightType? = nil
        )
        {
            self.insightType = insightType
        }
    }

}

extension CloudTrailClientTypes {
    public enum InsightType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apicallrateinsight
        case apierrorrateinsight
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightType] {
            return [
                .apicallrateinsight,
                .apierrorrateinsight,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apicallrateinsight: return "ApiCallRateInsight"
            case .apierrorrateinsight: return "ApiErrorRateInsight"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InsightType(rawValue: rawValue) ?? InsightType.sdkUnknown(rawValue)
        }
    }
}

extension InsufficientDependencyServiceAccessPermissionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientDependencyServiceAccessPermissionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the IAM identity that is used to create the organization resource lacks one or more required permissions for creating an organization resource in a required service.
public struct InsufficientDependencyServiceAccessPermissionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientDependencyServiceAccessPermission" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InsufficientDependencyServiceAccessPermissionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientDependencyServiceAccessPermissionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientEncryptionPolicyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientEncryptionPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the policy on the S3 bucket or KMS key does not have sufficient permissions for the operation.
public struct InsufficientEncryptionPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientEncryptionPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InsufficientEncryptionPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientEncryptionPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientS3BucketPolicyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientS3BucketPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the policy on the S3 bucket is not sufficient.
public struct InsufficientS3BucketPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientS3BucketPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InsufficientS3BucketPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientS3BucketPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientSnsTopicPolicyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientSnsTopicPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the policy on the Amazon SNS topic is not sufficient.
public struct InsufficientSnsTopicPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientSnsTopicPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InsufficientSnsTopicPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InsufficientSnsTopicPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCloudWatchLogsLogGroupArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCloudWatchLogsLogGroupArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the provided CloudWatch Logs log group is not valid.
public struct InvalidCloudWatchLogsLogGroupArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCloudWatchLogsLogGroupArn" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCloudWatchLogsLogGroupArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCloudWatchLogsLogGroupArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCloudWatchLogsRoleArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidCloudWatchLogsRoleArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the provided role is not valid.
public struct InvalidCloudWatchLogsRoleArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCloudWatchLogsRoleArn" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidCloudWatchLogsRoleArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCloudWatchLogsRoleArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDateRangeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidDateRangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A date range for the query was specified that is not valid. Be sure that the start time is chronologically before the end time. For more information about writing a query, see [Create or edit a query](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-create-edit-query.html) in the CloudTrail User Guide.
public struct InvalidDateRangeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDateRange" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidDateRangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDateRangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventCategoryException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidEventCategoryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs if an event category that is not valid is specified as a value of EventCategory.
public struct InvalidEventCategoryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEventCategory" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidEventCategoryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventCategoryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventDataStoreCategoryException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidEventDataStoreCategoryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when event categories of specified event data stores are not valid.
public struct InvalidEventDataStoreCategoryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEventDataStoreCategory" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidEventDataStoreCategoryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventDataStoreCategoryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventDataStoreStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidEventDataStoreStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The event data store is not in a status that supports the operation.
public struct InvalidEventDataStoreStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEventDataStoreStatus" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidEventDataStoreStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventDataStoreStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventSelectorsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidEventSelectorsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the PutEventSelectors operation is called with a number of event selectors, advanced event selectors, or data resources that is not valid. The combination of event selectors or advanced event selectors and data resources is not valid. A trail can have up to 5 event selectors. If a trail uses advanced event selectors, a maximum of 500 total values for all conditions in all advanced event selectors is allowed. A trail is limited to 250 data resources. These data resources can be distributed across event selectors, but the overall total cannot exceed 250. You can:
///
/// * Specify a valid number of event selectors (1 to 5) for a trail.
///
/// * Specify a valid number of data resources (1 to 250) for an event selector. The limit of number of resources on an individual event selector is configurable up to 250. However, this upper limit is allowed only if the total number of data resources does not exceed 250 across all event selectors for a trail.
///
/// * Specify up to 500 values for all conditions in all advanced event selectors for a trail.
///
/// * Specify a valid value for a parameter. For example, specifying the ReadWriteType parameter with a value of read-only is not valid.
public struct InvalidEventSelectorsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEventSelectors" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidEventSelectorsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEventSelectorsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHomeRegionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidHomeRegionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when an operation is called on a trail from a Region other than the Region in which the trail was created.
public struct InvalidHomeRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidHomeRegion" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidHomeRegionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidHomeRegionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidImportSourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidImportSourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the provided source S3 bucket is not valid for import.
public struct InvalidImportSourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidImportSource" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidImportSourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidImportSourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInsightSelectorsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidInsightSelectorsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The formatting or syntax of the InsightSelectors JSON statement in your PutInsightSelectors or GetInsightSelectors request is not valid, or the specified insight type in the InsightSelectors statement is not a valid insight type.
public struct InvalidInsightSelectorsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInsightSelectors" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidInsightSelectorsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInsightSelectorsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidKmsKeyIdException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidKmsKeyIdExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the KMS key ARN is not valid.
public struct InvalidKmsKeyIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidKmsKeyId" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidKmsKeyIdExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidKmsKeyIdExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLookupAttributesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidLookupAttributesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when a lookup attribute is specified that is not valid.
public struct InvalidLookupAttributesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLookupAttributes" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidLookupAttributesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLookupAttributesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown if the limit specified is not valid.
public struct InvalidMaxResultsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMaxResults" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxResultsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A token that is not valid, or a token that was previously used in a request with different parameters. This exception is thrown if the token is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextToken" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the combination of parameters provided is not valid.
public struct InvalidParameterCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterCombinationError" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request includes a parameter that is not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryStatementException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidQueryStatementExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The query that was submitted has validation errors, or uses incorrect syntax or unsupported keywords. For more information about writing a query, see [Create or edit a query](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-create-edit-query.html) in the CloudTrail User Guide.
public struct InvalidQueryStatementException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidQueryStatement" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidQueryStatementExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidQueryStatementExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryStatusException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidQueryStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The query status is not valid for the operation.
public struct InvalidQueryStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidQueryStatus" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidQueryStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidQueryStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidS3BucketNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the provided S3 bucket name is not valid.
public struct InvalidS3BucketNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3BucketName" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidS3BucketNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3BucketNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3PrefixException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidS3PrefixExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the provided S3 prefix is not valid.
public struct InvalidS3PrefixException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3Prefix" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidS3PrefixExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidS3PrefixExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnsTopicNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSnsTopicNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the provided SNS topic name is not valid.
public struct InvalidSnsTopicNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSnsTopicName" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSnsTopicNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSnsTopicNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified value of Source is not valid.
public struct InvalidSourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSource" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified tag key or values are not valid. It can also occur if there are duplicate tags or too many tags on the resource.
public struct InvalidTagParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTagParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTimeRangeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTimeRangeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs if the timestamp values are not valid. Either the start time occurs after the end time, or the time range is outside the range of possible values.
public struct InvalidTimeRangeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTimeRange" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTimeRangeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTimeRangeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Reserved for future use.
public struct InvalidTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidToken" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTrailNameException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTrailNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:
///
/// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
///
/// * Start with a letter or number, and end with a letter or number
///
/// * Be between 3 and 128 characters
///
/// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
///
/// * Not be in IP address format (for example, 192.168.5.4)
public struct InvalidTrailNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTrailName" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTrailNameExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTrailNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KmsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when there is an issue with the specified KMS key and the trail or event data store can't be updated.
public struct KmsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KmsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KmsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsKeyDisabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KmsKeyDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is no longer in use.
@available(*, deprecated)
public struct KmsKeyDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsKeyDisabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KmsKeyDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KmsKeyDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsKeyNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KmsKeyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the KMS key does not exist, when the S3 bucket and the KMS key are not in the same Region, or when the KMS key associated with the Amazon SNS topic either does not exist or is not in the same Region.
public struct KmsKeyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsKeyNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KmsKeyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KmsKeyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// The maximum number of CloudTrail channels to display on a single page.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutput: Swift.Equatable {
    /// The list of channels in the account.
    public var channels: [CloudTrailClientTypes.Channel]?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        channels: [CloudTrailClientTypes.Channel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputBody: Swift.Equatable {
    let channels: [CloudTrailClientTypes.Channel]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[CloudTrailClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [CloudTrailClientTypes.Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChannelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEventDataStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEventDataStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEventDataStoresInput: Swift.Equatable {
    /// The maximum number of event data stores to display on a single page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of event data store results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventDataStoresInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEventDataStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventDataStoresOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventDataStoresOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventDataStores = output.eventDataStores
            self.nextToken = output.nextToken
        } else {
            self.eventDataStores = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventDataStoresOutput: Swift.Equatable {
    /// Contains information about event data stores in the account, in the current Region.
    public var eventDataStores: [CloudTrailClientTypes.EventDataStore]?
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        eventDataStores: [CloudTrailClientTypes.EventDataStore]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventDataStores = eventDataStores
        self.nextToken = nextToken
    }
}

struct ListEventDataStoresOutputBody: Swift.Equatable {
    let eventDataStores: [CloudTrailClientTypes.EventDataStore]?
    let nextToken: Swift.String?
}

extension ListEventDataStoresOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStores = "EventDataStores"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoresContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventDataStore?].self, forKey: .eventDataStores)
        var eventDataStoresDecoded0:[CloudTrailClientTypes.EventDataStore]? = nil
        if let eventDataStoresContainer = eventDataStoresContainer {
            eventDataStoresDecoded0 = [CloudTrailClientTypes.EventDataStore]()
            for structure0 in eventDataStoresContainer {
                if let structure0 = structure0 {
                    eventDataStoresDecoded0?.append(structure0)
                }
            }
        }
        eventDataStores = eventDataStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEventDataStoresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidMaxResults": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImportFailuresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImportFailuresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListImportFailuresInput: Swift.Equatable {
    /// The ID of the import.
    /// This member is required.
    public var importId: Swift.String?
    /// The maximum number of failures to display on a single page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of import failures.
    public var nextToken: Swift.String?

    public init(
        importId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importId = importId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportFailuresInputBody: Swift.Equatable {
    let importId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImportFailuresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportFailuresOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImportFailuresOutputBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.nextToken = output.nextToken
        } else {
            self.failures = nil
            self.nextToken = nil
        }
    }
}

public struct ListImportFailuresOutput: Swift.Equatable {
    /// Contains information about the import failures.
    public var failures: [CloudTrailClientTypes.ImportFailureListItem]?
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        failures: [CloudTrailClientTypes.ImportFailureListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.failures = failures
        self.nextToken = nextToken
    }
}

struct ListImportFailuresOutputBody: Swift.Equatable {
    let failures: [CloudTrailClientTypes.ImportFailureListItem]?
    let nextToken: Swift.String?
}

extension ListImportFailuresOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures = "Failures"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failuresContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.ImportFailureListItem?].self, forKey: .failures)
        var failuresDecoded0:[CloudTrailClientTypes.ImportFailureListItem]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [CloudTrailClientTypes.ImportFailureListItem]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImportFailuresOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case importStatus = "ImportStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let importStatus = self.importStatus {
            try encodeContainer.encode(importStatus.rawValue, forKey: .importStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListImportsInput: Swift.Equatable {
    /// The ARN of the destination event data store.
    public var destination: Swift.String?
    /// The status of the import.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// The maximum number of imports to display on a single page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of import results.
    public var nextToken: Swift.String?

    public init(
        destination: Swift.String? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destination = destination
        self.importStatus = importStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let destination: Swift.String?
    let importStatus: CloudTrailClientTypes.ImportStatus?
    let nextToken: Swift.String?
}

extension ListImportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case importStatus = "ImportStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.imports = output.imports
            self.nextToken = output.nextToken
        } else {
            self.imports = nil
            self.nextToken = nil
        }
    }
}

public struct ListImportsOutput: Swift.Equatable {
    /// The list of returned imports.
    public var imports: [CloudTrailClientTypes.ImportsListItem]?
    /// A token you can use to get the next page of import results.
    public var nextToken: Swift.String?

    public init(
        imports: [CloudTrailClientTypes.ImportsListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imports = imports
        self.nextToken = nextToken
    }
}

struct ListImportsOutputBody: Swift.Equatable {
    let imports: [CloudTrailClientTypes.ImportsListItem]?
    let nextToken: Swift.String?
}

extension ListImportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imports = "Imports"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.ImportsListItem?].self, forKey: .imports)
        var importsDecoded0:[CloudTrailClientTypes.ImportsListItem]? = nil
        if let importsContainer = importsContainer {
            importsDecoded0 = [CloudTrailClientTypes.ImportsListItem]()
            for structure0 in importsContainer {
                if let structure0 = structure0 {
                    importsDecoded0?.append(structure0)
                }
            }
        }
        imports = importsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPublicKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListPublicKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Requests the public keys for a specified time range.
public struct ListPublicKeysInput: Swift.Equatable {
    /// Optionally specifies, in UTC, the end of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used.
    public var endTime: ClientRuntime.Date?
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Optionally specifies, in UTC, the start of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used, and the current public key is returned.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListPublicKeysInputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
}

extension ListPublicKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPublicKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPublicKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.publicKeyList = output.publicKeyList
        } else {
            self.nextToken = nil
            self.publicKeyList = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct ListPublicKeysOutput: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Contains an array of PublicKey objects. The returned public keys may have validity time ranges that overlap.
    public var publicKeyList: [CloudTrailClientTypes.PublicKey]?

    public init(
        nextToken: Swift.String? = nil,
        publicKeyList: [CloudTrailClientTypes.PublicKey]? = nil
    )
    {
        self.nextToken = nextToken
        self.publicKeyList = publicKeyList
    }
}

struct ListPublicKeysOutputBody: Swift.Equatable {
    let publicKeyList: [CloudTrailClientTypes.PublicKey]?
    let nextToken: Swift.String?
}

extension ListPublicKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case publicKeyList = "PublicKeyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.PublicKey?].self, forKey: .publicKeyList)
        var publicKeyListDecoded0:[CloudTrailClientTypes.PublicKey]? = nil
        if let publicKeyListContainer = publicKeyListContainer {
            publicKeyListDecoded0 = [CloudTrailClientTypes.PublicKey]()
            for structure0 in publicKeyListContainer {
                if let structure0 = structure0 {
                    publicKeyListDecoded0?.append(structure0)
                }
            }
        }
        publicKeyList = publicKeyListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPublicKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidTimeRange": return try await InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidToken": return try await InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListQueriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventDataStore = "EventDataStore"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryStatus = "QueryStatus"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryStatus = self.queryStatus {
            try encodeContainer.encode(queryStatus.rawValue, forKey: .queryStatus)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListQueriesInput: Swift.Equatable {
    /// Use with StartTime to bound a ListQueries request, and limit its results to only those queries run within a specified time period.
    public var endTime: ClientRuntime.Date?
    /// The ARN (or the ID suffix of the ARN) of an event data store on which queries were run.
    /// This member is required.
    public var eventDataStore: Swift.String?
    /// The maximum number of queries to show on a page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?
    /// The status of queries that you want to return in results. Valid values for QueryStatus include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.
    public var queryStatus: CloudTrailClientTypes.QueryStatus?
    /// Use with EndTime to bound a ListQueries request, and limit its results to only those queries run within a specified time period.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        eventDataStore: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventDataStore = eventDataStore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryStatus = queryStatus
        self.startTime = startTime
    }
}

struct ListQueriesInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let queryStatus: CloudTrailClientTypes.QueryStatus?
}

extension ListQueriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventDataStore = "EventDataStore"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryStatus = "QueryStatus"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
    }
}

extension ListQueriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListQueriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queries = output.queries
        } else {
            self.nextToken = nil
            self.queries = nil
        }
    }
}

public struct ListQueriesOutput: Swift.Equatable {
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?
    /// Lists matching query results, and shows query ID, status, and creation time of each query.
    public var queries: [CloudTrailClientTypes.Query]?

    public init(
        nextToken: Swift.String? = nil,
        queries: [CloudTrailClientTypes.Query]? = nil
    )
    {
        self.nextToken = nextToken
        self.queries = queries
    }
}

struct ListQueriesOutputBody: Swift.Equatable {
    let queries: [CloudTrailClientTypes.Query]?
    let nextToken: Swift.String?
}

extension ListQueriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case queries = "Queries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queriesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Query?].self, forKey: .queries)
        var queriesDecoded0:[CloudTrailClientTypes.Query]? = nil
        if let queriesContainer = queriesContainer {
            queriesDecoded0 = [CloudTrailClientTypes.Query]()
            for structure0 in queriesContainer {
                if let structure0 = structure0 {
                    queriesDecoded0?.append(structure0)
                }
            }
        }
        queries = queriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListQueriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidDateRange": return try await InvalidDateRangeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResults": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryStatus": return try await InvalidQueryStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceIdList = "ResourceIdList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIdList = resourceIdList {
            var resourceIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIdList)
            for string0 in resourceIdList {
                try resourceIdListContainer.encode(string0)
            }
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies a list of tags to return.
public struct ListTagsInput: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Specifies a list of trail, event data store, or channel ARNs whose tags will be listed. The list has a limit of 20 ARNs. Example trail ARN format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail Example event data store ARN format: arn:aws:cloudtrail:us-east-2:123456789012:eventdatastore/EXAMPLE-f852-4e8f-8bd1-bcf6cEXAMPLE Example channel ARN format: arn:aws:cloudtrail:us-east-2:123456789012:channel/01234567890
    /// This member is required.
    public var resourceIdList: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        resourceIdList: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdList = resourceIdList
    }
}

struct ListTagsInputBody: Swift.Equatable {
    let resourceIdList: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceIdList = "ResourceIdList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIdList)
        var resourceIdListDecoded0:[Swift.String]? = nil
        if let resourceIdListContainer = resourceIdListContainer {
            resourceIdListDecoded0 = [Swift.String]()
            for string0 in resourceIdListContainer {
                if let string0 = string0 {
                    resourceIdListDecoded0?.append(string0)
                }
            }
        }
        resourceIdList = resourceIdListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceTagList = output.resourceTagList
        } else {
            self.nextToken = nil
            self.resourceTagList = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct ListTagsOutput: Swift.Equatable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// A list of resource tags.
    public var resourceTagList: [CloudTrailClientTypes.ResourceTag]?

    public init(
        nextToken: Swift.String? = nil,
        resourceTagList: [CloudTrailClientTypes.ResourceTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTagList = resourceTagList
    }
}

struct ListTagsOutputBody: Swift.Equatable {
    let resourceTagList: [CloudTrailClientTypes.ResourceTag]?
    let nextToken: Swift.String?
}

extension ListTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceTagList = "ResourceTagList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.ResourceTag?].self, forKey: .resourceTagList)
        var resourceTagListDecoded0:[CloudTrailClientTypes.ResourceTag]? = nil
        if let resourceTagListContainer = resourceTagListContainer {
            resourceTagListDecoded0 = [CloudTrailClientTypes.ResourceTag]()
            for structure0 in resourceTagListContainer {
                if let structure0 = structure0 {
                    resourceTagListDecoded0?.append(structure0)
                }
            }
        }
        resourceTagList = resourceTagListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ChannelARNInvalid": return try await ChannelARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidToken": return try await InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceTypeNotSupported": return try await ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTrailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTrailsInput: Swift.Equatable {
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListTrailsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListTrailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trails = output.trails
        } else {
            self.nextToken = nil
            self.trails = nil
        }
    }
}

public struct ListTrailsOutput: Swift.Equatable {
    /// The token to use to get the next page of results after a previous API call. If the token does not appear, there are no more results to return. The token must be passed in with the same parameters as the previous call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?
    /// Returns the name, ARN, and home Region of trails in the current account.
    public var trails: [CloudTrailClientTypes.TrailInfo]?

    public init(
        nextToken: Swift.String? = nil,
        trails: [CloudTrailClientTypes.TrailInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.trails = trails
    }
}

struct ListTrailsOutputBody: Swift.Equatable {
    let trails: [CloudTrailClientTypes.TrailInfo]?
    let nextToken: Swift.String?
}

extension ListTrailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case trails = "Trails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.TrailInfo?].self, forKey: .trails)
        var trailsDecoded0:[CloudTrailClientTypes.TrailInfo]? = nil
        if let trailsContainer = trailsContainer {
            trailsDecoded0 = [CloudTrailClientTypes.TrailInfo]()
            for structure0 in trailsContainer {
                if let structure0 = structure0 {
                    trailsDecoded0?.append(structure0)
                }
            }
        }
        trails = trailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTrailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudTrailClientTypes.LookupAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeKey = "AttributeKey"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKey = self.attributeKey {
            try encodeContainer.encode(attributeKey.rawValue, forKey: .attributeKey)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.LookupAttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension CloudTrailClientTypes {
    /// Specifies an attribute and value that filter the events returned.
    public struct LookupAttribute: Swift.Equatable {
        /// Specifies an attribute on which to filter the events returned.
        /// This member is required.
        public var attributeKey: CloudTrailClientTypes.LookupAttributeKey?
        /// Specifies a value for the specified AttributeKey.
        /// This member is required.
        public var attributeValue: Swift.String?

        public init(
            attributeKey: CloudTrailClientTypes.LookupAttributeKey? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeKey = attributeKey
            self.attributeValue = attributeValue
        }
    }

}

extension CloudTrailClientTypes {
    public enum LookupAttributeKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessKeyId
        case eventId
        case eventName
        case eventSource
        case readOnly
        case resourceName
        case resourceType
        case username
        case sdkUnknown(Swift.String)

        public static var allCases: [LookupAttributeKey] {
            return [
                .accessKeyId,
                .eventId,
                .eventName,
                .eventSource,
                .readOnly,
                .resourceName,
                .resourceType,
                .username,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessKeyId: return "AccessKeyId"
            case .eventId: return "EventId"
            case .eventName: return "EventName"
            case .eventSource: return "EventSource"
            case .readOnly: return "ReadOnly"
            case .resourceName: return "ResourceName"
            case .resourceType: return "ResourceType"
            case .username: return "Username"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LookupAttributeKey(rawValue: rawValue) ?? LookupAttributeKey.sdkUnknown(rawValue)
        }
    }
}

extension LookupEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventCategory = "EventCategory"
        case lookupAttributes = "LookupAttributes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventCategory = self.eventCategory {
            try encodeContainer.encode(eventCategory.rawValue, forKey: .eventCategory)
        }
        if let lookupAttributes = lookupAttributes {
            var lookupAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lookupAttributes)
            for lookupattribute0 in lookupAttributes {
                try lookupAttributesContainer.encode(lookupattribute0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension LookupEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Contains a request for LookupEvents.
public struct LookupEventsInput: Swift.Equatable {
    /// Specifies that only events that occur before or at the specified time are returned. If the specified end time is before the specified start time, an error is returned.
    public var endTime: ClientRuntime.Date?
    /// Specifies the event category. If you do not specify an event category, events of the category are not returned in the response. For example, if you do not specify insight as the value of EventCategory, no Insights events are returned.
    public var eventCategory: CloudTrailClientTypes.EventCategory?
    /// Contains a list of lookup attributes. Currently the list can contain only one item.
    public var lookupAttributes: [CloudTrailClientTypes.LookupAttribute]?
    /// The number of events to return. Possible values are 1 through 50. The default is 50.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?
    /// Specifies that only events that occur after or at the specified time are returned. If the specified start time is after the specified end time, an error is returned.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        eventCategory: CloudTrailClientTypes.EventCategory? = nil,
        lookupAttributes: [CloudTrailClientTypes.LookupAttribute]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventCategory = eventCategory
        self.lookupAttributes = lookupAttributes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct LookupEventsInputBody: Swift.Equatable {
    let lookupAttributes: [CloudTrailClientTypes.LookupAttribute]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let eventCategory: CloudTrailClientTypes.EventCategory?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension LookupEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case eventCategory = "EventCategory"
        case lookupAttributes = "LookupAttributes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lookupAttributesContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.LookupAttribute?].self, forKey: .lookupAttributes)
        var lookupAttributesDecoded0:[CloudTrailClientTypes.LookupAttribute]? = nil
        if let lookupAttributesContainer = lookupAttributesContainer {
            lookupAttributesDecoded0 = [CloudTrailClientTypes.LookupAttribute]()
            for structure0 in lookupAttributesContainer {
                if let structure0 = structure0 {
                    lookupAttributesDecoded0?.append(structure0)
                }
            }
        }
        lookupAttributes = lookupAttributesDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let eventCategoryDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventCategory.self, forKey: .eventCategory)
        eventCategory = eventCategoryDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LookupEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LookupEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

/// Contains a response to a LookupEvents action.
public struct LookupEventsOutput: Swift.Equatable {
    /// A list of events returned based on the lookup attributes specified and the CloudTrail event. The events list is sorted by time. The most recent event is listed first.
    public var events: [CloudTrailClientTypes.Event]?
    /// The token to use to get the next page of results after a previous API call. If the token does not appear, there are no more results to return. The token must be passed in with the same parameters as the previous call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init(
        events: [CloudTrailClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct LookupEventsOutputBody: Swift.Equatable {
    let events: [CloudTrailClientTypes.Event]?
    let nextToken: Swift.String?
}

extension LookupEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[CloudTrailClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [CloudTrailClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum LookupEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidEventCategory": return try await InvalidEventCategoryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidLookupAttributes": return try await InvalidLookupAttributesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidMaxResults": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTimeRange": return try await InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MaxConcurrentQueriesException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaxConcurrentQueriesExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are already running the maximum number of concurrent queries. The maximum number of concurrent queries is 10. Wait a minute for some queries to finish, and then run the query again.
public struct MaxConcurrentQueriesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxConcurrentQueries" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaxConcurrentQueriesExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaxConcurrentQueriesExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumNumberOfTrailsExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MaximumNumberOfTrailsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the maximum number of trails is reached.
public struct MaximumNumberOfTrailsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumNumberOfTrailsExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MaximumNumberOfTrailsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MaximumNumberOfTrailsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoManagementAccountSLRExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoManagementAccountSLRExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the management account does not have a service-linked role.
public struct NoManagementAccountSLRExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoManagementAccountSLRExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoManagementAccountSLRExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoManagementAccountSLRExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotOrganizationManagementAccountException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotOrganizationManagementAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the account making the request is not the organization's management account.
public struct NotOrganizationManagementAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotOrganizationManagementAccount" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotOrganizationManagementAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotOrganizationManagementAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotOrganizationMasterAccountException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotOrganizationMasterAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail or event data store is not the management account for an organization in Organizations. For more information, see [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html) or [Create an event data store](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-event-data-store.html).
public struct NotOrganizationMasterAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotOrganizationMasterAccount" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotOrganizationMasterAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotOrganizationMasterAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotPermittedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the requested operation is not permitted.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermitted" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotInAllFeaturesModeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OrganizationNotInAllFeaturesModeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when Organizations is not configured to support all features. All features must be enabled in Organizations to support creating an organization trail or event data store.
public struct OrganizationNotInAllFeaturesModeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationNotInAllFeaturesMode" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OrganizationNotInAllFeaturesModeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationNotInAllFeaturesModeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationsNotInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OrganizationsNotInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the request is made from an Amazon Web Services account that is not a member of an organization. To make this request, sign in using the credentials of an account that belongs to an organization.
public struct OrganizationsNotInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationsNotInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OrganizationsNotInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OrganizationsNotInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.PublicKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fingerprint = "Fingerprint"
        case validityEndTime = "ValidityEndTime"
        case validityStartTime = "ValidityStartTime"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fingerprint = self.fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let validityEndTime = self.validityEndTime {
            try encodeContainer.encodeTimestamp(validityEndTime, format: .epochSeconds, forKey: .validityEndTime)
        }
        if let validityStartTime = self.validityStartTime {
            try encodeContainer.encodeTimestamp(validityStartTime, format: .epochSeconds, forKey: .validityStartTime)
        }
        if let value = self.value {
            try encodeContainer.encode(value.base64EncodedString(), forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .value)
        value = valueDecoded
        let validityStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .validityStartTime)
        validityStartTime = validityStartTimeDecoded
        let validityEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .validityEndTime)
        validityEndTime = validityEndTimeDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
    }
}

extension CloudTrailClientTypes {
    /// Contains information about a returned public key.
    public struct PublicKey: Swift.Equatable {
        /// The fingerprint of the public key.
        public var fingerprint: Swift.String?
        /// The ending time of validity of the public key.
        public var validityEndTime: ClientRuntime.Date?
        /// The starting time of validity of the public key.
        public var validityStartTime: ClientRuntime.Date?
        /// The DER encoded public key value in PKCS#1 format.
        public var value: ClientRuntime.Data?

        public init(
            fingerprint: Swift.String? = nil,
            validityEndTime: ClientRuntime.Date? = nil,
            validityStartTime: ClientRuntime.Date? = nil,
            value: ClientRuntime.Data? = nil
        )
        {
            self.fingerprint = fingerprint
            self.validityEndTime = validityEndTime
            self.validityStartTime = validityStartTime
            self.value = value
        }
    }

}

extension PutEventSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let eventSelectors = eventSelectors {
            var eventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSelectors)
            for eventselector0 in eventSelectors {
                try eventSelectorsContainer.encode(eventselector0)
            }
        }
        if let trailName = self.trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension PutEventSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutEventSelectorsInput: Swift.Equatable {
    /// Specifies the settings for advanced event selectors. You can add advanced event selectors, and conditions for your advanced event selectors, up to a maximum of 500 values for all conditions and selectors on a trail. You can use either AdvancedEventSelectors or EventSelectors, but not both. If you apply AdvancedEventSelectors to a trail, any existing EventSelectors are overwritten. For more information about advanced event selectors, see [Logging data events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) in the CloudTrail User Guide.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the settings for your event selectors. You can configure up to five event selectors for a trail. You can use either EventSelectors or AdvancedEventSelectors in a PutEventSelectors request, but not both. If you apply EventSelectors to a trail, any existing AdvancedEventSelectors are overwritten.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the following format. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailName: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailName = trailName
    }
}

struct PutEventSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
    let eventSelectors: [CloudTrailClientTypes.EventSelector]?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
}

extension PutEventSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailName = "TrailName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[CloudTrailClientTypes.EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [CloudTrailClientTypes.EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension PutEventSelectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutEventSelectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.eventSelectors = output.eventSelectors
            self.trailARN = output.trailARN
        } else {
            self.advancedEventSelectors = nil
            self.eventSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct PutEventSelectorsOutput: Swift.Equatable {
    /// Specifies the advanced event selectors configured for your trail.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the event selectors configured for your trail.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// Specifies the ARN of the trail that was updated with event selectors. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

struct PutEventSelectorsOutputBody: Swift.Equatable {
    let trailARN: Swift.String?
    let eventSelectors: [CloudTrailClientTypes.EventSelector]?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
}

extension PutEventSelectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailARN = "TrailARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[CloudTrailClientTypes.EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [CloudTrailClientTypes.EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

enum PutEventSelectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventSelectors": return try await InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidHomeRegion": return try await InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutInsightSelectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailName = "TrailName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightSelectors = insightSelectors {
            var insightSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insightSelectors)
            for insightselector0 in insightSelectors {
                try insightSelectorsContainer.encode(insightselector0)
            }
        }
        if let trailName = self.trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

extension PutInsightSelectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInsightSelectorsInput: Swift.Equatable {
    /// A JSON string that contains the insight types you want to log on a trail. ApiCallRateInsight and ApiErrorRateInsight are valid Insight types. The ApiCallRateInsight Insights type analyzes write-only management API calls that are aggregated per minute against a baseline API call volume. The ApiErrorRateInsight Insights type analyzes management API calls that result in error codes. The error is shown if the API call is unsuccessful.
    /// This member is required.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The name of the CloudTrail trail for which you want to change or add Insights selectors.
    /// This member is required.
    public var trailName: Swift.String?

    public init(
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        trailName: Swift.String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailName = trailName
    }
}

struct PutInsightSelectorsInputBody: Swift.Equatable {
    let trailName: Swift.String?
    let insightSelectors: [CloudTrailClientTypes.InsightSelector]?
}

extension PutInsightSelectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailName = "TrailName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailName)
        trailName = trailNameDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[CloudTrailClientTypes.InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [CloudTrailClientTypes.InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

extension PutInsightSelectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutInsightSelectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.insightSelectors = output.insightSelectors
            self.trailARN = output.trailARN
        } else {
            self.insightSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct PutInsightSelectorsOutput: Swift.Equatable {
    /// A JSON string that contains the Insights event types that you want to log on a trail. The valid Insights types in this release are ApiErrorRateInsight and ApiCallRateInsight.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The Amazon Resource Name (ARN) of a trail for which you want to change or add Insights selectors.
    public var trailARN: Swift.String?

    public init(
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailARN = trailARN
    }
}

struct PutInsightSelectorsOutputBody: Swift.Equatable {
    let trailARN: Swift.String?
    let insightSelectors: [CloudTrailClientTypes.InsightSelector]?
}

extension PutInsightSelectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailARN = "TrailARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[CloudTrailClientTypes.InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [CloudTrailClientTypes.InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

enum PutInsightSelectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientEncryptionPolicy": return try await InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientS3BucketPolicy": return try await InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidHomeRegion": return try await InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInsightSelectors": return try await InvalidInsightSelectorsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3BucketDoesNotExist": return try await S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourcePolicy = "ResourcePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourcePolicy = self.resourcePolicy {
            try encodeContainer.encode(resourcePolicy, forKey: .resourcePolicy)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel attached to the resource-based policy. The following is the format of a resource ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/MyChannel.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A JSON-formatted string for an Amazon Web Services resource-based policy. The following are requirements for the resource policy:
    ///
    /// * Contains only one action: cloudtrail-data:PutAuditEvents
    ///
    /// * Contains at least one statement. The policy can have a maximum of 20 statements.
    ///
    /// * Each statement contains at least one principal. A statement can have a maximum of 50 principals.
    /// This member is required.
    public var resourcePolicy: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourcePolicy = resourcePolicy
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourcePolicy: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourcePolicy = "ResourcePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

extension PutResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.resourcePolicy = output.resourcePolicy
        } else {
            self.resourceArn = nil
            self.resourcePolicy = nil
        }
    }
}

public struct PutResourcePolicyOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel attached to the resource-based policy.
    public var resourceArn: Swift.String?
    /// The JSON-formatted string of the Amazon Web Services resource-based policy attached to the CloudTrail channel.
    public var resourcePolicy: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourcePolicy = resourcePolicy
    }
}

struct PutResourcePolicyOutputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourcePolicy: Swift.String?
}

extension PutResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourcePolicy = "ResourcePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
    }
}

enum PutResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceARNNotValid": return try await ResourceARNNotValidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePolicyNotValid": return try await ResourcePolicyNotValidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceTypeNotSupported": return try await ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudTrailClientTypes.Query: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case queryId = "QueryId"
        case queryStatus = "QueryStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let queryId = self.queryId {
            try encodeContainer.encode(queryId, forKey: .queryId)
        }
        if let queryStatus = self.queryStatus {
            try encodeContainer.encode(queryStatus.rawValue, forKey: .queryStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
        let queryStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.QueryStatus.self, forKey: .queryStatus)
        queryStatus = queryStatusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CloudTrailClientTypes {
    /// A SQL string of criteria about events that you want to collect in an event data store.
    public struct Query: Swift.Equatable {
        /// The creation time of a query.
        public var creationTime: ClientRuntime.Date?
        /// The ID of a query.
        public var queryId: Swift.String?
        /// The status of the query. This can be QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.
        public var queryStatus: CloudTrailClientTypes.QueryStatus?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            queryId: Swift.String? = nil,
            queryStatus: CloudTrailClientTypes.QueryStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.queryId = queryId
            self.queryStatus = queryStatus
        }
    }

}

extension QueryIdNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QueryIdNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The query ID does not exist or does not map to a query.
public struct QueryIdNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryIdNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct QueryIdNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension QueryIdNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.QueryStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesScanned = "BytesScanned"
        case resultsCount = "ResultsCount"
        case totalResultsCount = "TotalResultsCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesScanned = self.bytesScanned {
            try encodeContainer.encode(bytesScanned, forKey: .bytesScanned)
        }
        if let resultsCount = self.resultsCount {
            try encodeContainer.encode(resultsCount, forKey: .resultsCount)
        }
        if let totalResultsCount = self.totalResultsCount {
            try encodeContainer.encode(totalResultsCount, forKey: .totalResultsCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .resultsCount)
        resultsCount = resultsCountDecoded
        let totalResultsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResultsCount)
        totalResultsCount = totalResultsCountDecoded
        let bytesScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScanned)
        bytesScanned = bytesScannedDecoded
    }
}

extension CloudTrailClientTypes {
    /// Metadata about a query, such as the number of results.
    public struct QueryStatistics: Swift.Equatable {
        /// The total bytes that the query scanned in the event data store. This value matches the number of bytes for which your account is billed for the query, unless the query is still running.
        public var bytesScanned: Swift.Int?
        /// The number of results returned.
        public var resultsCount: Swift.Int?
        /// The total number of results returned by a query.
        public var totalResultsCount: Swift.Int?

        public init(
            bytesScanned: Swift.Int? = nil,
            resultsCount: Swift.Int? = nil,
            totalResultsCount: Swift.Int? = nil
        )
        {
            self.bytesScanned = bytesScanned
            self.resultsCount = resultsCount
            self.totalResultsCount = totalResultsCount
        }
    }

}

extension CloudTrailClientTypes.QueryStatisticsForDescribeQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesScanned = "BytesScanned"
        case creationTime = "CreationTime"
        case eventsMatched = "EventsMatched"
        case eventsScanned = "EventsScanned"
        case executionTimeInMillis = "ExecutionTimeInMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesScanned = self.bytesScanned {
            try encodeContainer.encode(bytesScanned, forKey: .bytesScanned)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let eventsMatched = self.eventsMatched {
            try encodeContainer.encode(eventsMatched, forKey: .eventsMatched)
        }
        if let eventsScanned = self.eventsScanned {
            try encodeContainer.encode(eventsScanned, forKey: .eventsScanned)
        }
        if let executionTimeInMillis = self.executionTimeInMillis {
            try encodeContainer.encode(executionTimeInMillis, forKey: .executionTimeInMillis)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsMatchedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsMatched)
        eventsMatched = eventsMatchedDecoded
        let eventsScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventsScanned)
        eventsScanned = eventsScannedDecoded
        let bytesScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesScanned)
        bytesScanned = bytesScannedDecoded
        let executionTimeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTimeInMillis)
        executionTimeInMillis = executionTimeInMillisDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CloudTrailClientTypes {
    /// Gets metadata about a query, including the number of events that were matched, the total number of events scanned, the query run time in milliseconds, and the query's creation time.
    public struct QueryStatisticsForDescribeQuery: Swift.Equatable {
        /// The total bytes that the query scanned in the event data store. This value matches the number of bytes for which your account is billed for the query, unless the query is still running.
        public var bytesScanned: Swift.Int?
        /// The creation time of the query.
        public var creationTime: ClientRuntime.Date?
        /// The number of events that matched a query.
        public var eventsMatched: Swift.Int?
        /// The number of events that the query scanned in the event data store.
        public var eventsScanned: Swift.Int?
        /// The query's run time, in milliseconds.
        public var executionTimeInMillis: Swift.Int?

        public init(
            bytesScanned: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            eventsMatched: Swift.Int? = nil,
            eventsScanned: Swift.Int? = nil,
            executionTimeInMillis: Swift.Int? = nil
        )
        {
            self.bytesScanned = bytesScanned
            self.creationTime = creationTime
            self.eventsMatched = eventsMatched
            self.eventsScanned = eventsScanned
            self.executionTimeInMillis = executionTimeInMillis
        }
    }

}

extension CloudTrailClientTypes {
    public enum QueryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case finished
        case queued
        case running
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryStatus] {
            return [
                .cancelled,
                .failed,
                .finished,
                .queued,
                .running,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryStatus(rawValue: rawValue) ?? QueryStatus.sdkUnknown(rawValue)
        }
    }
}

extension CloudTrailClientTypes {
    public enum ReadWriteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case readonly
        case writeonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadWriteType] {
            return [
                .all,
                .readonly,
                .writeonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .readonly: return "ReadOnly"
            case .writeonly: return "WriteOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadWriteType(rawValue: rawValue) ?? ReadWriteType.sdkUnknown(rawValue)
        }
    }
}

extension RegisterOrganizationDelegatedAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId = "MemberAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountId = self.memberAccountId {
            try encodeContainer.encode(memberAccountId, forKey: .memberAccountId)
        }
    }
}

extension RegisterOrganizationDelegatedAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies an organization member account ID as a CloudTrail delegated administrator.
public struct RegisterOrganizationDelegatedAdminInput: Swift.Equatable {
    /// An organization member account ID that you want to designate as a delegated administrator.
    /// This member is required.
    public var memberAccountId: Swift.String?

    public init(
        memberAccountId: Swift.String? = nil
    )
    {
        self.memberAccountId = memberAccountId
    }
}

struct RegisterOrganizationDelegatedAdminInputBody: Swift.Equatable {
    let memberAccountId: Swift.String?
}

extension RegisterOrganizationDelegatedAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountId = "MemberAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberAccountId)
        memberAccountId = memberAccountIdDecoded
    }
}

extension RegisterOrganizationDelegatedAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Returns the following response if successful. Otherwise, returns an error.
public struct RegisterOrganizationDelegatedAdminOutput: Swift.Equatable {

    public init() { }
}

enum RegisterOrganizationDelegatedAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccountNotFound": return try await AccountNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AccountRegistered": return try await AccountRegisteredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CannotDelegateManagementAccount": return try await CannotDelegateManagementAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudTrailAccessNotEnabled": return try await CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DelegatedAdminAccountLimitExceeded": return try await DelegatedAdminAccountLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationManagementAccount": return try await NotOrganizationManagementAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotInAllFeaturesMode": return try await OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationsNotInUse": return try await OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
    }
}

extension RemoveTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies the tags to remove from a trail, event data store, or channel.
public struct RemoveTagsInput: Swift.Equatable {
    /// Specifies the ARN of the trail, event data store, or channel from which tags should be removed. Example trail ARN format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail Example event data store ARN format: arn:aws:cloudtrail:us-east-2:123456789012:eventdatastore/EXAMPLE-f852-4e8f-8bd1-bcf6cEXAMPLE Example channel ARN format: arn:aws:cloudtrail:us-east-2:123456789012:channel/01234567890
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies a list of tags to be removed.
    /// This member is required.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

struct RemoveTagsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let tagsList: [CloudTrailClientTypes.Tag]?
}

extension RemoveTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension RemoveTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct RemoveTagsOutput: Swift.Equatable {

    public init() { }
}

enum RemoveTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ChannelARNInvalid": return try await ChannelARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelNotFound": return try await ChannelNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagParameter": return try await InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFound": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceTypeNotSupported": return try await ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudTrailClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CloudTrailClientTypes {
    /// Specifies the type and name of a resource referenced by an event.
    public struct Resource: Swift.Equatable {
        /// The name of the resource referenced by the event returned. These are user-created names whose values will depend on the environment. For example, the resource name might be "auto-scaling-test-group" for an Auto Scaling Group or "i-1234567" for an EC2 Instance.
        public var resourceName: Swift.String?
        /// The type of a resource referenced by the event returned. When the resource type cannot be determined, null is returned. Some examples of resource types are: Instance for EC2, Trail for CloudTrail, DBInstance for Amazon RDS, and AccessKey for IAM. To learn more about how to look up and filter events by the resource types supported for a service, see [Filtering CloudTrail Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/view-cloudtrail-events-console.html#filtering-cloudtrail-events).
        public var resourceType: Swift.String?

        public init(
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }

}

extension ResourceARNNotValidException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceARNNotValidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the provided resource does not exist, or the ARN format of the resource is not valid. The following is the valid format for a resource ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/MyChannel.
public struct ResourceARNNotValidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceARNNotValid" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceARNNotValidExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceARNNotValidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified resource is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourcePolicyNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourcePolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified resource policy is not found.
public struct ResourcePolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePolicyNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourcePolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourcePolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourcePolicyNotValidException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourcePolicyNotValidExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the resouce-based policy has syntax errors, or contains a principal that is not valid. The following are requirements for the resource policy:
///
/// * Contains only one action: cloudtrail-data:PutAuditEvents
///
/// * Contains at least one statement. The policy can have a maximum of 20 statements.
///
/// * Each statement contains at least one principal. A statement can have a maximum of 50 principals.
public struct ResourcePolicyNotValidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePolicyNotValid" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourcePolicyNotValidExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourcePolicyNotValidExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tag0 in tagsList {
                try tagsListContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[CloudTrailClientTypes.Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [CloudTrailClientTypes.Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension CloudTrailClientTypes {
    /// A resource tag.
    public struct ResourceTag: Swift.Equatable {
        /// Specifies the ARN of the resource.
        public var resourceId: Swift.String?
        /// A list of tags.
        public var tagsList: [CloudTrailClientTypes.Tag]?

        public init(
            resourceId: Swift.String? = nil,
            tagsList: [CloudTrailClientTypes.Tag]? = nil
        )
        {
            self.resourceId = resourceId
            self.tagsList = tagsList
        }
    }

}

extension ResourceTypeNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified resource type is not supported by CloudTrail.
public struct ResourceTypeNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceTypeNotSupported" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceTypeNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceTypeNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestoreEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
    }
}

extension RestoreEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RestoreEventDataStoreInput: Swift.Equatable {
    /// The ARN (or the ID suffix of the ARN) of the event data store that you want to restore.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

struct RestoreEventDataStoreInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
}

extension RestoreEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
    }
}

extension RestoreEventDataStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestoreEventDataStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.createdTimestamp = output.createdTimestamp
            self.eventDataStoreArn = output.eventDataStoreArn
            self.kmsKeyId = output.kmsKeyId
            self.multiRegionEnabled = output.multiRegionEnabled
            self.name = output.name
            self.organizationEnabled = output.organizationEnabled
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.terminationProtectionEnabled = output.terminationProtectionEnabled
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.advancedEventSelectors = nil
            self.createdTimestamp = nil
            self.eventDataStoreArn = nil
            self.kmsKeyId = nil
            self.multiRegionEnabled = nil
            self.name = nil
            self.organizationEnabled = nil
            self.retentionPeriod = nil
            self.status = nil
            self.terminationProtectionEnabled = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct RestoreEventDataStoreOutput: Swift.Equatable {
    /// The advanced event selectors that were used to select events.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The timestamp of an event data store's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The event data store ARN.
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store is collecting events from all Regions, or only from the Region in which the event data store was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of the event data store.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// Indicates that termination protection is enabled and the event data store cannot be automatically deleted.
    public var terminationProtectionEnabled: Swift.Bool?
    /// The timestamp that shows when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: ClientRuntime.Date?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

struct RestoreEventDataStoreOutputBody: Swift.Equatable {
    let eventDataStoreArn: Swift.String?
    let name: Swift.String?
    let status: CloudTrailClientTypes.EventDataStoreStatus?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
}

extension RestoreEventDataStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

enum RestoreEventDataStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailAccessNotEnabled": return try await CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreMaxLimitExceeded": return try await EventDataStoreMaxLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventDataStoreStatus": return try await InvalidEventDataStoreStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotInAllFeaturesMode": return try await OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationsNotInUse": return try await OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension S3BucketDoesNotExistException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: S3BucketDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified S3 bucket does not exist.
public struct S3BucketDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "S3BucketDoesNotExist" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct S3BucketDoesNotExistExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension S3BucketDoesNotExistExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.S3ImportSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketAccessRoleArn = "S3BucketAccessRoleArn"
        case s3BucketRegion = "S3BucketRegion"
        case s3LocationUri = "S3LocationUri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketAccessRoleArn = self.s3BucketAccessRoleArn {
            try encodeContainer.encode(s3BucketAccessRoleArn, forKey: .s3BucketAccessRoleArn)
        }
        if let s3BucketRegion = self.s3BucketRegion {
            try encodeContainer.encode(s3BucketRegion, forKey: .s3BucketRegion)
        }
        if let s3LocationUri = self.s3LocationUri {
            try encodeContainer.encode(s3LocationUri, forKey: .s3LocationUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3LocationUri)
        s3LocationUri = s3LocationUriDecoded
        let s3BucketRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketRegion)
        s3BucketRegion = s3BucketRegionDecoded
        let s3BucketAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketAccessRoleArn)
        s3BucketAccessRoleArn = s3BucketAccessRoleArnDecoded
    }
}

extension CloudTrailClientTypes {
    /// The settings for the source S3 bucket.
    public struct S3ImportSource: Swift.Equatable {
        /// The IAM ARN role used to access the source S3 bucket.
        /// This member is required.
        public var s3BucketAccessRoleArn: Swift.String?
        /// The Region associated with the source S3 bucket.
        /// This member is required.
        public var s3BucketRegion: Swift.String?
        /// The URI for the source S3 bucket.
        /// This member is required.
        public var s3LocationUri: Swift.String?

        public init(
            s3BucketAccessRoleArn: Swift.String? = nil,
            s3BucketRegion: Swift.String? = nil,
            s3LocationUri: Swift.String? = nil
        )
        {
            self.s3BucketAccessRoleArn = s3BucketAccessRoleArn
            self.s3BucketRegion = s3BucketRegion
            self.s3LocationUri = s3LocationUri
        }
    }

}

extension CloudTrailClientTypes.SourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case applyToAllRegions = "ApplyToAllRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let applyToAllRegions = self.applyToAllRegions {
            try encodeContainer.encode(applyToAllRegions, forKey: .applyToAllRegions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyToAllRegionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .applyToAllRegions)
        applyToAllRegions = applyToAllRegionsDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension CloudTrailClientTypes {
    /// Contains configuration information about the channel.
    public struct SourceConfig: Swift.Equatable {
        /// The advanced event selectors that are configured for the channel.
        public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
        /// Specifies whether the channel applies to a single Region or to all Regions.
        public var applyToAllRegions: Swift.Bool?

        public init(
            advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
            applyToAllRegions: Swift.Bool? = nil
        )
        {
            self.advancedEventSelectors = advancedEventSelectors
            self.applyToAllRegions = applyToAllRegions
        }
    }

}

extension StartEventDataStoreIngestionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
    }
}

extension StartEventDataStoreIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartEventDataStoreIngestionInput: Swift.Equatable {
    /// The ARN (or ID suffix of the ARN) of the event data store for which you want to start ingestion.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

struct StartEventDataStoreIngestionInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
}

extension StartEventDataStoreIngestionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
    }
}

extension StartEventDataStoreIngestionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartEventDataStoreIngestionOutput: Swift.Equatable {

    public init() { }
}

enum StartEventDataStoreIngestionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventDataStoreCategory": return try await InvalidEventDataStoreCategoryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventDataStoreStatus": return try await InvalidEventDataStoreStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartImportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case startEventTime = "StartEventTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for eventdatastorearn0 in destinations {
                try destinationsContainer.encode(eventdatastorearn0)
            }
        }
        if let endEventTime = self.endEventTime {
            try encodeContainer.encodeTimestamp(endEventTime, format: .epochSeconds, forKey: .endEventTime)
        }
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
        if let importSource = self.importSource {
            try encodeContainer.encode(importSource, forKey: .importSource)
        }
        if let startEventTime = self.startEventTime {
            try encodeContainer.encodeTimestamp(startEventTime, format: .epochSeconds, forKey: .startEventTime)
        }
    }
}

extension StartImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartImportInput: Swift.Equatable {
    /// The ARN of the destination event data store. Use this parameter for a new import.
    public var destinations: [Swift.String]?
    /// Use with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period. When you specify a time range, CloudTrail checks the prefix and log file names to verify the names contain a date between the specified StartEventTime and EndEventTime before attempting to import events.
    public var endEventTime: ClientRuntime.Date?
    /// The ID of the import. Use this parameter when you are retrying an import.
    public var importId: Swift.String?
    /// The source S3 bucket for the import. Use this parameter for a new import.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Use with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period. When you specify a time range, CloudTrail checks the prefix and log file names to verify the names contain a date between the specified StartEventTime and EndEventTime before attempting to import events.
    public var startEventTime: ClientRuntime.Date?

    public init(
        destinations: [Swift.String]? = nil,
        endEventTime: ClientRuntime.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        startEventTime: ClientRuntime.Date? = nil
    )
    {
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.startEventTime = startEventTime
    }
}

struct StartImportInputBody: Swift.Equatable {
    let destinations: [Swift.String]?
    let importSource: CloudTrailClientTypes.ImportSource?
    let startEventTime: ClientRuntime.Date?
    let endEventTime: ClientRuntime.Date?
    let importId: Swift.String?
}

extension StartImportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case startEventTime = "StartEventTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let importSourceDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportSource.self, forKey: .importSource)
        importSource = importSourceDecoded
        let startEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startEventTime)
        startEventTime = startEventTimeDecoded
        let endEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endEventTime)
        endEventTime = endEventTimeDecoded
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

extension StartImportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImportOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.destinations = output.destinations
            self.endEventTime = output.endEventTime
            self.importId = output.importId
            self.importSource = output.importSource
            self.importStatus = output.importStatus
            self.startEventTime = output.startEventTime
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.createdTimestamp = nil
            self.destinations = nil
            self.endEventTime = nil
            self.importId = nil
            self.importSource = nil
            self.importStatus = nil
            self.startEventTime = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct StartImportOutput: Swift.Equatable {
    /// The timestamp for the import's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the destination event data store.
    public var destinations: [Swift.String]?
    /// Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var endEventTime: ClientRuntime.Date?
    /// The ID of the import.
    public var importId: Swift.String?
    /// The source S3 bucket for the import.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Shows the status of the import after a StartImport request. An import finishes with a status of COMPLETED if there were no failures, or FAILED if there were failures.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var startEventTime: ClientRuntime.Date?
    /// The timestamp of the import's last update, if applicable.
    public var updatedTimestamp: ClientRuntime.Date?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        destinations: [Swift.String]? = nil,
        endEventTime: ClientRuntime.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        startEventTime: ClientRuntime.Date? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.importStatus = importStatus
        self.startEventTime = startEventTime
        self.updatedTimestamp = updatedTimestamp
    }
}

struct StartImportOutputBody: Swift.Equatable {
    let importId: Swift.String?
    let destinations: [Swift.String]?
    let importSource: CloudTrailClientTypes.ImportSource?
    let startEventTime: ClientRuntime.Date?
    let endEventTime: ClientRuntime.Date?
    let importStatus: CloudTrailClientTypes.ImportStatus?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
}

extension StartImportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case importStatus = "ImportStatus"
        case startEventTime = "StartEventTime"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let importSourceDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportSource.self, forKey: .importSource)
        importSource = importSourceDecoded
        let startEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startEventTime)
        startEventTime = startEventTimeDecoded
        let endEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endEventTime)
        endEventTime = endEventTimeDecoded
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

enum StartImportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccountHasOngoingImport": return try await AccountHasOngoingImportException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ImportNotFound": return try await ImportNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientEncryptionPolicy": return try await InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventDataStoreCategory": return try await InvalidEventDataStoreCategoryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventDataStoreStatus": return try await InvalidEventDataStoreStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidImportSource": return try await InvalidImportSourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// The request to CloudTrail to start logging Amazon Web Services API calls for an account.
public struct StartLoggingInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail for which CloudTrail logs Amazon Web Services API calls. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StartLoggingInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StartLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartLoggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct StartLoggingOutput: Swift.Equatable {

    public init() { }
}

enum StartLoggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidHomeRegion": return try await InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryS3Uri = "DeliveryS3Uri"
        case queryAlias = "QueryAlias"
        case queryParameters = "QueryParameters"
        case queryStatement = "QueryStatement"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryS3Uri = self.deliveryS3Uri {
            try encodeContainer.encode(deliveryS3Uri, forKey: .deliveryS3Uri)
        }
        if let queryAlias = self.queryAlias {
            try encodeContainer.encode(queryAlias, forKey: .queryAlias)
        }
        if let queryParameters = queryParameters {
            var queryParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryParameters)
            for queryparameter0 in queryParameters {
                try queryParametersContainer.encode(queryparameter0)
            }
        }
        if let queryStatement = self.queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
    }
}

extension StartQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartQueryInput: Swift.Equatable {
    /// The URI for the S3 bucket where CloudTrail delivers the query results.
    public var deliveryS3Uri: Swift.String?
    /// The alias that identifies a query template.
    public var queryAlias: Swift.String?
    /// The query parameters for the specified QueryAlias.
    public var queryParameters: [Swift.String]?
    /// The SQL code of your query.
    public var queryStatement: Swift.String?

    public init(
        deliveryS3Uri: Swift.String? = nil,
        queryAlias: Swift.String? = nil,
        queryParameters: [Swift.String]? = nil,
        queryStatement: Swift.String? = nil
    )
    {
        self.deliveryS3Uri = deliveryS3Uri
        self.queryAlias = queryAlias
        self.queryParameters = queryParameters
        self.queryStatement = queryStatement
    }
}

struct StartQueryInputBody: Swift.Equatable {
    let queryStatement: Swift.String?
    let deliveryS3Uri: Swift.String?
    let queryAlias: Swift.String?
    let queryParameters: [Swift.String]?
}

extension StartQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryS3Uri = "DeliveryS3Uri"
        case queryAlias = "QueryAlias"
        case queryParameters = "QueryParameters"
        case queryStatement = "QueryStatement"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStatementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let deliveryS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryS3Uri)
        deliveryS3Uri = deliveryS3UriDecoded
        let queryAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryAlias)
        queryAlias = queryAliasDecoded
        let queryParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .queryParameters)
        var queryParametersDecoded0:[Swift.String]? = nil
        if let queryParametersContainer = queryParametersContainer {
            queryParametersDecoded0 = [Swift.String]()
            for string0 in queryParametersContainer {
                if let string0 = string0 {
                    queryParametersDecoded0?.append(string0)
                }
            }
        }
        queryParameters = queryParametersDecoded0
    }
}

extension StartQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.queryId = output.queryId
        } else {
            self.queryId = nil
        }
    }
}

public struct StartQueryOutput: Swift.Equatable {
    /// The ID of the started query.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

struct StartQueryOutputBody: Swift.Equatable {
    let queryId: Swift.String?
}

extension StartQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryId = "QueryId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryId)
        queryId = queryIdDecoded
    }
}

enum StartQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientEncryptionPolicy": return try await InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientS3BucketPolicy": return try await InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidQueryStatement": return try await InvalidQueryStatementException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidS3BucketName": return try await InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidS3Prefix": return try await InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MaxConcurrentQueries": return try await MaxConcurrentQueriesException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3BucketDoesNotExist": return try await S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopEventDataStoreIngestionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
    }
}

extension StopEventDataStoreIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopEventDataStoreIngestionInput: Swift.Equatable {
    /// The ARN (or ID suffix of the ARN) of the event data store for which you want to stop ingestion.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

struct StopEventDataStoreIngestionInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
}

extension StopEventDataStoreIngestionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataStore = "EventDataStore"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
    }
}

extension StopEventDataStoreIngestionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopEventDataStoreIngestionOutput: Swift.Equatable {

    public init() { }
}

enum StopEventDataStoreIngestionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventDataStoreCategory": return try await InvalidEventDataStoreCategoryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventDataStoreStatus": return try await InvalidEventDataStoreStatusException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopImportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importId = self.importId {
            try encodeContainer.encode(importId, forKey: .importId)
        }
    }
}

extension StopImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopImportInput: Swift.Equatable {
    /// The ID of the import.
    /// This member is required.
    public var importId: Swift.String?

    public init(
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

struct StopImportInputBody: Swift.Equatable {
    let importId: Swift.String?
}

extension StopImportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId = "ImportId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

extension StopImportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopImportOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTimestamp = output.createdTimestamp
            self.destinations = output.destinations
            self.endEventTime = output.endEventTime
            self.importId = output.importId
            self.importSource = output.importSource
            self.importStatistics = output.importStatistics
            self.importStatus = output.importStatus
            self.startEventTime = output.startEventTime
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.createdTimestamp = nil
            self.destinations = nil
            self.endEventTime = nil
            self.importId = nil
            self.importSource = nil
            self.importStatistics = nil
            self.importStatus = nil
            self.startEventTime = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct StopImportOutput: Swift.Equatable {
    /// The timestamp of the import's creation.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the destination event data store.
    public var destinations: [Swift.String]?
    /// Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var endEventTime: ClientRuntime.Date?
    /// The ID for the import.
    public var importId: Swift.String?
    /// The source S3 bucket for the import.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Returns information on the stopped import.
    public var importStatistics: CloudTrailClientTypes.ImportStatistics?
    /// The status of the import.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var startEventTime: ClientRuntime.Date?
    /// The timestamp of the import's last update.
    public var updatedTimestamp: ClientRuntime.Date?

    public init(
        createdTimestamp: ClientRuntime.Date? = nil,
        destinations: [Swift.String]? = nil,
        endEventTime: ClientRuntime.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        importStatistics: CloudTrailClientTypes.ImportStatistics? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        startEventTime: ClientRuntime.Date? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.importStatistics = importStatistics
        self.importStatus = importStatus
        self.startEventTime = startEventTime
        self.updatedTimestamp = updatedTimestamp
    }
}

struct StopImportOutputBody: Swift.Equatable {
    let importId: Swift.String?
    let importSource: CloudTrailClientTypes.ImportSource?
    let destinations: [Swift.String]?
    let importStatus: CloudTrailClientTypes.ImportStatus?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let startEventTime: ClientRuntime.Date?
    let endEventTime: ClientRuntime.Date?
    let importStatistics: CloudTrailClientTypes.ImportStatistics?
}

extension StopImportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case destinations = "Destinations"
        case endEventTime = "EndEventTime"
        case importId = "ImportId"
        case importSource = "ImportSource"
        case importStatistics = "ImportStatistics"
        case importStatus = "ImportStatus"
        case startEventTime = "StartEventTime"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
        let importSourceDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportSource.self, forKey: .importSource)
        importSource = importSourceDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .destinations)
        var destinationsDecoded0:[Swift.String]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Swift.String]()
            for string0 in destinationsContainer {
                if let string0 = string0 {
                    destinationsDecoded0?.append(string0)
                }
            }
        }
        destinations = destinationsDecoded0
        let importStatusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatus.self, forKey: .importStatus)
        importStatus = importStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let startEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startEventTime)
        startEventTime = startEventTimeDecoded
        let endEventTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endEventTime)
        endEventTime = endEventTimeDecoded
        let importStatisticsDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.ImportStatistics.self, forKey: .importStatistics)
        importStatistics = importStatisticsDecoded
    }
}

enum StopImportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ImportNotFound": return try await ImportNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopLoggingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StopLoggingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Passes the request to CloudTrail to stop logging Amazon Web Services API calls for the specified account.
public struct StopLoggingInput: Swift.Equatable {
    /// Specifies the name or the CloudTrail ARN of the trail for which CloudTrail will stop logging Amazon Web Services API calls. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopLoggingInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StopLoggingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopLoggingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct StopLoggingOutput: Swift.Equatable {

    public init() { }
}

enum StopLoggingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidHomeRegion": return try await InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudTrailClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudTrailClientTypes {
    /// A custom key-value pair associated with a resource such as a CloudTrail trail, event data store, or channel.
    public struct Tag: Swift.Equatable {
        /// The key in a key-value pair. The key must be must be no longer than 128 Unicode characters. The key must be unique for the resource to which it applies.
        /// This member is required.
        public var key: Swift.String?
        /// The value in a key-value pair of a tag. The value must be no longer than 256 Unicode characters.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagsLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of tags per trail, event data store, or channel has exceeded the permitted amount. Currently, the limit is 50.
public struct TagsLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagsLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagsLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the request rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.Trail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case hasCustomEventSelectors = "HasCustomEventSelectors"
        case hasInsightSelectors = "HasInsightSelectors"
        case homeRegion = "HomeRegion"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = self.cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let hasCustomEventSelectors = self.hasCustomEventSelectors {
            try encodeContainer.encode(hasCustomEventSelectors, forKey: .hasCustomEventSelectors)
        }
        if let hasInsightSelectors = self.hasInsightSelectors {
            try encodeContainer.encode(hasInsightSelectors, forKey: .hasInsightSelectors)
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let includeGlobalServiceEvents = self.includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = self.isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = self.isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logFileValidationEnabled = self.logFileValidationEnabled {
            try encodeContainer.encode(logFileValidationEnabled, forKey: .logFileValidationEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicARN = self.snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
        if let snsTopicName = self.snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let trailARN = self.trailARN {
            try encodeContainer.encode(trailARN, forKey: .trailARN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let hasCustomEventSelectorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasCustomEventSelectors)
        hasCustomEventSelectors = hasCustomEventSelectorsDecoded
        let hasInsightSelectorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasInsightSelectors)
        hasInsightSelectors = hasInsightSelectorsDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension CloudTrailClientTypes {
    /// The settings for a trail.
    public struct Trail: Swift.Equatable {
        /// Specifies an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Specifies if the trail has custom event selectors.
        public var hasCustomEventSelectors: Swift.Bool?
        /// Specifies whether a trail has insight types specified in an InsightSelector list.
        public var hasInsightSelectors: Swift.Bool?
        /// The Region in which the trail was created.
        public var homeRegion: Swift.String?
        /// Set to True to include Amazon Web Services API calls from Amazon Web Services global services such as IAM. Otherwise, False.
        public var includeGlobalServiceEvents: Swift.Bool?
        /// Specifies whether the trail exists only in one Region or exists in all Regions.
        public var isMultiRegionTrail: Swift.Bool?
        /// Specifies whether the trail is an organization trail.
        public var isOrganizationTrail: Swift.Bool?
        /// Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
        public var kmsKeyId: Swift.String?
        /// Specifies whether log file validation is enabled.
        public var logFileValidationEnabled: Swift.Bool?
        /// Name of the trail set by calling [CreateTrail]. The maximum length is 128 characters.
        public var name: Swift.String?
        /// Name of the Amazon S3 bucket into which CloudTrail delivers your trail files. See [Amazon S3 Bucket Naming Requirements](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html).
        public var s3BucketName: Swift.String?
        /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html). The maximum length is 200 characters.
        public var s3KeyPrefix: Swift.String?
        /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The following is the format of a topic ARN. arn:aws:sns:us-east-2:123456789012:MyTopic
        public var snsTopicARN: Swift.String?
        /// This field is no longer in use. Use SnsTopicARN.
        @available(*, deprecated)
        public var snsTopicName: Swift.String?
        /// Specifies the ARN of the trail. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
        public var trailARN: Swift.String?

        public init(
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            cloudWatchLogsRoleArn: Swift.String? = nil,
            hasCustomEventSelectors: Swift.Bool? = nil,
            hasInsightSelectors: Swift.Bool? = nil,
            homeRegion: Swift.String? = nil,
            includeGlobalServiceEvents: Swift.Bool? = nil,
            isMultiRegionTrail: Swift.Bool? = nil,
            isOrganizationTrail: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            logFileValidationEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            snsTopicARN: Swift.String? = nil,
            snsTopicName: Swift.String? = nil,
            trailARN: Swift.String? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.hasCustomEventSelectors = hasCustomEventSelectors
            self.hasInsightSelectors = hasInsightSelectors
            self.homeRegion = homeRegion
            self.includeGlobalServiceEvents = includeGlobalServiceEvents
            self.isMultiRegionTrail = isMultiRegionTrail
            self.isOrganizationTrail = isOrganizationTrail
            self.kmsKeyId = kmsKeyId
            self.logFileValidationEnabled = logFileValidationEnabled
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.snsTopicARN = snsTopicARN
            self.snsTopicName = snsTopicName
            self.trailARN = trailARN
        }
    }

}

extension TrailAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TrailAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the specified trail already exists.
public struct TrailAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrailAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TrailAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrailAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailClientTypes.TrailInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case homeRegion = "HomeRegion"
        case name = "Name"
        case trailARN = "TrailARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trailARN = self.trailARN {
            try encodeContainer.encode(trailARN, forKey: .trailARN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
    }
}

extension CloudTrailClientTypes {
    /// Information about a CloudTrail trail, including the trail's name, home Region, and Amazon Resource Name (ARN).
    public struct TrailInfo: Swift.Equatable {
        /// The Amazon Web Services Region in which a trail was created.
        public var homeRegion: Swift.String?
        /// The name of a trail.
        public var name: Swift.String?
        /// The ARN of a trail.
        public var trailARN: Swift.String?

        public init(
            homeRegion: Swift.String? = nil,
            name: Swift.String? = nil,
            trailARN: Swift.String? = nil
        )
        {
            self.homeRegion = homeRegion
            self.name = name
            self.trailARN = trailARN
        }
    }

}

extension TrailNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TrailNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the trail with the given name is not found.
public struct TrailNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrailNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TrailNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrailNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrailNotProvidedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TrailNotProvidedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is no longer in use.
public struct TrailNotProvidedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrailNotProvided" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TrailNotProvidedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TrailNotProvidedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the requested operation is not supported.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case destinations = "Destinations"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for destination0 in destinations {
                try destinationsContainer.encode(destination0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The ARN or ID (the ARN suffix) of the channel that you want to update.
    /// This member is required.
    public var channel: Swift.String?
    /// The ARNs of event data stores that you want to log events arriving through the channel.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// Changes the name of the channel.
    public var name: Swift.String?

    public init(
        channel: Swift.String? = nil,
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        name: Swift.String? = nil
    )
    {
        self.channel = channel
        self.destinations = destinations
        self.name = name
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let channel: Swift.String?
    let destinations: [CloudTrailClientTypes.Destination]?
    let name: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
        case destinations = "Destinations"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channel)
        channel = channelDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[CloudTrailClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [CloudTrailClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.destinations = output.destinations
            self.name = output.name
            self.source = output.source
        } else {
            self.channelArn = nil
            self.destinations = nil
            self.name = nil
            self.source = nil
        }
    }
}

public struct UpdateChannelOutput: Swift.Equatable {
    /// The ARN of the channel that was updated.
    public var channelArn: Swift.String?
    /// The event data stores that log events arriving through the channel.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// The name of the channel that was updated.
    public var name: Swift.String?
    /// The event source of the channel that was updated.
    public var source: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        name: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.destinations = destinations
        self.name = name
        self.source = source
    }
}

struct UpdateChannelOutputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let name: Swift.String?
    let source: Swift.String?
    let destinations: [CloudTrailClientTypes.Destination]?
}

extension UpdateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case destinations = "Destinations"
        case name = "Name"
        case source = "Source"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[CloudTrailClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [CloudTrailClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

enum UpdateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ChannelAlreadyExists": return try await ChannelAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelARNInvalid": return try await ChannelARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelNotFound": return try await ChannelNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventDataStoreCategory": return try await InvalidEventDataStoreCategoryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEventDataStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventDataStore = "EventDataStore"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselector0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselector0)
            }
        }
        if let eventDataStore = self.eventDataStore {
            try encodeContainer.encode(eventDataStore, forKey: .eventDataStore)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let multiRegionEnabled = self.multiRegionEnabled {
            try encodeContainer.encode(multiRegionEnabled, forKey: .multiRegionEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationEnabled = self.organizationEnabled {
            try encodeContainer.encode(organizationEnabled, forKey: .organizationEnabled)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let terminationProtectionEnabled = self.terminationProtectionEnabled {
            try encodeContainer.encode(terminationProtectionEnabled, forKey: .terminationProtectionEnabled)
        }
    }
}

extension UpdateEventDataStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEventDataStoreInput: Swift.Equatable {
    /// The advanced event selectors used to select events for the event data store. You can configure up to five advanced event selectors for each event data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The ARN (or the ID suffix of the ARN) of the event data store that you want to update.
    /// This member is required.
    public var eventDataStore: Swift.String?
    /// Specifies the KMS key ID to use to encrypt the events delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. Disabling or deleting the KMS key, or removing CloudTrail permissions on the key, prevents CloudTrail from logging events to the event data store, and prevents users from querying the data in the event data store that was encrypted with the key. After you associate an event data store with a KMS key, the KMS key cannot be removed or changed. Before you disable or delete a KMS key that you are using with an event data store, delete or back up your event data store. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether an event data store collects events from all Regions, or only from the Region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The event data store name.
    public var name: Swift.String?
    /// Specifies whether an event data store collects events logged for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of the event data store, in days. You can set a retention period of up to 2557 days, the equivalent of seven years. CloudTrail Lake determines whether to retain an event by checking if the eventTime of the event is within the specified retention period. For example, if you set a retention period of 90 days, CloudTrail will remove events when the eventTime is older than 90 days. If you decrease the retention period of an event data store, CloudTrail will remove any events with an eventTime older than the new retention period. For example, if the previous retention period was 365 days and you decrease it to 100 days, CloudTrail will remove events with an eventTime older than 100 days.
    public var retentionPeriod: Swift.Int?
    /// Indicates that termination protection is enabled and the event data store cannot be automatically deleted.
    public var terminationProtectionEnabled: Swift.Bool?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventDataStore: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventDataStore = eventDataStore
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.terminationProtectionEnabled = terminationProtectionEnabled
    }
}

struct UpdateEventDataStoreInputBody: Swift.Equatable {
    let eventDataStore: Swift.String?
    let name: Swift.String?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let kmsKeyId: Swift.String?
}

extension UpdateEventDataStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventDataStore = "EventDataStore"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStore)
        eventDataStore = eventDataStoreDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension UpdateEventDataStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEventDataStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.createdTimestamp = output.createdTimestamp
            self.eventDataStoreArn = output.eventDataStoreArn
            self.kmsKeyId = output.kmsKeyId
            self.multiRegionEnabled = output.multiRegionEnabled
            self.name = output.name
            self.organizationEnabled = output.organizationEnabled
            self.retentionPeriod = output.retentionPeriod
            self.status = output.status
            self.terminationProtectionEnabled = output.terminationProtectionEnabled
            self.updatedTimestamp = output.updatedTimestamp
        } else {
            self.advancedEventSelectors = nil
            self.createdTimestamp = nil
            self.eventDataStoreArn = nil
            self.kmsKeyId = nil
            self.multiRegionEnabled = nil
            self.name = nil
            self.organizationEnabled = nil
            self.retentionPeriod = nil
            self.status = nil
            self.terminationProtectionEnabled = nil
            self.updatedTimestamp = nil
        }
    }
}

public struct UpdateEventDataStoreOutput: Swift.Equatable {
    /// The advanced event selectors that are applied to the event data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The timestamp that shows when an event data store was first created.
    public var createdTimestamp: ClientRuntime.Date?
    /// The ARN of the event data store.
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store includes events from all Regions, or only from the Region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of an event data store.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// Indicates whether termination protection is enabled for the event data store.
    public var terminationProtectionEnabled: Swift.Bool?
    /// The timestamp that shows when the event data store was last updated. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: ClientRuntime.Date?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        createdTimestamp: ClientRuntime.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

struct UpdateEventDataStoreOutputBody: Swift.Equatable {
    let eventDataStoreArn: Swift.String?
    let name: Swift.String?
    let status: CloudTrailClientTypes.EventDataStoreStatus?
    let advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    let multiRegionEnabled: Swift.Bool?
    let organizationEnabled: Swift.Bool?
    let retentionPeriod: Swift.Int?
    let terminationProtectionEnabled: Swift.Bool?
    let createdTimestamp: ClientRuntime.Date?
    let updatedTimestamp: ClientRuntime.Date?
    let kmsKeyId: Swift.String?
}

extension UpdateEventDataStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case createdTimestamp = "CreatedTimestamp"
        case eventDataStoreArn = "EventDataStoreArn"
        case kmsKeyId = "KmsKeyId"
        case multiRegionEnabled = "MultiRegionEnabled"
        case name = "Name"
        case organizationEnabled = "OrganizationEnabled"
        case retentionPeriod = "RetentionPeriod"
        case status = "Status"
        case terminationProtectionEnabled = "TerminationProtectionEnabled"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDataStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDataStoreArn)
        eventDataStoreArn = eventDataStoreArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudTrailClientTypes.EventDataStoreStatus.self, forKey: .status)
        status = statusDecoded
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([CloudTrailClientTypes.AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[CloudTrailClientTypes.AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [CloudTrailClientTypes.AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
        let multiRegionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiRegionEnabled)
        multiRegionEnabled = multiRegionEnabledDecoded
        let organizationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .organizationEnabled)
        organizationEnabled = organizationEnabledDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let terminationProtectionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminationProtectionEnabled)
        terminationProtectionEnabled = terminationProtectionEnabledDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

enum UpdateEventDataStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailAccessNotEnabled": return try await CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreAlreadyExists": return try await EventDataStoreAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreARNInvalid": return try await EventDataStoreARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreHasOngoingImport": return try await EventDataStoreHasOngoingImportException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "EventDataStoreNotFound": return try await EventDataStoreNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InactiveEventDataStore": return try await InactiveEventDataStoreException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientEncryptionPolicy": return try await InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventSelectors": return try await InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidKmsKeyId": return try await InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsKeyNotFound": return try await KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotInAllFeaturesMode": return try await OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationsNotInUse": return try await OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTrailInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = self.cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let enableLogFileValidation = self.enableLogFileValidation {
            try encodeContainer.encode(enableLogFileValidation, forKey: .enableLogFileValidation)
        }
        if let includeGlobalServiceEvents = self.includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = self.isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = self.isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicName = self.snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
    }
}

extension UpdateTrailInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Specifies settings to update for the trail.
public struct UpdateTrailInput: Swift.Equatable {
    /// Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs are delivered. You must use a log group that exists in your account. Not required unless you specify CloudWatchLogsRoleArn.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group. You must use a role that exists in your account.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether log file validation is enabled. The default is false. When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail does not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.
    public var enableLogFileValidation: Swift.Bool?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail applies only to the current Region or to all Regions. The default is false. If the trail exists only in the current Region and this value is set to true, shadow trails (replications of the trail) will be created in the other Regions. If the trail exists in all Regions and this value is set to false, the trail will remain in the Region where it was created, and its shadow trails in other Regions will be deleted. As a best practice, consider using trails that log events in all Regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is applied to all accounts in an organization in Organizations, or only for the current Amazon Web Services account. The default is false, and cannot be true unless the call is made on behalf of an Amazon Web Services account that is the management account or delegated administrator account for an organization in Organizations. If the trail is not an organization trail and this is set to true, the trail will be created in all Amazon Web Services accounts that belong to the organization. If the trail is an organization trail and this is set to false, the trail will remain in the current Amazon Web Services account but be deleted from all member accounts in the organization.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by "alias/", a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies the name of the trail or trail ARN. If Name is a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If Name is a trail ARN, it must be in the following format. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files. See [Amazon S3 Bucket Naming Requirements](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html).
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html). The maximum length is 200 characters.
    public var s3KeyPrefix: Swift.String?
    /// Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
    public var snsTopicName: Swift.String?

    public init(
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        enableLogFileValidation: Swift.Bool? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicName: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
    }
}

struct UpdateTrailInputBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let enableLogFileValidation: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
}

extension UpdateTrailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let enableLogFileValidationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableLogFileValidation)
        enableLogFileValidation = enableLogFileValidationDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension UpdateTrailOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTrailOutputBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogsLogGroupArn = output.cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = output.cloudWatchLogsRoleArn
            self.includeGlobalServiceEvents = output.includeGlobalServiceEvents
            self.isMultiRegionTrail = output.isMultiRegionTrail
            self.isOrganizationTrail = output.isOrganizationTrail
            self.kmsKeyId = output.kmsKeyId
            self.logFileValidationEnabled = output.logFileValidationEnabled
            self.name = output.name
            self.s3BucketName = output.s3BucketName
            self.s3KeyPrefix = output.s3KeyPrefix
            self.snsTopicARN = output.snsTopicARN
            self.snsTopicName = output.snsTopicName
            self.trailARN = output.trailARN
        } else {
            self.cloudWatchLogsLogGroupArn = nil
            self.cloudWatchLogsRoleArn = nil
            self.includeGlobalServiceEvents = nil
            self.isMultiRegionTrail = nil
            self.isOrganizationTrail = nil
            self.kmsKeyId = nil
            self.logFileValidationEnabled = nil
            self.name = nil
            self.s3BucketName = nil
            self.s3KeyPrefix = nil
            self.snsTopicARN = nil
            self.snsTopicName = nil
            self.trailARN = nil
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct UpdateTrailOutput: Swift.Equatable {
    /// Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs are delivered.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail exists in one Region or in all Regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is an organization trail.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether log file integrity validation is enabled.
    public var logFileValidationEnabled: Swift.Bool?
    /// Specifies the name of the trail.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your IAM Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html).
    public var s3KeyPrefix: Swift.String?
    /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The following is the format of a topic ARN. arn:aws:sns:us-east-2:123456789012:MyTopic
    public var snsTopicARN: Swift.String?
    /// This field is no longer in use. Use SnsTopicARN.
    @available(*, deprecated)
    public var snsTopicName: Swift.String?
    /// Specifies the ARN of the trail that was updated. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init(
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        logFileValidationEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicARN: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

struct UpdateTrailOutputBody: Swift.Equatable {
    let name: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let snsTopicName: Swift.String?
    let snsTopicARN: Swift.String?
    let includeGlobalServiceEvents: Swift.Bool?
    let isMultiRegionTrail: Swift.Bool?
    let trailARN: Swift.String?
    let logFileValidationEnabled: Swift.Bool?
    let cloudWatchLogsLogGroupArn: Swift.String?
    let cloudWatchLogsRoleArn: Swift.String?
    let kmsKeyId: Swift.String?
    let isOrganizationTrail: Swift.Bool?
}

extension UpdateTrailOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

enum UpdateTrailOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "CloudTrailAccessNotEnabled": return try await CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudTrailARNInvalid": return try await CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudTrailInvalidClientTokenId": return try await CloudTrailInvalidClientTokenIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CloudWatchLogsDeliveryUnavailable": return try await CloudWatchLogsDeliveryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientDependencyServiceAccessPermission": return try await InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientEncryptionPolicy": return try await InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientS3BucketPolicy": return try await InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientSnsTopicPolicy": return try await InsufficientSnsTopicPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCloudWatchLogsLogGroupArn": return try await InvalidCloudWatchLogsLogGroupArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidCloudWatchLogsRoleArn": return try await InvalidCloudWatchLogsRoleArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEventSelectors": return try await InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidHomeRegion": return try await InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidKmsKeyId": return try await InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterCombinationError": return try await InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidS3BucketName": return try await InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidS3Prefix": return try await InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSnsTopicName": return try await InvalidSnsTopicNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTrailName": return try await InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsKeyDisabled": return try await KmsKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsKeyNotFound": return try await KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoManagementAccountSLRExists": return try await NoManagementAccountSLRExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotOrganizationMasterAccount": return try await NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationNotInAllFeaturesMode": return try await OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OrganizationsNotInUse": return try await OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "S3BucketDoesNotExist": return try await S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotFound": return try await TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TrailNotProvided": return try await TrailNotProvidedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperation": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
