//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.timestampReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when you start a new import and a previous import is still in progress.
public struct AccountHasOngoingImportException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountHasOngoingImport" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified account is not found or not part of an organization.
public struct AccountNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified account is not registered as the CloudTrail delegated administrator.
public struct AccountNotRegisteredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountNotRegistered" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the account is already registered as the CloudTrail delegated administrator.
public struct AccountRegisteredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountRegistered" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified value of ChannelARN is not valid.
public struct ChannelARNInvalidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelARNInvalid" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when CloudTrail cannot find the specified channel.
public struct ChannelNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when an operation is called with an ARN that is not valid. The following is the format of a trail ARN: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail The following is the format of an event data store ARN: arn:aws:cloudtrail:us-east-2:123456789012:eventdatastore/EXAMPLE-f852-4e8f-8bd1-bcf6cEXAMPLE The following is the format of a channel ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/01234567890
public struct CloudTrailARNInvalidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudTrailARNInvalid" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified resource is not ready for an operation. This can occur when you try to run an operation on a resource before CloudTrail has time to fully load the resource, or because another operation is modifying the resource. If this exception occurs, wait a few minutes, and then try the operation again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified event data store ARN is not valid or does not map to an event data store in your account.
public struct EventDataStoreARNInvalidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreARNInvalid" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified event data store was not found.
public struct EventDataStoreNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The event data store is inactive.
public struct InactiveEventDataStoreException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InactiveEventDataStore" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified tag key or values are not valid. It can also occur if there are duplicate tags or too many tags on the resource.
public struct InvalidTagParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagParameter" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:
///
/// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
///
/// * Start with a letter or number, and end with a letter or number
///
/// * Be between 3 and 128 characters
///
/// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
///
/// * Not be in IP address format (for example, 192.168.5.4)
public struct InvalidTrailNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTrailName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the management account does not have a service-linked role.
public struct NoManagementAccountSLRExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoManagementAccountSLRExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the Amazon Web Services account making the request to create or update an organization trail or event data store is not the management account for an organization in Organizations. For more information, see [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html) or [Organization event data stores](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-lake-organizations.html).
public struct NotOrganizationMasterAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotOrganizationMasterAccount" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the requested operation is not permitted.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermitted" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified resource is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified resource type is not supported by CloudTrail.
public struct ResourceTypeNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceTypeNotSupported" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of tags per trail, event data store, or channel has exceeded the permitted amount. Currently, the limit is 50.
public struct TagsLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagsLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the requested operation is not supported.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudTrailClientTypes {

    /// A custom key-value pair associated with a resource such as a CloudTrail trail, event data store, or channel.
    public struct Tag: Swift.Sendable {
        /// The key in a key-value pair. The key must be must be no longer than 128 Unicode characters. The key must be unique for the resource to which it applies.
        /// This member is required.
        public var key: Swift.String?
        /// The value in a key-value pair of a tag. The value must be no longer than 256 Unicode characters.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

/// Specifies the tags to add to a trail, event data store, or channel.
public struct AddTagsInput: Swift.Sendable {
    /// Specifies the ARN of the trail, event data store, or channel to which one or more tags will be added. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail The format of an event data store ARN is: arn:aws:cloudtrail:us-east-2:123456789012:eventdatastore/EXAMPLE-f852-4e8f-8bd1-bcf6cEXAMPLE The format of a channel ARN is: arn:aws:cloudtrail:us-east-2:123456789012:channel/01234567890
    /// This member is required.
    public var resourceId: Swift.String?
    /// Contains a list of tags, up to a limit of 50
    /// This member is required.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

/// Returns the objects or data if successful. Otherwise, returns an error.
public struct AddTagsOutput: Swift.Sendable {

    public init() { }
}

extension CloudTrailClientTypes {

    /// A single selector statement in an advanced event selector.
    public struct AdvancedFieldSelector: Swift.Sendable {
        /// An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        public var endsWith: [Swift.String]?
        /// An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
        public var equals: [Swift.String]?
        /// A field in a CloudTrail event record on which to filter events to be logged. For event data stores for CloudTrail Insights events, Config configuration items, Audit Manager evidence, or events outside of Amazon Web Services, the field is used only for selecting events as filtering is not supported. For CloudTrail management events, supported fields include eventCategory (required), eventSource, and readOnly. For CloudTrail data events, supported fields include eventCategory (required), resources.type (required), eventName, readOnly, and resources.ARN. For CloudTrail network activity events, supported fields include eventCategory (required), eventSource (required), eventName, errorCode, and vpcEndpointId. For event data stores for CloudTrail Insights events, Config configuration items, Audit Manager evidence, or events outside of Amazon Web Services, the only supported field is eventCategory.
        ///
        /// * readOnly - This is an optional field that is only used for management events and data events. This field can be set to Equals with a value of true or false. If you do not add this field, CloudTrail logs both read and write events. A value of true logs only read events. A value of false logs only write events.
        ///
        /// * eventSource - This field is only used for management events and network activity events. For management events, this is an optional field that can be set to NotEqualskms.amazonaws.com to exclude KMS management events, or NotEqualsrdsdata.amazonaws.com to exclude RDS management events. For network activity events, this is a required field that only uses the Equals operator. Set this field to the event source for which you want to log network activity events. If you want to log network activity events for multiple event sources, you must create a separate field selector for each event source. The following are valid values for network activity events:
        ///
        /// * cloudtrail.amazonaws.com
        ///
        /// * ec2.amazonaws.com
        ///
        /// * kms.amazonaws.com
        ///
        /// * secretsmanager.amazonaws.com
        ///
        ///
        ///
        ///
        /// * eventName - This is an optional field that is only used for data events and network activity events. You can use any operator with eventName. You can use it to ﬁlter in or ﬁlter out specific events. You can have multiple values for this ﬁeld, separated by commas.
        ///
        /// * eventCategory - This field is required and must be set to Equals.
        ///
        /// * For CloudTrail management events, the value must be Management.
        ///
        /// * For CloudTrail data events, the value must be Data.
        ///
        /// * For CloudTrail network activity events, the value must be NetworkActivity.
        ///
        ///
        /// The following are used only for event data stores:
        ///
        /// * For CloudTrail Insights events, the value must be Insight.
        ///
        /// * For Config configuration items, the value must be ConfigurationItem.
        ///
        /// * For Audit Manager evidence, the value must be Evidence.
        ///
        /// * For non-Amazon Web Services events, the value must be ActivityAuditLog.
        ///
        ///
        ///
        ///
        /// * errorCode - This ﬁeld is only used to filter CloudTrail network activity events and is optional. This is the error code to filter on. Currently, the only valid errorCode is VpceAccessDenied. errorCode can only use the Equals operator.
        ///
        /// * resources.type - This ﬁeld is required for CloudTrail data events. resources.type can only use the Equals operator. The value can be one of the following:
        ///
        /// * AWS::AppConfig::Configuration
        ///
        /// * AWS::B2BI::Transformer
        ///
        /// * AWS::Bedrock::AgentAlias
        ///
        /// * AWS::Bedrock::FlowAlias
        ///
        /// * AWS::Bedrock::Guardrail
        ///
        /// * AWS::Bedrock::KnowledgeBase
        ///
        /// * AWS::Cassandra::Table
        ///
        /// * AWS::CloudFront::KeyValueStore
        ///
        /// * AWS::CloudTrail::Channel
        ///
        /// * AWS::CloudWatch::Metric
        ///
        /// * AWS::CodeWhisperer::Customization
        ///
        /// * AWS::CodeWhisperer::Profile
        ///
        /// * AWS::Cognito::IdentityPool
        ///
        /// * AWS::DynamoDB::Stream
        ///
        /// * AWS::DynamoDB::Table
        ///
        /// * AWS::EC2::Snapshot
        ///
        /// * AWS::EMRWAL::Workspace
        ///
        /// * AWS::FinSpace::Environment
        ///
        /// * AWS::Glue::Table
        ///
        /// * AWS::GreengrassV2::ComponentVersion
        ///
        /// * AWS::GreengrassV2::Deployment
        ///
        /// * AWS::GuardDuty::Detector
        ///
        /// * AWS::IoT::Certificate
        ///
        /// * AWS::IoT::Thing
        ///
        /// * AWS::IoTSiteWise::Asset
        ///
        /// * AWS::IoTSiteWise::TimeSeries
        ///
        /// * AWS::IoTTwinMaker::Entity
        ///
        /// * AWS::IoTTwinMaker::Workspace
        ///
        /// * AWS::KendraRanking::ExecutionPlan
        ///
        /// * AWS::Kinesis::Stream
        ///
        /// * AWS::Kinesis::StreamConsumer
        ///
        /// * AWS::KinesisVideo::Stream
        ///
        /// * AWS::Lambda::Function
        ///
        /// * AWS::MachineLearning::MlModel
        ///
        /// * AWS::ManagedBlockchain::Network
        ///
        /// * AWS::ManagedBlockchain::Node
        ///
        /// * AWS::MedicalImaging::Datastore
        ///
        /// * AWS::NeptuneGraph::Graph
        ///
        /// * AWS::One::UKey
        ///
        /// * AWS::One::User
        ///
        /// * AWS::PaymentCryptography::Alias
        ///
        /// * AWS::PaymentCryptography::Key
        ///
        /// * AWS::PCAConnectorAD::Connector
        ///
        /// * AWS::PCAConnectorSCEP::Connector
        ///
        /// * AWS::QApps:QApp
        ///
        /// * AWS::QBusiness::Application
        ///
        /// * AWS::QBusiness::DataSource
        ///
        /// * AWS::QBusiness::Index
        ///
        /// * AWS::QBusiness::WebExperience
        ///
        /// * AWS::RDS::DBCluster
        ///
        /// * AWS::RUM::AppMonitor
        ///
        /// * AWS::S3::AccessPoint
        ///
        /// * AWS::S3::Object
        ///
        /// * AWS::S3Express::Object
        ///
        /// * AWS::S3ObjectLambda::AccessPoint
        ///
        /// * AWS::S3Outposts::Object
        ///
        /// * AWS::SageMaker::Endpoint
        ///
        /// * AWS::SageMaker::ExperimentTrialComponent
        ///
        /// * AWS::SageMaker::FeatureGroup
        ///
        /// * AWS::ServiceDiscovery::Namespace
        ///
        /// * AWS::ServiceDiscovery::Service
        ///
        /// * AWS::SCN::Instance
        ///
        /// * AWS::SNS::PlatformEndpoint
        ///
        /// * AWS::SNS::Topic
        ///
        /// * AWS::SQS::Queue
        ///
        /// * AWS::SSM::ManagedNode
        ///
        /// * AWS::SSMMessages::ControlChannel
        ///
        /// * AWS::StepFunctions::StateMachine
        ///
        /// * AWS::SWF::Domain
        ///
        /// * AWS::ThinClient::Device
        ///
        /// * AWS::ThinClient::Environment
        ///
        /// * AWS::Timestream::Database
        ///
        /// * AWS::Timestream::Table
        ///
        /// * AWS::VerifiedPermissions::PolicyStore
        ///
        /// * AWS::XRay::Trace
        ///
        ///
        /// You can have only one resources.type ﬁeld per selector. To log events on more than one resource type, add another selector.
        ///
        /// * resources.ARN - The resources.ARN is an optional field for data events. You can use any operator with resources.ARN, but if you use Equals or NotEquals, the value must exactly match the ARN of a valid resource of the type you've speciﬁed in the template as the value of resources.type. To log all data events for all objects in a specific S3 bucket, use the StartsWith operator, and include only the bucket ARN as the matching value. For information about filtering data events on the resources.ARN field, see [Filtering data events by resources.ARN](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/filtering-data-events.html#filtering-data-events-resourcearn) in the CloudTrail User Guide. You can't use the resources.ARN field to filter resource types that do not have ARNs.
        ///
        /// * vpcEndpointId - This ﬁeld is only used to filter CloudTrail network activity events and is optional. This field identifies the VPC endpoint that the request passed through. You can use any operator with vpcEndpointId.
        /// This member is required.
        public var field: Swift.String?
        /// An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        public var notEndsWith: [Swift.String]?
        /// An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        public var notEquals: [Swift.String]?
        /// An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        public var notStartsWith: [Swift.String]?
        /// An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        public var startsWith: [Swift.String]?

        public init(
            endsWith: [Swift.String]? = nil,
            equals: [Swift.String]? = nil,
            field: Swift.String? = nil,
            notEndsWith: [Swift.String]? = nil,
            notEquals: [Swift.String]? = nil,
            notStartsWith: [Swift.String]? = nil,
            startsWith: [Swift.String]? = nil
        )
        {
            self.endsWith = endsWith
            self.equals = equals
            self.field = field
            self.notEndsWith = notEndsWith
            self.notEquals = notEquals
            self.notStartsWith = notStartsWith
            self.startsWith = startsWith
        }
    }
}

extension CloudTrailClientTypes {

    /// Advanced event selectors let you create fine-grained selectors for CloudTrail management, data, and network activity events. They help you control costs by logging only those events that are important to you. For more information about configuring advanced event selectors, see the [Logging data events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html), [Logging network activity events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-network-events-with-cloudtrail.html), and [Logging management events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-management-events-with-cloudtrail.html) topics in the CloudTrail User Guide. You cannot apply both event selectors and advanced event selectors to a trail. Supported CloudTrail event record fields for management events
    ///
    /// * eventCategory (required)
    ///
    /// * eventSource
    ///
    /// * readOnly
    ///
    ///
    /// Supported CloudTrail event record fields for data events
    ///
    /// * eventCategory (required)
    ///
    /// * resources.type (required)
    ///
    /// * readOnly
    ///
    /// * eventName
    ///
    /// * resources.ARN
    ///
    ///
    /// Supported CloudTrail event record fields for network activity events Network activity events is in preview release for CloudTrail and is subject to change.
    ///
    /// * eventCategory (required)
    ///
    /// * eventSource (required)
    ///
    /// * eventName
    ///
    /// * errorCode - The only valid value for errorCode is VpceAccessDenied.
    ///
    /// * vpcEndpointId
    ///
    ///
    /// For event data stores for CloudTrail Insights events, Config configuration items, Audit Manager evidence, or events outside of Amazon Web Services, the only supported field is eventCategory.
    public struct AdvancedEventSelector: Swift.Sendable {
        /// Contains all selector statements in an advanced event selector.
        /// This member is required.
        public var fieldSelectors: [CloudTrailClientTypes.AdvancedFieldSelector]?
        /// An optional, descriptive name for an advanced event selector, such as "Log data events for only two S3 buckets".
        public var name: Swift.String?

        public init(
            fieldSelectors: [CloudTrailClientTypes.AdvancedFieldSelector]? = nil,
            name: Swift.String? = nil
        )
        {
            self.fieldSelectors = fieldSelectors
            self.name = name
        }
    }
}

extension CloudTrailClientTypes {

    public enum BillingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case extendableRetentionPricing
        case fixedRetentionPricing
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingMode] {
            return [
                .extendableRetentionPricing,
                .fixedRetentionPricing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .extendableRetentionPricing: return "EXTENDABLE_RETENTION_PRICING"
            case .fixedRetentionPricing: return "FIXED_RETENTION_PRICING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified query cannot be canceled because it is in the FINISHED, FAILED, TIMED_OUT, or CANCELLED state.
public struct InactiveQueryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InactiveQuery" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request includes a parameter that is not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameter" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The query ID does not exist or does not map to a query.
public struct QueryIdNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryIdNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelQueryInput: Swift.Sendable {
    /// The ARN (or the ID suffix of the ARN) of an event data store on which the specified query is running.
    @available(*, deprecated, message: "EventDataStore is no longer required by CancelQueryRequest")
    public var eventDataStore: Swift.String?
    /// The ID of the query that you want to cancel. The QueryId comes from the response of a StartQuery operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.queryId = queryId
    }
}

extension CloudTrailClientTypes {

    public enum QueryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case failed
        case finished
        case queued
        case running
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryStatus] {
            return [
                .cancelled,
                .failed,
                .finished,
                .queued,
                .running,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelQueryOutput: Swift.Sendable {
    /// The ID of the canceled query.
    /// This member is required.
    public var queryId: Swift.String?
    /// Shows the status of a query after a CancelQuery request. Typically, the values shown are either RUNNING or CANCELLED.
    /// This member is required.
    public var queryStatus: CloudTrailClientTypes.QueryStatus?

    public init(
        queryId: Swift.String? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil
    )
    {
        self.queryId = queryId
        self.queryStatus = queryStatus
    }
}

/// This exception is thrown when the management account of an organization is registered as the CloudTrail delegated administrator.
public struct CannotDelegateManagementAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotDelegateManagementAccount" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudTrailClientTypes {

    /// Contains information about a returned CloudTrail channel.
    public struct Channel: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of a channel.
        public var channelArn: Swift.String?
        /// The name of the CloudTrail channel. For service-linked channels, the name is aws-service-channel/service-name/custom-suffix where service-name represents the name of the Amazon Web Services service that created the channel and custom-suffix represents the suffix created by the Amazon Web Services service.
        public var name: Swift.String?

        public init(
            channelArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.channelArn = channelArn
            self.name = name
        }
    }
}

/// This exception is thrown when the provided channel already exists.
public struct ChannelAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified event data store cannot yet be deleted because it is in use by a channel.
public struct ChannelExistsForEDSException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelExistsForEDS" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the maximum number of channels limit is exceeded.
public struct ChannelMaxLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelMaxLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when event categories of specified event data stores are not valid.
public struct InvalidEventDataStoreCategoryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEventDataStoreCategory" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified value of Source is not valid.
public struct InvalidSourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSource" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudTrailClientTypes {

    public enum DestinationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsService
        case eventDataStore
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .awsService,
                .eventDataStore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsService: return "AWS_SERVICE"
            case .eventDataStore: return "EVENT_DATA_STORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudTrailClientTypes {

    /// Contains information about the destination receiving events.
    public struct Destination: Swift.Sendable {
        /// For channels used for a CloudTrail Lake integration, the location is the ARN of an event data store that receives events from a channel. For service-linked channels, the location is the name of the Amazon Web Services service.
        /// This member is required.
        public var location: Swift.String?
        /// The type of destination for events arriving from a channel. For channels used for a CloudTrail Lake integration, the value is EVENT_DATA_STORE. For service-linked channels, the value is AWS_SERVICE.
        /// This member is required.
        public var type: CloudTrailClientTypes.DestinationType?

        public init(
            location: Swift.String? = nil,
            type: CloudTrailClientTypes.DestinationType? = nil
        )
        {
            self.location = location
            self.type = type
        }
    }
}

public struct CreateChannelInput: Swift.Sendable {
    /// One or more event data stores to which events arriving through a channel will be logged.
    /// This member is required.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the partner or external event source. You cannot change this name after you create the channel. A maximum of one channel is allowed per source. A source can be either Custom for all valid non-Amazon Web Services events, or the name of a partner event source. For information about the source names for available partners, see [Additional information about integration partners](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-event-data-store-integration.html#cloudtrail-lake-partner-information) in the CloudTrail User Guide.
    /// This member is required.
    public var source: Swift.String?
    /// A list of tags.
    public var tags: [CloudTrailClientTypes.Tag]?

    public init(
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        name: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.destinations = destinations
        self.name = name
        self.source = source
        self.tags = tags
    }
}

public struct CreateChannelOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new channel.
    public var channelArn: Swift.String?
    /// The event data stores that log the events arriving through the channel.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// The name of the new channel.
    public var name: Swift.String?
    /// The partner or external event source name.
    public var source: Swift.String?
    /// A list of tags.
    public var tags: [CloudTrailClientTypes.Tag]?

    public init(
        channelArn: Swift.String? = nil,
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        name: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.channelArn = channelArn
        self.destinations = destinations
        self.name = name
        self.source = source
        self.tags = tags
    }
}

/// This exception is thrown when trusted access has not been enabled between CloudTrail and Organizations. For more information, see [How to enable or disable trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_integrate_services.html#orgs_how-to-enable-disable-trusted-access) in the Organizations User Guide and [Prepare For Creating a Trail For Your Organization](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html) in the CloudTrail User Guide.
public struct CloudTrailAccessNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudTrailAccessNotEnabled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An event data store with that name already exists.
public struct EventDataStoreAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your account has used the maximum number of event data stores.
public struct EventDataStoreMaxLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreMaxLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the IAM identity that is used to create the organization resource lacks one or more required permissions for creating an organization resource in a required service.
public struct InsufficientDependencyServiceAccessPermissionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientDependencyServiceAccessPermission" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the policy on the S3 bucket or KMS key does not have sufficient permissions for the operation.
public struct InsufficientEncryptionPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientEncryptionPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the PutEventSelectors operation is called with a number of event selectors, advanced event selectors, or data resources that is not valid. The combination of event selectors or advanced event selectors and data resources is not valid. A trail can have up to 5 event selectors. If a trail uses advanced event selectors, a maximum of 500 total values for all conditions in all advanced event selectors is allowed. A trail is limited to 250 data resources. These data resources can be distributed across event selectors, but the overall total cannot exceed 250. You can:
///
/// * Specify a valid number of event selectors (1 to 5) for a trail.
///
/// * Specify a valid number of data resources (1 to 250) for an event selector. The limit of number of resources on an individual event selector is configurable up to 250. However, this upper limit is allowed only if the total number of data resources does not exceed 250 across all event selectors for a trail.
///
/// * Specify up to 500 values for all conditions in all advanced event selectors for a trail.
///
/// * Specify a valid value for a parameter. For example, specifying the ReadWriteType parameter with a value of read-only is not valid.
public struct InvalidEventSelectorsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEventSelectors" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the KMS key ARN is not valid.
public struct InvalidKmsKeyIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidKmsKeyId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when there is an issue with the specified KMS key and the trail or event data store can't be updated.
public struct KmsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the KMS key does not exist, when the S3 bucket and the KMS key are not in the same Region, or when the KMS key associated with the Amazon SNS topic either does not exist or is not in the same Region.
public struct KmsKeyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsKeyNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when Organizations is not configured to support all features. All features must be enabled in Organizations to support creating an organization trail or event data store.
public struct OrganizationNotInAllFeaturesModeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationNotInAllFeaturesMode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the request is made from an Amazon Web Services account that is not a member of an organization. To make this request, sign in using the credentials of an account that belongs to an organization.
public struct OrganizationsNotInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationsNotInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateEventDataStoreInput: Swift.Sendable {
    /// The advanced event selectors to use to select the events for the data store. You can configure up to five advanced event selectors for each event data store. For more information about how to use advanced event selectors to log CloudTrail events, see [Log events by using advanced event selectors](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html#creating-data-event-selectors-advanced) in the CloudTrail User Guide. For more information about how to use advanced event selectors to include Config configuration items in your event data store, see [Create an event data store for Config configuration items](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/lake-eds-cli.html#lake-cli-create-eds-config) in the CloudTrail User Guide. For more information about how to use advanced event selectors to include events outside of Amazon Web Services events in your event data store, see [Create an integration to log events from outside Amazon Web Services](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/lake-integrations-cli.html#lake-cli-create-integration) in the CloudTrail User Guide.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The billing mode for the event data store determines the cost for ingesting events and the default and maximum retention period for the event data store. The following are the possible values:
    ///
    /// * EXTENDABLE_RETENTION_PRICING - This billing mode is generally recommended if you want a flexible retention period of up to 3653 days (about 10 years). The default retention period for this billing mode is 366 days.
    ///
    /// * FIXED_RETENTION_PRICING - This billing mode is recommended if you expect to ingest more than 25 TB of event data per month and need a retention period of up to 2557 days (about 7 years). The default retention period for this billing mode is 2557 days.
    ///
    ///
    /// The default value is EXTENDABLE_RETENTION_PRICING. For more information about CloudTrail pricing, see [CloudTrail Pricing](http://aws.amazon.com/cloudtrail/pricing/) and [Managing CloudTrail Lake costs](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-lake-manage-costs.html).
    public var billingMode: CloudTrailClientTypes.BillingMode?
    /// Specifies the KMS key ID to use to encrypt the events delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. Disabling or deleting the KMS key, or removing CloudTrail permissions on the key, prevents CloudTrail from logging events to the event data store, and prevents users from querying the data in the event data store that was encrypted with the key. After you associate an event data store with a KMS key, the KMS key cannot be removed or changed. Before you disable or delete a KMS key that you are using with an event data store, delete or back up your event data store. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether the event data store includes events from all Regions, or only from the Region in which the event data store is created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether an event data store collects events logged for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of the event data store, in days. If BillingMode is set to EXTENDABLE_RETENTION_PRICING, you can set a retention period of up to 3653 days, the equivalent of 10 years. If BillingMode is set to FIXED_RETENTION_PRICING, you can set a retention period of up to 2557 days, the equivalent of seven years. CloudTrail Lake determines whether to retain an event by checking if the eventTime of the event is within the specified retention period. For example, if you set a retention period of 90 days, CloudTrail will remove events when the eventTime is older than 90 days. If you plan to copy trail events to this event data store, we recommend that you consider both the age of the events that you want to copy as well as how long you want to keep the copied events in your event data store. For example, if you copy trail events that are 5 years old and specify a retention period of 7 years, the event data store will retain those events for two years.
    public var retentionPeriod: Swift.Int?
    /// Specifies whether the event data store should start ingesting live events. The default is true.
    public var startIngestion: Swift.Bool?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?
    /// Specifies whether termination protection is enabled for the event data store. If termination protection is enabled, you cannot delete the event data store until termination protection is disabled.
    public var terminationProtectionEnabled: Swift.Bool?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        billingMode: CloudTrailClientTypes.BillingMode? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        startIngestion: Swift.Bool? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.billingMode = billingMode
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.startIngestion = startIngestion
        self.tagsList = tagsList
        self.terminationProtectionEnabled = terminationProtectionEnabled
    }
}

extension CloudTrailClientTypes {

    public enum EventDataStoreStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case enabled
        case pendingDeletion
        case startingIngestion
        case stoppedIngestion
        case stoppingIngestion
        case sdkUnknown(Swift.String)

        public static var allCases: [EventDataStoreStatus] {
            return [
                .created,
                .enabled,
                .pendingDeletion,
                .startingIngestion,
                .stoppedIngestion,
                .stoppingIngestion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .enabled: return "ENABLED"
            case .pendingDeletion: return "PENDING_DELETION"
            case .startingIngestion: return "STARTING_INGESTION"
            case .stoppedIngestion: return "STOPPED_INGESTION"
            case .stoppingIngestion: return "STOPPING_INGESTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateEventDataStoreOutput: Swift.Sendable {
    /// The advanced event selectors that were used to select the events for the data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The billing mode for the event data store.
    public var billingMode: CloudTrailClientTypes.BillingMode?
    /// The timestamp that shows when the event data store was created.
    public var createdTimestamp: Foundation.Date?
    /// The ARN of the event data store.
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store collects events from all Regions, or only from the Region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of an event data store, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of event data store creation.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?
    /// Indicates whether termination protection is enabled for the event data store.
    public var terminationProtectionEnabled: Swift.Bool?
    /// The timestamp that shows when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: Foundation.Date?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        billingMode: CloudTrailClientTypes.BillingMode? = nil,
        createdTimestamp: Foundation.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: Foundation.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.billingMode = billingMode
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.tagsList = tagsList
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

/// This exception is thrown when a call results in the InvalidClientTokenId error code. This can occur when you are creating or updating a trail to send notifications to an Amazon SNS topic that is in a suspended Amazon Web Services account.
public struct CloudTrailInvalidClientTokenIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudTrailInvalidClientTokenId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Cannot set a CloudWatch Logs delivery for this Region.
public struct CloudWatchLogsDeliveryUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CloudWatchLogsDeliveryUnavailable" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the policy on the S3 bucket is not sufficient.
public struct InsufficientS3BucketPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientS3BucketPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the policy on the Amazon SNS topic is not sufficient.
public struct InsufficientSnsTopicPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientSnsTopicPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the provided CloudWatch Logs log group is not valid.
public struct InvalidCloudWatchLogsLogGroupArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCloudWatchLogsLogGroupArn" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the provided role is not valid.
public struct InvalidCloudWatchLogsRoleArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCloudWatchLogsRoleArn" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the combination of parameters provided is not valid.
public struct InvalidParameterCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterCombinationError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the provided S3 bucket name is not valid.
public struct InvalidS3BucketNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3BucketName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the provided S3 prefix is not valid.
public struct InvalidS3PrefixException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3Prefix" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the provided SNS topic name is not valid.
public struct InvalidSnsTopicNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSnsTopicName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is no longer in use.
@available(*, deprecated)
public struct KmsKeyDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsKeyDisabled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the maximum number of trails is reached.
public struct MaximumNumberOfTrailsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaximumNumberOfTrailsExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified S3 bucket does not exist.
public struct S3BucketDoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "S3BucketDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the request rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified trail already exists.
public struct TrailAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrailAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is no longer in use.
public struct TrailNotProvidedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrailNotProvided" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Specifies the settings for each trail.
public struct CreateTrailInput: Swift.Sendable {
    /// Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered. You must use a log group that exists in your account. Not required unless you specify CloudWatchLogsRoleArn.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group. You must use a role that exists in your account.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether log file integrity validation is enabled. The default is false. When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail does not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.
    public var enableLogFileValidation: Swift.Bool?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail is created in the current Region or in all Regions. The default is false, which creates a trail only in the Region where you are signed in. As a best practice, consider creating trails that log events in all Regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account. The default is false, and cannot be true unless the call is made on behalf of an Amazon Web Services account that is the management account or delegated administrator account for an organization in Organizations.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies the name of the trail. The name must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files. For information about bucket naming rules, see [Bucket naming rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html) in the Amazon Simple Storage Service User Guide.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/get-and-view-cloudtrail-log-files.html#cloudtrail-find-log-files). The maximum length is 200 characters.
    public var s3KeyPrefix: Swift.String?
    /// Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
    public var snsTopicName: Swift.String?
    /// A list of tags.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init(
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        enableLogFileValidation: Swift.Bool? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
        self.tagsList = tagsList
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct CreateTrailOutput: Swift.Sendable {
    /// Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs will be delivered.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail exists in one Region or in all Regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is an organization trail.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether log file integrity validation is enabled.
    public var logFileValidationEnabled: Swift.Bool?
    /// Specifies the name of the trail.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/get-and-view-cloudtrail-log-files.html#cloudtrail-find-log-files).
    public var s3KeyPrefix: Swift.String?
    /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The format of a topic ARN is: arn:aws:sns:us-east-2:123456789012:MyTopic
    public var snsTopicARN: Swift.String?
    /// This field is no longer in use. Use SnsTopicARN.
    @available(*, deprecated)
    public var snsTopicName: Swift.String?
    /// Specifies the ARN of the trail that was created. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init(
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        logFileValidationEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicARN: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

public struct DeleteChannelInput: Swift.Sendable {
    /// The ARN or the UUID value of the channel that you want to delete.
    /// This member is required.
    public var channel: Swift.String?

    public init(
        channel: Swift.String? = nil
    )
    {
        self.channel = channel
    }
}

public struct DeleteChannelOutput: Swift.Sendable {

    public init() { }
}

/// You cannot delete the event data store because Lake query federation is enabled. To delete the event data store, run the DisableFederation operation to disable Lake query federation on the event data store.
public struct EventDataStoreFederationEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreFederationEnabled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when you try to update or delete an event data store that currently has an import in progress.
public struct EventDataStoreHasOngoingImportException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreHasOngoingImport" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The event data store cannot be deleted because termination protection is enabled for it.
public struct EventDataStoreTerminationProtectedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EventDataStoreTerminationProtectedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteEventDataStoreInput: Swift.Sendable {
    /// The ARN (or the ID suffix of the ARN) of the event data store to delete.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

public struct DeleteEventDataStoreOutput: Swift.Sendable {

    public init() { }
}

/// This exception is thrown when the provided resource does not exist, or the ARN format of the resource is not valid. The following is the valid format for a resource ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/MyChannel.
public struct ResourceARNNotValidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceARNNotValid" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the specified resource policy is not found.
public struct ResourcePolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePolicyNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel you're deleting the resource-based policy from. The following is the format of a resource ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/MyChannel.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput: Swift.Sendable {

    public init() { }
}

/// This exception is thrown when an operation is called on a trail from a Region other than the Region in which the trail was created.
public struct InvalidHomeRegionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidHomeRegion" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when the trail with the given name is not found.
public struct TrailNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TrailNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request that specifies the name of a trail to delete.
public struct DeleteTrailInput: Swift.Sendable {
    /// Specifies the name or the CloudTrail ARN of the trail to be deleted. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct DeleteTrailOutput: Swift.Sendable {

    public init() { }
}

/// This exception is thrown when the account making the request is not the organization's management account.
public struct NotOrganizationManagementAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotOrganizationManagementAccount" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Removes CloudTrail delegated administrator permissions from a specified member account in an organization that is currently designated as a delegated administrator.
public struct DeregisterOrganizationDelegatedAdminInput: Swift.Sendable {
    /// A delegated administrator account ID. This is a member account in an organization that is currently designated as a delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init(
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

/// Returns the following response if successful. Otherwise, returns an error.
public struct DeregisterOrganizationDelegatedAdminOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeQueryInput: Swift.Sendable {
    /// The ARN (or the ID suffix of the ARN) of an event data store on which the specified query was run.
    @available(*, deprecated, message: "EventDataStore is no longer required by DescribeQueryRequest")
    public var eventDataStore: Swift.String?
    /// The alias that identifies a query template.
    public var queryAlias: Swift.String?
    /// The query ID.
    public var queryId: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil,
        queryAlias: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.queryAlias = queryAlias
        self.queryId = queryId
    }
}

extension CloudTrailClientTypes {

    public enum DeliveryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case accessDeniedSigningFile
        case cancelled
        case failed
        case failedSigningFile
        case pending
        case resourceNotFound
        case success
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryStatus] {
            return [
                .accessDenied,
                .accessDeniedSigningFile,
                .cancelled,
                .failed,
                .failedSigningFile,
                .pending,
                .resourceNotFound,
                .success,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .accessDeniedSigningFile: return "ACCESS_DENIED_SIGNING_FILE"
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .failedSigningFile: return "FAILED_SIGNING_FILE"
            case .pending: return "PENDING"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .success: return "SUCCESS"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudTrailClientTypes {

    /// Gets metadata about a query, including the number of events that were matched, the total number of events scanned, the query run time in milliseconds, and the query's creation time.
    public struct QueryStatisticsForDescribeQuery: Swift.Sendable {
        /// The total bytes that the query scanned in the event data store. This value matches the number of bytes for which your account is billed for the query, unless the query is still running.
        public var bytesScanned: Swift.Int?
        /// The creation time of the query.
        public var creationTime: Foundation.Date?
        /// The number of events that matched a query.
        public var eventsMatched: Swift.Int?
        /// The number of events that the query scanned in the event data store.
        public var eventsScanned: Swift.Int?
        /// The query's run time, in milliseconds.
        public var executionTimeInMillis: Swift.Int?

        public init(
            bytesScanned: Swift.Int? = nil,
            creationTime: Foundation.Date? = nil,
            eventsMatched: Swift.Int? = nil,
            eventsScanned: Swift.Int? = nil,
            executionTimeInMillis: Swift.Int? = nil
        )
        {
            self.bytesScanned = bytesScanned
            self.creationTime = creationTime
            self.eventsMatched = eventsMatched
            self.eventsScanned = eventsScanned
            self.executionTimeInMillis = executionTimeInMillis
        }
    }
}

public struct DescribeQueryOutput: Swift.Sendable {
    /// The URI for the S3 bucket where CloudTrail delivered query results, if applicable.
    public var deliveryS3Uri: Swift.String?
    /// The delivery status.
    public var deliveryStatus: CloudTrailClientTypes.DeliveryStatus?
    /// The error message returned if a query failed.
    public var errorMessage: Swift.String?
    /// The ID of the query.
    public var queryId: Swift.String?
    /// Metadata about a query, including the number of events that were matched, the total number of events scanned, the query run time in milliseconds, and the query's creation time.
    public var queryStatistics: CloudTrailClientTypes.QueryStatisticsForDescribeQuery?
    /// The status of a query. Values for QueryStatus include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED
    public var queryStatus: CloudTrailClientTypes.QueryStatus?
    /// The SQL code of a query.
    public var queryString: Swift.String?

    public init(
        deliveryS3Uri: Swift.String? = nil,
        deliveryStatus: CloudTrailClientTypes.DeliveryStatus? = nil,
        errorMessage: Swift.String? = nil,
        queryId: Swift.String? = nil,
        queryStatistics: CloudTrailClientTypes.QueryStatisticsForDescribeQuery? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.deliveryS3Uri = deliveryS3Uri
        self.deliveryStatus = deliveryStatus
        self.errorMessage = errorMessage
        self.queryId = queryId
        self.queryStatistics = queryStatistics
        self.queryStatus = queryStatus
        self.queryString = queryString
    }
}

/// Returns information about the trail.
public struct DescribeTrailsInput: Swift.Sendable {
    /// Specifies whether to include shadow trails in the response. A shadow trail is the replication in a Region of a trail that was created in a different Region, or in the case of an organization trail, the replication of an organization trail in member accounts. If you do not include shadow trails, organization trails in a member account and Region replication trails will not be returned. The default is true.
    public var includeShadowTrails: Swift.Bool?
    /// Specifies a list of trail names, trail ARNs, or both, of the trails to describe. The format of a trail ARN is: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail If an empty list is specified, information for the trail in the current Region is returned.
    ///
    /// * If an empty list is specified and IncludeShadowTrails is false, then information for all trails in the current Region is returned.
    ///
    /// * If an empty list is specified and IncludeShadowTrails is null or true, then information for all trails in the current Region and any associated shadow trails in other Regions is returned.
    ///
    ///
    /// If one or more trail names are specified, information is returned only if the names match the names of trails belonging only to the current Region and current account. To return information about a trail in another Region, you must specify its trail ARN.
    public var trailNameList: [Swift.String]?

    public init(
        includeShadowTrails: Swift.Bool? = nil,
        trailNameList: [Swift.String]? = nil
    )
    {
        self.includeShadowTrails = includeShadowTrails
        self.trailNameList = trailNameList
    }
}

extension CloudTrailClientTypes {

    /// The settings for a trail.
    public struct Trail: Swift.Sendable {
        /// Specifies an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Specifies if the trail has custom event selectors.
        public var hasCustomEventSelectors: Swift.Bool?
        /// Specifies whether a trail has insight types specified in an InsightSelector list.
        public var hasInsightSelectors: Swift.Bool?
        /// The Region in which the trail was created.
        public var homeRegion: Swift.String?
        /// Set to True to include Amazon Web Services API calls from Amazon Web Services global services such as IAM. Otherwise, False.
        public var includeGlobalServiceEvents: Swift.Bool?
        /// Specifies whether the trail exists only in one Region or exists in all Regions.
        public var isMultiRegionTrail: Swift.Bool?
        /// Specifies whether the trail is an organization trail.
        public var isOrganizationTrail: Swift.Bool?
        /// Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
        public var kmsKeyId: Swift.String?
        /// Specifies whether log file validation is enabled.
        public var logFileValidationEnabled: Swift.Bool?
        /// Name of the trail set by calling [CreateTrail]. The maximum length is 128 characters.
        public var name: Swift.String?
        /// Name of the Amazon S3 bucket into which CloudTrail delivers your trail files. See [Amazon S3 Bucket naming rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html).
        public var s3BucketName: Swift.String?
        /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/get-and-view-cloudtrail-log-files.html#cloudtrail-find-log-files). The maximum length is 200 characters.
        public var s3KeyPrefix: Swift.String?
        /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The following is the format of a topic ARN. arn:aws:sns:us-east-2:123456789012:MyTopic
        public var snsTopicARN: Swift.String?
        /// This field is no longer in use. Use SnsTopicARN.
        @available(*, deprecated)
        public var snsTopicName: Swift.String?
        /// Specifies the ARN of the trail. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
        public var trailARN: Swift.String?

        public init(
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            cloudWatchLogsRoleArn: Swift.String? = nil,
            hasCustomEventSelectors: Swift.Bool? = nil,
            hasInsightSelectors: Swift.Bool? = nil,
            homeRegion: Swift.String? = nil,
            includeGlobalServiceEvents: Swift.Bool? = nil,
            isMultiRegionTrail: Swift.Bool? = nil,
            isOrganizationTrail: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            logFileValidationEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            snsTopicARN: Swift.String? = nil,
            snsTopicName: Swift.String? = nil,
            trailARN: Swift.String? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.hasCustomEventSelectors = hasCustomEventSelectors
            self.hasInsightSelectors = hasInsightSelectors
            self.homeRegion = homeRegion
            self.includeGlobalServiceEvents = includeGlobalServiceEvents
            self.isMultiRegionTrail = isMultiRegionTrail
            self.isOrganizationTrail = isOrganizationTrail
            self.kmsKeyId = kmsKeyId
            self.logFileValidationEnabled = logFileValidationEnabled
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.snsTopicARN = snsTopicARN
            self.snsTopicName = snsTopicName
            self.trailARN = trailARN
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct DescribeTrailsOutput: Swift.Sendable {
    /// The list of trail objects. Trail objects with string values are only returned if values for the objects exist in a trail's configuration. For example, SNSTopicName and SNSTopicARN are only returned in results if a trail is configured to send SNS notifications. Similarly, KMSKeyId only appears in results if a trail's log files are encrypted with KMS customer managed keys.
    public var trailList: [CloudTrailClientTypes.Trail]?

    public init(
        trailList: [CloudTrailClientTypes.Trail]? = nil
    )
    {
        self.trailList = trailList
    }
}

/// You are trying to update a resource when another request is in progress. Allow sufficient wait time for the previous request to complete, then retry your request.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModification" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DisableFederationInput: Swift.Sendable {
    /// The ARN (or ID suffix of the ARN) of the event data store for which you want to disable Lake query federation.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

extension CloudTrailClientTypes {

    public enum FederationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [FederationStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DisableFederationOutput: Swift.Sendable {
    /// The ARN of the event data store for which you disabled Lake query federation.
    public var eventDataStoreArn: Swift.String?
    /// The federation status.
    public var federationStatus: CloudTrailClientTypes.FederationStatus?

    public init(
        eventDataStoreArn: Swift.String? = nil,
        federationStatus: CloudTrailClientTypes.FederationStatus? = nil
    )
    {
        self.eventDataStoreArn = eventDataStoreArn
        self.federationStatus = federationStatus
    }
}

public struct EnableFederationInput: Swift.Sendable {
    /// The ARN (or ID suffix of the ARN) of the event data store for which you want to enable Lake query federation.
    /// This member is required.
    public var eventDataStore: Swift.String?
    /// The ARN of the federation role to use for the event data store. Amazon Web Services services like Lake Formation use this federation role to access data for the federated event data store. The federation role must exist in your account and provide the [required minimum permissions](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-federation.html#query-federation-permissions-role).
    /// This member is required.
    public var federationRoleArn: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil,
        federationRoleArn: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.federationRoleArn = federationRoleArn
    }
}

public struct EnableFederationOutput: Swift.Sendable {
    /// The ARN of the event data store for which you enabled Lake query federation.
    public var eventDataStoreArn: Swift.String?
    /// The ARN of the federation role.
    public var federationRoleArn: Swift.String?
    /// The federation status.
    public var federationStatus: CloudTrailClientTypes.FederationStatus?

    public init(
        eventDataStoreArn: Swift.String? = nil,
        federationRoleArn: Swift.String? = nil,
        federationStatus: CloudTrailClientTypes.FederationStatus? = nil
    )
    {
        self.eventDataStoreArn = eventDataStoreArn
        self.federationRoleArn = federationRoleArn
        self.federationStatus = federationStatus
    }
}

public struct GetChannelInput: Swift.Sendable {
    /// The ARN or UUID of a channel.
    /// This member is required.
    public var channel: Swift.String?

    public init(
        channel: Swift.String? = nil
    )
    {
        self.channel = channel
    }
}

extension CloudTrailClientTypes {

    /// A table showing information about the most recent successful and failed attempts to ingest events.
    public struct IngestionStatus: Swift.Sendable {
        /// The event ID of the most recent attempt to ingest events.
        public var latestIngestionAttemptEventID: Swift.String?
        /// The time stamp of the most recent attempt to ingest events on the channel.
        public var latestIngestionAttemptTime: Foundation.Date?
        /// The error code for the most recent failure to ingest events.
        public var latestIngestionErrorCode: Swift.String?
        /// The event ID of the most recent successful ingestion of events.
        public var latestIngestionSuccessEventID: Swift.String?
        /// The time stamp of the most recent successful ingestion of events for the channel.
        public var latestIngestionSuccessTime: Foundation.Date?

        public init(
            latestIngestionAttemptEventID: Swift.String? = nil,
            latestIngestionAttemptTime: Foundation.Date? = nil,
            latestIngestionErrorCode: Swift.String? = nil,
            latestIngestionSuccessEventID: Swift.String? = nil,
            latestIngestionSuccessTime: Foundation.Date? = nil
        )
        {
            self.latestIngestionAttemptEventID = latestIngestionAttemptEventID
            self.latestIngestionAttemptTime = latestIngestionAttemptTime
            self.latestIngestionErrorCode = latestIngestionErrorCode
            self.latestIngestionSuccessEventID = latestIngestionSuccessEventID
            self.latestIngestionSuccessTime = latestIngestionSuccessTime
        }
    }
}

extension CloudTrailClientTypes {

    /// Contains configuration information about the channel.
    public struct SourceConfig: Swift.Sendable {
        /// The advanced event selectors that are configured for the channel.
        public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
        /// Specifies whether the channel applies to a single Region or to all Regions.
        public var applyToAllRegions: Swift.Bool?

        public init(
            advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
            applyToAllRegions: Swift.Bool? = nil
        )
        {
            self.advancedEventSelectors = advancedEventSelectors
            self.applyToAllRegions = applyToAllRegions
        }
    }
}

public struct GetChannelOutput: Swift.Sendable {
    /// The ARN of an channel returned by a GetChannel request.
    public var channelArn: Swift.String?
    /// The destinations for the channel. For channels created for integrations, the destinations are the event data stores that log events arriving through the channel. For service-linked channels, the destination is the Amazon Web Services service that created the service-linked channel to receive events.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// A table showing information about the most recent successful and failed attempts to ingest events.
    public var ingestionStatus: CloudTrailClientTypes.IngestionStatus?
    /// The name of the CloudTrail channel. For service-linked channels, the name is aws-service-channel/service-name/custom-suffix where service-name represents the name of the Amazon Web Services service that created the channel and custom-suffix represents the suffix generated by the Amazon Web Services service.
    public var name: Swift.String?
    /// The source for the CloudTrail channel.
    public var source: Swift.String?
    /// Provides information about the advanced event selectors configured for the channel, and whether the channel applies to all Regions or a single Region.
    public var sourceConfig: CloudTrailClientTypes.SourceConfig?

    public init(
        channelArn: Swift.String? = nil,
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        ingestionStatus: CloudTrailClientTypes.IngestionStatus? = nil,
        name: Swift.String? = nil,
        source: Swift.String? = nil,
        sourceConfig: CloudTrailClientTypes.SourceConfig? = nil
    )
    {
        self.channelArn = channelArn
        self.destinations = destinations
        self.ingestionStatus = ingestionStatus
        self.name = name
        self.source = source
        self.sourceConfig = sourceConfig
    }
}

public struct GetEventDataStoreInput: Swift.Sendable {
    /// The ARN (or ID suffix of the ARN) of the event data store about which you want information.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

extension CloudTrailClientTypes {

    /// Contains information about a partition key for an event data store.
    public struct PartitionKey: Swift.Sendable {
        /// The name of the partition key.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the partition key. For example, bigint or string.
        /// This member is required.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

public struct GetEventDataStoreOutput: Swift.Sendable {
    /// The advanced event selectors used to select events for the data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The billing mode for the event data store.
    public var billingMode: CloudTrailClientTypes.BillingMode?
    /// The timestamp of the event data store's creation.
    public var createdTimestamp: Foundation.Date?
    /// The event data store Amazon Resource Number (ARN).
    public var eventDataStoreArn: Swift.String?
    /// If Lake query federation is enabled, provides the ARN of the federation role used to access the resources for the federated event data store.
    public var federationRoleArn: Swift.String?
    /// Indicates the [Lake query federation](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-federation.html) status. The status is ENABLED if Lake query federation is enabled, or DISABLED if Lake query federation is disabled. You cannot delete an event data store if the FederationStatus is ENABLED.
    public var federationStatus: CloudTrailClientTypes.FederationStatus?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store includes events from all Regions, or only from the Region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The partition keys for the event data store. To improve query performance and efficiency, CloudTrail Lake organizes event data into partitions based on values derived from partition keys.
    public var partitionKeys: [CloudTrailClientTypes.PartitionKey]?
    /// The retention period of the event data store, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of an event data store.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// Indicates that termination protection is enabled.
    public var terminationProtectionEnabled: Swift.Bool?
    /// Shows the time that an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: Foundation.Date?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        billingMode: CloudTrailClientTypes.BillingMode? = nil,
        createdTimestamp: Foundation.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        federationRoleArn: Swift.String? = nil,
        federationStatus: CloudTrailClientTypes.FederationStatus? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        partitionKeys: [CloudTrailClientTypes.PartitionKey]? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: Foundation.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.billingMode = billingMode
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.federationRoleArn = federationRoleArn
        self.federationStatus = federationStatus
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.partitionKeys = partitionKeys
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

public struct GetEventSelectorsInput: Swift.Sendable {
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init(
        trailName: Swift.String? = nil
    )
    {
        self.trailName = trailName
    }
}

extension CloudTrailClientTypes {

    /// You can configure the DataResource in an EventSelector to log data events for the following three resource types:
    ///
    /// * AWS::DynamoDB::Table
    ///
    /// * AWS::Lambda::Function
    ///
    /// * AWS::S3::Object
    ///
    ///
    /// To log data events for all other resource types including objects stored in [directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html), you must use [AdvancedEventSelectors](https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_AdvancedEventSelector.html). You must also use AdvancedEventSelectors if you want to filter on the eventName field. Configure the DataResource to specify the resource type and resource ARNs for which you want to log data events. The total number of allowed data resources is 250. This number can be distributed between 1 and 5 event selectors, but the total cannot exceed 250 across all selectors for the trail. The following example demonstrates how logging works when you configure logging of all data events for a general purpose bucket named amzn-s3-demo-bucket1. In this example, the CloudTrail user specified an empty prefix, and the option to log both Read and Write data events.
    ///
    /// * A user uploads an image file to amzn-s3-demo-bucket1.
    ///
    /// * The PutObject API operation is an Amazon S3 object-level API. It is recorded as a data event in CloudTrail. Because the CloudTrail user specified an S3 bucket with an empty prefix, events that occur on any object in that bucket are logged. The trail processes and logs the event.
    ///
    /// * A user uploads an object to an Amazon S3 bucket named arn:aws:s3:::amzn-s3-demo-bucket1.
    ///
    /// * The PutObject API operation occurred for an object in an S3 bucket that the CloudTrail user didn't specify for the trail. The trail doesn’t log the event.
    ///
    ///
    /// The following example demonstrates how logging works when you configure logging of Lambda data events for a Lambda function named MyLambdaFunction, but not for all Lambda functions.
    ///
    /// * A user runs a script that includes a call to the MyLambdaFunction function and the MyOtherLambdaFunction function.
    ///
    /// * The Invoke API operation on MyLambdaFunction is an Lambda API. It is recorded as a data event in CloudTrail. Because the CloudTrail user specified logging data events for MyLambdaFunction, any invocations of that function are logged. The trail processes and logs the event.
    ///
    /// * The Invoke API operation on MyOtherLambdaFunction is an Lambda API. Because the CloudTrail user did not specify logging data events for all Lambda functions, the Invoke operation for MyOtherLambdaFunction does not match the function specified for the trail. The trail doesn’t log the event.
    public struct DataResource: Swift.Sendable {
        /// The resource type in which you want to log data events. You can specify the following basic event selector resource types:
        ///
        /// * AWS::DynamoDB::Table
        ///
        /// * AWS::Lambda::Function
        ///
        /// * AWS::S3::Object
        ///
        ///
        /// Additional resource types are available through advanced event selectors. For more information about these additional resource types, see [AdvancedFieldSelector](https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_AdvancedFieldSelector.html).
        public var type: Swift.String?
        /// An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified resource type.
        ///
        /// * To log data events for all objects in all S3 buckets in your Amazon Web Services account, specify the prefix as arn:aws:s3. This also enables logging of data event activity performed by any user or role in your Amazon Web Services account, even if that activity is performed on a bucket that belongs to another Amazon Web Services account.
        ///
        /// * To log data events for all objects in an S3 bucket, specify the bucket and an empty object prefix such as arn:aws:s3:::amzn-s3-demo-bucket1/. The trail logs data events for all objects in this S3 bucket.
        ///
        /// * To log data events for specific objects, specify the S3 bucket and object prefix such as arn:aws:s3:::amzn-s3-demo-bucket1/example-images. The trail logs data events for objects in this S3 bucket that match the prefix.
        ///
        /// * To log data events for all Lambda functions in your Amazon Web Services account, specify the prefix as arn:aws:lambda. This also enables logging of Invoke activity performed by any user or role in your Amazon Web Services account, even if that activity is performed on a function that belongs to another Amazon Web Services account.
        ///
        /// * To log data events for a specific Lambda function, specify the function ARN. Lambda function ARNs are exact. For example, if you specify a function ARN arn:aws:lambda:us-west-2:111111111111:function:helloworld, data events will only be logged for arn:aws:lambda:us-west-2:111111111111:function:helloworld. They will not be logged for arn:aws:lambda:us-west-2:111111111111:function:helloworld2.
        ///
        /// * To log data events for all DynamoDB tables in your Amazon Web Services account, specify the prefix as arn:aws:dynamodb.
        public var values: [Swift.String]?

        public init(
            type: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.type = type
            self.values = values
        }
    }
}

extension CloudTrailClientTypes {

    public enum ReadWriteType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case readonly
        case writeonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadWriteType] {
            return [
                .all,
                .readonly,
                .writeonly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .readonly: return "ReadOnly"
            case .writeonly: return "WriteOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudTrailClientTypes {

    /// Use event selectors to further specify the management and data event settings for your trail. By default, trails created without specific event selectors will be configured to log all read and write management events, and no data events. When an event occurs in your account, CloudTrail evaluates the event selector for all trails. For each trail, if the event matches any event selector, the trail processes and logs the event. If the event doesn't match any event selector, the trail doesn't log the event. You can configure up to five event selectors for a trail. You cannot apply both event selectors and advanced event selectors to a trail.
    public struct EventSelector: Swift.Sendable {
        /// CloudTrail supports data event logging for Amazon S3 objects in standard S3 buckets, Lambda functions, and Amazon DynamoDB tables with basic event selectors. You can specify up to 250 resources for an individual event selector, but the total number of data resources cannot exceed 250 across all event selectors in a trail. This limit does not apply if you configure resource logging for all data events. For more information, see [Data Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) and [Limits in CloudTrail](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/WhatIsCloudTrail-Limits.html) in the CloudTrail User Guide. To log data events for all other resource types including objects stored in [directory buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/directory-buckets-overview.html), you must use [AdvancedEventSelectors](https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_AdvancedEventSelector.html). You must also use AdvancedEventSelectors if you want to filter on the eventName field.
        public var dataResources: [CloudTrailClientTypes.DataResource]?
        /// An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out Key Management Service or Amazon RDS Data API events by containing kms.amazonaws.com or rdsdata.amazonaws.com. By default, ExcludeManagementEventSources is empty, and KMS and Amazon RDS Data API events are logged to your trail. You can exclude management event sources only in Regions that support the event source.
        public var excludeManagementEventSources: [Swift.String]?
        /// Specify if you want your event selector to include management events for your trail. For more information, see [Management Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-management-events-with-cloudtrail.html) in the CloudTrail User Guide. By default, the value is true. The first copy of management events is free. You are charged for additional copies of management events that you are logging on any subsequent trail in the same Region. For more information about CloudTrail pricing, see [CloudTrail Pricing](http://aws.amazon.com/cloudtrail/pricing/).
        public var includeManagementEvents: Swift.Bool?
        /// Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation. By default, the value is All.
        public var readWriteType: CloudTrailClientTypes.ReadWriteType?

        public init(
            dataResources: [CloudTrailClientTypes.DataResource]? = nil,
            excludeManagementEventSources: [Swift.String]? = nil,
            includeManagementEvents: Swift.Bool? = nil,
            readWriteType: CloudTrailClientTypes.ReadWriteType? = nil
        )
        {
            self.dataResources = dataResources
            self.excludeManagementEventSources = excludeManagementEventSources
            self.includeManagementEvents = includeManagementEvents
            self.readWriteType = readWriteType
        }
    }
}

public struct GetEventSelectorsOutput: Swift.Sendable {
    /// The advanced event selectors that are configured for the trail.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The event selectors that are configured for the trail.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// The specified trail ARN that has the event selectors.
    public var trailARN: Swift.String?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

/// The specified import was not found.
public struct ImportNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ImportNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetImportInput: Swift.Sendable {
    /// The ID for the import.
    /// This member is required.
    public var importId: Swift.String?

    public init(
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

extension CloudTrailClientTypes {

    /// The settings for the source S3 bucket.
    public struct S3ImportSource: Swift.Sendable {
        /// The IAM ARN role used to access the source S3 bucket.
        /// This member is required.
        public var s3BucketAccessRoleArn: Swift.String?
        /// The Region associated with the source S3 bucket.
        /// This member is required.
        public var s3BucketRegion: Swift.String?
        /// The URI for the source S3 bucket.
        /// This member is required.
        public var s3LocationUri: Swift.String?

        public init(
            s3BucketAccessRoleArn: Swift.String? = nil,
            s3BucketRegion: Swift.String? = nil,
            s3LocationUri: Swift.String? = nil
        )
        {
            self.s3BucketAccessRoleArn = s3BucketAccessRoleArn
            self.s3BucketRegion = s3BucketRegion
            self.s3LocationUri = s3LocationUri
        }
    }
}

extension CloudTrailClientTypes {

    /// The import source.
    public struct ImportSource: Swift.Sendable {
        /// The source S3 bucket.
        /// This member is required.
        public var s3: CloudTrailClientTypes.S3ImportSource?

        public init(
            s3: CloudTrailClientTypes.S3ImportSource? = nil
        )
        {
            self.s3 = s3
        }
    }
}

extension CloudTrailClientTypes {

    /// Provides statistics for the specified ImportID. CloudTrail does not update import statistics in real-time. Returned values for parameters such as EventsCompleted may be lower than the actual value, because CloudTrail updates statistics incrementally over the course of the import.
    public struct ImportStatistics: Swift.Sendable {
        /// The number of trail events imported into the event data store.
        public var eventsCompleted: Swift.Int?
        /// The number of failed entries.
        public var failedEntries: Swift.Int?
        /// The number of log files that completed import.
        public var filesCompleted: Swift.Int?
        /// The number of S3 prefixes that completed import.
        public var prefixesCompleted: Swift.Int?
        /// The number of S3 prefixes found for the import.
        public var prefixesFound: Swift.Int?

        public init(
            eventsCompleted: Swift.Int? = nil,
            failedEntries: Swift.Int? = nil,
            filesCompleted: Swift.Int? = nil,
            prefixesCompleted: Swift.Int? = nil,
            prefixesFound: Swift.Int? = nil
        )
        {
            self.eventsCompleted = eventsCompleted
            self.failedEntries = failedEntries
            self.filesCompleted = filesCompleted
            self.prefixesCompleted = prefixesCompleted
            self.prefixesFound = prefixesFound
        }
    }
}

extension CloudTrailClientTypes {

    public enum ImportStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case initializing
        case inProgress
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportStatus] {
            return [
                .completed,
                .failed,
                .initializing,
                .inProgress,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .initializing: return "INITIALIZING"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetImportOutput: Swift.Sendable {
    /// The timestamp of the import's creation.
    public var createdTimestamp: Foundation.Date?
    /// The ARN of the destination event data store.
    public var destinations: [Swift.String]?
    /// Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var endEventTime: Foundation.Date?
    /// The ID of the import.
    public var importId: Swift.String?
    /// The source S3 bucket.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Provides statistics for the import. CloudTrail does not update import statistics in real-time. Returned values for parameters such as EventsCompleted may be lower than the actual value, because CloudTrail updates statistics incrementally over the course of the import.
    public var importStatistics: CloudTrailClientTypes.ImportStatistics?
    /// The status of the import.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var startEventTime: Foundation.Date?
    /// The timestamp of when the import was updated.
    public var updatedTimestamp: Foundation.Date?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        destinations: [Swift.String]? = nil,
        endEventTime: Foundation.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        importStatistics: CloudTrailClientTypes.ImportStatistics? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        startEventTime: Foundation.Date? = nil,
        updatedTimestamp: Foundation.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.importStatistics = importStatistics
        self.importStatus = importStatus
        self.startEventTime = startEventTime
        self.updatedTimestamp = updatedTimestamp
    }
}

/// If you run GetInsightSelectors on a trail or event data store that does not have Insights events enabled, the operation throws the exception InsightNotEnabledException.
public struct InsightNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsightNotEnabled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetInsightSelectorsInput: Swift.Sendable {
    /// Specifies the ARN (or ID suffix of the ARN) of the event data store for which you want to get Insights selectors. You cannot use this parameter with the TrailName parameter.
    public var eventDataStore: Swift.String?
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail You cannot use this parameter with the EventDataStore parameter.
    public var trailName: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil,
        trailName: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.trailName = trailName
    }
}

extension CloudTrailClientTypes {

    public enum InsightType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apicallrateinsight
        case apierrorrateinsight
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightType] {
            return [
                .apicallrateinsight,
                .apierrorrateinsight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apicallrateinsight: return "ApiCallRateInsight"
            case .apierrorrateinsight: return "ApiErrorRateInsight"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudTrailClientTypes {

    /// A JSON string that contains a list of Insights types that are logged on a trail or event data store.
    public struct InsightSelector: Swift.Sendable {
        /// The type of Insights events to log on a trail or event data store. ApiCallRateInsight and ApiErrorRateInsight are valid Insight types. The ApiCallRateInsight Insights type analyzes write-only management API calls that are aggregated per minute against a baseline API call volume. The ApiErrorRateInsight Insights type analyzes management API calls that result in error codes. The error is shown if the API call is unsuccessful.
        public var insightType: CloudTrailClientTypes.InsightType?

        public init(
            insightType: CloudTrailClientTypes.InsightType? = nil
        )
        {
            self.insightType = insightType
        }
    }
}

public struct GetInsightSelectorsOutput: Swift.Sendable {
    /// The ARN of the source event data store that enabled Insights events.
    public var eventDataStoreArn: Swift.String?
    /// A JSON string that contains the Insight types you want to log on a trail or event data store. ApiErrorRateInsight and ApiCallRateInsight are supported as Insights types.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The ARN of the destination event data store that logs Insights events.
    public var insightsDestination: Swift.String?
    /// The Amazon Resource Name (ARN) of a trail for which you want to get Insights selectors.
    public var trailARN: Swift.String?

    public init(
        eventDataStoreArn: Swift.String? = nil,
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        insightsDestination: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.eventDataStoreArn = eventDataStoreArn
        self.insightSelectors = insightSelectors
        self.insightsDestination = insightsDestination
        self.trailARN = trailARN
    }
}

/// This exception is thrown if the limit specified is not valid.
public struct InvalidMaxResultsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMaxResults" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A token that is not valid, or a token that was previously used in a request with different parameters. This exception is thrown if the token is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextToken" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetQueryResultsInput: Swift.Sendable {
    /// The ARN (or ID suffix of the ARN) of the event data store against which the query was run.
    @available(*, deprecated, message: "EventDataStore is no longer required by GetQueryResultsRequest")
    public var eventDataStore: Swift.String?
    /// The maximum number of query results to display on a single page.
    public var maxQueryResults: Swift.Int?
    /// A token you can use to get the next page of query results.
    public var nextToken: Swift.String?
    /// The ID of the query for which you want to get results.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil,
        maxQueryResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.maxQueryResults = maxQueryResults
        self.nextToken = nextToken
        self.queryId = queryId
    }
}

extension CloudTrailClientTypes {

    /// Metadata about a query, such as the number of results.
    public struct QueryStatistics: Swift.Sendable {
        /// The total bytes that the query scanned in the event data store. This value matches the number of bytes for which your account is billed for the query, unless the query is still running.
        public var bytesScanned: Swift.Int?
        /// The number of results returned.
        public var resultsCount: Swift.Int?
        /// The total number of results returned by a query.
        public var totalResultsCount: Swift.Int?

        public init(
            bytesScanned: Swift.Int? = nil,
            resultsCount: Swift.Int? = nil,
            totalResultsCount: Swift.Int? = nil
        )
        {
            self.bytesScanned = bytesScanned
            self.resultsCount = resultsCount
            self.totalResultsCount = totalResultsCount
        }
    }
}

public struct GetQueryResultsOutput: Swift.Sendable {
    /// The error message returned if a query failed.
    public var errorMessage: Swift.String?
    /// A token you can use to get the next page of query results.
    public var nextToken: Swift.String?
    /// Contains the individual event results of the query.
    public var queryResultRows: [[[Swift.String: Swift.String]]]?
    /// Shows the count of query results.
    public var queryStatistics: CloudTrailClientTypes.QueryStatistics?
    /// The status of the query. Values include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.
    public var queryStatus: CloudTrailClientTypes.QueryStatus?

    public init(
        errorMessage: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        queryResultRows: [[[Swift.String: Swift.String]]]? = nil,
        queryStatistics: CloudTrailClientTypes.QueryStatistics? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil
    )
    {
        self.errorMessage = errorMessage
        self.nextToken = nextToken
        self.queryResultRows = queryResultRows
        self.queryStatistics = queryStatistics
        self.queryStatus = queryStatus
    }
}

public struct GetResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel attached to the resource-based policy. The following is the format of a resource ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/MyChannel.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel attached to resource-based policy.
    public var resourceArn: Swift.String?
    /// A JSON-formatted string that contains the resource-based policy attached to the CloudTrail channel.
    public var resourcePolicy: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourcePolicy = resourcePolicy
    }
}

public struct GetTrailInput: Swift.Sendable {
    /// The name or the Amazon Resource Name (ARN) of the trail for which you want to retrieve settings information.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetTrailOutput: Swift.Sendable {
    /// The settings for a trail.
    public var trail: CloudTrailClientTypes.Trail?

    public init(
        trail: CloudTrailClientTypes.Trail? = nil
    )
    {
        self.trail = trail
    }
}

/// The name of a trail about which you want the current status.
public struct GetTrailStatusInput: Swift.Sendable {
    /// Specifies the name or the CloudTrail ARN of the trail for which you are requesting status. To get the status of a shadow trail (a replication of the trail in another Region), you must specify its ARN. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct GetTrailStatusOutput: Swift.Sendable {
    /// Whether the CloudTrail trail is currently logging Amazon Web Services API calls.
    public var isLogging: Swift.Bool?
    /// Displays any CloudWatch Logs error that CloudTrail encountered when attempting to deliver logs to CloudWatch Logs.
    public var latestCloudWatchLogsDeliveryError: Swift.String?
    /// Displays the most recent date and time when CloudTrail delivered logs to CloudWatch Logs.
    public var latestCloudWatchLogsDeliveryTime: Foundation.Date?
    /// This field is no longer in use.
    public var latestDeliveryAttemptSucceeded: Swift.String?
    /// This field is no longer in use.
    public var latestDeliveryAttemptTime: Swift.String?
    /// Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver log files to the designated bucket. For more information, see [Error Responses](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html) in the Amazon S3 API Reference. This error occurs only when there is a problem with the destination S3 bucket, and does not occur for requests that time out. To resolve the issue, fix the [bucket policy](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create-s3-bucket-policy-for-cloudtrail.html) so that CloudTrail can write to the bucket; or create a new bucket and call UpdateTrail to specify the new bucket.
    public var latestDeliveryError: Swift.String?
    /// Specifies the date and time that CloudTrail last delivered log files to an account's Amazon S3 bucket.
    public var latestDeliveryTime: Foundation.Date?
    /// Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver a digest file to the designated bucket. For more information, see [Error Responses](https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html) in the Amazon S3 API Reference. This error occurs only when there is a problem with the destination S3 bucket, and does not occur for requests that time out. To resolve the issue, fix the [bucket policy](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create-s3-bucket-policy-for-cloudtrail.html) so that CloudTrail can write to the bucket; or create a new bucket and call UpdateTrail to specify the new bucket.
    public var latestDigestDeliveryError: Swift.String?
    /// Specifies the date and time that CloudTrail last delivered a digest file to an account's Amazon S3 bucket.
    public var latestDigestDeliveryTime: Foundation.Date?
    /// This field is no longer in use.
    public var latestNotificationAttemptSucceeded: Swift.String?
    /// This field is no longer in use.
    public var latestNotificationAttemptTime: Swift.String?
    /// Displays any Amazon SNS error that CloudTrail encountered when attempting to send a notification. For more information about Amazon SNS errors, see the [Amazon SNS Developer Guide](https://docs.aws.amazon.com/sns/latest/dg/welcome.html).
    public var latestNotificationError: Swift.String?
    /// Specifies the date and time of the most recent Amazon SNS notification that CloudTrail has written a new log file to an account's Amazon S3 bucket.
    public var latestNotificationTime: Foundation.Date?
    /// Specifies the most recent date and time when CloudTrail started recording API calls for an Amazon Web Services account.
    public var startLoggingTime: Foundation.Date?
    /// Specifies the most recent date and time when CloudTrail stopped recording API calls for an Amazon Web Services account.
    public var stopLoggingTime: Foundation.Date?
    /// This field is no longer in use.
    public var timeLoggingStarted: Swift.String?
    /// This field is no longer in use.
    public var timeLoggingStopped: Swift.String?

    public init(
        isLogging: Swift.Bool? = nil,
        latestCloudWatchLogsDeliveryError: Swift.String? = nil,
        latestCloudWatchLogsDeliveryTime: Foundation.Date? = nil,
        latestDeliveryAttemptSucceeded: Swift.String? = nil,
        latestDeliveryAttemptTime: Swift.String? = nil,
        latestDeliveryError: Swift.String? = nil,
        latestDeliveryTime: Foundation.Date? = nil,
        latestDigestDeliveryError: Swift.String? = nil,
        latestDigestDeliveryTime: Foundation.Date? = nil,
        latestNotificationAttemptSucceeded: Swift.String? = nil,
        latestNotificationAttemptTime: Swift.String? = nil,
        latestNotificationError: Swift.String? = nil,
        latestNotificationTime: Foundation.Date? = nil,
        startLoggingTime: Foundation.Date? = nil,
        stopLoggingTime: Foundation.Date? = nil,
        timeLoggingStarted: Swift.String? = nil,
        timeLoggingStopped: Swift.String? = nil
    )
    {
        self.isLogging = isLogging
        self.latestCloudWatchLogsDeliveryError = latestCloudWatchLogsDeliveryError
        self.latestCloudWatchLogsDeliveryTime = latestCloudWatchLogsDeliveryTime
        self.latestDeliveryAttemptSucceeded = latestDeliveryAttemptSucceeded
        self.latestDeliveryAttemptTime = latestDeliveryAttemptTime
        self.latestDeliveryError = latestDeliveryError
        self.latestDeliveryTime = latestDeliveryTime
        self.latestDigestDeliveryError = latestDigestDeliveryError
        self.latestDigestDeliveryTime = latestDigestDeliveryTime
        self.latestNotificationAttemptSucceeded = latestNotificationAttemptSucceeded
        self.latestNotificationAttemptTime = latestNotificationAttemptTime
        self.latestNotificationError = latestNotificationError
        self.latestNotificationTime = latestNotificationTime
        self.startLoggingTime = startLoggingTime
        self.stopLoggingTime = stopLoggingTime
        self.timeLoggingStarted = timeLoggingStarted
        self.timeLoggingStopped = timeLoggingStopped
    }
}

public struct ListChannelsInput: Swift.Sendable {
    /// The maximum number of CloudTrail channels to display on a single page.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListChannelsOutput: Swift.Sendable {
    /// The list of channels in the account.
    public var channels: [CloudTrailClientTypes.Channel]?
    /// The token to use to get the next page of results after a previous API call.
    public var nextToken: Swift.String?

    public init(
        channels: [CloudTrailClientTypes.Channel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

public struct ListEventDataStoresInput: Swift.Sendable {
    /// The maximum number of event data stores to display on a single page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of event data store results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CloudTrailClientTypes {

    /// A storage lake of event data against which you can run complex SQL-based queries. An event data store can include events that you have logged on your account. To select events for an event data store, use [advanced event selectors](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-lake-concepts.html#adv-event-selectors).
    public struct EventDataStore: Swift.Sendable {
        /// The advanced event selectors that were used to select events for the data store.
        @available(*, deprecated, message: "AdvancedEventSelectors is no longer returned by ListEventDataStores")
        public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
        /// The timestamp of the event data store's creation.
        @available(*, deprecated, message: "CreatedTimestamp is no longer returned by ListEventDataStores")
        public var createdTimestamp: Foundation.Date?
        /// The ARN of the event data store.
        public var eventDataStoreArn: Swift.String?
        /// Indicates whether the event data store includes events from all Regions, or only from the Region in which it was created.
        @available(*, deprecated, message: "MultiRegionEnabled is no longer returned by ListEventDataStores")
        public var multiRegionEnabled: Swift.Bool?
        /// The name of the event data store.
        public var name: Swift.String?
        /// Indicates that an event data store is collecting logged events for an organization.
        @available(*, deprecated, message: "OrganizationEnabled is no longer returned by ListEventDataStores")
        public var organizationEnabled: Swift.Bool?
        /// The retention period, in days.
        @available(*, deprecated, message: "RetentionPeriod is no longer returned by ListEventDataStores")
        public var retentionPeriod: Swift.Int?
        /// The status of an event data store.
        @available(*, deprecated, message: "Status is no longer returned by ListEventDataStores")
        public var status: CloudTrailClientTypes.EventDataStoreStatus?
        /// Indicates whether the event data store is protected from termination.
        @available(*, deprecated, message: "TerminationProtectionEnabled is no longer returned by ListEventDataStores")
        public var terminationProtectionEnabled: Swift.Bool?
        /// The timestamp showing when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
        @available(*, deprecated, message: "UpdatedTimestamp is no longer returned by ListEventDataStores")
        public var updatedTimestamp: Foundation.Date?

        public init(
            advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
            createdTimestamp: Foundation.Date? = nil,
            eventDataStoreArn: Swift.String? = nil,
            multiRegionEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            organizationEnabled: Swift.Bool? = nil,
            retentionPeriod: Swift.Int? = nil,
            status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
            terminationProtectionEnabled: Swift.Bool? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.advancedEventSelectors = advancedEventSelectors
            self.createdTimestamp = createdTimestamp
            self.eventDataStoreArn = eventDataStoreArn
            self.multiRegionEnabled = multiRegionEnabled
            self.name = name
            self.organizationEnabled = organizationEnabled
            self.retentionPeriod = retentionPeriod
            self.status = status
            self.terminationProtectionEnabled = terminationProtectionEnabled
            self.updatedTimestamp = updatedTimestamp
        }
    }
}

public struct ListEventDataStoresOutput: Swift.Sendable {
    /// Contains information about event data stores in the account, in the current Region.
    public var eventDataStores: [CloudTrailClientTypes.EventDataStore]?
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        eventDataStores: [CloudTrailClientTypes.EventDataStore]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventDataStores = eventDataStores
        self.nextToken = nextToken
    }
}

public struct ListImportFailuresInput: Swift.Sendable {
    /// The ID of the import.
    /// This member is required.
    public var importId: Swift.String?
    /// The maximum number of failures to display on a single page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of import failures.
    public var nextToken: Swift.String?

    public init(
        importId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importId = importId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CloudTrailClientTypes {

    public enum ImportFailureStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case retry
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportFailureStatus] {
            return [
                .failed,
                .retry,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .retry: return "RETRY"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudTrailClientTypes {

    /// Provides information about an import failure.
    public struct ImportFailureListItem: Swift.Sendable {
        /// Provides the reason the import failed.
        public var errorMessage: Swift.String?
        /// The type of import error.
        public var errorType: Swift.String?
        /// When the import was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The location of the failure in the S3 bucket.
        public var location: Swift.String?
        /// The status of the import.
        public var status: CloudTrailClientTypes.ImportFailureStatus?

        public init(
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            location: Swift.String? = nil,
            status: CloudTrailClientTypes.ImportFailureStatus? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.lastUpdatedTime = lastUpdatedTime
            self.location = location
            self.status = status
        }
    }
}

public struct ListImportFailuresOutput: Swift.Sendable {
    /// Contains information about the import failures.
    public var failures: [CloudTrailClientTypes.ImportFailureListItem]?
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?

    public init(
        failures: [CloudTrailClientTypes.ImportFailureListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.failures = failures
        self.nextToken = nextToken
    }
}

public struct ListImportsInput: Swift.Sendable {
    /// The ARN of the destination event data store.
    public var destination: Swift.String?
    /// The status of the import.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// The maximum number of imports to display on a single page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of import results.
    public var nextToken: Swift.String?

    public init(
        destination: Swift.String? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destination = destination
        self.importStatus = importStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CloudTrailClientTypes {

    /// Contains information about an import that was returned by a lookup request.
    public struct ImportsListItem: Swift.Sendable {
        /// The timestamp of the import's creation.
        public var createdTimestamp: Foundation.Date?
        /// The ARN of the destination event data store.
        public var destinations: [Swift.String]?
        /// The ID of the import.
        public var importId: Swift.String?
        /// The status of the import.
        public var importStatus: CloudTrailClientTypes.ImportStatus?
        /// The timestamp of the import's last update.
        public var updatedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            destinations: [Swift.String]? = nil,
            importId: Swift.String? = nil,
            importStatus: CloudTrailClientTypes.ImportStatus? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.destinations = destinations
            self.importId = importId
            self.importStatus = importStatus
            self.updatedTimestamp = updatedTimestamp
        }
    }
}

public struct ListImportsOutput: Swift.Sendable {
    /// The list of returned imports.
    public var imports: [CloudTrailClientTypes.ImportsListItem]?
    /// A token you can use to get the next page of import results.
    public var nextToken: Swift.String?

    public init(
        imports: [CloudTrailClientTypes.ImportsListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imports = imports
        self.nextToken = nextToken
    }
}

extension CloudTrailClientTypes {

    public enum InsightsMetricDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fillWithZeros
        case nonZeroData
        case sdkUnknown(Swift.String)

        public static var allCases: [InsightsMetricDataType] {
            return [
                .fillWithZeros,
                .nonZeroData
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fillWithZeros: return "FillWithZeros"
            case .nonZeroData: return "NonZeroData"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListInsightsMetricDataInput: Swift.Sendable {
    /// Type of datapoints to return. Valid values are NonZeroData and FillWithZeros. The default is NonZeroData.
    public var dataType: CloudTrailClientTypes.InsightsMetricDataType?
    /// Specifies, in UTC, the end time for time-series data. The value specified is exclusive; results include data points up to the specified time stamp. The default is the time of request.
    public var endTime: Foundation.Date?
    /// Conditionally required if the InsightType parameter is set to ApiErrorRateInsight. If returning metrics for the ApiErrorRateInsight Insights type, this is the error to retrieve data for. For example, AccessDenied.
    public var errorCode: Swift.String?
    /// The name of the event, typically the Amazon Web Services API on which unusual levels of activity were recorded.
    /// This member is required.
    public var eventName: Swift.String?
    /// The Amazon Web Services service to which the request was made, such as iam.amazonaws.com or s3.amazonaws.com.
    /// This member is required.
    public var eventSource: Swift.String?
    /// The type of CloudTrail Insights event, which is either ApiCallRateInsight or ApiErrorRateInsight. The ApiCallRateInsight Insights type analyzes write-only management API calls that are aggregated per minute against a baseline API call volume. The ApiErrorRateInsight Insights type analyzes management API calls that result in error codes.
    /// This member is required.
    public var insightType: CloudTrailClientTypes.InsightType?
    /// The maximum number of datapoints to return. Valid values are integers from 1 to 21600. The default value is 21600.
    public var maxResults: Swift.Int?
    /// Returned if all datapoints can't be returned in a single call. For example, due to reaching MaxResults. Add this parameter to the request to continue retrieving results starting from the last evaluated point.
    public var nextToken: Swift.String?
    /// Granularity of data to retrieve, in seconds. Valid values are 60, 300, and 3600. If you specify any other value, you will get an error. The default is 3600 seconds.
    public var period: Swift.Int?
    /// Specifies, in UTC, the start time for time-series data. The value specified is inclusive; results include data points with the specified time stamp. The default is 90 days before the time of request.
    public var startTime: Foundation.Date?

    public init(
        dataType: CloudTrailClientTypes.InsightsMetricDataType? = nil,
        endTime: Foundation.Date? = nil,
        errorCode: Swift.String? = nil,
        eventName: Swift.String? = nil,
        eventSource: Swift.String? = nil,
        insightType: CloudTrailClientTypes.InsightType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        period: Swift.Int? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.dataType = dataType
        self.endTime = endTime
        self.errorCode = errorCode
        self.eventName = eventName
        self.eventSource = eventSource
        self.insightType = insightType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.period = period
        self.startTime = startTime
    }
}

public struct ListInsightsMetricDataOutput: Swift.Sendable {
    /// Only returned if InsightType parameter was set to ApiErrorRateInsight. If returning metrics for the ApiErrorRateInsight Insights type, this is the error to retrieve data for. For example, AccessDenied.
    public var errorCode: Swift.String?
    /// The name of the event, typically the Amazon Web Services API on which unusual levels of activity were recorded.
    public var eventName: Swift.String?
    /// The Amazon Web Services service to which the request was made, such as iam.amazonaws.com or s3.amazonaws.com.
    public var eventSource: Swift.String?
    /// The type of CloudTrail Insights event, which is either ApiCallRateInsight or ApiErrorRateInsight. The ApiCallRateInsight Insights type analyzes write-only management API calls that are aggregated per minute against a baseline API call volume. The ApiErrorRateInsight Insights type analyzes management API calls that result in error codes.
    public var insightType: CloudTrailClientTypes.InsightType?
    /// Only returned if the full results could not be returned in a single query. You can set the NextToken parameter in the next request to this value to continue retrieval.
    public var nextToken: Swift.String?
    /// List of timestamps at intervals corresponding to the specified time period.
    public var timestamps: [Foundation.Date]?
    /// List of values representing the API call rate or error rate at each timestamp. The number of values is equal to the number of timestamps.
    public var values: [Swift.Double]?

    public init(
        errorCode: Swift.String? = nil,
        eventName: Swift.String? = nil,
        eventSource: Swift.String? = nil,
        insightType: CloudTrailClientTypes.InsightType? = nil,
        nextToken: Swift.String? = nil,
        timestamps: [Foundation.Date]? = nil,
        values: [Swift.Double]? = nil
    )
    {
        self.errorCode = errorCode
        self.eventName = eventName
        self.eventSource = eventSource
        self.insightType = insightType
        self.nextToken = nextToken
        self.timestamps = timestamps
        self.values = values
    }
}

/// Occurs if the timestamp values are not valid. Either the start time occurs after the end time, or the time range is outside the range of possible values.
public struct InvalidTimeRangeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTimeRange" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Reserved for future use.
public struct InvalidTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidToken" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Requests the public keys for a specified time range.
public struct ListPublicKeysInput: Swift.Sendable {
    /// Optionally specifies, in UTC, the end of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used.
    public var endTime: Foundation.Date?
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Optionally specifies, in UTC, the start of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used, and the current public key is returned.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension CloudTrailClientTypes {

    /// Contains information about a returned public key.
    public struct PublicKey: Swift.Sendable {
        /// The fingerprint of the public key.
        public var fingerprint: Swift.String?
        /// The ending time of validity of the public key.
        public var validityEndTime: Foundation.Date?
        /// The starting time of validity of the public key.
        public var validityStartTime: Foundation.Date?
        /// The DER encoded public key value in PKCS#1 format.
        public var value: Foundation.Data?

        public init(
            fingerprint: Swift.String? = nil,
            validityEndTime: Foundation.Date? = nil,
            validityStartTime: Foundation.Date? = nil,
            value: Foundation.Data? = nil
        )
        {
            self.fingerprint = fingerprint
            self.validityEndTime = validityEndTime
            self.validityStartTime = validityStartTime
            self.value = value
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct ListPublicKeysOutput: Swift.Sendable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Contains an array of PublicKey objects. The returned public keys may have validity time ranges that overlap.
    public var publicKeyList: [CloudTrailClientTypes.PublicKey]?

    public init(
        nextToken: Swift.String? = nil,
        publicKeyList: [CloudTrailClientTypes.PublicKey]? = nil
    )
    {
        self.nextToken = nextToken
        self.publicKeyList = publicKeyList
    }
}

/// A date range for the query was specified that is not valid. Be sure that the start time is chronologically before the end time. For more information about writing a query, see [Create or edit a query](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-create-edit-query.html) in the CloudTrail User Guide.
public struct InvalidDateRangeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDateRange" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The query status is not valid for the operation.
public struct InvalidQueryStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidQueryStatus" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListQueriesInput: Swift.Sendable {
    /// Use with StartTime to bound a ListQueries request, and limit its results to only those queries run within a specified time period.
    public var endTime: Foundation.Date?
    /// The ARN (or the ID suffix of the ARN) of an event data store on which queries were run.
    /// This member is required.
    public var eventDataStore: Swift.String?
    /// The maximum number of queries to show on a page.
    public var maxResults: Swift.Int?
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?
    /// The status of queries that you want to return in results. Valid values for QueryStatus include QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.
    public var queryStatus: CloudTrailClientTypes.QueryStatus?
    /// Use with EndTime to bound a ListQueries request, and limit its results to only those queries run within a specified time period.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        eventDataStore: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryStatus: CloudTrailClientTypes.QueryStatus? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventDataStore = eventDataStore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryStatus = queryStatus
        self.startTime = startTime
    }
}

extension CloudTrailClientTypes {

    /// A SQL string of criteria about events that you want to collect in an event data store.
    public struct Query: Swift.Sendable {
        /// The creation time of a query.
        public var creationTime: Foundation.Date?
        /// The ID of a query.
        public var queryId: Swift.String?
        /// The status of the query. This can be QUEUED, RUNNING, FINISHED, FAILED, TIMED_OUT, or CANCELLED.
        public var queryStatus: CloudTrailClientTypes.QueryStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            queryId: Swift.String? = nil,
            queryStatus: CloudTrailClientTypes.QueryStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.queryId = queryId
            self.queryStatus = queryStatus
        }
    }
}

public struct ListQueriesOutput: Swift.Sendable {
    /// A token you can use to get the next page of results.
    public var nextToken: Swift.String?
    /// Lists matching query results, and shows query ID, status, and creation time of each query.
    public var queries: [CloudTrailClientTypes.Query]?

    public init(
        nextToken: Swift.String? = nil,
        queries: [CloudTrailClientTypes.Query]? = nil
    )
    {
        self.nextToken = nextToken
        self.queries = queries
    }
}

/// Specifies a list of tags to return.
public struct ListTagsInput: Swift.Sendable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// Specifies a list of trail, event data store, or channel ARNs whose tags will be listed. The list has a limit of 20 ARNs. Example trail ARN format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail Example event data store ARN format: arn:aws:cloudtrail:us-east-2:123456789012:eventdatastore/EXAMPLE-f852-4e8f-8bd1-bcf6cEXAMPLE Example channel ARN format: arn:aws:cloudtrail:us-east-2:123456789012:channel/01234567890
    /// This member is required.
    public var resourceIdList: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        resourceIdList: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdList = resourceIdList
    }
}

extension CloudTrailClientTypes {

    /// A resource tag.
    public struct ResourceTag: Swift.Sendable {
        /// Specifies the ARN of the resource.
        public var resourceId: Swift.String?
        /// A list of tags.
        public var tagsList: [CloudTrailClientTypes.Tag]?

        public init(
            resourceId: Swift.String? = nil,
            tagsList: [CloudTrailClientTypes.Tag]? = nil
        )
        {
            self.resourceId = resourceId
            self.tagsList = tagsList
        }
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct ListTagsOutput: Swift.Sendable {
    /// Reserved for future use.
    public var nextToken: Swift.String?
    /// A list of resource tags.
    public var resourceTagList: [CloudTrailClientTypes.ResourceTag]?

    public init(
        nextToken: Swift.String? = nil,
        resourceTagList: [CloudTrailClientTypes.ResourceTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTagList = resourceTagList
    }
}

public struct ListTrailsInput: Swift.Sendable {
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension CloudTrailClientTypes {

    /// Information about a CloudTrail trail, including the trail's name, home Region, and Amazon Resource Name (ARN).
    public struct TrailInfo: Swift.Sendable {
        /// The Amazon Web Services Region in which a trail was created.
        public var homeRegion: Swift.String?
        /// The name of a trail.
        public var name: Swift.String?
        /// The ARN of a trail.
        public var trailARN: Swift.String?

        public init(
            homeRegion: Swift.String? = nil,
            name: Swift.String? = nil,
            trailARN: Swift.String? = nil
        )
        {
            self.homeRegion = homeRegion
            self.name = name
            self.trailARN = trailARN
        }
    }
}

public struct ListTrailsOutput: Swift.Sendable {
    /// The token to use to get the next page of results after a previous API call. If the token does not appear, there are no more results to return. The token must be passed in with the same parameters as the previous call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?
    /// Returns the name, ARN, and home Region of trails in the current account.
    public var trails: [CloudTrailClientTypes.TrailInfo]?

    public init(
        nextToken: Swift.String? = nil,
        trails: [CloudTrailClientTypes.TrailInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.trails = trails
    }
}

/// Occurs if an event category that is not valid is specified as a value of EventCategory.
public struct InvalidEventCategoryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEventCategory" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Occurs when a lookup attribute is specified that is not valid.
public struct InvalidLookupAttributesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLookupAttributes" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudTrailClientTypes {

    public enum EventCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case insight
        case sdkUnknown(Swift.String)

        public static var allCases: [EventCategory] {
            return [
                .insight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .insight: return "insight"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudTrailClientTypes {

    public enum LookupAttributeKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessKeyId
        case eventId
        case eventName
        case eventSource
        case readOnly
        case resourceName
        case resourceType
        case username
        case sdkUnknown(Swift.String)

        public static var allCases: [LookupAttributeKey] {
            return [
                .accessKeyId,
                .eventId,
                .eventName,
                .eventSource,
                .readOnly,
                .resourceName,
                .resourceType,
                .username
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessKeyId: return "AccessKeyId"
            case .eventId: return "EventId"
            case .eventName: return "EventName"
            case .eventSource: return "EventSource"
            case .readOnly: return "ReadOnly"
            case .resourceName: return "ResourceName"
            case .resourceType: return "ResourceType"
            case .username: return "Username"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudTrailClientTypes {

    /// Specifies an attribute and value that filter the events returned.
    public struct LookupAttribute: Swift.Sendable {
        /// Specifies an attribute on which to filter the events returned.
        /// This member is required.
        public var attributeKey: CloudTrailClientTypes.LookupAttributeKey?
        /// Specifies a value for the specified AttributeKey. The maximum length for the AttributeValue is 2000 characters. The following characters ('_', '', ',', '\\n') count as two characters towards the 2000 character limit.
        /// This member is required.
        public var attributeValue: Swift.String?

        public init(
            attributeKey: CloudTrailClientTypes.LookupAttributeKey? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributeKey = attributeKey
            self.attributeValue = attributeValue
        }
    }
}

/// Contains a request for LookupEvents.
public struct LookupEventsInput: Swift.Sendable {
    /// Specifies that only events that occur before or at the specified time are returned. If the specified end time is before the specified start time, an error is returned.
    public var endTime: Foundation.Date?
    /// Specifies the event category. If you do not specify an event category, events of the category are not returned in the response. For example, if you do not specify insight as the value of EventCategory, no Insights events are returned.
    public var eventCategory: CloudTrailClientTypes.EventCategory?
    /// Contains a list of lookup attributes. Currently the list can contain only one item.
    public var lookupAttributes: [CloudTrailClientTypes.LookupAttribute]?
    /// The number of events to return. Possible values are 1 through 50. The default is 50.
    public var maxResults: Swift.Int?
    /// The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the original call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?
    /// Specifies that only events that occur after or at the specified time are returned. If the specified start time is after the specified end time, an error is returned.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        eventCategory: CloudTrailClientTypes.EventCategory? = nil,
        lookupAttributes: [CloudTrailClientTypes.LookupAttribute]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventCategory = eventCategory
        self.lookupAttributes = lookupAttributes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension CloudTrailClientTypes {

    /// Specifies the type and name of a resource referenced by an event.
    public struct Resource: Swift.Sendable {
        /// The name of the resource referenced by the event returned. These are user-created names whose values will depend on the environment. For example, the resource name might be "auto-scaling-test-group" for an Auto Scaling Group or "i-1234567" for an EC2 Instance.
        public var resourceName: Swift.String?
        /// The type of a resource referenced by the event returned. When the resource type cannot be determined, null is returned. Some examples of resource types are: Instance for EC2, Trail for CloudTrail, DBInstance for Amazon RDS, and AccessKey for IAM. To learn more about how to look up and filter events by the resource types supported for a service, see [Filtering CloudTrail Events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/view-cloudtrail-events-console.html#filtering-cloudtrail-events).
        public var resourceType: Swift.String?

        public init(
            resourceName: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }
}

extension CloudTrailClientTypes {

    /// Contains information about an event that was returned by a lookup request. The result includes a representation of a CloudTrail event.
    public struct Event: Swift.Sendable {
        /// The Amazon Web Services access key ID that was used to sign the request. If the request was made with temporary security credentials, this is the access key ID of the temporary credentials.
        public var accessKeyId: Swift.String?
        /// A JSON string that contains a representation of the event returned.
        public var cloudTrailEvent: Swift.String?
        /// The CloudTrail ID of the event returned.
        public var eventId: Swift.String?
        /// The name of the event returned.
        public var eventName: Swift.String?
        /// The Amazon Web Services service to which the request was made.
        public var eventSource: Swift.String?
        /// The date and time of the event returned.
        public var eventTime: Foundation.Date?
        /// Information about whether the event is a write event or a read event.
        public var readOnly: Swift.String?
        /// A list of resources referenced by the event returned.
        public var resources: [CloudTrailClientTypes.Resource]?
        /// A user name or role name of the requester that called the API in the event returned.
        public var username: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            cloudTrailEvent: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventName: Swift.String? = nil,
            eventSource: Swift.String? = nil,
            eventTime: Foundation.Date? = nil,
            readOnly: Swift.String? = nil,
            resources: [CloudTrailClientTypes.Resource]? = nil,
            username: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.cloudTrailEvent = cloudTrailEvent
            self.eventId = eventId
            self.eventName = eventName
            self.eventSource = eventSource
            self.eventTime = eventTime
            self.readOnly = readOnly
            self.resources = resources
            self.username = username
        }
    }
}

/// Contains a response to a LookupEvents action.
public struct LookupEventsOutput: Swift.Sendable {
    /// A list of events returned based on the lookup attributes specified and the CloudTrail event. The events list is sorted by time. The most recent event is listed first.
    public var events: [CloudTrailClientTypes.Event]?
    /// The token to use to get the next page of results after a previous API call. If the token does not appear, there are no more results to return. The token must be passed in with the same parameters as the previous call. For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.
    public var nextToken: Swift.String?

    public init(
        events: [CloudTrailClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

public struct PutEventSelectorsInput: Swift.Sendable {
    /// Specifies the settings for advanced event selectors. You can use advanced event selectors to log management events, data events for all resource types, and network activity events. You can add advanced event selectors, and conditions for your advanced event selectors, up to a maximum of 500 values for all conditions and selectors on a trail. You can use either AdvancedEventSelectors or EventSelectors, but not both. If you apply AdvancedEventSelectors to a trail, any existing EventSelectors are overwritten. For more information about advanced event selectors, see [Logging data events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html) and [Logging network activity events](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-network-events-with-cloudtrail.html) in the CloudTrail User Guide.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the settings for your event selectors. You can use event selectors to log management events and data events for the following resource types:
    ///
    /// * AWS::DynamoDB::Table
    ///
    /// * AWS::Lambda::Function
    ///
    /// * AWS::S3::Object
    ///
    ///
    /// You can't use event selectors to log network activity events. You can configure up to five event selectors for a trail. You can use either EventSelectors or AdvancedEventSelectors in a PutEventSelectors request, but not both. If you apply EventSelectors to a trail, any existing AdvancedEventSelectors are overwritten.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// Specifies the name of the trail or trail ARN. If you specify a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If you specify a trail ARN, it must be in the following format. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var trailName: Swift.String?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailName: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailName = trailName
    }
}

public struct PutEventSelectorsOutput: Swift.Sendable {
    /// Specifies the advanced event selectors configured for your trail.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// Specifies the event selectors configured for your trail.
    public var eventSelectors: [CloudTrailClientTypes.EventSelector]?
    /// Specifies the ARN of the trail that was updated with event selectors. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        eventSelectors: [CloudTrailClientTypes.EventSelector]? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

/// For PutInsightSelectors, this exception is thrown when the formatting or syntax of the InsightSelectors JSON statement is not valid, or the specified InsightType in the InsightSelectors statement is not valid. Valid values for InsightType are ApiCallRateInsight and ApiErrorRateInsight. To enable Insights on an event data store, the destination event data store specified by the InsightsDestination parameter must log Insights events and the source event data store specified by the EventDataStore parameter must log management events. For UpdateEventDataStore, this exception is thrown if Insights are enabled on the event data store and the updated advanced event selectors are not compatible with the configured InsightSelectors. If the InsightSelectors includes an InsightType of ApiCallRateInsight, the source event data store must log write management events. If the InsightSelectors includes an InsightType of ApiErrorRateInsight, the source event data store must log management events.
public struct InvalidInsightSelectorsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInsightSelectors" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutInsightSelectorsInput: Swift.Sendable {
    /// The ARN (or ID suffix of the ARN) of the source event data store for which you want to change or add Insights selectors. To enable Insights on an event data store, you must provide both the EventDataStore and InsightsDestination parameters. You cannot use this parameter with the TrailName parameter.
    public var eventDataStore: Swift.String?
    /// A JSON string that contains the Insights types you want to log on a trail or event data store. ApiCallRateInsight and ApiErrorRateInsight are valid Insight types. The ApiCallRateInsight Insights type analyzes write-only management API calls that are aggregated per minute against a baseline API call volume. The ApiErrorRateInsight Insights type analyzes management API calls that result in error codes. The error is shown if the API call is unsuccessful.
    /// This member is required.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The ARN (or ID suffix of the ARN) of the destination event data store that logs Insights events. To enable Insights on an event data store, you must provide both the EventDataStore and InsightsDestination parameters. You cannot use this parameter with the TrailName parameter.
    public var insightsDestination: Swift.String?
    /// The name of the CloudTrail trail for which you want to change or add Insights selectors. You cannot use this parameter with the EventDataStore and InsightsDestination parameters.
    public var trailName: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil,
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        insightsDestination: Swift.String? = nil,
        trailName: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
        self.insightSelectors = insightSelectors
        self.insightsDestination = insightsDestination
        self.trailName = trailName
    }
}

public struct PutInsightSelectorsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the source event data store for which you want to change or add Insights selectors.
    public var eventDataStoreArn: Swift.String?
    /// A JSON string that contains the Insights event types that you want to log on a trail or event data store. The valid Insights types are ApiErrorRateInsight and ApiCallRateInsight.
    public var insightSelectors: [CloudTrailClientTypes.InsightSelector]?
    /// The ARN of the destination event data store that logs Insights events.
    public var insightsDestination: Swift.String?
    /// The Amazon Resource Name (ARN) of a trail for which you want to change or add Insights selectors.
    public var trailARN: Swift.String?

    public init(
        eventDataStoreArn: Swift.String? = nil,
        insightSelectors: [CloudTrailClientTypes.InsightSelector]? = nil,
        insightsDestination: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.eventDataStoreArn = eventDataStoreArn
        self.insightSelectors = insightSelectors
        self.insightsDestination = insightsDestination
        self.trailARN = trailARN
    }
}

/// This exception is thrown when the resouce-based policy has syntax errors, or contains a principal that is not valid. The following are requirements for the resource policy:
///
/// * Contains only one action: cloudtrail-data:PutAuditEvents
///
/// * Contains at least one statement. The policy can have a maximum of 20 statements.
///
/// * Each statement contains at least one principal. A statement can have a maximum of 50 principals.
public struct ResourcePolicyNotValidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePolicyNotValid" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel attached to the resource-based policy. The following is the format of a resource ARN: arn:aws:cloudtrail:us-east-2:123456789012:channel/MyChannel.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A JSON-formatted string for an Amazon Web Services resource-based policy. The following are requirements for the resource policy:
    ///
    /// * Contains only one action: cloudtrail-data:PutAuditEvents
    ///
    /// * Contains at least one statement. The policy can have a maximum of 20 statements.
    ///
    /// * Each statement contains at least one principal. A statement can have a maximum of 50 principals.
    /// This member is required.
    public var resourcePolicy: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourcePolicy = resourcePolicy
    }
}

public struct PutResourcePolicyOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the CloudTrail channel attached to the resource-based policy.
    public var resourceArn: Swift.String?
    /// The JSON-formatted string of the Amazon Web Services resource-based policy attached to the CloudTrail channel.
    public var resourcePolicy: Swift.String?

    public init(
        resourceArn: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourcePolicy = resourcePolicy
    }
}

/// This exception is thrown when the maximum number of CloudTrail delegated administrators is reached.
public struct DelegatedAdminAccountLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DelegatedAdminAccountLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Specifies an organization member account ID as a CloudTrail delegated administrator.
public struct RegisterOrganizationDelegatedAdminInput: Swift.Sendable {
    /// An organization member account ID that you want to designate as a delegated administrator.
    /// This member is required.
    public var memberAccountId: Swift.String?

    public init(
        memberAccountId: Swift.String? = nil
    )
    {
        self.memberAccountId = memberAccountId
    }
}

/// Returns the following response if successful. Otherwise, returns an error.
public struct RegisterOrganizationDelegatedAdminOutput: Swift.Sendable {

    public init() { }
}

/// Specifies the tags to remove from a trail, event data store, or channel.
public struct RemoveTagsInput: Swift.Sendable {
    /// Specifies the ARN of the trail, event data store, or channel from which tags should be removed. Example trail ARN format: arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail Example event data store ARN format: arn:aws:cloudtrail:us-east-2:123456789012:eventdatastore/EXAMPLE-f852-4e8f-8bd1-bcf6cEXAMPLE Example channel ARN format: arn:aws:cloudtrail:us-east-2:123456789012:channel/01234567890
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies a list of tags to be removed.
    /// This member is required.
    public var tagsList: [CloudTrailClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tagsList: [CloudTrailClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct RemoveTagsOutput: Swift.Sendable {

    public init() { }
}

/// The event data store is not in a status that supports the operation.
public struct InvalidEventDataStoreStatusException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEventDataStoreStatus" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct RestoreEventDataStoreInput: Swift.Sendable {
    /// The ARN (or the ID suffix of the ARN) of the event data store that you want to restore.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

public struct RestoreEventDataStoreOutput: Swift.Sendable {
    /// The advanced event selectors that were used to select events.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The billing mode for the event data store.
    public var billingMode: CloudTrailClientTypes.BillingMode?
    /// The timestamp of an event data store's creation.
    public var createdTimestamp: Foundation.Date?
    /// The event data store ARN.
    public var eventDataStoreArn: Swift.String?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store is collecting events from all Regions, or only from the Region in which the event data store was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of the event data store.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// Indicates that termination protection is enabled and the event data store cannot be automatically deleted.
    public var terminationProtectionEnabled: Swift.Bool?
    /// The timestamp that shows when an event data store was updated, if applicable. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: Foundation.Date?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        billingMode: CloudTrailClientTypes.BillingMode? = nil,
        createdTimestamp: Foundation.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: Foundation.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.billingMode = billingMode
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

public struct StartEventDataStoreIngestionInput: Swift.Sendable {
    /// The ARN (or ID suffix of the ARN) of the event data store for which you want to start ingestion.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

public struct StartEventDataStoreIngestionOutput: Swift.Sendable {

    public init() { }
}

/// This exception is thrown when the provided source S3 bucket is not valid for import.
public struct InvalidImportSourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidImportSource" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartImportInput: Swift.Sendable {
    /// The ARN of the destination event data store. Use this parameter for a new import.
    public var destinations: [Swift.String]?
    /// Use with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period. When you specify a time range, CloudTrail checks the prefix and log file names to verify the names contain a date between the specified StartEventTime and EndEventTime before attempting to import events.
    public var endEventTime: Foundation.Date?
    /// The ID of the import. Use this parameter when you are retrying an import.
    public var importId: Swift.String?
    /// The source S3 bucket for the import. Use this parameter for a new import.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Use with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period. When you specify a time range, CloudTrail checks the prefix and log file names to verify the names contain a date between the specified StartEventTime and EndEventTime before attempting to import events.
    public var startEventTime: Foundation.Date?

    public init(
        destinations: [Swift.String]? = nil,
        endEventTime: Foundation.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        startEventTime: Foundation.Date? = nil
    )
    {
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.startEventTime = startEventTime
    }
}

public struct StartImportOutput: Swift.Sendable {
    /// The timestamp for the import's creation.
    public var createdTimestamp: Foundation.Date?
    /// The ARN of the destination event data store.
    public var destinations: [Swift.String]?
    /// Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var endEventTime: Foundation.Date?
    /// The ID of the import.
    public var importId: Swift.String?
    /// The source S3 bucket for the import.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Shows the status of the import after a StartImport request. An import finishes with a status of COMPLETED if there were no failures, or FAILED if there were failures.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var startEventTime: Foundation.Date?
    /// The timestamp of the import's last update, if applicable.
    public var updatedTimestamp: Foundation.Date?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        destinations: [Swift.String]? = nil,
        endEventTime: Foundation.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        startEventTime: Foundation.Date? = nil,
        updatedTimestamp: Foundation.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.importStatus = importStatus
        self.startEventTime = startEventTime
        self.updatedTimestamp = updatedTimestamp
    }
}

/// The request to CloudTrail to start logging Amazon Web Services API calls for an account.
public struct StartLoggingInput: Swift.Sendable {
    /// Specifies the name or the CloudTrail ARN of the trail for which CloudTrail logs Amazon Web Services API calls. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct StartLoggingOutput: Swift.Sendable {

    public init() { }
}

/// The query that was submitted has validation errors, or uses incorrect syntax or unsupported keywords. For more information about writing a query, see [Create or edit a query](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-create-edit-query.html) in the CloudTrail User Guide.
public struct InvalidQueryStatementException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidQueryStatement" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You are already running the maximum number of concurrent queries. The maximum number of concurrent queries is 10. Wait a minute for some queries to finish, and then run the query again.
public struct MaxConcurrentQueriesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Brief description of the exception returned by the request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxConcurrentQueries" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartQueryInput: Swift.Sendable {
    /// The URI for the S3 bucket where CloudTrail delivers the query results.
    public var deliveryS3Uri: Swift.String?
    /// The alias that identifies a query template.
    public var queryAlias: Swift.String?
    /// The query parameters for the specified QueryAlias.
    public var queryParameters: [Swift.String]?
    /// The SQL code of your query.
    public var queryStatement: Swift.String?

    public init(
        deliveryS3Uri: Swift.String? = nil,
        queryAlias: Swift.String? = nil,
        queryParameters: [Swift.String]? = nil,
        queryStatement: Swift.String? = nil
    )
    {
        self.deliveryS3Uri = deliveryS3Uri
        self.queryAlias = queryAlias
        self.queryParameters = queryParameters
        self.queryStatement = queryStatement
    }
}

public struct StartQueryOutput: Swift.Sendable {
    /// The ID of the started query.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

public struct StopEventDataStoreIngestionInput: Swift.Sendable {
    /// The ARN (or ID suffix of the ARN) of the event data store for which you want to stop ingestion.
    /// This member is required.
    public var eventDataStore: Swift.String?

    public init(
        eventDataStore: Swift.String? = nil
    )
    {
        self.eventDataStore = eventDataStore
    }
}

public struct StopEventDataStoreIngestionOutput: Swift.Sendable {

    public init() { }
}

public struct StopImportInput: Swift.Sendable {
    /// The ID of the import.
    /// This member is required.
    public var importId: Swift.String?

    public init(
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

public struct StopImportOutput: Swift.Sendable {
    /// The timestamp of the import's creation.
    public var createdTimestamp: Foundation.Date?
    /// The ARN of the destination event data store.
    public var destinations: [Swift.String]?
    /// Used with StartEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var endEventTime: Foundation.Date?
    /// The ID for the import.
    public var importId: Swift.String?
    /// The source S3 bucket for the import.
    public var importSource: CloudTrailClientTypes.ImportSource?
    /// Returns information on the stopped import.
    public var importStatistics: CloudTrailClientTypes.ImportStatistics?
    /// The status of the import.
    public var importStatus: CloudTrailClientTypes.ImportStatus?
    /// Used with EndEventTime to bound a StartImport request, and limit imported trail events to only those events logged within a specified time period.
    public var startEventTime: Foundation.Date?
    /// The timestamp of the import's last update.
    public var updatedTimestamp: Foundation.Date?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        destinations: [Swift.String]? = nil,
        endEventTime: Foundation.Date? = nil,
        importId: Swift.String? = nil,
        importSource: CloudTrailClientTypes.ImportSource? = nil,
        importStatistics: CloudTrailClientTypes.ImportStatistics? = nil,
        importStatus: CloudTrailClientTypes.ImportStatus? = nil,
        startEventTime: Foundation.Date? = nil,
        updatedTimestamp: Foundation.Date? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinations = destinations
        self.endEventTime = endEventTime
        self.importId = importId
        self.importSource = importSource
        self.importStatistics = importStatistics
        self.importStatus = importStatus
        self.startEventTime = startEventTime
        self.updatedTimestamp = updatedTimestamp
    }
}

/// Passes the request to CloudTrail to stop logging Amazon Web Services API calls for the specified account.
public struct StopLoggingInput: Swift.Sendable {
    /// Specifies the name or the CloudTrail ARN of the trail for which CloudTrail will stop logging Amazon Web Services API calls. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct StopLoggingOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateChannelInput: Swift.Sendable {
    /// The ARN or ID (the ARN suffix) of the channel that you want to update.
    /// This member is required.
    public var channel: Swift.String?
    /// The ARNs of event data stores that you want to log events arriving through the channel.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// Changes the name of the channel.
    public var name: Swift.String?

    public init(
        channel: Swift.String? = nil,
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        name: Swift.String? = nil
    )
    {
        self.channel = channel
        self.destinations = destinations
        self.name = name
    }
}

public struct UpdateChannelOutput: Swift.Sendable {
    /// The ARN of the channel that was updated.
    public var channelArn: Swift.String?
    /// The event data stores that log events arriving through the channel.
    public var destinations: [CloudTrailClientTypes.Destination]?
    /// The name of the channel that was updated.
    public var name: Swift.String?
    /// The event source of the channel that was updated.
    public var source: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        destinations: [CloudTrailClientTypes.Destination]? = nil,
        name: Swift.String? = nil,
        source: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.destinations = destinations
        self.name = name
        self.source = source
    }
}

public struct UpdateEventDataStoreInput: Swift.Sendable {
    /// The advanced event selectors used to select events for the event data store. You can configure up to five advanced event selectors for each event data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// You can't change the billing mode from EXTENDABLE_RETENTION_PRICING to FIXED_RETENTION_PRICING. If BillingMode is set to EXTENDABLE_RETENTION_PRICING and you want to use FIXED_RETENTION_PRICING instead, you'll need to stop ingestion on the event data store and create a new event data store that uses FIXED_RETENTION_PRICING. The billing mode for the event data store determines the cost for ingesting events and the default and maximum retention period for the event data store. The following are the possible values:
    ///
    /// * EXTENDABLE_RETENTION_PRICING - This billing mode is generally recommended if you want a flexible retention period of up to 3653 days (about 10 years). The default retention period for this billing mode is 366 days.
    ///
    /// * FIXED_RETENTION_PRICING - This billing mode is recommended if you expect to ingest more than 25 TB of event data per month and need a retention period of up to 2557 days (about 7 years). The default retention period for this billing mode is 2557 days.
    ///
    ///
    /// For more information about CloudTrail pricing, see [CloudTrail Pricing](http://aws.amazon.com/cloudtrail/pricing/) and [Managing CloudTrail Lake costs](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-lake-manage-costs.html).
    public var billingMode: CloudTrailClientTypes.BillingMode?
    /// The ARN (or the ID suffix of the ARN) of the event data store that you want to update.
    /// This member is required.
    public var eventDataStore: Swift.String?
    /// Specifies the KMS key ID to use to encrypt the events delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. Disabling or deleting the KMS key, or removing CloudTrail permissions on the key, prevents CloudTrail from logging events to the event data store, and prevents users from querying the data in the event data store that was encrypted with the key. After you associate an event data store with a KMS key, the KMS key cannot be removed or changed. Before you disable or delete a KMS key that you are using with an event data store, delete or back up your event data store. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether an event data store collects events from all Regions, or only from the Region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The event data store name.
    public var name: Swift.String?
    /// Specifies whether an event data store collects events logged for an organization in Organizations. Only the management account for the organization can convert an organization event data store to a non-organization event data store, or convert a non-organization event data store to an organization event data store.
    public var organizationEnabled: Swift.Bool?
    /// The retention period of the event data store, in days. If BillingMode is set to EXTENDABLE_RETENTION_PRICING, you can set a retention period of up to 3653 days, the equivalent of 10 years. If BillingMode is set to FIXED_RETENTION_PRICING, you can set a retention period of up to 2557 days, the equivalent of seven years. CloudTrail Lake determines whether to retain an event by checking if the eventTime of the event is within the specified retention period. For example, if you set a retention period of 90 days, CloudTrail will remove events when the eventTime is older than 90 days. If you decrease the retention period of an event data store, CloudTrail will remove any events with an eventTime older than the new retention period. For example, if the previous retention period was 365 days and you decrease it to 100 days, CloudTrail will remove events with an eventTime older than 100 days.
    public var retentionPeriod: Swift.Int?
    /// Indicates that termination protection is enabled and the event data store cannot be automatically deleted.
    public var terminationProtectionEnabled: Swift.Bool?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        billingMode: CloudTrailClientTypes.BillingMode? = nil,
        eventDataStore: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.billingMode = billingMode
        self.eventDataStore = eventDataStore
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.terminationProtectionEnabled = terminationProtectionEnabled
    }
}

public struct UpdateEventDataStoreOutput: Swift.Sendable {
    /// The advanced event selectors that are applied to the event data store.
    public var advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]?
    /// The billing mode for the event data store.
    public var billingMode: CloudTrailClientTypes.BillingMode?
    /// The timestamp that shows when an event data store was first created.
    public var createdTimestamp: Foundation.Date?
    /// The ARN of the event data store.
    public var eventDataStoreArn: Swift.String?
    /// If Lake query federation is enabled, provides the ARN of the federation role used to access the resources for the federated event data store.
    public var federationRoleArn: Swift.String?
    /// Indicates the [Lake query federation](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/query-federation.html) status. The status is ENABLED if Lake query federation is enabled, or DISABLED if Lake query federation is disabled. You cannot delete an event data store if the FederationStatus is ENABLED.
    public var federationStatus: CloudTrailClientTypes.FederationStatus?
    /// Specifies the KMS key ID that encrypts the events delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Indicates whether the event data store includes events from all Regions, or only from the Region in which it was created.
    public var multiRegionEnabled: Swift.Bool?
    /// The name of the event data store.
    public var name: Swift.String?
    /// Indicates whether an event data store is collecting logged events for an organization in Organizations.
    public var organizationEnabled: Swift.Bool?
    /// The retention period, in days.
    public var retentionPeriod: Swift.Int?
    /// The status of an event data store.
    public var status: CloudTrailClientTypes.EventDataStoreStatus?
    /// Indicates whether termination protection is enabled for the event data store.
    public var terminationProtectionEnabled: Swift.Bool?
    /// The timestamp that shows when the event data store was last updated. UpdatedTimestamp is always either the same or newer than the time shown in CreatedTimestamp.
    public var updatedTimestamp: Foundation.Date?

    public init(
        advancedEventSelectors: [CloudTrailClientTypes.AdvancedEventSelector]? = nil,
        billingMode: CloudTrailClientTypes.BillingMode? = nil,
        createdTimestamp: Foundation.Date? = nil,
        eventDataStoreArn: Swift.String? = nil,
        federationRoleArn: Swift.String? = nil,
        federationStatus: CloudTrailClientTypes.FederationStatus? = nil,
        kmsKeyId: Swift.String? = nil,
        multiRegionEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationEnabled: Swift.Bool? = nil,
        retentionPeriod: Swift.Int? = nil,
        status: CloudTrailClientTypes.EventDataStoreStatus? = nil,
        terminationProtectionEnabled: Swift.Bool? = nil,
        updatedTimestamp: Foundation.Date? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.billingMode = billingMode
        self.createdTimestamp = createdTimestamp
        self.eventDataStoreArn = eventDataStoreArn
        self.federationRoleArn = federationRoleArn
        self.federationStatus = federationStatus
        self.kmsKeyId = kmsKeyId
        self.multiRegionEnabled = multiRegionEnabled
        self.name = name
        self.organizationEnabled = organizationEnabled
        self.retentionPeriod = retentionPeriod
        self.status = status
        self.terminationProtectionEnabled = terminationProtectionEnabled
        self.updatedTimestamp = updatedTimestamp
    }
}

/// Specifies settings to update for the trail.
public struct UpdateTrailInput: Swift.Sendable {
    /// Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs are delivered. You must use a log group that exists in your account. Not required unless you specify CloudWatchLogsRoleArn.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group. You must use a role that exists in your account.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether log file validation is enabled. The default is false. When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail does not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.
    public var enableLogFileValidation: Swift.Bool?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail applies only to the current Region or to all Regions. The default is false. If the trail exists only in the current Region and this value is set to true, shadow trails (replications of the trail) will be created in the other Regions. If the trail exists in all Regions and this value is set to false, the trail will remain in the Region where it was created, and its shadow trails in other Regions will be deleted. As a best practice, consider using trails that log events in all Regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is applied to all accounts in an organization in Organizations, or only for the current Amazon Web Services account. The default is false, and cannot be true unless the call is made on behalf of an Amazon Web Services account that is the management account for an organization in Organizations. If the trail is not an organization trail and this is set to true, the trail will be created in all Amazon Web Services accounts that belong to the organization. If the trail is an organization trail and this is set to false, the trail will remain in the current Amazon Web Services account but be deleted from all member accounts in the organization. Only the management account for the organization can convert an organization trail to a non-organization trail, or convert a non-organization trail to an organization trail.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The value can be an alias name prefixed by "alias/", a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier. CloudTrail also supports KMS multi-Region keys. For more information about multi-Region keys, see [Using multi-Region keys](https://docs.aws.amazon.com/kms/latest/developerguide/multi-region-keys-overview.html) in the Key Management Service Developer Guide. Examples:
    ///
    /// * alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:alias/MyAliasName
    ///
    /// * arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    ///
    /// * 12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies the name of the trail or trail ARN. If Name is a trail name, the string must meet the following requirements:
    ///
    /// * Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)
    ///
    /// * Start with a letter or number, and end with a letter or number
    ///
    /// * Be between 3 and 128 characters
    ///
    /// * Have no adjacent periods, underscores or dashes. Names like my-_namespace and my--namespace are not valid.
    ///
    /// * Not be in IP address format (for example, 192.168.5.4)
    ///
    ///
    /// If Name is a trail ARN, it must be in the following format. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files. See [Amazon S3 Bucket naming rules](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html).
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your CloudTrail Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/get-and-view-cloudtrail-log-files.html#cloudtrail-find-log-files). The maximum length is 200 characters.
    public var s3KeyPrefix: Swift.String?
    /// Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.
    public var snsTopicName: Swift.String?

    public init(
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        enableLogFileValidation: Swift.Bool? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicName: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
    }
}

/// Returns the objects or data listed below if successful. Otherwise, returns an error.
public struct UpdateTrailOutput: Swift.Sendable {
    /// Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs are delivered.
    public var cloudWatchLogsLogGroupArn: Swift.String?
    /// Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.
    public var cloudWatchLogsRoleArn: Swift.String?
    /// Specifies whether the trail is publishing events from global services such as IAM to the log files.
    public var includeGlobalServiceEvents: Swift.Bool?
    /// Specifies whether the trail exists in one Region or in all Regions.
    public var isMultiRegionTrail: Swift.Bool?
    /// Specifies whether the trail is an organization trail.
    public var isOrganizationTrail: Swift.Bool?
    /// Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the following format. arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012
    public var kmsKeyId: Swift.String?
    /// Specifies whether log file integrity validation is enabled.
    public var logFileValidationEnabled: Swift.Bool?
    /// Specifies the name of the trail.
    public var name: Swift.String?
    /// Specifies the name of the Amazon S3 bucket designated for publishing log files.
    public var s3BucketName: Swift.String?
    /// Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated for log file delivery. For more information, see [Finding Your IAM Log Files](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/get-and-view-cloudtrail-log-files.html#cloudtrail-find-log-files).
    public var s3KeyPrefix: Swift.String?
    /// Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The following is the format of a topic ARN. arn:aws:sns:us-east-2:123456789012:MyTopic
    public var snsTopicARN: Swift.String?
    /// This field is no longer in use. Use SnsTopicARN.
    @available(*, deprecated)
    public var snsTopicName: Swift.String?
    /// Specifies the ARN of the trail that was updated. The following is the format of a trail ARN. arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail
    public var trailARN: Swift.String?

    public init(
        cloudWatchLogsLogGroupArn: Swift.String? = nil,
        cloudWatchLogsRoleArn: Swift.String? = nil,
        includeGlobalServiceEvents: Swift.Bool? = nil,
        isMultiRegionTrail: Swift.Bool? = nil,
        isOrganizationTrail: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        logFileValidationEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        snsTopicARN: Swift.String? = nil,
        snsTopicName: Swift.String? = nil,
        trailARN: Swift.String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

extension AddTagsInput {

    static func urlPathProvider(_ value: AddTagsInput) -> Swift.String? {
        return "/"
    }
}

extension CancelQueryInput {

    static func urlPathProvider(_ value: CancelQueryInput) -> Swift.String? {
        return "/"
    }
}

extension CreateChannelInput {

    static func urlPathProvider(_ value: CreateChannelInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEventDataStoreInput {

    static func urlPathProvider(_ value: CreateEventDataStoreInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTrailInput {

    static func urlPathProvider(_ value: CreateTrailInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteChannelInput {

    static func urlPathProvider(_ value: DeleteChannelInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEventDataStoreInput {

    static func urlPathProvider(_ value: DeleteEventDataStoreInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTrailInput {

    static func urlPathProvider(_ value: DeleteTrailInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterOrganizationDelegatedAdminInput {

    static func urlPathProvider(_ value: DeregisterOrganizationDelegatedAdminInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeQueryInput {

    static func urlPathProvider(_ value: DescribeQueryInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTrailsInput {

    static func urlPathProvider(_ value: DescribeTrailsInput) -> Swift.String? {
        return "/"
    }
}

extension DisableFederationInput {

    static func urlPathProvider(_ value: DisableFederationInput) -> Swift.String? {
        return "/"
    }
}

extension EnableFederationInput {

    static func urlPathProvider(_ value: EnableFederationInput) -> Swift.String? {
        return "/"
    }
}

extension GetChannelInput {

    static func urlPathProvider(_ value: GetChannelInput) -> Swift.String? {
        return "/"
    }
}

extension GetEventDataStoreInput {

    static func urlPathProvider(_ value: GetEventDataStoreInput) -> Swift.String? {
        return "/"
    }
}

extension GetEventSelectorsInput {

    static func urlPathProvider(_ value: GetEventSelectorsInput) -> Swift.String? {
        return "/"
    }
}

extension GetImportInput {

    static func urlPathProvider(_ value: GetImportInput) -> Swift.String? {
        return "/"
    }
}

extension GetInsightSelectorsInput {

    static func urlPathProvider(_ value: GetInsightSelectorsInput) -> Swift.String? {
        return "/"
    }
}

extension GetQueryResultsInput {

    static func urlPathProvider(_ value: GetQueryResultsInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetTrailInput {

    static func urlPathProvider(_ value: GetTrailInput) -> Swift.String? {
        return "/"
    }
}

extension GetTrailStatusInput {

    static func urlPathProvider(_ value: GetTrailStatusInput) -> Swift.String? {
        return "/"
    }
}

extension ListChannelsInput {

    static func urlPathProvider(_ value: ListChannelsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEventDataStoresInput {

    static func urlPathProvider(_ value: ListEventDataStoresInput) -> Swift.String? {
        return "/"
    }
}

extension ListImportFailuresInput {

    static func urlPathProvider(_ value: ListImportFailuresInput) -> Swift.String? {
        return "/"
    }
}

extension ListImportsInput {

    static func urlPathProvider(_ value: ListImportsInput) -> Swift.String? {
        return "/"
    }
}

extension ListInsightsMetricDataInput {

    static func urlPathProvider(_ value: ListInsightsMetricDataInput) -> Swift.String? {
        return "/"
    }
}

extension ListPublicKeysInput {

    static func urlPathProvider(_ value: ListPublicKeysInput) -> Swift.String? {
        return "/"
    }
}

extension ListQueriesInput {

    static func urlPathProvider(_ value: ListQueriesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTrailsInput {

    static func urlPathProvider(_ value: ListTrailsInput) -> Swift.String? {
        return "/"
    }
}

extension LookupEventsInput {

    static func urlPathProvider(_ value: LookupEventsInput) -> Swift.String? {
        return "/"
    }
}

extension PutEventSelectorsInput {

    static func urlPathProvider(_ value: PutEventSelectorsInput) -> Swift.String? {
        return "/"
    }
}

extension PutInsightSelectorsInput {

    static func urlPathProvider(_ value: PutInsightSelectorsInput) -> Swift.String? {
        return "/"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterOrganizationDelegatedAdminInput {

    static func urlPathProvider(_ value: RegisterOrganizationDelegatedAdminInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveTagsInput {

    static func urlPathProvider(_ value: RemoveTagsInput) -> Swift.String? {
        return "/"
    }
}

extension RestoreEventDataStoreInput {

    static func urlPathProvider(_ value: RestoreEventDataStoreInput) -> Swift.String? {
        return "/"
    }
}

extension StartEventDataStoreIngestionInput {

    static func urlPathProvider(_ value: StartEventDataStoreIngestionInput) -> Swift.String? {
        return "/"
    }
}

extension StartImportInput {

    static func urlPathProvider(_ value: StartImportInput) -> Swift.String? {
        return "/"
    }
}

extension StartLoggingInput {

    static func urlPathProvider(_ value: StartLoggingInput) -> Swift.String? {
        return "/"
    }
}

extension StartQueryInput {

    static func urlPathProvider(_ value: StartQueryInput) -> Swift.String? {
        return "/"
    }
}

extension StopEventDataStoreIngestionInput {

    static func urlPathProvider(_ value: StopEventDataStoreIngestionInput) -> Swift.String? {
        return "/"
    }
}

extension StopImportInput {

    static func urlPathProvider(_ value: StopImportInput) -> Swift.String? {
        return "/"
    }
}

extension StopLoggingInput {

    static func urlPathProvider(_ value: StopLoggingInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateChannelInput {

    static func urlPathProvider(_ value: UpdateChannelInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateEventDataStoreInput {

    static func urlPathProvider(_ value: UpdateEventDataStoreInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTrailInput {

    static func urlPathProvider(_ value: UpdateTrailInput) -> Swift.String? {
        return "/"
    }
}

extension AddTagsInput {

    static func write(value: AddTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["TagsList"].writeList(value.tagsList, memberWritingClosure: CloudTrailClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CancelQueryInput {

    static func write(value: CancelQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
        try writer["QueryId"].write(value.queryId)
    }
}

extension CreateChannelInput {

    static func write(value: CreateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destinations"].writeList(value.destinations, memberWritingClosure: CloudTrailClientTypes.Destination.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Source"].write(value.source)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: CloudTrailClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEventDataStoreInput {

    static func write(value: CreateEventDataStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdvancedEventSelectors"].writeList(value.advancedEventSelectors, memberWritingClosure: CloudTrailClientTypes.AdvancedEventSelector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BillingMode"].write(value.billingMode)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MultiRegionEnabled"].write(value.multiRegionEnabled)
        try writer["Name"].write(value.name)
        try writer["OrganizationEnabled"].write(value.organizationEnabled)
        try writer["RetentionPeriod"].write(value.retentionPeriod)
        try writer["StartIngestion"].write(value.startIngestion)
        try writer["TagsList"].writeList(value.tagsList, memberWritingClosure: CloudTrailClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TerminationProtectionEnabled"].write(value.terminationProtectionEnabled)
    }
}

extension CreateTrailInput {

    static func write(value: CreateTrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsLogGroupArn"].write(value.cloudWatchLogsLogGroupArn)
        try writer["CloudWatchLogsRoleArn"].write(value.cloudWatchLogsRoleArn)
        try writer["EnableLogFileValidation"].write(value.enableLogFileValidation)
        try writer["IncludeGlobalServiceEvents"].write(value.includeGlobalServiceEvents)
        try writer["IsMultiRegionTrail"].write(value.isMultiRegionTrail)
        try writer["IsOrganizationTrail"].write(value.isOrganizationTrail)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["Name"].write(value.name)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3KeyPrefix"].write(value.s3KeyPrefix)
        try writer["SnsTopicName"].write(value.snsTopicName)
        try writer["TagsList"].writeList(value.tagsList, memberWritingClosure: CloudTrailClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteChannelInput {

    static func write(value: DeleteChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Channel"].write(value.channel)
    }
}

extension DeleteEventDataStoreInput {

    static func write(value: DeleteEventDataStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
    }
}

extension DeleteResourcePolicyInput {

    static func write(value: DeleteResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DeleteTrailInput {

    static func write(value: DeleteTrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeregisterOrganizationDelegatedAdminInput {

    static func write(value: DeregisterOrganizationDelegatedAdminInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DelegatedAdminAccountId"].write(value.delegatedAdminAccountId)
    }
}

extension DescribeQueryInput {

    static func write(value: DescribeQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
        try writer["QueryAlias"].write(value.queryAlias)
        try writer["QueryId"].write(value.queryId)
    }
}

extension DescribeTrailsInput {

    static func write(value: DescribeTrailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeShadowTrails"].write(value.includeShadowTrails)
        try writer["trailNameList"].writeList(value.trailNameList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisableFederationInput {

    static func write(value: DisableFederationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
    }
}

extension EnableFederationInput {

    static func write(value: EnableFederationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
        try writer["FederationRoleArn"].write(value.federationRoleArn)
    }
}

extension GetChannelInput {

    static func write(value: GetChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Channel"].write(value.channel)
    }
}

extension GetEventDataStoreInput {

    static func write(value: GetEventDataStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
    }
}

extension GetEventSelectorsInput {

    static func write(value: GetEventSelectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrailName"].write(value.trailName)
    }
}

extension GetImportInput {

    static func write(value: GetImportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImportId"].write(value.importId)
    }
}

extension GetInsightSelectorsInput {

    static func write(value: GetInsightSelectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
        try writer["TrailName"].write(value.trailName)
    }
}

extension GetQueryResultsInput {

    static func write(value: GetQueryResultsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
        try writer["MaxQueryResults"].write(value.maxQueryResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QueryId"].write(value.queryId)
    }
}

extension GetResourcePolicyInput {

    static func write(value: GetResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension GetTrailInput {

    static func write(value: GetTrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetTrailStatusInput {

    static func write(value: GetTrailStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension ListChannelsInput {

    static func write(value: ListChannelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListEventDataStoresInput {

    static func write(value: ListEventDataStoresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListImportFailuresInput {

    static func write(value: ListImportFailuresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImportId"].write(value.importId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListImportsInput {

    static func write(value: ListImportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
        try writer["ImportStatus"].write(value.importStatus)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListInsightsMetricDataInput {

    static func write(value: ListInsightsMetricDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataType"].write(value.dataType)
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ErrorCode"].write(value.errorCode)
        try writer["EventName"].write(value.eventName)
        try writer["EventSource"].write(value.eventSource)
        try writer["InsightType"].write(value.insightType)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Period"].write(value.period)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListPublicKeysInput {

    static func write(value: ListPublicKeysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListQueriesInput {

    static func write(value: ListQueriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["EventDataStore"].write(value.eventDataStore)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QueryStatus"].write(value.queryStatus)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListTagsInput {

    static func write(value: ListTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceIdList"].writeList(value.resourceIdList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTrailsInput {

    static func write(value: ListTrailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
    }
}

extension LookupEventsInput {

    static func write(value: LookupEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["EventCategory"].write(value.eventCategory)
        try writer["LookupAttributes"].writeList(value.lookupAttributes, memberWritingClosure: CloudTrailClientTypes.LookupAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension PutEventSelectorsInput {

    static func write(value: PutEventSelectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdvancedEventSelectors"].writeList(value.advancedEventSelectors, memberWritingClosure: CloudTrailClientTypes.AdvancedEventSelector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EventSelectors"].writeList(value.eventSelectors, memberWritingClosure: CloudTrailClientTypes.EventSelector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrailName"].write(value.trailName)
    }
}

extension PutInsightSelectorsInput {

    static func write(value: PutInsightSelectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
        try writer["InsightSelectors"].writeList(value.insightSelectors, memberWritingClosure: CloudTrailClientTypes.InsightSelector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InsightsDestination"].write(value.insightsDestination)
        try writer["TrailName"].write(value.trailName)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourcePolicy"].write(value.resourcePolicy)
    }
}

extension RegisterOrganizationDelegatedAdminInput {

    static func write(value: RegisterOrganizationDelegatedAdminInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberAccountId"].write(value.memberAccountId)
    }
}

extension RemoveTagsInput {

    static func write(value: RemoveTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["TagsList"].writeList(value.tagsList, memberWritingClosure: CloudTrailClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RestoreEventDataStoreInput {

    static func write(value: RestoreEventDataStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
    }
}

extension StartEventDataStoreIngestionInput {

    static func write(value: StartEventDataStoreIngestionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
    }
}

extension StartImportInput {

    static func write(value: StartImportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destinations"].writeList(value.destinations, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EndEventTime"].writeTimestamp(value.endEventTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ImportId"].write(value.importId)
        try writer["ImportSource"].write(value.importSource, with: CloudTrailClientTypes.ImportSource.write(value:to:))
        try writer["StartEventTime"].writeTimestamp(value.startEventTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension StartLoggingInput {

    static func write(value: StartLoggingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension StartQueryInput {

    static func write(value: StartQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryS3Uri"].write(value.deliveryS3Uri)
        try writer["QueryAlias"].write(value.queryAlias)
        try writer["QueryParameters"].writeList(value.queryParameters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryStatement"].write(value.queryStatement)
    }
}

extension StopEventDataStoreIngestionInput {

    static func write(value: StopEventDataStoreIngestionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventDataStore"].write(value.eventDataStore)
    }
}

extension StopImportInput {

    static func write(value: StopImportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImportId"].write(value.importId)
    }
}

extension StopLoggingInput {

    static func write(value: StopLoggingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateChannelInput {

    static func write(value: UpdateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Channel"].write(value.channel)
        try writer["Destinations"].writeList(value.destinations, memberWritingClosure: CloudTrailClientTypes.Destination.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }
}

extension UpdateEventDataStoreInput {

    static func write(value: UpdateEventDataStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdvancedEventSelectors"].writeList(value.advancedEventSelectors, memberWritingClosure: CloudTrailClientTypes.AdvancedEventSelector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BillingMode"].write(value.billingMode)
        try writer["EventDataStore"].write(value.eventDataStore)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MultiRegionEnabled"].write(value.multiRegionEnabled)
        try writer["Name"].write(value.name)
        try writer["OrganizationEnabled"].write(value.organizationEnabled)
        try writer["RetentionPeriod"].write(value.retentionPeriod)
        try writer["TerminationProtectionEnabled"].write(value.terminationProtectionEnabled)
    }
}

extension UpdateTrailInput {

    static func write(value: UpdateTrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsLogGroupArn"].write(value.cloudWatchLogsLogGroupArn)
        try writer["CloudWatchLogsRoleArn"].write(value.cloudWatchLogsRoleArn)
        try writer["EnableLogFileValidation"].write(value.enableLogFileValidation)
        try writer["IncludeGlobalServiceEvents"].write(value.includeGlobalServiceEvents)
        try writer["IsMultiRegionTrail"].write(value.isMultiRegionTrail)
        try writer["IsOrganizationTrail"].write(value.isOrganizationTrail)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["Name"].write(value.name)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3KeyPrefix"].write(value.s3KeyPrefix)
        try writer["SnsTopicName"].write(value.snsTopicName)
    }
}

extension AddTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddTagsOutput {
        return AddTagsOutput()
    }
}

extension CancelQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelQueryOutput()
        value.queryId = try reader["QueryId"].readIfPresent() ?? ""
        value.queryStatus = try reader["QueryStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Destination.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateEventDataStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventDataStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventDataStoreOutput()
        value.advancedEventSelectors = try reader["AdvancedEventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.AdvancedEventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.billingMode = try reader["BillingMode"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eventDataStoreArn = try reader["EventDataStoreArn"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.multiRegionEnabled = try reader["MultiRegionEnabled"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.organizationEnabled = try reader["OrganizationEnabled"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tagsList = try reader["TagsList"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.terminationProtectionEnabled = try reader["TerminationProtectionEnabled"].readIfPresent()
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CreateTrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTrailOutput()
        value.cloudWatchLogsLogGroupArn = try reader["CloudWatchLogsLogGroupArn"].readIfPresent()
        value.cloudWatchLogsRoleArn = try reader["CloudWatchLogsRoleArn"].readIfPresent()
        value.includeGlobalServiceEvents = try reader["IncludeGlobalServiceEvents"].readIfPresent()
        value.isMultiRegionTrail = try reader["IsMultiRegionTrail"].readIfPresent()
        value.isOrganizationTrail = try reader["IsOrganizationTrail"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.logFileValidationEnabled = try reader["LogFileValidationEnabled"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3KeyPrefix = try reader["S3KeyPrefix"].readIfPresent()
        value.snsTopicARN = try reader["SnsTopicARN"].readIfPresent()
        value.snsTopicName = try reader["SnsTopicName"].readIfPresent()
        value.trailARN = try reader["TrailARN"].readIfPresent()
        return value
    }
}

extension DeleteChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelOutput {
        return DeleteChannelOutput()
    }
}

extension DeleteEventDataStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventDataStoreOutput {
        return DeleteEventDataStoreOutput()
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeleteTrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTrailOutput {
        return DeleteTrailOutput()
    }
}

extension DeregisterOrganizationDelegatedAdminOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterOrganizationDelegatedAdminOutput {
        return DeregisterOrganizationDelegatedAdminOutput()
    }
}

extension DescribeQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeQueryOutput()
        value.deliveryS3Uri = try reader["DeliveryS3Uri"].readIfPresent()
        value.deliveryStatus = try reader["DeliveryStatus"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.queryId = try reader["QueryId"].readIfPresent()
        value.queryStatistics = try reader["QueryStatistics"].readIfPresent(with: CloudTrailClientTypes.QueryStatisticsForDescribeQuery.read(from:))
        value.queryStatus = try reader["QueryStatus"].readIfPresent()
        value.queryString = try reader["QueryString"].readIfPresent()
        return value
    }
}

extension DescribeTrailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTrailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTrailsOutput()
        value.trailList = try reader["trailList"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Trail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisableFederationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableFederationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableFederationOutput()
        value.eventDataStoreArn = try reader["EventDataStoreArn"].readIfPresent()
        value.federationStatus = try reader["FederationStatus"].readIfPresent()
        return value
    }
}

extension EnableFederationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableFederationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableFederationOutput()
        value.eventDataStoreArn = try reader["EventDataStoreArn"].readIfPresent()
        value.federationRoleArn = try reader["FederationRoleArn"].readIfPresent()
        value.federationStatus = try reader["FederationStatus"].readIfPresent()
        return value
    }
}

extension GetChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChannelOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Destination.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ingestionStatus = try reader["IngestionStatus"].readIfPresent(with: CloudTrailClientTypes.IngestionStatus.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.sourceConfig = try reader["SourceConfig"].readIfPresent(with: CloudTrailClientTypes.SourceConfig.read(from:))
        return value
    }
}

extension GetEventDataStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventDataStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventDataStoreOutput()
        value.advancedEventSelectors = try reader["AdvancedEventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.AdvancedEventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.billingMode = try reader["BillingMode"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eventDataStoreArn = try reader["EventDataStoreArn"].readIfPresent()
        value.federationRoleArn = try reader["FederationRoleArn"].readIfPresent()
        value.federationStatus = try reader["FederationStatus"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.multiRegionEnabled = try reader["MultiRegionEnabled"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.organizationEnabled = try reader["OrganizationEnabled"].readIfPresent()
        value.partitionKeys = try reader["PartitionKeys"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.PartitionKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.terminationProtectionEnabled = try reader["TerminationProtectionEnabled"].readIfPresent()
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetEventSelectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventSelectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventSelectorsOutput()
        value.advancedEventSelectors = try reader["AdvancedEventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.AdvancedEventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventSelectors = try reader["EventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.EventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.trailARN = try reader["TrailARN"].readIfPresent()
        return value
    }
}

extension GetImportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.endEventTime = try reader["EndEventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.importId = try reader["ImportId"].readIfPresent()
        value.importSource = try reader["ImportSource"].readIfPresent(with: CloudTrailClientTypes.ImportSource.read(from:))
        value.importStatistics = try reader["ImportStatistics"].readIfPresent(with: CloudTrailClientTypes.ImportStatistics.read(from:))
        value.importStatus = try reader["ImportStatus"].readIfPresent()
        value.startEventTime = try reader["StartEventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetInsightSelectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInsightSelectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInsightSelectorsOutput()
        value.eventDataStoreArn = try reader["EventDataStoreArn"].readIfPresent()
        value.insightSelectors = try reader["InsightSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.InsightSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.insightsDestination = try reader["InsightsDestination"].readIfPresent()
        value.trailARN = try reader["TrailARN"].readIfPresent()
        return value
    }
}

extension GetQueryResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryResultsOutput()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.queryResultRows = try reader["QueryResultRows"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.queryStatistics = try reader["QueryStatistics"].readIfPresent(with: CloudTrailClientTypes.QueryStatistics.read(from:))
        value.queryStatus = try reader["QueryStatus"].readIfPresent()
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourcePolicy = try reader["ResourcePolicy"].readIfPresent()
        return value
    }
}

extension GetTrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTrailOutput()
        value.trail = try reader["Trail"].readIfPresent(with: CloudTrailClientTypes.Trail.read(from:))
        return value
    }
}

extension GetTrailStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTrailStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTrailStatusOutput()
        value.isLogging = try reader["IsLogging"].readIfPresent()
        value.latestCloudWatchLogsDeliveryError = try reader["LatestCloudWatchLogsDeliveryError"].readIfPresent()
        value.latestCloudWatchLogsDeliveryTime = try reader["LatestCloudWatchLogsDeliveryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestDeliveryAttemptSucceeded = try reader["LatestDeliveryAttemptSucceeded"].readIfPresent()
        value.latestDeliveryAttemptTime = try reader["LatestDeliveryAttemptTime"].readIfPresent()
        value.latestDeliveryError = try reader["LatestDeliveryError"].readIfPresent()
        value.latestDeliveryTime = try reader["LatestDeliveryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestDigestDeliveryError = try reader["LatestDigestDeliveryError"].readIfPresent()
        value.latestDigestDeliveryTime = try reader["LatestDigestDeliveryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestNotificationAttemptSucceeded = try reader["LatestNotificationAttemptSucceeded"].readIfPresent()
        value.latestNotificationAttemptTime = try reader["LatestNotificationAttemptTime"].readIfPresent()
        value.latestNotificationError = try reader["LatestNotificationError"].readIfPresent()
        value.latestNotificationTime = try reader["LatestNotificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startLoggingTime = try reader["StartLoggingTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopLoggingTime = try reader["StopLoggingTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.timeLoggingStarted = try reader["TimeLoggingStarted"].readIfPresent()
        value.timeLoggingStopped = try reader["TimeLoggingStopped"].readIfPresent()
        return value
    }
}

extension ListChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsOutput()
        value.channels = try reader["Channels"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Channel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEventDataStoresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventDataStoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventDataStoresOutput()
        value.eventDataStores = try reader["EventDataStores"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.EventDataStore.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListImportFailuresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportFailuresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportFailuresOutput()
        value.failures = try reader["Failures"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.ImportFailureListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListImportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportsOutput()
        value.imports = try reader["Imports"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.ImportsListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInsightsMetricDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInsightsMetricDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInsightsMetricDataOutput()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.eventName = try reader["EventName"].readIfPresent()
        value.eventSource = try reader["EventSource"].readIfPresent()
        value.insightType = try reader["InsightType"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.timestamps = try reader["Timestamps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPublicKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPublicKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPublicKeysOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.publicKeyList = try reader["PublicKeyList"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.PublicKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListQueriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQueriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueriesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.queries = try reader["Queries"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Query.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceTagList = try reader["ResourceTagList"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTrailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTrailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrailsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.trails = try reader["Trails"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.TrailInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LookupEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> LookupEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = LookupEventsOutput()
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PutEventSelectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEventSelectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEventSelectorsOutput()
        value.advancedEventSelectors = try reader["AdvancedEventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.AdvancedEventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventSelectors = try reader["EventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.EventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.trailARN = try reader["TrailARN"].readIfPresent()
        return value
    }
}

extension PutInsightSelectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutInsightSelectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutInsightSelectorsOutput()
        value.eventDataStoreArn = try reader["EventDataStoreArn"].readIfPresent()
        value.insightSelectors = try reader["InsightSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.InsightSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.insightsDestination = try reader["InsightsDestination"].readIfPresent()
        value.trailARN = try reader["TrailARN"].readIfPresent()
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourcePolicy = try reader["ResourcePolicy"].readIfPresent()
        return value
    }
}

extension RegisterOrganizationDelegatedAdminOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterOrganizationDelegatedAdminOutput {
        return RegisterOrganizationDelegatedAdminOutput()
    }
}

extension RemoveTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveTagsOutput {
        return RemoveTagsOutput()
    }
}

extension RestoreEventDataStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreEventDataStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreEventDataStoreOutput()
        value.advancedEventSelectors = try reader["AdvancedEventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.AdvancedEventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.billingMode = try reader["BillingMode"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eventDataStoreArn = try reader["EventDataStoreArn"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.multiRegionEnabled = try reader["MultiRegionEnabled"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.organizationEnabled = try reader["OrganizationEnabled"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.terminationProtectionEnabled = try reader["TerminationProtectionEnabled"].readIfPresent()
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StartEventDataStoreIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartEventDataStoreIngestionOutput {
        return StartEventDataStoreIngestionOutput()
    }
}

extension StartImportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImportOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.endEventTime = try reader["EndEventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.importId = try reader["ImportId"].readIfPresent()
        value.importSource = try reader["ImportSource"].readIfPresent(with: CloudTrailClientTypes.ImportSource.read(from:))
        value.importStatus = try reader["ImportStatus"].readIfPresent()
        value.startEventTime = try reader["StartEventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StartLoggingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartLoggingOutput {
        return StartLoggingOutput()
    }
}

extension StartQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQueryOutput()
        value.queryId = try reader["QueryId"].readIfPresent()
        return value
    }
}

extension StopEventDataStoreIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopEventDataStoreIngestionOutput {
        return StopEventDataStoreIngestionOutput()
    }
}

extension StopImportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopImportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopImportOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.endEventTime = try reader["EndEventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.importId = try reader["ImportId"].readIfPresent()
        value.importSource = try reader["ImportSource"].readIfPresent(with: CloudTrailClientTypes.ImportSource.read(from:))
        value.importStatistics = try reader["ImportStatistics"].readIfPresent(with: CloudTrailClientTypes.ImportStatistics.read(from:))
        value.importStatus = try reader["ImportStatus"].readIfPresent()
        value.startEventTime = try reader["StartEventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StopLoggingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopLoggingOutput {
        return StopLoggingOutput()
    }
}

extension UpdateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Destination.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        return value
    }
}

extension UpdateEventDataStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventDataStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEventDataStoreOutput()
        value.advancedEventSelectors = try reader["AdvancedEventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.AdvancedEventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.billingMode = try reader["BillingMode"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eventDataStoreArn = try reader["EventDataStoreArn"].readIfPresent()
        value.federationRoleArn = try reader["FederationRoleArn"].readIfPresent()
        value.federationStatus = try reader["FederationStatus"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.multiRegionEnabled = try reader["MultiRegionEnabled"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.organizationEnabled = try reader["OrganizationEnabled"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.terminationProtectionEnabled = try reader["TerminationProtectionEnabled"].readIfPresent()
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension UpdateTrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTrailOutput()
        value.cloudWatchLogsLogGroupArn = try reader["CloudWatchLogsLogGroupArn"].readIfPresent()
        value.cloudWatchLogsRoleArn = try reader["CloudWatchLogsRoleArn"].readIfPresent()
        value.includeGlobalServiceEvents = try reader["IncludeGlobalServiceEvents"].readIfPresent()
        value.isMultiRegionTrail = try reader["IsMultiRegionTrail"].readIfPresent()
        value.isOrganizationTrail = try reader["IsOrganizationTrail"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.logFileValidationEnabled = try reader["LogFileValidationEnabled"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3KeyPrefix = try reader["S3KeyPrefix"].readIfPresent()
        value.snsTopicARN = try reader["SnsTopicARN"].readIfPresent()
        value.snsTopicName = try reader["SnsTopicName"].readIfPresent()
        value.trailARN = try reader["TrailARN"].readIfPresent()
        return value
    }
}

enum AddTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ChannelARNInvalid": return try ChannelARNInvalidException.makeError(baseError: baseError)
            case "ChannelNotFound": return try ChannelNotFoundException.makeError(baseError: baseError)
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InvalidTagParameter": return try InvalidTagParameterException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceTypeNotSupported": return try ResourceTypeNotSupportedException.makeError(baseError: baseError)
            case "TagsLimitExceeded": return try TagsLimitExceededException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InactiveQuery": return try InactiveQueryException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "QueryIdNotFound": return try QueryIdNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ChannelAlreadyExists": return try ChannelAlreadyExistsException.makeError(baseError: baseError)
            case "ChannelMaxLimitExceeded": return try ChannelMaxLimitExceededException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InvalidEventDataStoreCategory": return try InvalidEventDataStoreCategoryException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidSource": return try InvalidSourceException.makeError(baseError: baseError)
            case "InvalidTagParameter": return try InvalidTagParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "TagsLimitExceeded": return try TagsLimitExceededException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventDataStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailAccessNotEnabled": return try CloudTrailAccessNotEnabledException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EventDataStoreAlreadyExists": return try EventDataStoreAlreadyExistsException.makeError(baseError: baseError)
            case "EventDataStoreMaxLimitExceeded": return try EventDataStoreMaxLimitExceededException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InsufficientEncryptionPolicy": return try InsufficientEncryptionPolicyException.makeError(baseError: baseError)
            case "InvalidEventSelectors": return try InvalidEventSelectorsException.makeError(baseError: baseError)
            case "InvalidKmsKeyId": return try InvalidKmsKeyIdException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidTagParameter": return try InvalidTagParameterException.makeError(baseError: baseError)
            case "KmsException": return try KmsException.makeError(baseError: baseError)
            case "KmsKeyNotFound": return try KmsKeyNotFoundException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesMode": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "OrganizationsNotInUse": return try OrganizationsNotInUseException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailAccessNotEnabled": return try CloudTrailAccessNotEnabledException.makeError(baseError: baseError)
            case "CloudTrailInvalidClientTokenId": return try CloudTrailInvalidClientTokenIdException.makeError(baseError: baseError)
            case "CloudWatchLogsDeliveryUnavailable": return try CloudWatchLogsDeliveryUnavailableException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InsufficientEncryptionPolicy": return try InsufficientEncryptionPolicyException.makeError(baseError: baseError)
            case "InsufficientS3BucketPolicy": return try InsufficientS3BucketPolicyException.makeError(baseError: baseError)
            case "InsufficientSnsTopicPolicy": return try InsufficientSnsTopicPolicyException.makeError(baseError: baseError)
            case "InvalidCloudWatchLogsLogGroupArn": return try InvalidCloudWatchLogsLogGroupArnException.makeError(baseError: baseError)
            case "InvalidCloudWatchLogsRoleArn": return try InvalidCloudWatchLogsRoleArnException.makeError(baseError: baseError)
            case "InvalidKmsKeyId": return try InvalidKmsKeyIdException.makeError(baseError: baseError)
            case "InvalidParameterCombinationError": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidS3BucketName": return try InvalidS3BucketNameException.makeError(baseError: baseError)
            case "InvalidS3Prefix": return try InvalidS3PrefixException.makeError(baseError: baseError)
            case "InvalidSnsTopicName": return try InvalidSnsTopicNameException.makeError(baseError: baseError)
            case "InvalidTagParameter": return try InvalidTagParameterException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "KmsException": return try KmsException.makeError(baseError: baseError)
            case "KmsKeyDisabled": return try KmsKeyDisabledException.makeError(baseError: baseError)
            case "KmsKeyNotFound": return try KmsKeyNotFoundException.makeError(baseError: baseError)
            case "MaximumNumberOfTrailsExceeded": return try MaximumNumberOfTrailsExceededException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesMode": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "OrganizationsNotInUse": return try OrganizationsNotInUseException.makeError(baseError: baseError)
            case "S3BucketDoesNotExist": return try S3BucketDoesNotExistException.makeError(baseError: baseError)
            case "TagsLimitExceeded": return try TagsLimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TrailAlreadyExists": return try TrailAlreadyExistsException.makeError(baseError: baseError)
            case "TrailNotProvided": return try TrailNotProvidedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ChannelARNInvalid": return try ChannelARNInvalidException.makeError(baseError: baseError)
            case "ChannelNotFound": return try ChannelNotFoundException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventDataStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ChannelExistsForEDS": return try ChannelExistsForEDSException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreFederationEnabled": return try EventDataStoreFederationEnabledException.makeError(baseError: baseError)
            case "EventDataStoreHasOngoingImport": return try EventDataStoreHasOngoingImportException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "EventDataStoreTerminationProtectedException": return try EventDataStoreTerminationProtectedException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceARNNotValid": return try ResourceARNNotValidException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePolicyNotFound": return try ResourcePolicyNotFoundException.makeError(baseError: baseError)
            case "ResourceTypeNotSupported": return try ResourceTypeNotSupportedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidHomeRegion": return try InvalidHomeRegionException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterOrganizationDelegatedAdminOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccountNotFound": return try AccountNotFoundException.makeError(baseError: baseError)
            case "AccountNotRegistered": return try AccountNotRegisteredException.makeError(baseError: baseError)
            case "CloudTrailAccessNotEnabled": return try CloudTrailAccessNotEnabledException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotOrganizationManagementAccount": return try NotOrganizationManagementAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesMode": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "OrganizationsNotInUse": return try OrganizationsNotInUseException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "QueryIdNotFound": return try QueryIdNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTrailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableFederationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "CloudTrailAccessNotEnabled": return try CloudTrailAccessNotEnabledException.makeError(baseError: baseError)
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesMode": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "OrganizationsNotInUse": return try OrganizationsNotInUseException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableFederationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceAccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "CloudTrailAccessNotEnabled": return try CloudTrailAccessNotEnabledException.makeError(baseError: baseError)
            case "ConcurrentModification": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreFederationEnabled": return try EventDataStoreFederationEnabledException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesMode": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "OrganizationsNotInUse": return try OrganizationsNotInUseException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ChannelARNInvalid": return try ChannelARNInvalidException.makeError(baseError: baseError)
            case "ChannelNotFound": return try ChannelNotFoundException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventDataStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventSelectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ImportNotFound": return try ImportNotFoundException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInsightSelectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "InsightNotEnabled": return try InsightNotEnabledException.makeError(baseError: baseError)
            case "InvalidParameterCombinationError": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InsufficientEncryptionPolicy": return try InsufficientEncryptionPolicyException.makeError(baseError: baseError)
            case "InvalidMaxResults": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "QueryIdNotFound": return try QueryIdNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceARNNotValid": return try ResourceARNNotValidException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePolicyNotFound": return try ResourcePolicyNotFoundException.makeError(baseError: baseError)
            case "ResourceTypeNotSupported": return try ResourceTypeNotSupportedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTrailStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextToken": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventDataStoresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidMaxResults": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportFailuresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextToken": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInsightsMetricDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPublicKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidTimeRange": return try InvalidTimeRangeException.makeError(baseError: baseError)
            case "InvalidToken": return try InvalidTokenException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQueriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InvalidDateRange": return try InvalidDateRangeException.makeError(baseError: baseError)
            case "InvalidMaxResults": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidQueryStatus": return try InvalidQueryStatusException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ChannelARNInvalid": return try ChannelARNInvalidException.makeError(baseError: baseError)
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InvalidToken": return try InvalidTokenException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceTypeNotSupported": return try ResourceTypeNotSupportedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTrailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum LookupEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidEventCategory": return try InvalidEventCategoryException.makeError(baseError: baseError)
            case "InvalidLookupAttributes": return try InvalidLookupAttributesException.makeError(baseError: baseError)
            case "InvalidMaxResults": return try InvalidMaxResultsException.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidTimeRange": return try InvalidTimeRangeException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEventSelectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidEventSelectors": return try InvalidEventSelectorsException.makeError(baseError: baseError)
            case "InvalidHomeRegion": return try InvalidHomeRegionException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutInsightSelectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "InsufficientEncryptionPolicy": return try InsufficientEncryptionPolicyException.makeError(baseError: baseError)
            case "InsufficientS3BucketPolicy": return try InsufficientS3BucketPolicyException.makeError(baseError: baseError)
            case "InvalidHomeRegion": return try InvalidHomeRegionException.makeError(baseError: baseError)
            case "InvalidInsightSelectors": return try InvalidInsightSelectorsException.makeError(baseError: baseError)
            case "InvalidParameterCombinationError": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "KmsException": return try KmsException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "S3BucketDoesNotExist": return try S3BucketDoesNotExistException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceARNNotValid": return try ResourceARNNotValidException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePolicyNotValid": return try ResourcePolicyNotValidException.makeError(baseError: baseError)
            case "ResourceTypeNotSupported": return try ResourceTypeNotSupportedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterOrganizationDelegatedAdminOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccountNotFound": return try AccountNotFoundException.makeError(baseError: baseError)
            case "AccountRegistered": return try AccountRegisteredException.makeError(baseError: baseError)
            case "CannotDelegateManagementAccount": return try CannotDelegateManagementAccountException.makeError(baseError: baseError)
            case "CloudTrailAccessNotEnabled": return try CloudTrailAccessNotEnabledException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DelegatedAdminAccountLimitExceeded": return try DelegatedAdminAccountLimitExceededException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotOrganizationManagementAccount": return try NotOrganizationManagementAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesMode": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "OrganizationsNotInUse": return try OrganizationsNotInUseException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ChannelARNInvalid": return try ChannelARNInvalidException.makeError(baseError: baseError)
            case "ChannelNotFound": return try ChannelNotFoundException.makeError(baseError: baseError)
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InvalidTagParameter": return try InvalidTagParameterException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceTypeNotSupported": return try ResourceTypeNotSupportedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreEventDataStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailAccessNotEnabled": return try CloudTrailAccessNotEnabledException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreMaxLimitExceeded": return try EventDataStoreMaxLimitExceededException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidEventDataStoreStatus": return try InvalidEventDataStoreStatusException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesMode": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "OrganizationsNotInUse": return try OrganizationsNotInUseException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartEventDataStoreIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidEventDataStoreCategory": return try InvalidEventDataStoreCategoryException.makeError(baseError: baseError)
            case "InvalidEventDataStoreStatus": return try InvalidEventDataStoreStatusException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccountHasOngoingImport": return try AccountHasOngoingImportException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "ImportNotFound": return try ImportNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InsufficientEncryptionPolicy": return try InsufficientEncryptionPolicyException.makeError(baseError: baseError)
            case "InvalidEventDataStoreCategory": return try InvalidEventDataStoreCategoryException.makeError(baseError: baseError)
            case "InvalidEventDataStoreStatus": return try InvalidEventDataStoreStatusException.makeError(baseError: baseError)
            case "InvalidImportSource": return try InvalidImportSourceException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartLoggingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidHomeRegion": return try InvalidHomeRegionException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InsufficientEncryptionPolicy": return try InsufficientEncryptionPolicyException.makeError(baseError: baseError)
            case "InsufficientS3BucketPolicy": return try InsufficientS3BucketPolicyException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidQueryStatement": return try InvalidQueryStatementException.makeError(baseError: baseError)
            case "InvalidS3BucketName": return try InvalidS3BucketNameException.makeError(baseError: baseError)
            case "InvalidS3Prefix": return try InvalidS3PrefixException.makeError(baseError: baseError)
            case "MaxConcurrentQueries": return try MaxConcurrentQueriesException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "S3BucketDoesNotExist": return try S3BucketDoesNotExistException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopEventDataStoreIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidEventDataStoreCategory": return try InvalidEventDataStoreCategoryException.makeError(baseError: baseError)
            case "InvalidEventDataStoreStatus": return try InvalidEventDataStoreStatusException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopImportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ImportNotFound": return try ImportNotFoundException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopLoggingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InvalidHomeRegion": return try InvalidHomeRegionException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ChannelAlreadyExists": return try ChannelAlreadyExistsException.makeError(baseError: baseError)
            case "ChannelARNInvalid": return try ChannelARNInvalidException.makeError(baseError: baseError)
            case "ChannelNotFound": return try ChannelNotFoundException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InvalidEventDataStoreCategory": return try InvalidEventDataStoreCategoryException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventDataStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailAccessNotEnabled": return try CloudTrailAccessNotEnabledException.makeError(baseError: baseError)
            case "EventDataStoreAlreadyExists": return try EventDataStoreAlreadyExistsException.makeError(baseError: baseError)
            case "EventDataStoreARNInvalid": return try EventDataStoreARNInvalidException.makeError(baseError: baseError)
            case "EventDataStoreHasOngoingImport": return try EventDataStoreHasOngoingImportException.makeError(baseError: baseError)
            case "EventDataStoreNotFound": return try EventDataStoreNotFoundException.makeError(baseError: baseError)
            case "InactiveEventDataStore": return try InactiveEventDataStoreException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InsufficientEncryptionPolicy": return try InsufficientEncryptionPolicyException.makeError(baseError: baseError)
            case "InvalidEventSelectors": return try InvalidEventSelectorsException.makeError(baseError: baseError)
            case "InvalidInsightSelectors": return try InvalidInsightSelectorsException.makeError(baseError: baseError)
            case "InvalidKmsKeyId": return try InvalidKmsKeyIdException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "KmsException": return try KmsException.makeError(baseError: baseError)
            case "KmsKeyNotFound": return try KmsKeyNotFoundException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesMode": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "OrganizationsNotInUse": return try OrganizationsNotInUseException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CloudTrailAccessNotEnabled": return try CloudTrailAccessNotEnabledException.makeError(baseError: baseError)
            case "CloudTrailARNInvalid": return try CloudTrailARNInvalidException.makeError(baseError: baseError)
            case "CloudTrailInvalidClientTokenId": return try CloudTrailInvalidClientTokenIdException.makeError(baseError: baseError)
            case "CloudWatchLogsDeliveryUnavailable": return try CloudWatchLogsDeliveryUnavailableException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InsufficientDependencyServiceAccessPermission": return try InsufficientDependencyServiceAccessPermissionException.makeError(baseError: baseError)
            case "InsufficientEncryptionPolicy": return try InsufficientEncryptionPolicyException.makeError(baseError: baseError)
            case "InsufficientS3BucketPolicy": return try InsufficientS3BucketPolicyException.makeError(baseError: baseError)
            case "InsufficientSnsTopicPolicy": return try InsufficientSnsTopicPolicyException.makeError(baseError: baseError)
            case "InvalidCloudWatchLogsLogGroupArn": return try InvalidCloudWatchLogsLogGroupArnException.makeError(baseError: baseError)
            case "InvalidCloudWatchLogsRoleArn": return try InvalidCloudWatchLogsRoleArnException.makeError(baseError: baseError)
            case "InvalidEventSelectors": return try InvalidEventSelectorsException.makeError(baseError: baseError)
            case "InvalidHomeRegion": return try InvalidHomeRegionException.makeError(baseError: baseError)
            case "InvalidKmsKeyId": return try InvalidKmsKeyIdException.makeError(baseError: baseError)
            case "InvalidParameterCombinationError": return try InvalidParameterCombinationException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidS3BucketName": return try InvalidS3BucketNameException.makeError(baseError: baseError)
            case "InvalidS3Prefix": return try InvalidS3PrefixException.makeError(baseError: baseError)
            case "InvalidSnsTopicName": return try InvalidSnsTopicNameException.makeError(baseError: baseError)
            case "InvalidTrailName": return try InvalidTrailNameException.makeError(baseError: baseError)
            case "KmsException": return try KmsException.makeError(baseError: baseError)
            case "KmsKeyDisabled": return try KmsKeyDisabledException.makeError(baseError: baseError)
            case "KmsKeyNotFound": return try KmsKeyNotFoundException.makeError(baseError: baseError)
            case "NoManagementAccountSLRExists": return try NoManagementAccountSLRExistsException.makeError(baseError: baseError)
            case "NotOrganizationMasterAccount": return try NotOrganizationMasterAccountException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "OrganizationNotInAllFeaturesMode": return try OrganizationNotInAllFeaturesModeException.makeError(baseError: baseError)
            case "OrganizationsNotInUse": return try OrganizationsNotInUseException.makeError(baseError: baseError)
            case "S3BucketDoesNotExist": return try S3BucketDoesNotExistException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TrailNotFound": return try TrailNotFoundException.makeError(baseError: baseError)
            case "TrailNotProvided": return try TrailNotProvidedException.makeError(baseError: baseError)
            case "UnsupportedOperation": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotOrganizationMasterAccountException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotOrganizationMasterAccountException {
        let reader = baseError.errorBodyReader
        var value = NotOrganizationMasterAccountException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTagParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTagParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidTagParameterException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTrailNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTrailNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidTrailNameException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChannelNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ChannelNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ChannelNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EventDataStoreNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EventDataStoreNotFoundException {
        let reader = baseError.errorBodyReader
        var value = EventDataStoreNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChannelARNInvalidException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ChannelARNInvalidException {
        let reader = baseError.errorBodyReader
        var value = ChannelARNInvalidException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InactiveEventDataStoreException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InactiveEventDataStoreException {
        let reader = baseError.errorBodyReader
        var value = InactiveEventDataStoreException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationNotPermittedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationNotPermittedException {
        let reader = baseError.errorBodyReader
        var value = OperationNotPermittedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagsLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagsLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = TagsLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EventDataStoreARNInvalidException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EventDataStoreARNInvalidException {
        let reader = baseError.errorBodyReader
        var value = EventDataStoreARNInvalidException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceTypeNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceTypeNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = ResourceTypeNotSupportedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoManagementAccountSLRExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoManagementAccountSLRExistsException {
        let reader = baseError.errorBodyReader
        var value = NoManagementAccountSLRExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudTrailARNInvalidException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudTrailARNInvalidException {
        let reader = baseError.errorBodyReader
        var value = CloudTrailARNInvalidException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InactiveQueryException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InactiveQueryException {
        let reader = baseError.errorBodyReader
        var value = InactiveQueryException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QueryIdNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> QueryIdNotFoundException {
        let reader = baseError.errorBodyReader
        var value = QueryIdNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChannelMaxLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ChannelMaxLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ChannelMaxLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSourceException {
        let reader = baseError.errorBodyReader
        var value = InvalidSourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEventDataStoreCategoryException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidEventDataStoreCategoryException {
        let reader = baseError.errorBodyReader
        var value = InvalidEventDataStoreCategoryException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChannelAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ChannelAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ChannelAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EventDataStoreAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EventDataStoreAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = EventDataStoreAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidKmsKeyIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidKmsKeyIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidKmsKeyIdException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OrganizationsNotInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OrganizationsNotInUseException {
        let reader = baseError.errorBodyReader
        var value = OrganizationsNotInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEventSelectorsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidEventSelectorsException {
        let reader = baseError.errorBodyReader
        var value = InvalidEventSelectorsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsufficientEncryptionPolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsufficientEncryptionPolicyException {
        let reader = baseError.errorBodyReader
        var value = InsufficientEncryptionPolicyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudTrailAccessNotEnabledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudTrailAccessNotEnabledException {
        let reader = baseError.errorBodyReader
        var value = CloudTrailAccessNotEnabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EventDataStoreMaxLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EventDataStoreMaxLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = EventDataStoreMaxLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KmsException {
        let reader = baseError.errorBodyReader
        var value = KmsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OrganizationNotInAllFeaturesModeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OrganizationNotInAllFeaturesModeException {
        let reader = baseError.errorBodyReader
        var value = OrganizationNotInAllFeaturesModeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsufficientDependencyServiceAccessPermissionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsufficientDependencyServiceAccessPermissionException {
        let reader = baseError.errorBodyReader
        var value = InsufficientDependencyServiceAccessPermissionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsKeyNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KmsKeyNotFoundException {
        let reader = baseError.errorBodyReader
        var value = KmsKeyNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TrailNotProvidedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TrailNotProvidedException {
        let reader = baseError.errorBodyReader
        var value = TrailNotProvidedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsKeyDisabledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KmsKeyDisabledException {
        let reader = baseError.errorBodyReader
        var value = KmsKeyDisabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidS3BucketNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidS3BucketNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidS3BucketNameException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsufficientS3BucketPolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsufficientS3BucketPolicyException {
        let reader = baseError.errorBodyReader
        var value = InsufficientS3BucketPolicyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCloudWatchLogsLogGroupArnException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCloudWatchLogsLogGroupArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidCloudWatchLogsLogGroupArnException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterCombinationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterCombinationException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterCombinationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsufficientSnsTopicPolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsufficientSnsTopicPolicyException {
        let reader = baseError.errorBodyReader
        var value = InsufficientSnsTopicPolicyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidS3PrefixException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidS3PrefixException {
        let reader = baseError.errorBodyReader
        var value = InvalidS3PrefixException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSnsTopicNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSnsTopicNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidSnsTopicNameException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCloudWatchLogsRoleArnException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCloudWatchLogsRoleArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidCloudWatchLogsRoleArnException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaximumNumberOfTrailsExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaximumNumberOfTrailsExceededException {
        let reader = baseError.errorBodyReader
        var value = MaximumNumberOfTrailsExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension S3BucketDoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> S3BucketDoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = S3BucketDoesNotExistException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TrailAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TrailAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = TrailAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudTrailInvalidClientTokenIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudTrailInvalidClientTokenIdException {
        let reader = baseError.errorBodyReader
        var value = CloudTrailInvalidClientTokenIdException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudWatchLogsDeliveryUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CloudWatchLogsDeliveryUnavailableException {
        let reader = baseError.errorBodyReader
        var value = CloudWatchLogsDeliveryUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChannelExistsForEDSException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ChannelExistsForEDSException {
        let reader = baseError.errorBodyReader
        var value = ChannelExistsForEDSException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EventDataStoreFederationEnabledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EventDataStoreFederationEnabledException {
        let reader = baseError.errorBodyReader
        var value = EventDataStoreFederationEnabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EventDataStoreHasOngoingImportException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EventDataStoreHasOngoingImportException {
        let reader = baseError.errorBodyReader
        var value = EventDataStoreHasOngoingImportException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EventDataStoreTerminationProtectedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EventDataStoreTerminationProtectedException {
        let reader = baseError.errorBodyReader
        var value = EventDataStoreTerminationProtectedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceARNNotValidException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceARNNotValidException {
        let reader = baseError.errorBodyReader
        var value = ResourceARNNotValidException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourcePolicyNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourcePolicyNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourcePolicyNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidHomeRegionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidHomeRegionException {
        let reader = baseError.errorBodyReader
        var value = InvalidHomeRegionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TrailNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TrailNotFoundException {
        let reader = baseError.errorBodyReader
        var value = TrailNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotOrganizationManagementAccountException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotOrganizationManagementAccountException {
        let reader = baseError.errorBodyReader
        var value = NotOrganizationManagementAccountException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccountNotRegisteredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccountNotRegisteredException {
        let reader = baseError.errorBodyReader
        var value = AccountNotRegisteredException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccountNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccountNotFoundException {
        let reader = baseError.errorBodyReader
        var value = AccountNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ImportNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ImportNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ImportNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsightNotEnabledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsightNotEnabledException {
        let reader = baseError.errorBodyReader
        var value = InsightNotEnabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidMaxResultsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidMaxResultsException {
        let reader = baseError.errorBodyReader
        var value = InvalidMaxResultsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTimeRangeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTimeRangeException {
        let reader = baseError.errorBodyReader
        var value = InvalidTimeRangeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDateRangeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDateRangeException {
        let reader = baseError.errorBodyReader
        var value = InvalidDateRangeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidQueryStatusException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidQueryStatusException {
        let reader = baseError.errorBodyReader
        var value = InvalidQueryStatusException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidLookupAttributesException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidLookupAttributesException {
        let reader = baseError.errorBodyReader
        var value = InvalidLookupAttributesException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEventCategoryException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidEventCategoryException {
        let reader = baseError.errorBodyReader
        var value = InvalidEventCategoryException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInsightSelectorsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInsightSelectorsException {
        let reader = baseError.errorBodyReader
        var value = InvalidInsightSelectorsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourcePolicyNotValidException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourcePolicyNotValidException {
        let reader = baseError.errorBodyReader
        var value = ResourcePolicyNotValidException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CannotDelegateManagementAccountException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CannotDelegateManagementAccountException {
        let reader = baseError.errorBodyReader
        var value = CannotDelegateManagementAccountException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccountRegisteredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccountRegisteredException {
        let reader = baseError.errorBodyReader
        var value = AccountRegisteredException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DelegatedAdminAccountLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DelegatedAdminAccountLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = DelegatedAdminAccountLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEventDataStoreStatusException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidEventDataStoreStatusException {
        let reader = baseError.errorBodyReader
        var value = InvalidEventDataStoreStatusException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccountHasOngoingImportException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccountHasOngoingImportException {
        let reader = baseError.errorBodyReader
        var value = AccountHasOngoingImportException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidImportSourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidImportSourceException {
        let reader = baseError.errorBodyReader
        var value = InvalidImportSourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidQueryStatementException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidQueryStatementException {
        let reader = baseError.errorBodyReader
        var value = InvalidQueryStatementException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxConcurrentQueriesException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxConcurrentQueriesException {
        let reader = baseError.errorBodyReader
        var value = MaxConcurrentQueriesException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudTrailClientTypes.Destination {

    static func write(value: CloudTrailClientTypes.Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Location"].write(value.location)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.Destination()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.location = try reader["Location"].readIfPresent() ?? ""
        return value
    }
}

extension CloudTrailClientTypes.Tag {

    static func write(value: CloudTrailClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.AdvancedEventSelector {

    static func write(value: CloudTrailClientTypes.AdvancedEventSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldSelectors"].writeList(value.fieldSelectors, memberWritingClosure: CloudTrailClientTypes.AdvancedFieldSelector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.AdvancedEventSelector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.AdvancedEventSelector()
        value.name = try reader["Name"].readIfPresent()
        value.fieldSelectors = try reader["FieldSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.AdvancedFieldSelector.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CloudTrailClientTypes.AdvancedFieldSelector {

    static func write(value: CloudTrailClientTypes.AdvancedFieldSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndsWith"].writeList(value.endsWith, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Equals"].writeList(value.equals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Field"].write(value.field)
        try writer["NotEndsWith"].writeList(value.notEndsWith, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotEquals"].writeList(value.notEquals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotStartsWith"].writeList(value.notStartsWith, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StartsWith"].writeList(value.startsWith, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.AdvancedFieldSelector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.AdvancedFieldSelector()
        value.field = try reader["Field"].readIfPresent() ?? ""
        value.equals = try reader["Equals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.startsWith = try reader["StartsWith"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.endsWith = try reader["EndsWith"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notEquals = try reader["NotEquals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notStartsWith = try reader["NotStartsWith"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notEndsWith = try reader["NotEndsWith"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CloudTrailClientTypes.QueryStatisticsForDescribeQuery {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.QueryStatisticsForDescribeQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.QueryStatisticsForDescribeQuery()
        value.eventsMatched = try reader["EventsMatched"].readIfPresent()
        value.eventsScanned = try reader["EventsScanned"].readIfPresent()
        value.bytesScanned = try reader["BytesScanned"].readIfPresent()
        value.executionTimeInMillis = try reader["ExecutionTimeInMillis"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CloudTrailClientTypes.Trail {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.Trail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.Trail()
        value.name = try reader["Name"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3KeyPrefix = try reader["S3KeyPrefix"].readIfPresent()
        value.snsTopicName = try reader["SnsTopicName"].readIfPresent()
        value.snsTopicARN = try reader["SnsTopicARN"].readIfPresent()
        value.includeGlobalServiceEvents = try reader["IncludeGlobalServiceEvents"].readIfPresent()
        value.isMultiRegionTrail = try reader["IsMultiRegionTrail"].readIfPresent()
        value.homeRegion = try reader["HomeRegion"].readIfPresent()
        value.trailARN = try reader["TrailARN"].readIfPresent()
        value.logFileValidationEnabled = try reader["LogFileValidationEnabled"].readIfPresent()
        value.cloudWatchLogsLogGroupArn = try reader["CloudWatchLogsLogGroupArn"].readIfPresent()
        value.cloudWatchLogsRoleArn = try reader["CloudWatchLogsRoleArn"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.hasCustomEventSelectors = try reader["HasCustomEventSelectors"].readIfPresent()
        value.hasInsightSelectors = try reader["HasInsightSelectors"].readIfPresent()
        value.isOrganizationTrail = try reader["IsOrganizationTrail"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.SourceConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.SourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.SourceConfig()
        value.applyToAllRegions = try reader["ApplyToAllRegions"].readIfPresent()
        value.advancedEventSelectors = try reader["AdvancedEventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.AdvancedEventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CloudTrailClientTypes.IngestionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.IngestionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.IngestionStatus()
        value.latestIngestionSuccessTime = try reader["LatestIngestionSuccessTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestIngestionSuccessEventID = try reader["LatestIngestionSuccessEventID"].readIfPresent()
        value.latestIngestionErrorCode = try reader["LatestIngestionErrorCode"].readIfPresent()
        value.latestIngestionAttemptTime = try reader["LatestIngestionAttemptTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestIngestionAttemptEventID = try reader["LatestIngestionAttemptEventID"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.PartitionKey {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.PartitionKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.PartitionKey()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? ""
        return value
    }
}

extension CloudTrailClientTypes.EventSelector {

    static func write(value: CloudTrailClientTypes.EventSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataResources"].writeList(value.dataResources, memberWritingClosure: CloudTrailClientTypes.DataResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeManagementEventSources"].writeList(value.excludeManagementEventSources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeManagementEvents"].write(value.includeManagementEvents)
        try writer["ReadWriteType"].write(value.readWriteType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.EventSelector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.EventSelector()
        value.readWriteType = try reader["ReadWriteType"].readIfPresent()
        value.includeManagementEvents = try reader["IncludeManagementEvents"].readIfPresent()
        value.dataResources = try reader["DataResources"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.DataResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.excludeManagementEventSources = try reader["ExcludeManagementEventSources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CloudTrailClientTypes.DataResource {

    static func write(value: CloudTrailClientTypes.DataResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.DataResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.DataResource()
        value.type = try reader["Type"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CloudTrailClientTypes.ImportSource {

    static func write(value: CloudTrailClientTypes.ImportSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3"].write(value.s3, with: CloudTrailClientTypes.S3ImportSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.ImportSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.ImportSource()
        value.s3 = try reader["S3"].readIfPresent(with: CloudTrailClientTypes.S3ImportSource.read(from:))
        return value
    }
}

extension CloudTrailClientTypes.S3ImportSource {

    static func write(value: CloudTrailClientTypes.S3ImportSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3BucketAccessRoleArn"].write(value.s3BucketAccessRoleArn)
        try writer["S3BucketRegion"].write(value.s3BucketRegion)
        try writer["S3LocationUri"].write(value.s3LocationUri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.S3ImportSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.S3ImportSource()
        value.s3LocationUri = try reader["S3LocationUri"].readIfPresent() ?? ""
        value.s3BucketRegion = try reader["S3BucketRegion"].readIfPresent() ?? ""
        value.s3BucketAccessRoleArn = try reader["S3BucketAccessRoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension CloudTrailClientTypes.ImportStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.ImportStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.ImportStatistics()
        value.prefixesFound = try reader["PrefixesFound"].readIfPresent()
        value.prefixesCompleted = try reader["PrefixesCompleted"].readIfPresent()
        value.filesCompleted = try reader["FilesCompleted"].readIfPresent()
        value.eventsCompleted = try reader["EventsCompleted"].readIfPresent()
        value.failedEntries = try reader["FailedEntries"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.InsightSelector {

    static func write(value: CloudTrailClientTypes.InsightSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightType"].write(value.insightType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.InsightSelector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.InsightSelector()
        value.insightType = try reader["InsightType"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.QueryStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.QueryStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.QueryStatistics()
        value.resultsCount = try reader["ResultsCount"].readIfPresent()
        value.totalResultsCount = try reader["TotalResultsCount"].readIfPresent()
        value.bytesScanned = try reader["BytesScanned"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.Channel {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.Channel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.Channel()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.EventDataStore {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.EventDataStore {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.EventDataStore()
        value.eventDataStoreArn = try reader["EventDataStoreArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.terminationProtectionEnabled = try reader["TerminationProtectionEnabled"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.advancedEventSelectors = try reader["AdvancedEventSelectors"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.AdvancedEventSelector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.multiRegionEnabled = try reader["MultiRegionEnabled"].readIfPresent()
        value.organizationEnabled = try reader["OrganizationEnabled"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CloudTrailClientTypes.ImportFailureListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.ImportFailureListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.ImportFailureListItem()
        value.location = try reader["Location"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.errorType = try reader["ErrorType"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CloudTrailClientTypes.ImportsListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.ImportsListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.ImportsListItem()
        value.importId = try reader["ImportId"].readIfPresent()
        value.importStatus = try reader["ImportStatus"].readIfPresent()
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CloudTrailClientTypes.PublicKey {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.PublicKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.PublicKey()
        value.value = try reader["Value"].readIfPresent()
        value.validityStartTime = try reader["ValidityStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.validityEndTime = try reader["ValidityEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.fingerprint = try reader["Fingerprint"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.Query {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.Query {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.Query()
        value.queryId = try reader["QueryId"].readIfPresent()
        value.queryStatus = try reader["QueryStatus"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CloudTrailClientTypes.ResourceTag {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.ResourceTag()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.tagsList = try reader["TagsList"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CloudTrailClientTypes.TrailInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.TrailInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.TrailInfo()
        value.trailARN = try reader["TrailARN"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.homeRegion = try reader["HomeRegion"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.Event()
        value.eventId = try reader["EventId"].readIfPresent()
        value.eventName = try reader["EventName"].readIfPresent()
        value.readOnly = try reader["ReadOnly"].readIfPresent()
        value.accessKeyId = try reader["AccessKeyId"].readIfPresent()
        value.eventTime = try reader["EventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.eventSource = try reader["EventSource"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: CloudTrailClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cloudTrailEvent = try reader["CloudTrailEvent"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudTrailClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudTrailClientTypes.Resource()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceName = try reader["ResourceName"].readIfPresent()
        return value
    }
}

extension CloudTrailClientTypes.LookupAttribute {

    static func write(value: CloudTrailClientTypes.LookupAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeKey"].write(value.attributeKey)
        try writer["AttributeValue"].write(value.attributeValue)
    }
}

public enum CloudTrailClientTypes {}
