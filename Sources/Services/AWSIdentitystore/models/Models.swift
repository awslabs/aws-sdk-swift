// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IdentitystoreClientTypes {
    static func makeServiceError(_ httpResponse: ClientRuntime.HttpResponse, _ decoder: ClientRuntime.ResponseDecoder? = nil, _ error: AWSClientRuntime.RestJSONError, _ id: String?) async throws -> Swift.Error? {
        switch error.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            default: return nil
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension IdentitystoreClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case country = "Country"
        case formatted = "Formatted"
        case locality = "Locality"
        case postalCode = "PostalCode"
        case primary = "Primary"
        case region = "Region"
        case streetAddress = "StreetAddress"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let formatted = self.formatted {
            try encodeContainer.encode(formatted, forKey: .formatted)
        }
        if let locality = self.locality {
            try encodeContainer.encode(locality, forKey: .locality)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if primary != false {
            try encodeContainer.encode(primary, forKey: .primary)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let streetAddress = self.streetAddress {
            try encodeContainer.encode(streetAddress, forKey: .streetAddress)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetAddress)
        streetAddress = streetAddressDecoded
        let localityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locality)
        locality = localityDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let formattedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatted)
        formatted = formattedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let primaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .primary) ?? false
        primary = primaryDecoded
    }
}

extension IdentitystoreClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(country: \"CONTENT_REDACTED\", formatted: \"CONTENT_REDACTED\", locality: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", primary: \"CONTENT_REDACTED\", region: \"CONTENT_REDACTED\", streetAddress: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The address associated with the specified user.
    public struct Address: Swift.Equatable {
        /// The country of the address.
        public var country: Swift.String?
        /// A string containing a formatted version of the address for display.
        public var formatted: Swift.String?
        /// A string of the address locality.
        public var locality: Swift.String?
        /// The postal code of the address.
        public var postalCode: Swift.String?
        /// A Boolean value representing whether this is the primary address for the associated resource.
        public var primary: Swift.Bool
        /// The region of the address.
        public var region: Swift.String?
        /// The street of the address.
        public var streetAddress: Swift.String?
        /// A string representing the type of address. For example, "Home."
        public var type: Swift.String?

        public init(
            country: Swift.String? = nil,
            formatted: Swift.String? = nil,
            locality: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            primary: Swift.Bool = false,
            region: Swift.String? = nil,
            streetAddress: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.country = country
            self.formatted = formatted
            self.locality = locality
            self.postalCode = postalCode
            self.primary = primary
            self.region = region
            self.streetAddress = streetAddress
            self.type = type
        }
    }

}

extension IdentitystoreClientTypes.AlternateIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalid = "ExternalId"
        case uniqueattribute = "UniqueAttribute"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .externalid(externalid):
                try container.encode(externalid, forKey: .externalid)
            case let .uniqueattribute(uniqueattribute):
                try container.encode(uniqueattribute, forKey: .uniqueattribute)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let externalidDecoded = try values.decodeIfPresent(IdentitystoreClientTypes.ExternalId.self, forKey: .externalid)
        if let externalid = externalidDecoded {
            self = .externalid(externalid)
            return
        }
        let uniqueattributeDecoded = try values.decodeIfPresent(IdentitystoreClientTypes.UniqueAttribute.self, forKey: .uniqueattribute)
        if let uniqueattribute = uniqueattributeDecoded {
            self = .uniqueattribute(uniqueattribute)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IdentitystoreClientTypes {
    /// A unique identifier for a user or group that is not the primary identifier. This value can be an identifier from an external identity provider (IdP) that is associated with the user, the group, or a unique attribute.
    public enum AlternateIdentifier: Swift.Equatable {
        /// The identifier issued to this resource by an external identity provider.
        case externalid(IdentitystoreClientTypes.ExternalId)
        /// An entity attribute that's unique to a specific entity.
        case uniqueattribute(IdentitystoreClientTypes.UniqueAttribute)
        case sdkUnknown(Swift.String)
    }

}

extension IdentitystoreClientTypes.AttributeOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePath = "AttributePath"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePath = self.attributePath {
            try encodeContainer.encode(attributePath, forKey: .attributePath)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributePath)
        attributePath = attributePathDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension IdentitystoreClientTypes {
    /// An operation that applies to the requested group. This operation might add, replace, or remove an attribute.
    public struct AttributeOperation: Swift.Equatable {
        /// A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.
        /// This member is required.
        public var attributePath: Swift.String?
        /// The value of the attribute. This is a Document type. This type is not supported by Java V1, Go V1, and older versions of the CLI.
        public var attributeValue: ClientRuntime.Document?

        public init(
            attributePath: Swift.String? = nil,
            attributeValue: ClientRuntime.Document? = nil
        )
        {
            self.attributePath = attributePath
            self.attributeValue = attributeValue
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.reason = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This request cannot be completed for one of the following reasons:
///
/// * Performing the requested operation would violate an existing uniqueness claim in the identity store. Resolve the conflict before retrying this request.
///
/// * The requested resource was being concurrently modified by another request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// This request cannot be completed for one of the following reasons:
        ///
        /// * Performing the requested operation would violate an existing uniqueness claim in the identity store. Resolve the conflict before retrying this request.
        ///
        /// * The requested resource was being concurrently modified by another request.
        public internal(set) var reason: IdentitystoreClientTypes.ConflictExceptionReason? = nil
        /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: IdentitystoreClientTypes.ConflictExceptionReason? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.requestId = requestId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
    let reason: IdentitystoreClientTypes.ConflictExceptionReason?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case reason = "Reason"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension IdentitystoreClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concurrentModification
        case uniquenessConstraintViolation
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .concurrentModification,
                .uniquenessConstraintViolation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concurrentModification: return "CONCURRENT_MODIFICATION"
            case .uniquenessConstraintViolation: return "UNIQUENESS_CONSTRAINT_VIOLATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGroupInput(identityStoreId: \(Swift.String(describing: identityStoreId)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// A string containing the description of the group.
    public var description: Swift.String?
    /// A string containing the name of the group. This value is commonly displayed when the group is referenced. Administrator and AWSAdministrators are reserved names and can't be used for users or groups.
    public var displayName: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.identityStoreId = identityStoreId
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case identityStoreId = "IdentityStoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateGroupMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }
}

extension CreateGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGroupMembershipInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?

    public init(
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.memberId = memberId
    }
}

struct CreateGroupMembershipInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
}

extension CreateGroupMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension CreateGroupMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGroupMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityStoreId = output.identityStoreId
            self.membershipId = output.membershipId
        } else {
            self.identityStoreId = nil
            self.membershipId = nil
        }
    }
}

public struct CreateGroupMembershipOutput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a newly created GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.membershipId = membershipId
    }
}

struct CreateGroupMembershipOutputBody: Swift.Equatable {
    let membershipId: Swift.String?
    let identityStoreId: Swift.String?
}

extension CreateGroupMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

enum CreateGroupMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
            self.identityStoreId = output.identityStoreId
        } else {
            self.groupId = nil
            self.identityStoreId = nil
        }
    }
}

public struct CreateGroupOutput: Swift.Equatable {
    /// The identifier of the newly created group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct CreateGroupOutputBody: Swift.Equatable {
    let groupId: Swift.String?
    let identityStoreId: Swift.String?
}

extension CreateGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

enum CreateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(addresses: \(Swift.String(describing: addresses)), emails: \(Swift.String(describing: emails)), identityStoreId: \(Swift.String(describing: identityStoreId)), name: \(Swift.String(describing: name)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), displayName: \"CONTENT_REDACTED\", locale: \"CONTENT_REDACTED\", nickName: \"CONTENT_REDACTED\", preferredLanguage: \"CONTENT_REDACTED\", profileUrl: \"CONTENT_REDACTED\", timezone: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\", userType: \"CONTENT_REDACTED\")"}
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case displayName = "DisplayName"
        case emails = "Emails"
        case identityStoreId = "IdentityStoreId"
        case locale = "Locale"
        case name = "Name"
        case nickName = "NickName"
        case phoneNumbers = "PhoneNumbers"
        case preferredLanguage = "PreferredLanguage"
        case profileUrl = "ProfileUrl"
        case timezone = "Timezone"
        case title = "Title"
        case userName = "UserName"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addresses = addresses {
            var addressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addresses)
            for address0 in addresses {
                try addressesContainer.encode(address0)
            }
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emails = emails {
            var emailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emails)
            for email0 in emails {
                try emailsContainer.encode(email0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nickName = self.nickName {
            try encodeContainer.encode(nickName, forKey: .nickName)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumber0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumber0)
            }
        }
        if let preferredLanguage = self.preferredLanguage {
            try encodeContainer.encode(preferredLanguage, forKey: .preferredLanguage)
        }
        if let profileUrl = self.profileUrl {
            try encodeContainer.encode(profileUrl, forKey: .profileUrl)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType, forKey: .userType)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// A list of Address objects containing addresses associated with the user.
    public var addresses: [IdentitystoreClientTypes.Address]?
    /// A string containing the name of the user. This value is typically formatted for display when the user is referenced. For example, "John Doe."
    public var displayName: Swift.String?
    /// A list of Email objects containing email addresses associated with the user.
    public var emails: [IdentitystoreClientTypes.Email]?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A string containing the geographical region or location of the user.
    public var locale: Swift.String?
    /// An object containing the name of the user.
    public var name: IdentitystoreClientTypes.Name?
    /// A string containing an alternate name for the user.
    public var nickName: Swift.String?
    /// A list of PhoneNumber objects containing phone numbers associated with the user.
    public var phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
    /// A string containing the preferred language of the user. For example, "American English" or "en-us."
    public var preferredLanguage: Swift.String?
    /// A string containing a URL that might be associated with the user.
    public var profileUrl: Swift.String?
    /// A string containing the time zone of the user.
    public var timezone: Swift.String?
    /// A string containing the title of the user. Possible values are left unspecified. The value can vary based on your specific use case.
    public var title: Swift.String?
    /// A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store. Administrator and AWSAdministrators are reserved names and can't be used for users or groups.
    public var userName: Swift.String?
    /// A string indicating the type of user. Possible values are left unspecified. The value can vary based on your specific use case.
    public var userType: Swift.String?

    public init(
        addresses: [IdentitystoreClientTypes.Address]? = nil,
        displayName: Swift.String? = nil,
        emails: [IdentitystoreClientTypes.Email]? = nil,
        identityStoreId: Swift.String? = nil,
        locale: Swift.String? = nil,
        name: IdentitystoreClientTypes.Name? = nil,
        nickName: Swift.String? = nil,
        phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]? = nil,
        preferredLanguage: Swift.String? = nil,
        profileUrl: Swift.String? = nil,
        timezone: Swift.String? = nil,
        title: Swift.String? = nil,
        userName: Swift.String? = nil,
        userType: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.displayName = displayName
        self.emails = emails
        self.identityStoreId = identityStoreId
        self.locale = locale
        self.name = name
        self.nickName = nickName
        self.phoneNumbers = phoneNumbers
        self.preferredLanguage = preferredLanguage
        self.profileUrl = profileUrl
        self.timezone = timezone
        self.title = title
        self.userName = userName
        self.userType = userType
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let userName: Swift.String?
    let name: IdentitystoreClientTypes.Name?
    let displayName: Swift.String?
    let nickName: Swift.String?
    let profileUrl: Swift.String?
    let emails: [IdentitystoreClientTypes.Email]?
    let addresses: [IdentitystoreClientTypes.Address]?
    let phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
    let userType: Swift.String?
    let title: Swift.String?
    let preferredLanguage: Swift.String?
    let locale: Swift.String?
    let timezone: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case displayName = "DisplayName"
        case emails = "Emails"
        case identityStoreId = "IdentityStoreId"
        case locale = "Locale"
        case name = "Name"
        case nickName = "NickName"
        case phoneNumbers = "PhoneNumbers"
        case preferredLanguage = "PreferredLanguage"
        case profileUrl = "ProfileUrl"
        case timezone = "Timezone"
        case title = "Title"
        case userName = "UserName"
        case userType = "UserType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.Name.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let nickNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nickName)
        nickName = nickNameDecoded
        let profileUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileUrl)
        profileUrl = profileUrlDecoded
        let emailsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Email?].self, forKey: .emails)
        var emailsDecoded0:[IdentitystoreClientTypes.Email]? = nil
        if let emailsContainer = emailsContainer {
            emailsDecoded0 = [IdentitystoreClientTypes.Email]()
            for structure0 in emailsContainer {
                if let structure0 = structure0 {
                    emailsDecoded0?.append(structure0)
                }
            }
        }
        emails = emailsDecoded0
        let addressesContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[IdentitystoreClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [IdentitystoreClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let phoneNumbersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[IdentitystoreClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [IdentitystoreClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let userTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userType)
        userType = userTypeDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let preferredLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredLanguage)
        preferredLanguage = preferredLanguageDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityStoreId = output.identityStoreId
            self.userId = output.userId
        } else {
            self.identityStoreId = nil
            self.userId = nil
        }
    }
}

public struct CreateUserOutput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier of the newly created user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let userId: Swift.String?
    let identityStoreId: Swift.String?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
}

extension DeleteGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteGroupMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
    }
}

extension DeleteGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGroupMembershipInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.membershipId = membershipId
    }
}

struct DeleteGroupMembershipInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let membershipId: Swift.String?
}

extension DeleteGroupMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
    }
}

extension DeleteGroupMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGroupMembershipOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let userId: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DeleteUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension DescribeGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeGroupInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store, such as d-1234567890. In this example, d- is a fixed prefix, and 1234567890 is a randomly generated string that contains numbers and lower case letters. This value is generated at the time that a new identity store is created.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct DescribeGroupInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
}

extension DescribeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DescribeGroupMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
    }
}

extension DescribeGroupMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeGroupMembershipInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.membershipId = membershipId
    }
}

struct DescribeGroupMembershipInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let membershipId: Swift.String?
}

extension DescribeGroupMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
    }
}

extension DescribeGroupMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGroupMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
            self.identityStoreId = output.identityStoreId
            self.memberId = output.memberId
            self.membershipId = output.membershipId
        } else {
            self.groupId = nil
            self.identityStoreId = nil
            self.memberId = nil
            self.membershipId = nil
        }
    }
}

public struct DescribeGroupMembershipOutput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// An object containing the identifier of a group member.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?
    /// The identifier for a GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.memberId = memberId
        self.membershipId = membershipId
    }
}

struct DescribeGroupMembershipOutputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let membershipId: Swift.String?
    let groupId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
}

extension DescribeGroupMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
        case membershipId = "MembershipId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

enum DescribeGroupMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGroupOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGroupOutput(externalIds: \(Swift.String(describing: externalIds)), groupId: \(Swift.String(describing: groupId)), identityStoreId: \(Swift.String(describing: identityStoreId)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension DescribeGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.displayName = output.displayName
            self.externalIds = output.externalIds
            self.groupId = output.groupId
            self.identityStoreId = output.identityStoreId
        } else {
            self.description = nil
            self.displayName = nil
            self.externalIds = nil
            self.groupId = nil
            self.identityStoreId = nil
        }
    }
}

public struct DescribeGroupOutput: Swift.Equatable {
    /// A string containing a description of the group.
    public var description: Swift.String?
    /// The groups display name value. The length limit is 1,024 characters. This value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new line, carriage return, space, and nonbreaking space in this attribute. This value is specified at the time that the group is created and stored as an attribute of the group object in the identity store.
    public var displayName: Swift.String?
    /// A list of ExternalId objects that contains the identifiers issued to this resource by an external identity provider.
    public var externalIds: [IdentitystoreClientTypes.ExternalId]?
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        externalIds: [IdentitystoreClientTypes.ExternalId]? = nil,
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.externalIds = externalIds
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct DescribeGroupOutputBody: Swift.Equatable {
    let groupId: Swift.String?
    let displayName: Swift.String?
    let externalIds: [IdentitystoreClientTypes.ExternalId]?
    let description: Swift.String?
    let identityStoreId: Swift.String?
}

extension DescribeGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case externalIds = "ExternalIds"
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let externalIdsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.ExternalId?].self, forKey: .externalIds)
        var externalIdsDecoded0:[IdentitystoreClientTypes.ExternalId]? = nil
        if let externalIdsContainer = externalIdsContainer {
            externalIdsDecoded0 = [IdentitystoreClientTypes.ExternalId]()
            for structure0 in externalIdsContainer {
                if let structure0 = structure0 {
                    externalIdsDecoded0?.append(structure0)
                }
            }
        }
        externalIds = externalIdsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

enum DescribeGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DescribeUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserInput: Swift.Equatable {
    /// The globally unique identifier for the identity store, such as d-1234567890. In this example, d- is a fixed prefix, and 1234567890 is a randomly generated string that contains numbers and lower case letters. This value is generated at the time that a new identity store is created.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let userId: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DescribeUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserOutput(addresses: \(Swift.String(describing: addresses)), emails: \(Swift.String(describing: emails)), externalIds: \(Swift.String(describing: externalIds)), identityStoreId: \(Swift.String(describing: identityStoreId)), name: \(Swift.String(describing: name)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), userId: \(Swift.String(describing: userId)), displayName: \"CONTENT_REDACTED\", locale: \"CONTENT_REDACTED\", nickName: \"CONTENT_REDACTED\", preferredLanguage: \"CONTENT_REDACTED\", profileUrl: \"CONTENT_REDACTED\", timezone: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\", userType: \"CONTENT_REDACTED\")"}
}

extension DescribeUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.addresses = output.addresses
            self.displayName = output.displayName
            self.emails = output.emails
            self.externalIds = output.externalIds
            self.identityStoreId = output.identityStoreId
            self.locale = output.locale
            self.name = output.name
            self.nickName = output.nickName
            self.phoneNumbers = output.phoneNumbers
            self.preferredLanguage = output.preferredLanguage
            self.profileUrl = output.profileUrl
            self.timezone = output.timezone
            self.title = output.title
            self.userId = output.userId
            self.userName = output.userName
            self.userType = output.userType
        } else {
            self.addresses = nil
            self.displayName = nil
            self.emails = nil
            self.externalIds = nil
            self.identityStoreId = nil
            self.locale = nil
            self.name = nil
            self.nickName = nil
            self.phoneNumbers = nil
            self.preferredLanguage = nil
            self.profileUrl = nil
            self.timezone = nil
            self.title = nil
            self.userId = nil
            self.userName = nil
            self.userType = nil
        }
    }
}

public struct DescribeUserOutput: Swift.Equatable {
    /// The physical address of the user.
    public var addresses: [IdentitystoreClientTypes.Address]?
    /// The display name of the user.
    public var displayName: Swift.String?
    /// The email address of the user.
    public var emails: [IdentitystoreClientTypes.Email]?
    /// A list of ExternalId objects that contains the identifiers issued to this resource by an external identity provider.
    public var externalIds: [IdentitystoreClientTypes.ExternalId]?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A string containing the geographical region or location of the user.
    public var locale: Swift.String?
    /// The name of the user.
    public var name: IdentitystoreClientTypes.Name?
    /// An alternative descriptive name for the user.
    public var nickName: Swift.String?
    /// A list of PhoneNumber objects associated with a user.
    public var phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
    /// The preferred language of the user.
    public var preferredLanguage: Swift.String?
    /// A URL link for the user's profile.
    public var profileUrl: Swift.String?
    /// The time zone for a user.
    public var timezone: Swift.String?
    /// A string containing the title of the user.
    public var title: Swift.String?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?
    /// A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store.
    public var userName: Swift.String?
    /// A string indicating the type of user.
    public var userType: Swift.String?

    public init(
        addresses: [IdentitystoreClientTypes.Address]? = nil,
        displayName: Swift.String? = nil,
        emails: [IdentitystoreClientTypes.Email]? = nil,
        externalIds: [IdentitystoreClientTypes.ExternalId]? = nil,
        identityStoreId: Swift.String? = nil,
        locale: Swift.String? = nil,
        name: IdentitystoreClientTypes.Name? = nil,
        nickName: Swift.String? = nil,
        phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]? = nil,
        preferredLanguage: Swift.String? = nil,
        profileUrl: Swift.String? = nil,
        timezone: Swift.String? = nil,
        title: Swift.String? = nil,
        userId: Swift.String? = nil,
        userName: Swift.String? = nil,
        userType: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.displayName = displayName
        self.emails = emails
        self.externalIds = externalIds
        self.identityStoreId = identityStoreId
        self.locale = locale
        self.name = name
        self.nickName = nickName
        self.phoneNumbers = phoneNumbers
        self.preferredLanguage = preferredLanguage
        self.profileUrl = profileUrl
        self.timezone = timezone
        self.title = title
        self.userId = userId
        self.userName = userName
        self.userType = userType
    }
}

struct DescribeUserOutputBody: Swift.Equatable {
    let userName: Swift.String?
    let userId: Swift.String?
    let externalIds: [IdentitystoreClientTypes.ExternalId]?
    let name: IdentitystoreClientTypes.Name?
    let displayName: Swift.String?
    let nickName: Swift.String?
    let profileUrl: Swift.String?
    let emails: [IdentitystoreClientTypes.Email]?
    let addresses: [IdentitystoreClientTypes.Address]?
    let phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
    let userType: Swift.String?
    let title: Swift.String?
    let preferredLanguage: Swift.String?
    let locale: Swift.String?
    let timezone: Swift.String?
    let identityStoreId: Swift.String?
}

extension DescribeUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case displayName = "DisplayName"
        case emails = "Emails"
        case externalIds = "ExternalIds"
        case identityStoreId = "IdentityStoreId"
        case locale = "Locale"
        case name = "Name"
        case nickName = "NickName"
        case phoneNumbers = "PhoneNumbers"
        case preferredLanguage = "PreferredLanguage"
        case profileUrl = "ProfileUrl"
        case timezone = "Timezone"
        case title = "Title"
        case userId = "UserId"
        case userName = "UserName"
        case userType = "UserType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let externalIdsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.ExternalId?].self, forKey: .externalIds)
        var externalIdsDecoded0:[IdentitystoreClientTypes.ExternalId]? = nil
        if let externalIdsContainer = externalIdsContainer {
            externalIdsDecoded0 = [IdentitystoreClientTypes.ExternalId]()
            for structure0 in externalIdsContainer {
                if let structure0 = structure0 {
                    externalIdsDecoded0?.append(structure0)
                }
            }
        }
        externalIds = externalIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.Name.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let nickNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nickName)
        nickName = nickNameDecoded
        let profileUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileUrl)
        profileUrl = profileUrlDecoded
        let emailsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Email?].self, forKey: .emails)
        var emailsDecoded0:[IdentitystoreClientTypes.Email]? = nil
        if let emailsContainer = emailsContainer {
            emailsDecoded0 = [IdentitystoreClientTypes.Email]()
            for structure0 in emailsContainer {
                if let structure0 = structure0 {
                    emailsDecoded0?.append(structure0)
                }
            }
        }
        emails = emailsDecoded0
        let addressesContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[IdentitystoreClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [IdentitystoreClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let phoneNumbersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[IdentitystoreClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [IdentitystoreClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let userTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userType)
        userType = userTypeDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let preferredLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredLanguage)
        preferredLanguage = preferredLanguageDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

enum DescribeUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IdentitystoreClientTypes.Email: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primary = "Primary"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if primary != false {
            try encodeContainer.encode(primary, forKey: .primary)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let primaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .primary) ?? false
        primary = primaryDecoded
    }
}

extension IdentitystoreClientTypes.Email: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Email(primary: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The email address associated with the user.
    public struct Email: Swift.Equatable {
        /// A Boolean value representing whether this is the primary email address for the associated resource.
        public var primary: Swift.Bool
        /// A string representing the type of address. For example, "Work."
        public var type: Swift.String?
        /// A string containing an email address. For example, "johndoe@amazon.com."
        public var value: Swift.String?

        public init(
            primary: Swift.Bool = false,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.primary = primary
            self.type = type
            self.value = value
        }
    }

}

extension IdentitystoreClientTypes.ExternalId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case issuer = "Issuer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IdentitystoreClientTypes.ExternalId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExternalId(id: \"CONTENT_REDACTED\", issuer: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The identifier issued to this resource by an external identity provider.
    public struct ExternalId: Swift.Equatable {
        /// The identifier issued to this resource by an external identity provider.
        /// This member is required.
        public var id: Swift.String?
        /// The issuer for an external identifier.
        /// This member is required.
        public var issuer: Swift.String?

        public init(
            id: Swift.String? = nil,
            issuer: Swift.String? = nil
        )
        {
            self.id = id
            self.issuer = issuer
        }
    }

}

extension IdentitystoreClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePath = "AttributePath"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePath = self.attributePath {
            try encodeContainer.encode(attributePath, forKey: .attributePath)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributePath)
        attributePath = attributePathDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension IdentitystoreClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(attributePath: \(Swift.String(describing: attributePath)), attributeValue: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// A query filter used by ListUsers and ListGroups. This filter object provides the attribute name and attribute value to search users or groups.
    public struct Filter: Swift.Equatable {
        /// The attribute path that is used to specify which attribute name to search. Length limit is 255 characters. For example, UserName is a valid attribute path for the ListUsers API, and DisplayName is a valid attribute path for the ListGroups API.
        /// This member is required.
        public var attributePath: Swift.String?
        /// Represents the data for an attribute. Each attribute value is described as a name-value pair.
        /// This member is required.
        public var attributeValue: Swift.String?

        public init(
            attributePath: Swift.String? = nil,
            attributeValue: Swift.String? = nil
        )
        {
            self.attributePath = attributePath
            self.attributeValue = attributeValue
        }
    }

}

extension GetGroupIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateIdentifier = "AlternateIdentifier"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateIdentifier = self.alternateIdentifier {
            try encodeContainer.encode(alternateIdentifier, forKey: .alternateIdentifier)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension GetGroupIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGroupIdInput: Swift.Equatable {
    /// A unique identifier for a user or group that is not the primary identifier. This value can be an identifier from an external identity provider (IdP) that is associated with the user, the group, or a unique attribute. For the unique attribute, the only valid path is displayName.
    /// This member is required.
    public var alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init(
        alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.alternateIdentifier = alternateIdentifier
        self.identityStoreId = identityStoreId
    }
}

struct GetGroupIdInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier?
}

extension GetGroupIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateIdentifier = "AlternateIdentifier"
        case identityStoreId = "IdentityStoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let alternateIdentifierDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.AlternateIdentifier.self, forKey: .alternateIdentifier)
        alternateIdentifier = alternateIdentifierDecoded
    }
}

extension GetGroupIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
            self.identityStoreId = output.identityStoreId
        } else {
            self.groupId = nil
            self.identityStoreId = nil
        }
    }
}

public struct GetGroupIdOutput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
    }
}

struct GetGroupIdOutputBody: Swift.Equatable {
    let groupId: Swift.String?
    let identityStoreId: Swift.String?
}

extension GetGroupIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

enum GetGroupIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGroupMembershipIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }
}

extension GetGroupMembershipIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGroupMembershipIdInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?

    public init(
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.memberId = memberId
    }
}

struct GetGroupMembershipIdInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
}

extension GetGroupMembershipIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension GetGroupMembershipIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupMembershipIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityStoreId = output.identityStoreId
            self.membershipId = output.membershipId
        } else {
            self.identityStoreId = nil
            self.membershipId = nil
        }
    }
}

public struct GetGroupMembershipIdOutput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a GroupMembership in an identity store.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.membershipId = membershipId
    }
}

struct GetGroupMembershipIdOutputBody: Swift.Equatable {
    let membershipId: Swift.String?
    let identityStoreId: Swift.String?
}

extension GetGroupMembershipIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case membershipId = "MembershipId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

enum GetGroupMembershipIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserIdInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateIdentifier = "AlternateIdentifier"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateIdentifier = self.alternateIdentifier {
            try encodeContainer.encode(alternateIdentifier, forKey: .alternateIdentifier)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }
}

extension GetUserIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUserIdInput: Swift.Equatable {
    /// A unique identifier for a user or group that is not the primary identifier. This value can be an identifier from an external identity provider (IdP) that is associated with the user, the group, or a unique attribute. For the unique attribute, the only valid paths are userName and emails.value.
    /// This member is required.
    public var alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?

    public init(
        alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier? = nil,
        identityStoreId: Swift.String? = nil
    )
    {
        self.alternateIdentifier = alternateIdentifier
        self.identityStoreId = identityStoreId
    }
}

struct GetUserIdInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let alternateIdentifier: IdentitystoreClientTypes.AlternateIdentifier?
}

extension GetUserIdInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateIdentifier = "AlternateIdentifier"
        case identityStoreId = "IdentityStoreId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let alternateIdentifierDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.AlternateIdentifier.self, forKey: .alternateIdentifier)
        alternateIdentifier = alternateIdentifierDecoded
    }
}

extension GetUserIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityStoreId = output.identityStoreId
            self.userId = output.userId
        } else {
            self.identityStoreId = nil
            self.userId = nil
        }
    }
}

public struct GetUserIdOutput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.userId = userId
    }
}

struct GetUserIdOutputBody: Swift.Equatable {
    let userId: Swift.String?
    let identityStoreId: Swift.String?
}

extension GetUserIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

enum GetUserIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IdentitystoreClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case externalIds = "ExternalIds"
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let externalIds = externalIds {
            var externalIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalIds)
            for externalid0 in externalIds {
                try externalIdsContainer.encode(externalid0)
            }
        }
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let externalIdsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.ExternalId?].self, forKey: .externalIds)
        var externalIdsDecoded0:[IdentitystoreClientTypes.ExternalId]? = nil
        if let externalIdsContainer = externalIdsContainer {
            externalIdsDecoded0 = [IdentitystoreClientTypes.ExternalId]()
            for structure0 in externalIdsContainer {
                if let structure0 = structure0 {
                    externalIdsDecoded0?.append(structure0)
                }
            }
        }
        externalIds = externalIdsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension IdentitystoreClientTypes.Group: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Group(externalIds: \(Swift.String(describing: externalIds)), groupId: \(Swift.String(describing: groupId)), identityStoreId: \(Swift.String(describing: identityStoreId)), description: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// A group object that contains the metadata and attributes for a specified group.
    public struct Group: Swift.Equatable {
        /// A string containing a description of the specified group.
        public var description: Swift.String?
        /// The display name value for the group. The length limit is 1,024 characters. This value can consist of letters, accented characters, symbols, numbers, punctuation, tab, new line, carriage return, space, and nonbreaking space in this attribute. This value is specified at the time the group is created and stored as an attribute of the group object in the identity store.
        public var displayName: Swift.String?
        /// A list of ExternalId objects that contains the identifiers issued to this resource by an external identity provider.
        public var externalIds: [IdentitystoreClientTypes.ExternalId]?
        /// The identifier for a group in the identity store.
        /// This member is required.
        public var groupId: Swift.String?
        /// The globally unique identifier for the identity store.
        /// This member is required.
        public var identityStoreId: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            externalIds: [IdentitystoreClientTypes.ExternalId]? = nil,
            groupId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.externalIds = externalIds
            self.groupId = groupId
            self.identityStoreId = identityStoreId
        }
    }

}

extension IdentitystoreClientTypes.GroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
        case membershipId = "MembershipId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension IdentitystoreClientTypes {
    /// Contains the identifiers for a group, a group member, and a GroupMembership object in the identity store.
    public struct GroupMembership: Swift.Equatable {
        /// The identifier for a group in the identity store.
        public var groupId: Swift.String?
        /// The globally unique identifier for the identity store.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
        public var memberId: IdentitystoreClientTypes.MemberId?
        /// The identifier for a GroupMembership object in an identity store.
        public var membershipId: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            memberId: IdentitystoreClientTypes.MemberId? = nil,
            membershipId: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.identityStoreId = identityStoreId
            self.memberId = memberId
            self.membershipId = membershipId
        }
    }

}

extension IdentitystoreClientTypes.GroupMembershipExistenceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case membershipExists = "MembershipExists"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if membershipExists != false {
            try encodeContainer.encode(membershipExists, forKey: .membershipExists)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
        let membershipExistsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .membershipExists) ?? false
        membershipExists = membershipExistsDecoded
    }
}

extension IdentitystoreClientTypes.GroupMembershipExistenceResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupMembershipExistenceResult(groupId: \(Swift.String(describing: groupId)), memberId: \(Swift.String(describing: memberId)), membershipExists: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// Indicates whether a resource is a member of a group in the identity store.
    public struct GroupMembershipExistenceResult: Swift.Equatable {
        /// The identifier for a group in the identity store.
        public var groupId: Swift.String?
        /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
        public var memberId: IdentitystoreClientTypes.MemberId?
        /// Indicates whether a membership relation exists or not.
        public var membershipExists: Swift.Bool

        public init(
            groupId: Swift.String? = nil,
            memberId: IdentitystoreClientTypes.MemberId? = nil,
            membershipExists: Swift.Bool = false
        )
        {
            self.groupId = groupId
            self.memberId = memberId
            self.membershipExists = membershipExists
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure with an internal server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
        public internal(set) var requestId: Swift.String? = nil
        /// The number of seconds to wait before retrying the next request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension IsMemberInGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupIds = groupIds {
            var groupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIds)
            for resourceid0 in groupIds {
                try groupIdsContainer.encode(resourceid0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
    }
}

extension IsMemberInGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct IsMemberInGroupsInput: Swift.Equatable {
    /// A list of identifiers for groups in the identity store.
    /// This member is required.
    public var groupIds: [Swift.String]?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// An object containing the identifier of a group member.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?

    public init(
        groupIds: [Swift.String]? = nil,
        identityStoreId: Swift.String? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil
    )
    {
        self.groupIds = groupIds
        self.identityStoreId = identityStoreId
        self.memberId = memberId
    }
}

struct IsMemberInGroupsInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
    let groupIds: [Swift.String]?
}

extension IsMemberInGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIds = "GroupIds"
        case identityStoreId = "IdentityStoreId"
        case memberId = "MemberId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
        let groupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupIds)
        var groupIdsDecoded0:[Swift.String]? = nil
        if let groupIdsContainer = groupIdsContainer {
            groupIdsDecoded0 = [Swift.String]()
            for string0 in groupIdsContainer {
                if let string0 = string0 {
                    groupIdsDecoded0?.append(string0)
                }
            }
        }
        groupIds = groupIdsDecoded0
    }
}

extension IsMemberInGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IsMemberInGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.results = output.results
        } else {
            self.results = nil
        }
    }
}

public struct IsMemberInGroupsOutput: Swift.Equatable {
    /// A list containing the results of membership existence checks.
    /// This member is required.
    public var results: [IdentitystoreClientTypes.GroupMembershipExistenceResult]?

    public init(
        results: [IdentitystoreClientTypes.GroupMembershipExistenceResult]? = nil
    )
    {
        self.results = results
    }
}

struct IsMemberInGroupsOutputBody: Swift.Equatable {
    let results: [IdentitystoreClientTypes.GroupMembershipExistenceResult]?
}

extension IsMemberInGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.GroupMembershipExistenceResult?].self, forKey: .results)
        var resultsDecoded0:[IdentitystoreClientTypes.GroupMembershipExistenceResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [IdentitystoreClientTypes.GroupMembershipExistenceResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
    }
}

enum IsMemberInGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroupMembershipsForMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case memberId = "MemberId"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let memberId = self.memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGroupMembershipsForMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupMembershipsForMemberInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in the ListUsers and ListGroups requests to specify how many results to return in one page. The length limit is 50 characters.
    public var maxResults: Swift.Int?
    /// An object that contains the identifier of a group member. Setting the UserID field to the specific identifier for a user indicates that the user is a member of the group.
    /// This member is required.
    public var memberId: IdentitystoreClientTypes.MemberId?
    /// The pagination token used for the ListUsers, ListGroups, and ListGroupMemberships API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        memberId: IdentitystoreClientTypes.MemberId? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.memberId = memberId
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsForMemberInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let memberId: IdentitystoreClientTypes.MemberId?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListGroupMembershipsForMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case memberId = "MemberId"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.MemberId.self, forKey: .memberId)
        memberId = memberIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupMembershipsForMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupMembershipsForMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupMemberships = output.groupMemberships
            self.nextToken = output.nextToken
        } else {
            self.groupMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupMembershipsForMemberOutput: Swift.Equatable {
    /// A list of GroupMembership objects in the group for a specified member.
    /// This member is required.
    public var groupMemberships: [IdentitystoreClientTypes.GroupMembership]?
    /// The pagination token used for the ListUsers, ListGroups, and ListGroupMemberships API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init(
        groupMemberships: [IdentitystoreClientTypes.GroupMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupMemberships = groupMemberships
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsForMemberOutputBody: Swift.Equatable {
    let groupMemberships: [IdentitystoreClientTypes.GroupMembership]?
    let nextToken: Swift.String?
}

extension ListGroupMembershipsForMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupMemberships = "GroupMemberships"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMembershipsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.GroupMembership?].self, forKey: .groupMemberships)
        var groupMembershipsDecoded0:[IdentitystoreClientTypes.GroupMembership]? = nil
        if let groupMembershipsContainer = groupMembershipsContainer {
            groupMembershipsDecoded0 = [IdentitystoreClientTypes.GroupMembership]()
            for structure0 in groupMembershipsContainer {
                if let structure0 = structure0 {
                    groupMembershipsDecoded0?.append(structure0)
                }
            }
        }
        groupMemberships = groupMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGroupMembershipsForMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroupMembershipsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGroupMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupMembershipsInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in all List requests to specify how many results to return in one page.
    public var maxResults: Swift.Int?
    /// The pagination token used for the ListUsers, ListGroups and ListGroupMemberships API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListGroupMembershipsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGroupMembershipsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupMembershipsOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupMemberships = output.groupMemberships
            self.nextToken = output.nextToken
        } else {
            self.groupMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupMembershipsOutput: Swift.Equatable {
    /// A list of GroupMembership objects in the group.
    /// This member is required.
    public var groupMemberships: [IdentitystoreClientTypes.GroupMembership]?
    /// The pagination token used for the ListUsers, ListGroups, and ListGroupMemberships API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init(
        groupMemberships: [IdentitystoreClientTypes.GroupMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupMemberships = groupMemberships
        self.nextToken = nextToken
    }
}

struct ListGroupMembershipsOutputBody: Swift.Equatable {
    let groupMemberships: [IdentitystoreClientTypes.GroupMembership]?
    let nextToken: Swift.String?
}

extension ListGroupMembershipsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupMemberships = "GroupMemberships"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupMembershipsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.GroupMembership?].self, forKey: .groupMemberships)
        var groupMembershipsDecoded0:[IdentitystoreClientTypes.GroupMembership]? = nil
        if let groupMembershipsContainer = groupMembershipsContainer {
            groupMembershipsDecoded0 = [IdentitystoreClientTypes.GroupMembership]()
            for structure0 in groupMembershipsContainer {
                if let structure0 = structure0 {
                    groupMembershipsDecoded0?.append(structure0)
                }
            }
        }
        groupMemberships = groupMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGroupMembershipsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// A list of Filter objects, which is used in the ListUsers and ListGroups requests.
    @available(*, deprecated, message: "Using filters with ListGroups API is deprecated, please use GetGroupId API instead.")
    public var filters: [IdentitystoreClientTypes.Filter]?
    /// The globally unique identifier for the identity store, such as d-1234567890. In this example, d- is a fixed prefix, and 1234567890 is a randomly generated string that contains numbers and lower case letters. This value is generated at the time that a new identity store is created.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in the ListUsers and ListGroups requests to specify how many results to return in one page. The length limit is 50 characters.
    public var maxResults: Swift.Int?
    /// The pagination token used for the ListUsers and ListGroups API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init(
        filters: [IdentitystoreClientTypes.Filter]? = nil,
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [IdentitystoreClientTypes.Filter]?
}

extension ListGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[IdentitystoreClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IdentitystoreClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutput: Swift.Equatable {
    /// A list of Group objects in the identity store.
    /// This member is required.
    public var groups: [IdentitystoreClientTypes.Group]?
    /// The pagination token used for the ListUsers and ListGroups API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it1 is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init(
        groups: [IdentitystoreClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputBody: Swift.Equatable {
    let groups: [IdentitystoreClientTypes.Group]?
    let nextToken: Swift.String?
}

extension ListGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Group?].self, forKey: .groups)
        var groupsDecoded0:[IdentitystoreClientTypes.Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [IdentitystoreClientTypes.Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// A list of Filter objects, which is used in the ListUsers and ListGroups requests.
    @available(*, deprecated, message: "Using filters with ListUsers API is deprecated, please use GetGroupId API instead.")
    public var filters: [IdentitystoreClientTypes.Filter]?
    /// The globally unique identifier for the identity store, such as d-1234567890. In this example, d- is a fixed prefix, and 1234567890 is a randomly generated string that contains numbers and lower case letters. This value is generated at the time that a new identity store is created.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The maximum number of results to be returned per request. This parameter is used in the ListUsers and ListGroups requests to specify how many results to return in one page. The length limit is 50 characters.
    public var maxResults: Swift.Int?
    /// The pagination token used for the ListUsers and ListGroups API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?

    public init(
        filters: [IdentitystoreClientTypes.Filter]? = nil,
        identityStoreId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.identityStoreId = identityStoreId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filters: [IdentitystoreClientTypes.Filter]?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case identityStoreId = "IdentityStoreId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filtersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[IdentitystoreClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [IdentitystoreClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutput: Swift.Equatable {
    /// The pagination token used for the ListUsers and ListGroups API operations. This value is generated by the identity store service. It is returned in the API response if the total results are more than the size of one page. This token is also returned when it is used in the API request to search for the next page.
    public var nextToken: Swift.String?
    /// A list of User objects in the identity store.
    /// This member is required.
    public var users: [IdentitystoreClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [IdentitystoreClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputBody: Swift.Equatable {
    let users: [IdentitystoreClientTypes.User]?
    let nextToken: Swift.String?
}

extension ListUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[IdentitystoreClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [IdentitystoreClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IdentitystoreClientTypes.MemberId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userid = "UserId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .userid(userid):
                try container.encode(userid, forKey: .userid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let useridDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .userid)
        if let userid = useridDecoded {
            self = .userid(userid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IdentitystoreClientTypes {
    /// An object containing the identifier of a group member.
    public enum MemberId: Swift.Equatable {
        /// An object containing the identifiers of resources that can be members.
        case userid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension IdentitystoreClientTypes.Name: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case familyName = "FamilyName"
        case formatted = "Formatted"
        case givenName = "GivenName"
        case honorificPrefix = "HonorificPrefix"
        case honorificSuffix = "HonorificSuffix"
        case middleName = "MiddleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let familyName = self.familyName {
            try encodeContainer.encode(familyName, forKey: .familyName)
        }
        if let formatted = self.formatted {
            try encodeContainer.encode(formatted, forKey: .formatted)
        }
        if let givenName = self.givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let honorificPrefix = self.honorificPrefix {
            try encodeContainer.encode(honorificPrefix, forKey: .honorificPrefix)
        }
        if let honorificSuffix = self.honorificSuffix {
            try encodeContainer.encode(honorificSuffix, forKey: .honorificSuffix)
        }
        if let middleName = self.middleName {
            try encodeContainer.encode(middleName, forKey: .middleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formattedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formatted)
        formatted = formattedDecoded
        let familyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .familyName)
        familyName = familyNameDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let middleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .middleName)
        middleName = middleNameDecoded
        let honorificPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .honorificPrefix)
        honorificPrefix = honorificPrefixDecoded
        let honorificSuffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .honorificSuffix)
        honorificSuffix = honorificSuffixDecoded
    }
}

extension IdentitystoreClientTypes.Name: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Name(familyName: \"CONTENT_REDACTED\", formatted: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", honorificPrefix: \"CONTENT_REDACTED\", honorificSuffix: \"CONTENT_REDACTED\", middleName: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The full name of the user.
    public struct Name: Swift.Equatable {
        /// The family name of the user.
        public var familyName: Swift.String?
        /// A string containing a formatted version of the name for display.
        public var formatted: Swift.String?
        /// The given name of the user.
        public var givenName: Swift.String?
        /// The honorific prefix of the user. For example, "Dr."
        public var honorificPrefix: Swift.String?
        /// The honorific suffix of the user. For example, "M.D."
        public var honorificSuffix: Swift.String?
        /// The middle name of the user.
        public var middleName: Swift.String?

        public init(
            familyName: Swift.String? = nil,
            formatted: Swift.String? = nil,
            givenName: Swift.String? = nil,
            honorificPrefix: Swift.String? = nil,
            honorificSuffix: Swift.String? = nil,
            middleName: Swift.String? = nil
        )
        {
            self.familyName = familyName
            self.formatted = formatted
            self.givenName = givenName
            self.honorificPrefix = honorificPrefix
            self.honorificSuffix = honorificSuffix
            self.middleName = middleName
        }
    }

}

extension IdentitystoreClientTypes.PhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primary = "Primary"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if primary != false {
            try encodeContainer.encode(primary, forKey: .primary)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let primaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .primary) ?? false
        primary = primaryDecoded
    }
}

extension IdentitystoreClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(primary: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// The phone number associated with the user.
    public struct PhoneNumber: Swift.Equatable {
        /// A Boolean value representing whether this is the primary phone number for the associated resource.
        public var primary: Swift.Bool
        /// A string representing the type of a phone number. For example, "Mobile."
        public var type: Swift.String?
        /// A string containing a phone number. For example, "8675309" or "+1 (800) 123-4567".
        public var value: Swift.String?

        public init(
            primary: Swift.Bool = false,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.primary = primary
            self.type = type
            self.value = value
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a requested resource is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
        public internal(set) var requestId: Swift.String? = nil
        /// The identifier for a resource in the identity store that can be used as UserId or GroupId. The format for ResourceId is either UUID or 1234567890-UUID, where UUID is a randomly generated value for each resource when it is created and 1234567890 represents the IdentityStoreId string value. In the case that the identity store is migrated from a legacy SSO identity store, the ResourceId for that identity store will be in the format of UUID. Otherwise, it will be in the 1234567890-UUID format.
        public internal(set) var resourceId: Swift.String? = nil
        /// An enum object indicating the type of resource in the identity store service. Valid values include USER, GROUP, and IDENTITY_STORE.
        public internal(set) var resourceType: IdentitystoreClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IdentitystoreClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let resourceType: IdentitystoreClientTypes.ResourceType?
    let resourceId: Swift.String?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension IdentitystoreClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case groupMembership
        case identityStore
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .group,
                .groupMembership,
                .identityStore,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .groupMembership: return "GROUP_MEMBERSHIP"
            case .identityStore: return "IDENTITY_STORE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause the number of users or groups in the identity store to exceed the maximum allowed.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the principal has crossed the throttling limits of the API operations.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
        public internal(set) var requestId: Swift.String? = nil
        /// The number of seconds to wait before retrying the next request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension IdentitystoreClientTypes.UniqueAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributePath = "AttributePath"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributePath = self.attributePath {
            try encodeContainer.encode(attributePath, forKey: .attributePath)
        }
        if let attributeValue = self.attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributePath)
        attributePath = attributePathDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension IdentitystoreClientTypes {
    /// An entity attribute that's unique to a specific entity.
    public struct UniqueAttribute: Swift.Equatable {
        /// A string representation of the path to a given attribute or sub-attribute. Supports JMESPath.
        /// This member is required.
        public var attributePath: Swift.String?
        /// The value of the attribute. This is a Document type. This type is not supported by Java V1, Go V1, and older versions of the CLI.
        /// This member is required.
        public var attributeValue: ClientRuntime.Document?

        public init(
            attributePath: Swift.String? = nil,
            attributeValue: ClientRuntime.Document? = nil
        )
        {
            self.attributePath = attributePath
            self.attributeValue = attributeValue
        }
    }

}

extension UpdateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case operations = "Operations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for attributeoperation0 in operations {
                try operationsContainer.encode(attributeoperation0)
            }
        }
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// The identifier for a group in the identity store.
    /// This member is required.
    public var groupId: Swift.String?
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A list of AttributeOperation objects to apply to the requested group. These operations might add, replace, or remove an attribute.
    /// This member is required.
    public var operations: [IdentitystoreClientTypes.AttributeOperation]?

    public init(
        groupId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        operations: [IdentitystoreClientTypes.AttributeOperation]? = nil
    )
    {
        self.groupId = groupId
        self.identityStoreId = identityStoreId
        self.operations = operations
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let groupId: Swift.String?
    let operations: [IdentitystoreClientTypes.AttributeOperation]?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case identityStoreId = "IdentityStoreId"
        case operations = "Operations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let operationsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.AttributeOperation?].self, forKey: .operations)
        var operationsDecoded0:[IdentitystoreClientTypes.AttributeOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [IdentitystoreClientTypes.AttributeOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension UpdateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case operations = "Operations"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for attributeoperation0 in operations {
                try operationsContainer.encode(attributeoperation0)
            }
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The globally unique identifier for the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A list of AttributeOperation objects to apply to the requested user. These operations might add, replace, or remove an attribute.
    /// This member is required.
    public var operations: [IdentitystoreClientTypes.AttributeOperation]?
    /// The identifier for a user in the identity store.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        identityStoreId: Swift.String? = nil,
        operations: [IdentitystoreClientTypes.AttributeOperation]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.identityStoreId = identityStoreId
        self.operations = operations
        self.userId = userId
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let userId: Swift.String?
    let operations: [IdentitystoreClientTypes.AttributeOperation]?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case operations = "Operations"
        case userId = "UserId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let operationsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.AttributeOperation?].self, forKey: .operations)
        var operationsDecoded0:[IdentitystoreClientTypes.AttributeOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [IdentitystoreClientTypes.AttributeOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateUserOutput: Swift.Equatable {

    public init() { }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IdentitystoreClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IdentitystoreClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case displayName = "DisplayName"
        case emails = "Emails"
        case externalIds = "ExternalIds"
        case identityStoreId = "IdentityStoreId"
        case locale = "Locale"
        case name = "Name"
        case nickName = "NickName"
        case phoneNumbers = "PhoneNumbers"
        case preferredLanguage = "PreferredLanguage"
        case profileUrl = "ProfileUrl"
        case timezone = "Timezone"
        case title = "Title"
        case userId = "UserId"
        case userName = "UserName"
        case userType = "UserType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addresses = addresses {
            var addressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addresses)
            for address0 in addresses {
                try addressesContainer.encode(address0)
            }
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emails = emails {
            var emailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emails)
            for email0 in emails {
                try emailsContainer.encode(email0)
            }
        }
        if let externalIds = externalIds {
            var externalIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalIds)
            for externalid0 in externalIds {
                try externalIdsContainer.encode(externalid0)
            }
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nickName = self.nickName {
            try encodeContainer.encode(nickName, forKey: .nickName)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumber0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumber0)
            }
        }
        if let preferredLanguage = self.preferredLanguage {
            try encodeContainer.encode(preferredLanguage, forKey: .preferredLanguage)
        }
        if let profileUrl = self.profileUrl {
            try encodeContainer.encode(profileUrl, forKey: .profileUrl)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType, forKey: .userType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let externalIdsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.ExternalId?].self, forKey: .externalIds)
        var externalIdsDecoded0:[IdentitystoreClientTypes.ExternalId]? = nil
        if let externalIdsContainer = externalIdsContainer {
            externalIdsDecoded0 = [IdentitystoreClientTypes.ExternalId]()
            for structure0 in externalIdsContainer {
                if let structure0 = structure0 {
                    externalIdsDecoded0?.append(structure0)
                }
            }
        }
        externalIds = externalIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(IdentitystoreClientTypes.Name.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let nickNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nickName)
        nickName = nickNameDecoded
        let profileUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileUrl)
        profileUrl = profileUrlDecoded
        let emailsContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Email?].self, forKey: .emails)
        var emailsDecoded0:[IdentitystoreClientTypes.Email]? = nil
        if let emailsContainer = emailsContainer {
            emailsDecoded0 = [IdentitystoreClientTypes.Email]()
            for structure0 in emailsContainer {
                if let structure0 = structure0 {
                    emailsDecoded0?.append(structure0)
                }
            }
        }
        emails = emailsDecoded0
        let addressesContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[IdentitystoreClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [IdentitystoreClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let phoneNumbersContainer = try containerValues.decodeIfPresent([IdentitystoreClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[IdentitystoreClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [IdentitystoreClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let userTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userType)
        userType = userTypeDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let preferredLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredLanguage)
        preferredLanguage = preferredLanguageDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension IdentitystoreClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(addresses: \(Swift.String(describing: addresses)), emails: \(Swift.String(describing: emails)), externalIds: \(Swift.String(describing: externalIds)), identityStoreId: \(Swift.String(describing: identityStoreId)), name: \(Swift.String(describing: name)), phoneNumbers: \(Swift.String(describing: phoneNumbers)), userId: \(Swift.String(describing: userId)), displayName: \"CONTENT_REDACTED\", locale: \"CONTENT_REDACTED\", nickName: \"CONTENT_REDACTED\", preferredLanguage: \"CONTENT_REDACTED\", profileUrl: \"CONTENT_REDACTED\", timezone: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\", userName: \"CONTENT_REDACTED\", userType: \"CONTENT_REDACTED\")"}
}

extension IdentitystoreClientTypes {
    /// A user object that contains the metadata and attributes for a specified user.
    public struct User: Swift.Equatable {
        /// A list of Address objects containing addresses associated with the user.
        public var addresses: [IdentitystoreClientTypes.Address]?
        /// A string containing the name of the user that is formatted for display when the user is referenced. For example, "John Doe."
        public var displayName: Swift.String?
        /// A list of Email objects containing email addresses associated with the user.
        public var emails: [IdentitystoreClientTypes.Email]?
        /// A list of ExternalId objects that contains the identifiers issued to this resource by an external identity provider.
        public var externalIds: [IdentitystoreClientTypes.ExternalId]?
        /// The globally unique identifier for the identity store.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// A string containing the geographical region or location of the user.
        public var locale: Swift.String?
        /// An object containing the name of the user.
        public var name: IdentitystoreClientTypes.Name?
        /// A string containing an alternate name for the user.
        public var nickName: Swift.String?
        /// A list of PhoneNumber objects containing phone numbers associated with the user.
        public var phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]?
        /// A string containing the preferred language of the user. For example, "American English" or "en-us."
        public var preferredLanguage: Swift.String?
        /// A string containing a URL that might be associated with the user.
        public var profileUrl: Swift.String?
        /// A string containing the time zone of the user.
        public var timezone: Swift.String?
        /// A string containing the title of the user. Possible values are left unspecified. The value can vary based on your specific use case.
        public var title: Swift.String?
        /// The identifier for a user in the identity store.
        /// This member is required.
        public var userId: Swift.String?
        /// A unique string used to identify the user. The length limit is 128 characters. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store.
        public var userName: Swift.String?
        /// A string indicating the type of user. Possible values are left unspecified. The value can vary based on your specific use case.
        public var userType: Swift.String?

        public init(
            addresses: [IdentitystoreClientTypes.Address]? = nil,
            displayName: Swift.String? = nil,
            emails: [IdentitystoreClientTypes.Email]? = nil,
            externalIds: [IdentitystoreClientTypes.ExternalId]? = nil,
            identityStoreId: Swift.String? = nil,
            locale: Swift.String? = nil,
            name: IdentitystoreClientTypes.Name? = nil,
            nickName: Swift.String? = nil,
            phoneNumbers: [IdentitystoreClientTypes.PhoneNumber]? = nil,
            preferredLanguage: Swift.String? = nil,
            profileUrl: Swift.String? = nil,
            timezone: Swift.String? = nil,
            title: Swift.String? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userType: Swift.String? = nil
        )
        {
            self.addresses = addresses
            self.displayName = displayName
            self.emails = emails
            self.externalIds = externalIds
            self.identityStoreId = identityStoreId
            self.locale = locale
            self.name = name
            self.nickName = nickName
            self.phoneNumbers = phoneNumbers
            self.preferredLanguage = preferredLanguage
            self.profileUrl = profileUrl
            self.timezone = timezone
            self.title = title
            self.userId = userId
            self.userName = userName
            self.userType = userType
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.requestId = output.requestId
        } else {
            self.properties.message = nil
            self.properties.requestId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because it contains a syntax error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier for each request. This value is a globally unique ID that is generated by the identity store service for each sent request, and is then returned inside the exception if the request fails.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case requestId = "RequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}
