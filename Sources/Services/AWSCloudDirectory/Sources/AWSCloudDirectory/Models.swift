//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers


public struct DetachTypedLinkOutput: Swift.Sendable {

    public init() { }
}

/// Access denied or directory not found. Either you don't have permissions for this directory or the directory does not exist. Try calling [ListDirectories] and check your permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Operations are only permitted on enabled directories.
public struct DirectoryNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryNotEnabledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The [Facet] that you provided was not well formed or could not be validated with the schema.
public struct FacetValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FacetValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates a problem that must be resolved by Amazon Web Services. This might be a transient error in which case you can retry your request until it succeeds. Otherwise, go to the [AWS Service Health Dashboard](http://status.aws.amazon.com/) site to see if there are any operational issues with the service.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that the provided ARN value is not valid.
public struct InvalidArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArnException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that limits are exceeded. See [Limits](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html) for more information.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. For example, if a write operation occurs on an object and then an attempt is made to read the object using “SERIALIZABLE” consistency, this exception may result. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct RetryableConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RetryableConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that your request is malformed in some manner. See the exception message.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudDirectoryClientTypes {

    /// A unique identifier for an attribute.
    public struct AttributeKey: Swift.Sendable {
        /// The name of the facet that the attribute exists within.
        /// This member is required.
        public var facetName: Swift.String?
        /// The name of the attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema that contains the facet and attribute.
        /// This member is required.
        public var schemaArn: Swift.String?

        public init(
            facetName: Swift.String? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.facetName = facetName
            self.name = name
            self.schemaArn = schemaArn
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the data for a typed attribute. You can set one, and only one, of the elements. Each attribute in an item is a name-value pair. Attributes have a single value.
    public enum TypedAttributeValue: Swift.Sendable {
        /// A string data value.
        case stringvalue(Swift.String)
        /// A binary data value.
        case binaryvalue(Foundation.Data)
        /// A Boolean data value.
        case booleanvalue(Swift.Bool)
        /// A number data value.
        case numbervalue(Swift.String)
        /// A date and time value.
        case datetimevalue(Foundation.Date)
        case sdkUnknown(Swift.String)
    }
}

extension CloudDirectoryClientTypes {

    /// The combination of an attribute key and an attribute value.
    public struct AttributeKeyAndValue: Swift.Sendable {
        /// The key of the attribute.
        /// This member is required.
        public var key: CloudDirectoryClientTypes.AttributeKey?
        /// The value of the attribute.
        /// This member is required.
        public var value: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            key: CloudDirectoryClientTypes.AttributeKey? = nil,
            value: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension CloudDirectoryClientTypes {

    /// The reference that identifies an object.
    public struct ObjectReference: Swift.Sendable {
        /// A path selector supports easy selection of an object by the parent/child links leading to it from the directory root. Use the link names from each parent/child link to construct the path. Path selectors start with a slash (/) and link names are separated by slashes. For more information about paths, see [Access Objects](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_access_objects.html). You can identify an object in one of the following ways:
        ///
        /// * $ObjectIdentifier - An object identifier is an opaque string provided by Amazon Cloud Directory. When creating objects, the system will provide you with the identifier of the created object. An object’s identifier is immutable and no two objects will ever share the same object identifier. To identify an object with ObjectIdentifier, the ObjectIdentifier must be wrapped in double quotes.
        ///
        /// * /some/path - Identifies the object based on path
        ///
        /// * #SomeBatchReference - Identifies the object in a batch call
        public var selector: Swift.String?

        public init(
            selector: Swift.String? = nil
        )
        {
            self.selector = selector
        }
    }
}

extension CloudDirectoryClientTypes {

    /// A facet.
    public struct SchemaFacet: Swift.Sendable {
        /// The name of the facet. If this value is set, SchemaArn must also be set.
        public var facetName: Swift.String?
        /// The ARN of the schema that contains the facet with no minor component. See [arns] and [In-Place Schema Upgrade](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_inplaceschemaupgrade.html) for a description of when to provide minor versions. If this value is set, FacetName must also be set.
        public var schemaArn: Swift.String?

        public init(
            facetName: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.facetName = facetName
            self.schemaArn = schemaArn
        }
    }
}

public struct AddFacetToObjectInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Attributes on the facet that you are adding to the object.
    public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    /// A reference to the object you are adding the specified facet to.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifiers for the facet that you are adding to the object. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

    public init(
        directoryArn: Swift.String? = nil,
        objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectAttributeList = objectAttributeList
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

public struct AddFacetToObjectOutput: Swift.Sendable {

    public init() { }
}

/// Indicates that an attempt to make an attachment was invalid. For example, attaching two nodes with a link type that is not applicable to the nodes or attempting to apply a schema to a directory a second time.
public struct InvalidAttachmentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAttachmentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that a schema could not be created due to a naming conflict. Please select a different name and then try again.
public struct SchemaAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SchemaAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ApplySchemaInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] into which the schema is copied. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Published schema Amazon Resource Name (ARN) that needs to be copied. For more information, see [arns].
    /// This member is required.
    public var publishedSchemaArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil,
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.publishedSchemaArn = publishedSchemaArn
    }
}

public struct ApplySchemaOutput: Swift.Sendable {
    /// The applied schema ARN that is associated with the copied schema in the [Directory]. You can use this ARN to describe the schema information applied on this directory. For more information, see [arns].
    public var appliedSchemaArn: Swift.String?
    /// The ARN that is associated with the [Directory]. For more information, see [arns].
    public var directoryArn: Swift.String?

    public init(
        appliedSchemaArn: Swift.String? = nil,
        directoryArn: Swift.String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
        self.directoryArn = directoryArn
    }
}

/// Indicates that a link could not be created due to a naming conflict. Choose a different name and then try again.
public struct LinkNameAlreadyInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LinkNameAlreadyInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AttachObjectInput: Swift.Sendable {
    /// The child object reference to be attached to the object.
    /// This member is required.
    public var childReference: CloudDirectoryClientTypes.ObjectReference?
    /// Amazon Resource Name (ARN) that is associated with the [Directory] where both objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The link name with which the child object is attached to the parent.
    /// This member is required.
    public var linkName: Swift.String?
    /// The parent object reference.
    /// This member is required.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        childReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        directoryArn: Swift.String? = nil,
        linkName: Swift.String? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.childReference = childReference
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

public struct AttachObjectOutput: Swift.Sendable {
    /// The attached ObjectIdentifier, which is the child ObjectIdentifier.
    public var attachedObjectIdentifier: Swift.String?

    public init(
        attachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

/// Indicates that the requested operation can only operate on policy objects.
public struct NotPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotPolicyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AttachPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where both objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The reference that identifies the object to which the policy will be attached.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// The reference that is associated with the policy object.
    /// This member is required.
    public var policyReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

public struct AttachPolicyOutput: Swift.Sendable {

    public init() { }
}

/// An object has been attempted to be attached to an object that does not have the appropriate attribute value.
public struct IndexedAttributeMissingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IndexedAttributeMissingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that the requested operation can only operate on index objects.
public struct NotIndexException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotIndexException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AttachToIndexInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the directory where the object and index exist.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the index that you are attaching the object to.
    /// This member is required.
    public var indexReference: CloudDirectoryClientTypes.ObjectReference?
    /// A reference to the object that you are attaching to the index.
    /// This member is required.
    public var targetReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

public struct AttachToIndexOutput: Swift.Sendable {
    /// The ObjectIdentifier of the object that was attached to the index.
    public var attachedObjectIdentifier: Swift.String?

    public init(
        attachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

extension CloudDirectoryClientTypes {

    /// Identifies the attribute name and value for a typed link.
    public struct AttributeNameAndValue: Swift.Sendable {
        /// The attribute name of the typed link.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The value for the typed link.
        /// This member is required.
        public var value: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            attributeName: Swift.String? = nil,
            value: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.attributeName = attributeName
            self.value = value
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Identifies the schema Amazon Resource Name (ARN) and facet name for the typed link.
    public struct TypedLinkSchemaAndFacetName: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
        /// This member is required.
        public var schemaArn: Swift.String?
        /// The unique name of the typed link facet.
        /// This member is required.
        public var typedLinkName: Swift.String?

        public init(
            schemaArn: Swift.String? = nil,
            typedLinkName: Swift.String? = nil
        )
        {
            self.schemaArn = schemaArn
            self.typedLinkName = typedLinkName
        }
    }
}

public struct AttachTypedLinkInput: Swift.Sendable {
    /// A set of attributes that are associated with the typed link.
    /// This member is required.
    public var attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]?
    /// The Amazon Resource Name (ARN) of the directory where you want to attach the typed link.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Identifies the source object that the typed link will attach to.
    /// This member is required.
    public var sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifies the target object that the typed link will attach to.
    /// This member is required.
    public var targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifies the typed link facet that is associated with the typed link.
    /// This member is required.
    public var typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?

    public init(
        attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]? = nil,
        directoryArn: Swift.String? = nil,
        sourceObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        targetObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil
    )
    {
        self.attributes = attributes
        self.directoryArn = directoryArn
        self.sourceObjectReference = sourceObjectReference
        self.targetObjectReference = targetObjectReference
        self.typedLinkFacet = typedLinkFacet
    }
}

extension CloudDirectoryClientTypes {

    /// Contains all the information that is used to uniquely identify a typed link. The parameters discussed in this topic are used to uniquely specify the typed link being operated on. The [AttachTypedLink] API returns a typed link specifier while the [DetachTypedLink] API accepts one as input. Similarly, the [ListIncomingTypedLinks] and [ListOutgoingTypedLinks] API operations provide typed link specifiers as output. You can also construct a typed link specifier from scratch.
    public struct TypedLinkSpecifier: Swift.Sendable {
        /// Identifies the attribute value to update.
        /// This member is required.
        public var identityAttributeValues: [CloudDirectoryClientTypes.AttributeNameAndValue]?
        /// Identifies the source object that the typed link will attach to.
        /// This member is required.
        public var sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the target object that the typed link will attach to.
        /// This member is required.
        public var targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the typed link facet that is associated with the typed link.
        /// This member is required.
        public var typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?

        public init(
            identityAttributeValues: [CloudDirectoryClientTypes.AttributeNameAndValue]? = nil,
            sourceObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil
        )
        {
            self.identityAttributeValues = identityAttributeValues
            self.sourceObjectReference = sourceObjectReference
            self.targetObjectReference = targetObjectReference
            self.typedLinkFacet = typedLinkFacet
        }
    }
}

public struct AttachTypedLinkOutput: Swift.Sendable {
    /// Returns a typed link specifier as output.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init(
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

extension CloudDirectoryClientTypes {

    public enum ConsistencyLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eventual
        case serializable
        case sdkUnknown(Swift.String)

        public static var allCases: [ConsistencyLevel] {
            return [
                .eventual,
                .serializable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eventual: return "EVENTUAL"
            case .serializable: return "SERIALIZABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Retrieves attributes that are associated with a typed link inside a [BatchRead] operation. For more information, see [GetLinkAttributes] and [BatchReadRequest$Operations].
    public struct BatchGetLinkAttributes: Swift.Sendable {
        /// A list of attribute names whose values will be retrieved.
        /// This member is required.
        public var attributeNames: [Swift.String]?
        /// Allows a typed link specifier to be accepted as input.
        /// This member is required.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init(
            attributeNames: [Swift.String]? = nil,
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.attributeNames = attributeNames
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Retrieves attributes within a facet that are associated with an object inside an [BatchRead] operation. For more information, see [GetObjectAttributes] and [BatchReadRequest$Operations].
    public struct BatchGetObjectAttributes: Swift.Sendable {
        /// List of attribute names whose values will be retrieved.
        /// This member is required.
        public var attributeNames: [Swift.String]?
        /// Reference that identifies the object whose attributes will be retrieved.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifier for the facet whose attributes will be retrieved. See [SchemaFacet] for details.
        /// This member is required.
        public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

        public init(
            attributeNames: [Swift.String]? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
        )
        {
            self.attributeNames = attributeNames
            self.objectReference = objectReference
            self.schemaFacet = schemaFacet
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Retrieves metadata about an object inside a [BatchRead] operation. For more information, see [GetObjectInformation] and [BatchReadRequest$Operations].
    public struct BatchGetObjectInformation: Swift.Sendable {
        /// A reference to the object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Lists indices attached to an object inside a [BatchRead] operation. For more information, see [ListAttachedIndices] and [BatchReadRequest$Operations].
    public struct BatchListAttachedIndices: Swift.Sendable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// A reference to the object that has indices attached.
        /// This member is required.
        public var targetReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetReference = targetReference
        }
    }
}

extension CloudDirectoryClientTypes {

    public enum RangeMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exclusive
        case first
        case inclusive
        case last
        case lastBeforeMissingValues
        case sdkUnknown(Swift.String)

        public static var allCases: [RangeMode] {
            return [
                .exclusive,
                .first,
                .inclusive,
                .last,
                .lastBeforeMissingValues
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exclusive: return "EXCLUSIVE"
            case .first: return "FIRST"
            case .inclusive: return "INCLUSIVE"
            case .last: return "LAST"
            case .lastBeforeMissingValues: return "LAST_BEFORE_MISSING_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudDirectoryClientTypes {

    /// A range of attribute values. For more information, see [Range Filters](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_range_filters.html).
    public struct TypedAttributeValueRange: Swift.Sendable {
        /// The inclusive or exclusive range end.
        /// This member is required.
        public var endMode: CloudDirectoryClientTypes.RangeMode?
        /// The attribute value to terminate the range at.
        public var endValue: CloudDirectoryClientTypes.TypedAttributeValue?
        /// The inclusive or exclusive range start.
        /// This member is required.
        public var startMode: CloudDirectoryClientTypes.RangeMode?
        /// The value to start the range at.
        public var startValue: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            endMode: CloudDirectoryClientTypes.RangeMode? = nil,
            endValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil,
            startMode: CloudDirectoryClientTypes.RangeMode? = nil,
            startValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.endMode = endMode
            self.endValue = endValue
            self.startMode = startMode
            self.startValue = startValue
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Identifies the range of attributes that are used by a specified filter.
    public struct TypedLinkAttributeRange: Swift.Sendable {
        /// The unique name of the typed link attribute.
        public var attributeName: Swift.String?
        /// The range of attribute values that are being selected.
        /// This member is required.
        public var range: CloudDirectoryClientTypes.TypedAttributeValueRange?

        public init(
            attributeName: Swift.String? = nil,
            range: CloudDirectoryClientTypes.TypedAttributeValueRange? = nil
        )
        {
            self.attributeName = attributeName
            self.range = range
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Returns a paginated list of all the incoming [TypedLinkSpecifier] information for an object inside a [BatchRead] operation. For more information, see [ListIncomingTypedLinks] and [BatchReadRequest$Operations].
    public struct BatchListIncomingTypedLinks: Swift.Sendable {
        /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
        public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
        /// Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls.
        public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
            filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.filterAttributeRanges = filterAttributeRanges
            self.filterTypedLink = filterTypedLink
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// A range of attributes.
    public struct ObjectAttributeRange: Swift.Sendable {
        /// The key of the attribute that the attribute range covers.
        public var attributeKey: CloudDirectoryClientTypes.AttributeKey?
        /// The range of attribute values being selected.
        public var range: CloudDirectoryClientTypes.TypedAttributeValueRange?

        public init(
            attributeKey: CloudDirectoryClientTypes.AttributeKey? = nil,
            range: CloudDirectoryClientTypes.TypedAttributeValueRange? = nil
        )
        {
            self.attributeKey = attributeKey
            self.range = range
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Lists objects attached to the specified index inside a [BatchRead] operation. For more information, see [ListIndex] and [BatchReadRequest$Operations].
    public struct BatchListIndex: Swift.Sendable {
        /// The reference to the index to list.
        /// This member is required.
        public var indexReference: CloudDirectoryClientTypes.ObjectReference?
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Specifies the ranges of indexed values that you want to query.
        public var rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]?

        public init(
            indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
        )
        {
            self.indexReference = indexReference
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.rangesOnIndexedValues = rangesOnIndexedValues
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListObjectAttributes] operation.
    public struct BatchListObjectAttributes: Swift.Sendable {
        /// Used to filter the list of object attributes that are associated with a certain facet.
        public var facetFilter: CloudDirectoryClientTypes.SchemaFacet?
        /// The maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Reference of the object whose attributes need to be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            facetFilter: CloudDirectoryClientTypes.SchemaFacet? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.facetFilter = facetFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListObjectChildren] operation.
    public struct BatchListObjectChildren: Swift.Sendable {
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Reference of the object for which child objects are being listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects inside a [BatchRead] operation. For more information, see [ListObjectParentPaths] and [BatchReadRequest$Operations].
    public struct BatchListObjectParentPaths: Swift.Sendable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Lists parent objects that are associated with a given object in pagination fashion.
    public struct BatchListObjectParents: Swift.Sendable {
        /// The maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies an object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Returns policies attached to an object in pagination fashion inside a [BatchRead] operation. For more information, see [ListObjectPolicies] and [BatchReadRequest$Operations].
    public struct BatchListObjectPolicies: Swift.Sendable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Returns a paginated list of all the outgoing [TypedLinkSpecifier] information for an object inside a [BatchRead] operation. For more information, see [ListOutgoingTypedLinks] and [BatchReadRequest$Operations].
    public struct BatchListOutgoingTypedLinks: Swift.Sendable {
        /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
        public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
        /// Filters are interpreted in the order of the attributes defined on the typed link facet, not the order they are supplied to any API calls.
        public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
            filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.filterAttributeRanges = filterAttributeRanges
            self.filterTypedLink = filterTypedLink
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Returns all of the ObjectIdentifiers to which a given policy is attached inside a [BatchRead] operation. For more information, see [ListPolicyAttachments] and [BatchReadRequest$Operations].
    public struct BatchListPolicyAttachments: Swift.Sendable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the policy object.
        /// This member is required.
        public var policyReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyReference = policyReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Lists all policies from the root of the Directory to the object specified inside a [BatchRead] operation. For more information, see [LookupPolicy] and [BatchReadRequest$Operations].
    public struct BatchLookupPolicy: Swift.Sendable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Reference that identifies the object whose policies will be looked up.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a BatchRead operation.
    public struct BatchReadOperation: Swift.Sendable {
        /// Retrieves attributes that are associated with a typed link.
        public var getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributes?
        /// Retrieves attributes within a facet that are associated with an object.
        public var getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributes?
        /// Retrieves metadata about an object.
        public var getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformation?
        /// Lists indices attached to an object.
        public var listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndices?
        /// Returns a paginated list of all the incoming [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinks?
        /// Lists objects attached to the specified index.
        public var listIndex: CloudDirectoryClientTypes.BatchListIndex?
        /// Lists all attributes that are associated with an object.
        public var listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributes?
        /// Returns a paginated list of child objects that are associated with a given object.
        public var listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildren?
        /// Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects. For more information about objects, see [Directory Structure](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directorystructure.html).
        public var listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPaths?
        /// Lists parent objects that are associated with a given object in pagination fashion.
        public var listObjectParents: CloudDirectoryClientTypes.BatchListObjectParents?
        /// Returns policies attached to an object in pagination fashion.
        public var listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPolicies?
        /// Returns a paginated list of all the outgoing [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinks?
        /// Returns all of the ObjectIdentifiers to which a given policy is attached.
        public var listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachments?
        /// Lists all policies from the root of the [Directory] to the object specified. If there are no policies present, an empty list is returned. If policies are present, and if some objects don't have the policies attached, it returns the ObjectIdentifier for such objects. If policies are present, it returns ObjectIdentifier, policyId, and policyType. Paths that don't lead to the root from the target object are ignored. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
        public var lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicy?

        public init(
            getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributes? = nil,
            getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributes? = nil,
            getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformation? = nil,
            listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndices? = nil,
            listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinks? = nil,
            listIndex: CloudDirectoryClientTypes.BatchListIndex? = nil,
            listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributes? = nil,
            listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildren? = nil,
            listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPaths? = nil,
            listObjectParents: CloudDirectoryClientTypes.BatchListObjectParents? = nil,
            listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPolicies? = nil,
            listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinks? = nil,
            listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachments? = nil,
            lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicy? = nil
        )
        {
            self.getLinkAttributes = getLinkAttributes
            self.getObjectAttributes = getObjectAttributes
            self.getObjectInformation = getObjectInformation
            self.listAttachedIndices = listAttachedIndices
            self.listIncomingTypedLinks = listIncomingTypedLinks
            self.listIndex = listIndex
            self.listObjectAttributes = listObjectAttributes
            self.listObjectChildren = listObjectChildren
            self.listObjectParentPaths = listObjectParentPaths
            self.listObjectParents = listObjectParents
            self.listObjectPolicies = listObjectPolicies
            self.listOutgoingTypedLinks = listOutgoingTypedLinks
            self.listPolicyAttachments = listPolicyAttachments
            self.lookupPolicy = lookupPolicy
        }
    }
}

public struct BatchReadInput: Swift.Sendable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A list of operations that are part of the batch.
    /// This member is required.
    public var operations: [CloudDirectoryClientTypes.BatchReadOperation]?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        operations: [CloudDirectoryClientTypes.BatchReadOperation]? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.operations = operations
    }
}

extension CloudDirectoryClientTypes {

    public enum BatchReadExceptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdeniedexception
        case cannotlistparentofrootexception
        case directorynotenabledexception
        case facetvalidationexception
        case internalserviceexception
        case invalidarnexception
        case invalidnexttokenexception
        case limitexceededexception
        case notindexexception
        case notnodeexception
        case notpolicyexception
        case resourcenotfoundexception
        case validationexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchReadExceptionType] {
            return [
                .accessdeniedexception,
                .cannotlistparentofrootexception,
                .directorynotenabledexception,
                .facetvalidationexception,
                .internalserviceexception,
                .invalidarnexception,
                .invalidnexttokenexception,
                .limitexceededexception,
                .notindexexception,
                .notnodeexception,
                .notpolicyexception,
                .resourcenotfoundexception,
                .validationexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .cannotlistparentofrootexception: return "CannotListParentOfRootException"
            case .directorynotenabledexception: return "DirectoryNotEnabledException"
            case .facetvalidationexception: return "FacetValidationException"
            case .internalserviceexception: return "InternalServiceException"
            case .invalidarnexception: return "InvalidArnException"
            case .invalidnexttokenexception: return "InvalidNextTokenException"
            case .limitexceededexception: return "LimitExceededException"
            case .notindexexception: return "NotIndexException"
            case .notnodeexception: return "NotNodeException"
            case .notpolicyexception: return "NotPolicyException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .validationexception: return "ValidationException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudDirectoryClientTypes {

    /// The batch read exception structure, which contains the exception type and message.
    public struct BatchReadException: Swift.Sendable {
        /// An exception message that is associated with the failure.
        public var message: Swift.String?
        /// A type of exception, such as InvalidArnException.
        public var type: CloudDirectoryClientTypes.BatchReadExceptionType?

        public init(
            message: Swift.String? = nil,
            type: CloudDirectoryClientTypes.BatchReadExceptionType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [GetLinkAttributes] response operation.
    public struct BatchGetLinkAttributesResponse: Swift.Sendable {
        /// The attributes that are associated with the typed link.
        public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

        public init(
            attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        )
        {
            self.attributes = attributes
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [GetObjectAttributes] response operation.
    public struct BatchGetObjectAttributesResponse: Swift.Sendable {
        /// The attribute values that are associated with an object.
        public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

        public init(
            attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        )
        {
            self.attributes = attributes
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [GetObjectInformation] response operation.
    public struct BatchGetObjectInformationResponse: Swift.Sendable {
        /// The ObjectIdentifier of the specified object.
        public var objectIdentifier: Swift.String?
        /// The facets attached to the specified object.
        public var schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?

        public init(
            objectIdentifier: Swift.String? = nil,
            schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
            self.schemaFacets = schemaFacets
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents an index and an attached object.
    public struct IndexAttachment: Swift.Sendable {
        /// The indexed attribute values.
        public var indexedAttributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// In response to [ListIndex], the ObjectIdentifier of the object attached to the index. In response to [ListAttachedIndices], the ObjectIdentifier of the index attached to the object. This field will always contain the ObjectIdentifier of the object on the opposite side of the attachment specified in the query.
        public var objectIdentifier: Swift.String?

        public init(
            indexedAttributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            objectIdentifier: Swift.String? = nil
        )
        {
            self.indexedAttributes = indexedAttributes
            self.objectIdentifier = objectIdentifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListAttachedIndices] response operation.
    public struct BatchListAttachedIndicesResponse: Swift.Sendable {
        /// The indices attached to the specified object.
        public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.indexAttachments = indexAttachments
            self.nextToken = nextToken
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListIncomingTypedLinks] response operation.
    public struct BatchListIncomingTypedLinksResponse: Swift.Sendable {
        /// Returns one or more typed link specifiers as output.
        public var linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.linkSpecifiers = linkSpecifiers
            self.nextToken = nextToken
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListIndex] response operation.
    public struct BatchListIndexResponse: Swift.Sendable {
        /// The objects and indexed values attached to the index.
        public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.indexAttachments = indexAttachments
            self.nextToken = nextToken
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListObjectAttributes] response operation.
    public struct BatchListObjectAttributesResponse: Swift.Sendable {
        /// The attributes map that is associated with the object. AttributeArn is the key; attribute value is the value.
        public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.nextToken = nextToken
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListObjectChildren] response operation.
    public struct BatchListObjectChildrenResponse: Swift.Sendable {
        /// The children structure, which is a map with the key as the LinkName and ObjectIdentifier as the value.
        public var children: [Swift.String: Swift.String]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            children: [Swift.String: Swift.String]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.children = children
            self.nextToken = nextToken
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Returns the path to the ObjectIdentifiers that is associated with the directory.
    public struct PathToObjectIdentifiers: Swift.Sendable {
        /// Lists ObjectIdentifiers starting from directory root to the object in the request.
        public var objectIdentifiers: [Swift.String]?
        /// The path that is used to identify the object starting from directory root.
        public var path: Swift.String?

        public init(
            objectIdentifiers: [Swift.String]? = nil,
            path: Swift.String? = nil
        )
        {
            self.objectIdentifiers = objectIdentifiers
            self.path = path
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListObjectParentPaths] response operation.
    public struct BatchListObjectParentPathsResponse: Swift.Sendable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Returns the path to the ObjectIdentifiers that are associated with the directory.
        public var pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]?

        public init(
            nextToken: Swift.String? = nil,
            pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
        )
        {
            self.nextToken = nextToken
            self.pathToObjectIdentifiersList = pathToObjectIdentifiersList
        }
    }
}

extension CloudDirectoryClientTypes {

    /// A pair of ObjectIdentifier and LinkName.
    public struct ObjectIdentifierAndLinkNameTuple: Swift.Sendable {
        /// The name of the link between the parent and the child object.
        public var linkName: Swift.String?
        /// The ID that is associated with the object.
        public var objectIdentifier: Swift.String?

        public init(
            linkName: Swift.String? = nil,
            objectIdentifier: Swift.String? = nil
        )
        {
            self.linkName = linkName
            self.objectIdentifier = objectIdentifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListObjectParents] response operation.
    public struct BatchListObjectParentsResponse: Swift.Sendable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Returns a list of parent reference and LinkName Tuples.
        public var parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]?

        public init(
            nextToken: Swift.String? = nil,
            parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil
        )
        {
            self.nextToken = nextToken
            self.parentLinks = parentLinks
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListObjectPolicies] response operation.
    public struct BatchListObjectPoliciesResponse: Swift.Sendable {
        /// A list of policy ObjectIdentifiers, that are attached to the object.
        public var attachedPolicyIds: [Swift.String]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            attachedPolicyIds: [Swift.String]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.attachedPolicyIds = attachedPolicyIds
            self.nextToken = nextToken
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListOutgoingTypedLinks] response operation.
    public struct BatchListOutgoingTypedLinksResponse: Swift.Sendable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Returns a typed link specifier as output.
        public var typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?

        public init(
            nextToken: Swift.String? = nil,
            typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        )
        {
            self.nextToken = nextToken
            self.typedLinkSpecifiers = typedLinkSpecifiers
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [ListPolicyAttachments] response operation.
    public struct BatchListPolicyAttachmentsResponse: Swift.Sendable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// A list of ObjectIdentifiers to which the policy is attached.
        public var objectIdentifiers: [Swift.String]?

        public init(
            nextToken: Swift.String? = nil,
            objectIdentifiers: [Swift.String]? = nil
        )
        {
            self.nextToken = nextToken
            self.objectIdentifiers = objectIdentifiers
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Contains the PolicyType, PolicyId, and the ObjectIdentifier to which it is attached. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
    public struct PolicyAttachment: Swift.Sendable {
        /// The ObjectIdentifier that is associated with PolicyAttachment.
        public var objectIdentifier: Swift.String?
        /// The ID of PolicyAttachment.
        public var policyId: Swift.String?
        /// The type of policy that can be associated with PolicyAttachment.
        public var policyType: Swift.String?

        public init(
            objectIdentifier: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyType: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
            self.policyId = policyId
            self.policyType = policyType
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Used when a regular object exists in a [Directory] and you want to find all of the policies that are associated with that object and the parent to that object.
    public struct PolicyToPath: Swift.Sendable {
        /// The path that is referenced from the root.
        public var path: Swift.String?
        /// List of policy objects.
        public var policies: [CloudDirectoryClientTypes.PolicyAttachment]?

        public init(
            path: Swift.String? = nil,
            policies: [CloudDirectoryClientTypes.PolicyAttachment]? = nil
        )
        {
            self.path = path
            self.policies = policies
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [LookupPolicy] response operation.
    public struct BatchLookupPolicyResponse: Swift.Sendable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Provides list of path to policies. Policies contain PolicyId, ObjectIdentifier, and PolicyType. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
        public var policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]?

        public init(
            nextToken: Swift.String? = nil,
            policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]? = nil
        )
        {
            self.nextToken = nextToken
            self.policyToPathList = policyToPathList
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a BatchRead success response operation.
    public struct BatchReadSuccessfulResponse: Swift.Sendable {
        /// The list of attributes to retrieve from the typed link.
        public var getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributesResponse?
        /// Retrieves attributes within a facet that are associated with an object.
        public var getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributesResponse?
        /// Retrieves metadata about an object.
        public var getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformationResponse?
        /// Lists indices attached to an object.
        public var listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndicesResponse?
        /// Returns a paginated list of all the incoming [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse?
        /// Lists objects attached to the specified index.
        public var listIndex: CloudDirectoryClientTypes.BatchListIndexResponse?
        /// Lists all attributes that are associated with an object.
        public var listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributesResponse?
        /// Returns a paginated list of child objects that are associated with a given object.
        public var listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildrenResponse?
        /// Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects. For more information about objects, see [Directory Structure](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directorystructure.html).
        public var listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPathsResponse?
        /// The list of parent objects to retrieve.
        public var listObjectParents: CloudDirectoryClientTypes.BatchListObjectParentsResponse?
        /// Returns policies attached to an object in pagination fashion.
        public var listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPoliciesResponse?
        /// Returns a paginated list of all the outgoing [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse?
        /// Returns all of the ObjectIdentifiers to which a given policy is attached.
        public var listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse?
        /// Lists all policies from the root of the [Directory] to the object specified. If there are no policies present, an empty list is returned. If policies are present, and if some objects don't have the policies attached, it returns the ObjectIdentifier for such objects. If policies are present, it returns ObjectIdentifier, policyId, and policyType. Paths that don't lead to the root from the target object are ignored. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
        public var lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicyResponse?

        public init(
            getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributesResponse? = nil,
            getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributesResponse? = nil,
            getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformationResponse? = nil,
            listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndicesResponse? = nil,
            listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse? = nil,
            listIndex: CloudDirectoryClientTypes.BatchListIndexResponse? = nil,
            listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributesResponse? = nil,
            listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildrenResponse? = nil,
            listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPathsResponse? = nil,
            listObjectParents: CloudDirectoryClientTypes.BatchListObjectParentsResponse? = nil,
            listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPoliciesResponse? = nil,
            listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse? = nil,
            listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse? = nil,
            lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicyResponse? = nil
        )
        {
            self.getLinkAttributes = getLinkAttributes
            self.getObjectAttributes = getObjectAttributes
            self.getObjectInformation = getObjectInformation
            self.listAttachedIndices = listAttachedIndices
            self.listIncomingTypedLinks = listIncomingTypedLinks
            self.listIndex = listIndex
            self.listObjectAttributes = listObjectAttributes
            self.listObjectChildren = listObjectChildren
            self.listObjectParentPaths = listObjectParentPaths
            self.listObjectParents = listObjectParents
            self.listObjectPolicies = listObjectPolicies
            self.listOutgoingTypedLinks = listOutgoingTypedLinks
            self.listPolicyAttachments = listPolicyAttachments
            self.lookupPolicy = lookupPolicy
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a BatchRead response operation.
    public struct BatchReadOperationResponse: Swift.Sendable {
        /// Identifies which operation in a batch has failed.
        public var exceptionResponse: CloudDirectoryClientTypes.BatchReadException?
        /// Identifies which operation in a batch has succeeded.
        public var successfulResponse: CloudDirectoryClientTypes.BatchReadSuccessfulResponse?

        public init(
            exceptionResponse: CloudDirectoryClientTypes.BatchReadException? = nil,
            successfulResponse: CloudDirectoryClientTypes.BatchReadSuccessfulResponse? = nil
        )
        {
            self.exceptionResponse = exceptionResponse
            self.successfulResponse = successfulResponse
        }
    }
}

public struct BatchReadOutput: Swift.Sendable {
    /// A list of all the responses for each batch read.
    public var responses: [CloudDirectoryClientTypes.BatchReadOperationResponse]?

    public init(
        responses: [CloudDirectoryClientTypes.BatchReadOperationResponse]? = nil
    )
    {
        self.responses = responses
    }
}

extension CloudDirectoryClientTypes {

    public enum BatchWriteExceptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdeniedexception
        case directorynotenabledexception
        case facetvalidationexception
        case indexedattributemissingexception
        case internalserviceexception
        case invalidarnexception
        case invalidattachmentexception
        case limitexceededexception
        case linknamealreadyinuseexception
        case notindexexception
        case notnodeexception
        case notpolicyexception
        case objectalreadydetachedexception
        case objectnotdetachedexception
        case resourcenotfoundexception
        case stillcontainslinksexception
        case unsupportedindextypeexception
        case validationexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchWriteExceptionType] {
            return [
                .accessdeniedexception,
                .directorynotenabledexception,
                .facetvalidationexception,
                .indexedattributemissingexception,
                .internalserviceexception,
                .invalidarnexception,
                .invalidattachmentexception,
                .limitexceededexception,
                .linknamealreadyinuseexception,
                .notindexexception,
                .notnodeexception,
                .notpolicyexception,
                .objectalreadydetachedexception,
                .objectnotdetachedexception,
                .resourcenotfoundexception,
                .stillcontainslinksexception,
                .unsupportedindextypeexception,
                .validationexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .directorynotenabledexception: return "DirectoryNotEnabledException"
            case .facetvalidationexception: return "FacetValidationException"
            case .indexedattributemissingexception: return "IndexedAttributeMissingException"
            case .internalserviceexception: return "InternalServiceException"
            case .invalidarnexception: return "InvalidArnException"
            case .invalidattachmentexception: return "InvalidAttachmentException"
            case .limitexceededexception: return "LimitExceededException"
            case .linknamealreadyinuseexception: return "LinkNameAlreadyInUseException"
            case .notindexexception: return "NotIndexException"
            case .notnodeexception: return "NotNodeException"
            case .notpolicyexception: return "NotPolicyException"
            case .objectalreadydetachedexception: return "ObjectAlreadyDetachedException"
            case .objectnotdetachedexception: return "ObjectNotDetachedException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .stillcontainslinksexception: return "StillContainsLinksException"
            case .unsupportedindextypeexception: return "UnsupportedIndexTypeException"
            case .validationexception: return "ValidationException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// A BatchWrite exception has occurred.
public struct BatchWriteException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var index: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: CloudDirectoryClientTypes.BatchWriteExceptionType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchWriteException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        index: Swift.Int = 0,
        message: Swift.String? = nil,
        type: CloudDirectoryClientTypes.BatchWriteExceptionType? = nil
    )
    {
        self.properties.index = index
        self.properties.message = message
        self.properties.type = type
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a batch add facet to object operation.
    public struct BatchAddFacetToObject: Swift.Sendable {
        /// The attributes to set on the object.
        /// This member is required.
        public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// A reference to the object being mutated.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Represents the facet being added to the object.
        /// This member is required.
        public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

        public init(
            objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
        )
        {
            self.objectAttributeList = objectAttributeList
            self.objectReference = objectReference
            self.schemaFacet = schemaFacet
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of an [AttachObject] operation.
    public struct BatchAttachObject: Swift.Sendable {
        /// The child object reference that is to be attached to the object.
        /// This member is required.
        public var childReference: CloudDirectoryClientTypes.ObjectReference?
        /// The name of the link.
        /// This member is required.
        public var linkName: Swift.String?
        /// The parent object reference.
        /// This member is required.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            childReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            linkName: Swift.String? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.childReference = childReference
            self.linkName = linkName
            self.parentReference = parentReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Attaches a policy object to a regular object inside a [BatchRead] operation. For more information, see [AttachPolicy] and [BatchReadRequest$Operations].
    public struct BatchAttachPolicy: Swift.Sendable {
        /// The reference that identifies the object to which the policy will be attached.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// The reference that is associated with the policy object.
        /// This member is required.
        public var policyReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
            self.policyReference = policyReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Attaches the specified object to the specified index inside a [BatchRead] operation. For more information, see [AttachToIndex] and [BatchReadRequest$Operations].
    public struct BatchAttachToIndex: Swift.Sendable {
        /// A reference to the index that you are attaching the object to.
        /// This member is required.
        public var indexReference: CloudDirectoryClientTypes.ObjectReference?
        /// A reference to the object that you are attaching to the index.
        /// This member is required.
        public var targetReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.indexReference = indexReference
            self.targetReference = targetReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Attaches a typed link to a specified source and target object inside a [BatchRead] operation. For more information, see [AttachTypedLink] and [BatchReadRequest$Operations].
    public struct BatchAttachTypedLink: Swift.Sendable {
        /// A set of attributes that are associated with the typed link.
        /// This member is required.
        public var attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]?
        /// Identifies the source object that the typed link will attach to.
        /// This member is required.
        public var sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the target object that the typed link will attach to.
        /// This member is required.
        public var targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the typed link facet that is associated with the typed link.
        /// This member is required.
        public var typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?

        public init(
            attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]? = nil,
            sourceObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil
        )
        {
            self.attributes = attributes
            self.sourceObjectReference = sourceObjectReference
            self.targetObjectReference = targetObjectReference
            self.typedLinkFacet = typedLinkFacet
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Creates an index object inside of a [BatchRead] operation. For more information, see [CreateIndex] and [BatchReadRequest$Operations].
    public struct BatchCreateIndex: Swift.Sendable {
        /// The batch reference name. See [Transaction Support](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html) for more information.
        public var batchReferenceName: Swift.String?
        /// Indicates whether the attribute that is being indexed has unique values or not.
        /// This member is required.
        public var isUnique: Swift.Bool
        /// The name of the link between the parent object and the index object.
        public var linkName: Swift.String?
        /// Specifies the attributes that should be indexed on. Currently only a single attribute is supported.
        /// This member is required.
        public var orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]?
        /// A reference to the parent object that contains the index object.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            batchReferenceName: Swift.String? = nil,
            isUnique: Swift.Bool = false,
            linkName: Swift.String? = nil,
            orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.batchReferenceName = batchReferenceName
            self.isUnique = isUnique
            self.linkName = linkName
            self.orderedIndexedAttributeList = orderedIndexedAttributeList
            self.parentReference = parentReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [CreateObject] operation.
    public struct BatchCreateObject: Swift.Sendable {
        /// The batch reference name. See [Transaction Support](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html) for more information.
        public var batchReferenceName: Swift.String?
        /// The name of the link.
        public var linkName: Swift.String?
        /// An attribute map, which contains an attribute ARN as the key and attribute value as the map value.
        /// This member is required.
        public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// If specified, the parent reference to which this object will be attached.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?
        /// A list of FacetArns that will be associated with the object. For more information, see [arns].
        /// This member is required.
        public var schemaFacet: [CloudDirectoryClientTypes.SchemaFacet]?

        public init(
            batchReferenceName: Swift.String? = nil,
            linkName: Swift.String? = nil,
            objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: [CloudDirectoryClientTypes.SchemaFacet]? = nil
        )
        {
            self.batchReferenceName = batchReferenceName
            self.linkName = linkName
            self.objectAttributeList = objectAttributeList
            self.parentReference = parentReference
            self.schemaFacet = schemaFacet
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [DeleteObject] operation.
    public struct BatchDeleteObject: Swift.Sendable {
        /// The reference that identifies the object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Detaches the specified object from the specified index inside a [BatchRead] operation. For more information, see [DetachFromIndex] and [BatchReadRequest$Operations].
    public struct BatchDetachFromIndex: Swift.Sendable {
        /// A reference to the index object.
        /// This member is required.
        public var indexReference: CloudDirectoryClientTypes.ObjectReference?
        /// A reference to the object being detached from the index.
        /// This member is required.
        public var targetReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.indexReference = indexReference
            self.targetReference = targetReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [DetachObject] operation.
    public struct BatchDetachObject: Swift.Sendable {
        /// The batch reference name. See [Transaction Support](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html) for more information.
        public var batchReferenceName: Swift.String?
        /// The name of the link.
        /// This member is required.
        public var linkName: Swift.String?
        /// Parent reference from which the object with the specified link name is detached.
        /// This member is required.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            batchReferenceName: Swift.String? = nil,
            linkName: Swift.String? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.batchReferenceName = batchReferenceName
            self.linkName = linkName
            self.parentReference = parentReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Detaches the specified policy from the specified directory inside a [BatchWrite] operation. For more information, see [DetachPolicy] and [BatchWriteRequest$Operations].
    public struct BatchDetachPolicy: Swift.Sendable {
        /// Reference that identifies the object whose policy object will be detached.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Reference that identifies the policy object.
        /// This member is required.
        public var policyReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
            self.policyReference = policyReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Detaches a typed link from a specified source and target object inside a [BatchRead] operation. For more information, see [DetachTypedLink] and [BatchReadRequest$Operations].
    public struct BatchDetachTypedLink: Swift.Sendable {
        /// Used to accept a typed link specifier as input.
        /// This member is required.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init(
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// A batch operation to remove a facet from an object.
    public struct BatchRemoveFacetFromObject: Swift.Sendable {
        /// A reference to the object whose facet will be removed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// The facet to remove from the object.
        /// This member is required.
        public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
        )
        {
            self.objectReference = objectReference
            self.schemaFacet = schemaFacet
        }
    }
}

extension CloudDirectoryClientTypes {

    public enum UpdateActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createOrUpdate
        case delete
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateActionType] {
            return [
                .createOrUpdate,
                .delete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createOrUpdate: return "CREATE_OR_UPDATE"
            case .delete: return "DELETE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudDirectoryClientTypes {

    /// The action to take on a typed link attribute value. Updates are only supported for attributes which don’t contribute to link identity.
    public struct LinkAttributeAction: Swift.Sendable {
        /// A type that can be either UPDATE_OR_CREATE or DELETE.
        public var attributeActionType: CloudDirectoryClientTypes.UpdateActionType?
        /// The value that you want to update to.
        public var attributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            attributeActionType: CloudDirectoryClientTypes.UpdateActionType? = nil,
            attributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.attributeActionType = attributeActionType
            self.attributeUpdateValue = attributeUpdateValue
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Structure that contains attribute update information.
    public struct LinkAttributeUpdate: Swift.Sendable {
        /// The action to perform as part of the attribute update.
        public var attributeAction: CloudDirectoryClientTypes.LinkAttributeAction?
        /// The key of the attribute being updated.
        public var attributeKey: CloudDirectoryClientTypes.AttributeKey?

        public init(
            attributeAction: CloudDirectoryClientTypes.LinkAttributeAction? = nil,
            attributeKey: CloudDirectoryClientTypes.AttributeKey? = nil
        )
        {
            self.attributeAction = attributeAction
            self.attributeKey = attributeKey
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Updates a given typed link’s attributes inside a [BatchRead] operation. Attributes to be updated must not contribute to the typed link’s identity, as defined by its IdentityAttributeOrder. For more information, see [UpdateLinkAttributes] and [BatchReadRequest$Operations].
    public struct BatchUpdateLinkAttributes: Swift.Sendable {
        /// The attributes update structure.
        /// This member is required.
        public var attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]?
        /// Allows a typed link specifier to be accepted as input.
        /// This member is required.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init(
            attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil,
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.attributeUpdates = attributeUpdates
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// The action to take on the object attribute.
    public struct ObjectAttributeAction: Swift.Sendable {
        /// A type that can be either Update or Delete.
        public var objectAttributeActionType: CloudDirectoryClientTypes.UpdateActionType?
        /// The value that you want to update to.
        public var objectAttributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            objectAttributeActionType: CloudDirectoryClientTypes.UpdateActionType? = nil,
            objectAttributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.objectAttributeActionType = objectAttributeActionType
            self.objectAttributeUpdateValue = objectAttributeUpdateValue
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Structure that contains attribute update information.
    public struct ObjectAttributeUpdate: Swift.Sendable {
        /// The action to perform as part of the attribute update.
        public var objectAttributeAction: CloudDirectoryClientTypes.ObjectAttributeAction?
        /// The key of the attribute being updated.
        public var objectAttributeKey: CloudDirectoryClientTypes.AttributeKey?

        public init(
            objectAttributeAction: CloudDirectoryClientTypes.ObjectAttributeAction? = nil,
            objectAttributeKey: CloudDirectoryClientTypes.AttributeKey? = nil
        )
        {
            self.objectAttributeAction = objectAttributeAction
            self.objectAttributeKey = objectAttributeKey
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a BatchUpdate operation.
    public struct BatchUpdateObjectAttributes: Swift.Sendable {
        /// Attributes update structure.
        /// This member is required.
        public var attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]?
        /// Reference that identifies the object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.attributeUpdates = attributeUpdates
            self.objectReference = objectReference
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a BatchWrite operation.
    public struct BatchWriteOperation: Swift.Sendable {
        /// A batch operation that adds a facet to an object.
        public var addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObject?
        /// Attaches an object to a [Directory].
        public var attachObject: CloudDirectoryClientTypes.BatchAttachObject?
        /// Attaches a policy object to a regular object. An object can have a limited number of attached policies.
        public var attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicy?
        /// Attaches the specified object to the specified index.
        public var attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndex?
        /// Attaches a typed link to a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLink?
        /// Creates an index object. See [Indexing and search](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/indexing_search.htm) for more information.
        public var createIndex: CloudDirectoryClientTypes.BatchCreateIndex?
        /// Creates an object.
        public var createObject: CloudDirectoryClientTypes.BatchCreateObject?
        /// Deletes an object in a [Directory].
        public var deleteObject: CloudDirectoryClientTypes.BatchDeleteObject?
        /// Detaches the specified object from the specified index.
        public var detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndex?
        /// Detaches an object from a [Directory].
        public var detachObject: CloudDirectoryClientTypes.BatchDetachObject?
        /// Detaches a policy from a [Directory].
        public var detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicy?
        /// Detaches a typed link from a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLink?
        /// A batch operation that removes a facet from an object.
        public var removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObject?
        /// Updates a given object's attributes.
        public var updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributes?
        /// Updates a given object's attributes.
        public var updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributes?

        public init(
            addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObject? = nil,
            attachObject: CloudDirectoryClientTypes.BatchAttachObject? = nil,
            attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicy? = nil,
            attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndex? = nil,
            attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLink? = nil,
            createIndex: CloudDirectoryClientTypes.BatchCreateIndex? = nil,
            createObject: CloudDirectoryClientTypes.BatchCreateObject? = nil,
            deleteObject: CloudDirectoryClientTypes.BatchDeleteObject? = nil,
            detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndex? = nil,
            detachObject: CloudDirectoryClientTypes.BatchDetachObject? = nil,
            detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicy? = nil,
            detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLink? = nil,
            removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObject? = nil,
            updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributes? = nil,
            updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributes? = nil
        )
        {
            self.addFacetToObject = addFacetToObject
            self.attachObject = attachObject
            self.attachPolicy = attachPolicy
            self.attachToIndex = attachToIndex
            self.attachTypedLink = attachTypedLink
            self.createIndex = createIndex
            self.createObject = createObject
            self.deleteObject = deleteObject
            self.detachFromIndex = detachFromIndex
            self.detachObject = detachObject
            self.detachPolicy = detachPolicy
            self.detachTypedLink = detachTypedLink
            self.removeFacetFromObject = removeFacetFromObject
            self.updateLinkAttributes = updateLinkAttributes
            self.updateObjectAttributes = updateObjectAttributes
        }
    }
}

public struct BatchWriteInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A list of operations that are part of the batch.
    /// This member is required.
    public var operations: [CloudDirectoryClientTypes.BatchWriteOperation]?

    public init(
        directoryArn: Swift.String? = nil,
        operations: [CloudDirectoryClientTypes.BatchWriteOperation]? = nil
    )
    {
        self.directoryArn = directoryArn
        self.operations = operations
    }
}

extension CloudDirectoryClientTypes {

    /// The result of a batch add facet to object operation.
    public struct BatchAddFacetToObjectResponse: Swift.Sendable {

        public init() { }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output batch [AttachObject] response operation.
    public struct BatchAttachObjectResponse: Swift.Sendable {
        /// The ObjectIdentifier of the object that has been attached.
        public var attachedObjectIdentifier: Swift.String?

        public init(
            attachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.attachedObjectIdentifier = attachedObjectIdentifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of an [AttachPolicy] response operation.
    public struct BatchAttachPolicyResponse: Swift.Sendable {

        public init() { }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [AttachToIndex] response operation.
    public struct BatchAttachToIndexResponse: Swift.Sendable {
        /// The ObjectIdentifier of the object that was attached to the index.
        public var attachedObjectIdentifier: Swift.String?

        public init(
            attachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.attachedObjectIdentifier = attachedObjectIdentifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [AttachTypedLink] response operation.
    public struct BatchAttachTypedLinkResponse: Swift.Sendable {
        /// Returns a typed link specifier as output.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init(
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [CreateIndex] response operation.
    public struct BatchCreateIndexResponse: Swift.Sendable {
        /// The ObjectIdentifier of the index created by this operation.
        public var objectIdentifier: Swift.String?

        public init(
            objectIdentifier: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [CreateObject] response operation.
    public struct BatchCreateObjectResponse: Swift.Sendable {
        /// The ID that is associated with the object.
        public var objectIdentifier: Swift.String?

        public init(
            objectIdentifier: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [DeleteObject] response operation.
    public struct BatchDeleteObjectResponse: Swift.Sendable {

        public init() { }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [DetachFromIndex] response operation.
    public struct BatchDetachFromIndexResponse: Swift.Sendable {
        /// The ObjectIdentifier of the object that was detached from the index.
        public var detachedObjectIdentifier: Swift.String?

        public init(
            detachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.detachedObjectIdentifier = detachedObjectIdentifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [DetachObject] response operation.
    public struct BatchDetachObjectResponse: Swift.Sendable {
        /// The ObjectIdentifier of the detached object.
        public var detachedObjectIdentifier: Swift.String?

        public init(
            detachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.detachedObjectIdentifier = detachedObjectIdentifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [DetachPolicy] response operation.
    public struct BatchDetachPolicyResponse: Swift.Sendable {

        public init() { }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [DetachTypedLink] response operation.
    public struct BatchDetachTypedLinkResponse: Swift.Sendable {

        public init() { }
    }
}

extension CloudDirectoryClientTypes {

    /// An empty result that represents success.
    public struct BatchRemoveFacetFromObjectResponse: Swift.Sendable {

        public init() { }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a [UpdateLinkAttributes] response operation.
    public struct BatchUpdateLinkAttributesResponse: Swift.Sendable {

        public init() { }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a BatchUpdate response operation.
    public struct BatchUpdateObjectAttributesResponse: Swift.Sendable {
        /// ID that is associated with the object.
        public var objectIdentifier: Swift.String?

        public init(
            objectIdentifier: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Represents the output of a BatchWrite response operation.
    public struct BatchWriteOperationResponse: Swift.Sendable {
        /// The result of an add facet to object batch operation.
        public var addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObjectResponse?
        /// Attaches an object to a [Directory].
        public var attachObject: CloudDirectoryClientTypes.BatchAttachObjectResponse?
        /// Attaches a policy object to a regular object. An object can have a limited number of attached policies.
        public var attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicyResponse?
        /// Attaches the specified object to the specified index.
        public var attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndexResponse?
        /// Attaches a typed link to a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLinkResponse?
        /// Creates an index object. See [Indexing and search](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/indexing_search.htm) for more information.
        public var createIndex: CloudDirectoryClientTypes.BatchCreateIndexResponse?
        /// Creates an object in a [Directory].
        public var createObject: CloudDirectoryClientTypes.BatchCreateObjectResponse?
        /// Deletes an object in a [Directory].
        public var deleteObject: CloudDirectoryClientTypes.BatchDeleteObjectResponse?
        /// Detaches the specified object from the specified index.
        public var detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndexResponse?
        /// Detaches an object from a [Directory].
        public var detachObject: CloudDirectoryClientTypes.BatchDetachObjectResponse?
        /// Detaches a policy from a [Directory].
        public var detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicyResponse?
        /// Detaches a typed link from a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLinkResponse?
        /// The result of a batch remove facet from object operation.
        public var removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse?
        /// Represents the output of a BatchWrite response operation.
        public var updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse?
        /// Updates a given object’s attributes.
        public var updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse?

        public init(
            addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObjectResponse? = nil,
            attachObject: CloudDirectoryClientTypes.BatchAttachObjectResponse? = nil,
            attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicyResponse? = nil,
            attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndexResponse? = nil,
            attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLinkResponse? = nil,
            createIndex: CloudDirectoryClientTypes.BatchCreateIndexResponse? = nil,
            createObject: CloudDirectoryClientTypes.BatchCreateObjectResponse? = nil,
            deleteObject: CloudDirectoryClientTypes.BatchDeleteObjectResponse? = nil,
            detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndexResponse? = nil,
            detachObject: CloudDirectoryClientTypes.BatchDetachObjectResponse? = nil,
            detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicyResponse? = nil,
            detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLinkResponse? = nil,
            removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse? = nil,
            updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse? = nil,
            updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse? = nil
        )
        {
            self.addFacetToObject = addFacetToObject
            self.attachObject = attachObject
            self.attachPolicy = attachPolicy
            self.attachToIndex = attachToIndex
            self.attachTypedLink = attachTypedLink
            self.createIndex = createIndex
            self.createObject = createObject
            self.deleteObject = deleteObject
            self.detachFromIndex = detachFromIndex
            self.detachObject = detachObject
            self.detachPolicy = detachPolicy
            self.detachTypedLink = detachTypedLink
            self.removeFacetFromObject = removeFacetFromObject
            self.updateLinkAttributes = updateLinkAttributes
            self.updateObjectAttributes = updateObjectAttributes
        }
    }
}

public struct BatchWriteOutput: Swift.Sendable {
    /// A list of all the responses for each batch write.
    public var responses: [CloudDirectoryClientTypes.BatchWriteOperationResponse]?

    public init(
        responses: [CloudDirectoryClientTypes.BatchWriteOperationResponse]? = nil
    )
    {
        self.responses = responses
    }
}

/// Indicates that a [Directory] could not be created due to a naming conflict. Choose a different name and try again.
public struct DirectoryAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateDirectoryInput: Swift.Sendable {
    /// The name of the [Directory]. Should be unique per account, per region.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the published schema that will be copied into the data [Directory]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

public struct CreateDirectoryOutput: Swift.Sendable {
    /// The ARN of the published schema in the [Directory]. Once a published schema is copied into the directory, it has its own ARN, which is referred to applied schema ARN. For more information, see [arns].
    /// This member is required.
    public var appliedSchemaArn: Swift.String?
    /// The ARN that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The name of the [Directory].
    /// This member is required.
    public var name: Swift.String?
    /// The root object node of the created directory.
    /// This member is required.
    public var objectIdentifier: Swift.String?

    public init(
        appliedSchemaArn: Swift.String? = nil,
        directoryArn: Swift.String? = nil,
        name: Swift.String? = nil,
        objectIdentifier: Swift.String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
        self.directoryArn = directoryArn
        self.name = name
        self.objectIdentifier = objectIdentifier
    }
}

/// A facet with the same name already exists.
public struct FacetAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FacetAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Occurs when any of the rule parameter keys or values are invalid.
public struct InvalidRuleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRuleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudDirectoryClientTypes {

    public enum RuleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binaryLength
        case numberComparison
        case stringFromSet
        case stringLength
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleType] {
            return [
                .binaryLength,
                .numberComparison,
                .stringFromSet,
                .stringLength
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binaryLength: return "BINARY_LENGTH"
            case .numberComparison: return "NUMBER_COMPARISON"
            case .stringFromSet: return "STRING_FROM_SET"
            case .stringLength: return "STRING_LENGTH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Contains an Amazon Resource Name (ARN) and parameters that are associated with the rule.
    public struct Rule: Swift.Sendable {
        /// The minimum and maximum parameters that are associated with the rule.
        public var parameters: [Swift.String: Swift.String]?
        /// The type of attribute validation rule.
        public var type: CloudDirectoryClientTypes.RuleType?

        public init(
            parameters: [Swift.String: Swift.String]? = nil,
            type: CloudDirectoryClientTypes.RuleType? = nil
        )
        {
            self.parameters = parameters
            self.type = type
        }
    }
}

extension CloudDirectoryClientTypes {

    public enum FacetAttributeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binary
        case boolean
        case datetime
        case number
        case string
        case variant
        case sdkUnknown(Swift.String)

        public static var allCases: [FacetAttributeType] {
            return [
                .binary,
                .boolean,
                .datetime,
                .number,
                .string,
                .variant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binary: return "BINARY"
            case .boolean: return "BOOLEAN"
            case .datetime: return "DATETIME"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case .variant: return "VARIANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudDirectoryClientTypes {

    /// A facet attribute definition. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
    public struct FacetAttributeDefinition: Swift.Sendable {
        /// The default value of the attribute (if configured).
        public var defaultValue: CloudDirectoryClientTypes.TypedAttributeValue?
        /// Whether the attribute is mutable or not.
        public var isImmutable: Swift.Bool
        /// Validation rules attached to the attribute definition.
        public var rules: [Swift.String: CloudDirectoryClientTypes.Rule]?
        /// The type of the attribute.
        /// This member is required.
        public var type: CloudDirectoryClientTypes.FacetAttributeType?

        public init(
            defaultValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil,
            isImmutable: Swift.Bool = false,
            rules: [Swift.String: CloudDirectoryClientTypes.Rule]? = nil,
            type: CloudDirectoryClientTypes.FacetAttributeType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.isImmutable = isImmutable
            self.rules = rules
            self.type = type
        }
    }
}

extension CloudDirectoryClientTypes {

    /// The facet attribute reference that specifies the attribute definition that contains the attribute facet name and attribute name.
    public struct FacetAttributeReference: Swift.Sendable {
        /// The target attribute name that is associated with the facet reference. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        /// This member is required.
        public var targetAttributeName: Swift.String?
        /// The target facet name that is associated with the facet reference. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        /// This member is required.
        public var targetFacetName: Swift.String?

        public init(
            targetAttributeName: Swift.String? = nil,
            targetFacetName: Swift.String? = nil
        )
        {
            self.targetAttributeName = targetAttributeName
            self.targetFacetName = targetFacetName
        }
    }
}

extension CloudDirectoryClientTypes {

    public enum RequiredAttributeBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notRequired
        case requiredAlways
        case sdkUnknown(Swift.String)

        public static var allCases: [RequiredAttributeBehavior] {
            return [
                .notRequired,
                .requiredAlways
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notRequired: return "NOT_REQUIRED"
            case .requiredAlways: return "REQUIRED_ALWAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudDirectoryClientTypes {

    /// An attribute that is associated with the [Facet].
    public struct FacetAttribute: Swift.Sendable {
        /// A facet attribute consists of either a definition or a reference. This structure contains the attribute definition. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        public var attributeDefinition: CloudDirectoryClientTypes.FacetAttributeDefinition?
        /// An attribute reference that is associated with the attribute. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        public var attributeReference: CloudDirectoryClientTypes.FacetAttributeReference?
        /// The name of the facet attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The required behavior of the FacetAttribute.
        public var requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior?

        public init(
            attributeDefinition: CloudDirectoryClientTypes.FacetAttributeDefinition? = nil,
            attributeReference: CloudDirectoryClientTypes.FacetAttributeReference? = nil,
            name: Swift.String? = nil,
            requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior? = nil
        )
        {
            self.attributeDefinition = attributeDefinition
            self.attributeReference = attributeReference
            self.name = name
            self.requiredBehavior = requiredBehavior
        }
    }
}

extension CloudDirectoryClientTypes {

    public enum FacetStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [FacetStyle] {
            return [
                .dynamic,
                .static
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudDirectoryClientTypes {

    public enum ObjectType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case index
        case leafNode
        case node
        case policy
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectType] {
            return [
                .index,
                .leafNode,
                .node,
                .policy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .index: return "INDEX"
            case .leafNode: return "LEAF_NODE"
            case .node: return "NODE"
            case .policy: return "POLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFacetInput: Swift.Sendable {
    /// The attributes that are associated with the [Facet].
    public var attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    /// There are two different styles that you can define on any given facet, Static and Dynamic. For static facets, all attributes must be defined in the schema. For dynamic facets, attributes can be defined during data plane operations.
    public var facetStyle: CloudDirectoryClientTypes.FacetStyle?
    /// The name of the [Facet], which is unique for a given schema.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether a given object created from this facet is of type node, leaf node, policy or index.
    ///
    /// * Node: Can have multiple children but one parent.
    ///
    ///
    ///
    ///
    /// * Leaf node: Cannot have children but can have multiple parents.
    ///
    ///
    ///
    ///
    /// * Policy: Allows you to store a policy document and policy type. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
    ///
    ///
    ///
    ///
    /// * Index: Can be created with the Index API.
    public var objectType: CloudDirectoryClientTypes.ObjectType?
    /// The schema ARN in which the new [Facet] will be created. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        attributes: [CloudDirectoryClientTypes.FacetAttribute]? = nil,
        facetStyle: CloudDirectoryClientTypes.FacetStyle? = nil,
        name: Swift.String? = nil,
        objectType: CloudDirectoryClientTypes.ObjectType? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.facetStyle = facetStyle
        self.name = name
        self.objectType = objectType
        self.schemaArn = schemaArn
    }
}

public struct CreateFacetOutput: Swift.Sendable {

    public init() { }
}

/// Indicates that the requested index type is not supported.
public struct UnsupportedIndexTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedIndexTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateIndexInput: Swift.Sendable {
    /// The ARN of the directory where the index should be created.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Indicates whether the attribute that is being indexed has unique values or not.
    /// This member is required.
    public var isUnique: Swift.Bool?
    /// The name of the link between the parent object and the index object.
    public var linkName: Swift.String?
    /// Specifies the attributes that should be indexed on. Currently only a single attribute is supported.
    /// This member is required.
    public var orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]?
    /// A reference to the parent object that contains the index object.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        isUnique: Swift.Bool? = false,
        linkName: Swift.String? = nil,
        orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.isUnique = isUnique
        self.linkName = linkName
        self.orderedIndexedAttributeList = orderedIndexedAttributeList
        self.parentReference = parentReference
    }
}

public struct CreateIndexOutput: Swift.Sendable {
    /// The ObjectIdentifier of the index created by this operation.
    public var objectIdentifier: Swift.String?

    public init(
        objectIdentifier: Swift.String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

public struct CreateObjectInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] in which the object will be created. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The name of link that is used to attach this object to a parent.
    public var linkName: Swift.String?
    /// The attribute map whose attribute ARN contains the key and attribute value as the map value.
    public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    /// If specified, the parent reference to which this object will be attached.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?
    /// A list of schema facets to be associated with the object. Do not provide minor version components. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?

    public init(
        directoryArn: Swift.String? = nil,
        linkName: Swift.String? = nil,
        objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]? = nil
    )
    {
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.objectAttributeList = objectAttributeList
        self.parentReference = parentReference
        self.schemaFacets = schemaFacets
    }
}

public struct CreateObjectOutput: Swift.Sendable {
    /// The identifier that is associated with the object.
    public var objectIdentifier: Swift.String?

    public init(
        objectIdentifier: Swift.String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

public struct CreateSchemaInput: Swift.Sendable {
    /// The name that is associated with the schema. This is unique to each account and in each region.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct CreateSchemaOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

extension CloudDirectoryClientTypes {

    /// A typed link attribute definition.
    public struct TypedLinkAttributeDefinition: Swift.Sendable {
        /// The default value of the attribute (if configured).
        public var defaultValue: CloudDirectoryClientTypes.TypedAttributeValue?
        /// Whether the attribute is mutable or not.
        public var isImmutable: Swift.Bool
        /// The unique name of the typed link attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The required behavior of the TypedLinkAttributeDefinition.
        /// This member is required.
        public var requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior?
        /// Validation rules that are attached to the attribute definition.
        public var rules: [Swift.String: CloudDirectoryClientTypes.Rule]?
        /// The type of the attribute.
        /// This member is required.
        public var type: CloudDirectoryClientTypes.FacetAttributeType?

        public init(
            defaultValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil,
            isImmutable: Swift.Bool = false,
            name: Swift.String? = nil,
            requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior? = nil,
            rules: [Swift.String: CloudDirectoryClientTypes.Rule]? = nil,
            type: CloudDirectoryClientTypes.FacetAttributeType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.isImmutable = isImmutable
            self.name = name
            self.requiredBehavior = requiredBehavior
            self.rules = rules
            self.type = type
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Defines the typed links structure and its attributes. To create a typed link facet, use the [CreateTypedLinkFacet] API.
    public struct TypedLinkFacet: Swift.Sendable {
        /// A set of key-value pairs associated with the typed link. Typed link attributes are used when you have data values that are related to the link itself, and not to one of the two objects being linked. Identity attributes also serve to distinguish the link from others of the same type between the same objects.
        /// This member is required.
        public var attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]?
        /// The set of attributes that distinguish links made from this facet from each other, in the order of significance. Listing typed links can filter on the values of these attributes. See [ListOutgoingTypedLinks] and [ListIncomingTypedLinks] for details.
        /// This member is required.
        public var identityAttributeOrder: [Swift.String]?
        /// The unique name of the typed link facet.
        /// This member is required.
        public var name: Swift.String?

        public init(
            attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil,
            identityAttributeOrder: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.identityAttributeOrder = identityAttributeOrder
            self.name = name
        }
    }
}

public struct CreateTypedLinkFacetInput: Swift.Sendable {
    /// [Facet] structure that is associated with the typed link facet.
    /// This member is required.
    public var facet: CloudDirectoryClientTypes.TypedLinkFacet?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        facet: CloudDirectoryClientTypes.TypedLinkFacet? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.facet = facet
        self.schemaArn = schemaArn
    }
}

public struct CreateTypedLinkFacetOutput: Swift.Sendable {

    public init() { }
}

/// A directory that has been deleted and to which access has been attempted. Note: The requested resource will eventually cease to exist.
public struct DirectoryDeletedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryDeletedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An operation can only operate on a disabled directory.
public struct DirectoryNotDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryNotDisabledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteDirectoryInput: Swift.Sendable {
    /// The ARN of the directory to delete.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

public struct DeleteDirectoryOutput: Swift.Sendable {
    /// The ARN of the deleted directory.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

/// Occurs when deleting a facet that contains an attribute that is a target to an attribute reference in a different facet.
public struct FacetInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FacetInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified [Facet] could not be found.
public struct FacetNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FacetNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteFacetInput: Swift.Sendable {
    /// The name of the facet to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the [Facet]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

public struct DeleteFacetOutput: Swift.Sendable {

    public init() { }
}

/// Indicates that the requested operation cannot be completed because the object has not been detached from the tree.
public struct ObjectNotDetachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ObjectNotDetachedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteObjectInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference that identifies the object.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

public struct DeleteObjectOutput: Swift.Sendable {

    public init() { }
}

/// The object could not be deleted because links still exist. Remove the links and then try the operation again.
public struct StillContainsLinksException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StillContainsLinksException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteSchemaInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the development schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

public struct DeleteSchemaOutput: Swift.Sendable {
    /// The input ARN that is returned as part of the response. For more information, see [arns].
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

public struct DeleteTypedLinkFacetInput: Swift.Sendable {
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

public struct DeleteTypedLinkFacetOutput: Swift.Sendable {

    public init() { }
}

/// Indicates that the object is not attached to the index.
public struct ObjectAlreadyDetachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ObjectAlreadyDetachedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DetachFromIndexInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the directory the index and object exist in.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the index object.
    /// This member is required.
    public var indexReference: CloudDirectoryClientTypes.ObjectReference?
    /// A reference to the object being detached from the index.
    /// This member is required.
    public var targetReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

public struct DetachFromIndexOutput: Swift.Sendable {
    /// The ObjectIdentifier of the object that was detached from the index.
    public var detachedObjectIdentifier: Swift.String?

    public init(
        detachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

/// Occurs when any invalid operations are performed on an object that is not a node, such as calling ListObjectChildren for a leaf node object.
public struct NotNodeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotNodeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DetachObjectInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The link name associated with the object that needs to be detached.
    /// This member is required.
    public var linkName: Swift.String?
    /// The parent reference from which the object with the specified link name is detached.
    /// This member is required.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        linkName: Swift.String? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

public struct DetachObjectOutput: Swift.Sendable {
    /// The ObjectIdentifier that was detached from the object.
    public var detachedObjectIdentifier: Swift.String?

    public init(
        detachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

public struct DetachPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where both objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Reference that identifies the object whose policy object will be detached.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Reference that identifies the policy object.
    /// This member is required.
    public var policyReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

public struct DetachPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DetachTypedLinkInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the directory where you want to detach the typed link.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Used to accept a typed link specifier as input.
    /// This member is required.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init(
        directoryArn: Swift.String? = nil,
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

public struct DisableDirectoryInput: Swift.Sendable {
    /// The ARN of the directory to disable.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

public struct DisableDirectoryOutput: Swift.Sendable {
    /// The ARN of the directory that has been disabled.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

public struct EnableDirectoryInput: Swift.Sendable {
    /// The ARN of the directory to enable.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

public struct EnableDirectoryOutput: Swift.Sendable {
    /// The ARN of the enabled directory.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

public struct GetAppliedSchemaVersionInput: Swift.Sendable {
    /// The ARN of the applied schema.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

public struct GetAppliedSchemaVersionOutput: Swift.Sendable {
    /// Current applied schema ARN, including the minor version in use if one was provided.
    public var appliedSchemaArn: Swift.String?

    public init(
        appliedSchemaArn: Swift.String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
    }
}

public struct GetDirectoryInput: Swift.Sendable {
    /// The ARN of the directory.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

extension CloudDirectoryClientTypes {

    public enum DirectoryState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryState] {
            return [
                .deleted,
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CloudDirectoryClientTypes {

    /// Directory structure that includes the directory name and directory ARN.
    public struct Directory: Swift.Sendable {
        /// The date and time when the directory was created.
        public var creationDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) that is associated with the directory. For more information, see [arns].
        public var directoryArn: Swift.String?
        /// The name of the directory.
        public var name: Swift.String?
        /// The state of the directory. Can be either Enabled, Disabled, or Deleted.
        public var state: CloudDirectoryClientTypes.DirectoryState?

        public init(
            creationDateTime: Foundation.Date? = nil,
            directoryArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: CloudDirectoryClientTypes.DirectoryState? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.directoryArn = directoryArn
            self.name = name
            self.state = state
        }
    }
}

public struct GetDirectoryOutput: Swift.Sendable {
    /// Metadata about the directory.
    /// This member is required.
    public var directory: CloudDirectoryClientTypes.Directory?

    public init(
        directory: CloudDirectoryClientTypes.Directory? = nil
    )
    {
        self.directory = directory
    }
}

public struct GetFacetInput: Swift.Sendable {
    /// The name of the facet to retrieve.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the [Facet]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

extension CloudDirectoryClientTypes {

    /// A structure that contains Name, ARN, Attributes, [Rule]s, and ObjectTypes. See [Facets](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_whatarefacets.html) for more information.
    public struct Facet: Swift.Sendable {
        /// There are two different styles that you can define on any given facet, Static and Dynamic. For static facets, all attributes must be defined in the schema. For dynamic facets, attributes can be defined during data plane operations.
        public var facetStyle: CloudDirectoryClientTypes.FacetStyle?
        /// The name of the [Facet].
        public var name: Swift.String?
        /// The object type that is associated with the facet. See [CreateFacetRequest$ObjectType] for more details.
        public var objectType: CloudDirectoryClientTypes.ObjectType?

        public init(
            facetStyle: CloudDirectoryClientTypes.FacetStyle? = nil,
            name: Swift.String? = nil,
            objectType: CloudDirectoryClientTypes.ObjectType? = nil
        )
        {
            self.facetStyle = facetStyle
            self.name = name
            self.objectType = objectType
        }
    }
}

public struct GetFacetOutput: Swift.Sendable {
    /// The [Facet] structure that is associated with the facet.
    public var facet: CloudDirectoryClientTypes.Facet?

    public init(
        facet: CloudDirectoryClientTypes.Facet? = nil
    )
    {
        self.facet = facet
    }
}

public struct GetLinkAttributesInput: Swift.Sendable {
    /// A list of attribute names whose values will be retrieved.
    /// This member is required.
    public var attributeNames: [Swift.String]?
    /// The consistency level at which to retrieve the attributes on a typed link.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the Directory where the typed link resides. For more information, see [arns] or [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Allows a typed link specifier to be accepted as input.
    /// This member is required.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init(
        attributeNames: [Swift.String]? = nil,
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.attributeNames = attributeNames
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

public struct GetLinkAttributesOutput: Swift.Sendable {
    /// The attributes that are associated with the typed link.
    public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

    public init(
        attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

public struct GetObjectAttributesInput: Swift.Sendable {
    /// List of attribute names whose values will be retrieved.
    /// This member is required.
    public var attributeNames: [Swift.String]?
    /// The consistency level at which to retrieve the attributes on an object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Reference that identifies the object whose attributes will be retrieved.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifier for the facet whose attributes will be retrieved. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

    public init(
        attributeNames: [Swift.String]? = nil,
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
    )
    {
        self.attributeNames = attributeNames
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

public struct GetObjectAttributesOutput: Swift.Sendable {
    /// The attributes that are associated with the object.
    public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

    public init(
        attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

public struct GetObjectInformationInput: Swift.Sendable {
    /// The consistency level at which to retrieve the object information.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The ARN of the directory being retrieved.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the object.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

public struct GetObjectInformationOutput: Swift.Sendable {
    /// The ObjectIdentifier of the specified object.
    public var objectIdentifier: Swift.String?
    /// The facets attached to the specified object. Although the response does not include minor version information, the most recently applied minor version of each Facet is in effect. See [GetAppliedSchemaVersion] for details.
    public var schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?

    public init(
        objectIdentifier: Swift.String? = nil,
        schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
        self.schemaFacets = schemaFacets
    }
}

public struct GetSchemaAsJsonInput: Swift.Sendable {
    /// The ARN of the schema to retrieve.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

public struct GetSchemaAsJsonOutput: Swift.Sendable {
    /// The JSON representation of the schema document.
    public var document: Swift.String?
    /// The name of the retrieved schema.
    public var name: Swift.String?

    public init(
        document: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.document = document
        self.name = name
    }
}

/// Indicates that the NextToken value is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetTypedLinkFacetInformationInput: Swift.Sendable {
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

public struct GetTypedLinkFacetInformationOutput: Swift.Sendable {
    /// The order of identity attributes for the facet, from most significant to least significant. The ability to filter typed links considers the order that the attributes are defined on the typed link facet. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range. Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls. For more information about identity attributes, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    public var identityAttributeOrder: [Swift.String]?

    public init(
        identityAttributeOrder: [Swift.String]? = nil
    )
    {
        self.identityAttributeOrder = identityAttributeOrder
    }
}

public struct ListAppliedSchemaArnsInput: Swift.Sendable {
    /// The ARN of the directory you are listing.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The response for ListAppliedSchemaArns when this parameter is used will list all minor version ARNs for a major version.
    public var schemaArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

public struct ListAppliedSchemaArnsOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs of schemas that are applied to the directory.
    public var schemaArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

public struct ListAttachedIndicesInput: Swift.Sendable {
    /// The consistency level to use for this operation.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The ARN of the directory.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A reference to the object that has indices attached.
    /// This member is required.
    public var targetReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetReference = targetReference
    }
}

public struct ListAttachedIndicesOutput: Swift.Sendable {
    /// The indices attached to the specified object.
    public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

public struct ListDevelopmentSchemaArnsInput: Swift.Sendable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDevelopmentSchemaArnsOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs of retrieved development schemas.
    public var schemaArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

public struct ListDirectoriesInput: Swift.Sendable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The state of the directories in the list. Can be either Enabled, Disabled, or Deleted.
    public var state: CloudDirectoryClientTypes.DirectoryState?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: CloudDirectoryClientTypes.DirectoryState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

public struct ListDirectoriesOutput: Swift.Sendable {
    /// Lists all directories that are associated with your account in pagination fashion.
    /// This member is required.
    public var directories: [CloudDirectoryClientTypes.Directory]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        directories: [CloudDirectoryClientTypes.Directory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directories = directories
        self.nextToken = nextToken
    }
}

public struct ListFacetAttributesInput: Swift.Sendable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The name of the facet whose attributes will be retrieved.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARN of the schema where the facet resides.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

public struct ListFacetAttributesOutput: Swift.Sendable {
    /// The attributes attached to the facet.
    public var attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        attributes: [CloudDirectoryClientTypes.FacetAttribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

public struct ListFacetNamesInput: Swift.Sendable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) to retrieve facet names from.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

public struct ListFacetNamesOutput: Swift.Sendable {
    /// The names of facets that exist within the schema.
    public var facetNames: [Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        facetNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.facetNames = facetNames
        self.nextToken = nextToken
    }
}

public struct ListIncomingTypedLinksInput: Swift.Sendable {
    /// The consistency level to execute the request at.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) of the directory where you want to list the typed links.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
    public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    /// Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls.
    public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Reference that identifies the object whose attributes will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
        filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

public struct ListIncomingTypedLinksOutput: Swift.Sendable {
    /// Returns one or more typed link specifiers as output.
    public var linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkSpecifiers = linkSpecifiers
        self.nextToken = nextToken
    }
}

public struct ListIndexInput: Swift.Sendable {
    /// The consistency level to execute the request at.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The ARN of the directory that the index exists in.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The reference to the index to list.
    /// This member is required.
    public var indexReference: CloudDirectoryClientTypes.ObjectReference?
    /// The maximum number of objects in a single page to retrieve from the index during a request. For more information, see [Amazon Cloud Directory Limits](http://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html).
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Specifies the ranges of indexed values that you want to query.
    public var rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rangesOnIndexedValues = rangesOnIndexedValues
    }
}

public struct ListIndexOutput: Swift.Sendable {
    /// The objects and indexed values attached to the index.
    public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

public struct ListManagedSchemaArnsInput: Swift.Sendable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The response for ListManagedSchemaArns. When this parameter is used, all minor version ARNs for a major version are listed.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

public struct ListManagedSchemaArnsOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs for all AWS managed schemas.
    public var schemaArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

public struct ListObjectAttributesInput: Swift.Sendable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Used to filter the list of object attributes that are associated with a certain facet.
    public var facetFilter: CloudDirectoryClientTypes.SchemaFacet?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object whose attributes will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        facetFilter: CloudDirectoryClientTypes.SchemaFacet? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.facetFilter = facetFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

public struct ListObjectAttributesOutput: Swift.Sendable {
    /// Attributes map that is associated with the object. AttributeArn is the key, and attribute value is the value.
    public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

public struct ListObjectChildrenInput: Swift.Sendable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object for which child objects are being listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

public struct ListObjectChildrenOutput: Swift.Sendable {
    /// Children structure, which is a map with key as the LinkName and ObjectIdentifier as the value.
    public var children: [Swift.String: Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        children: [Swift.String: Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.children = children
        self.nextToken = nextToken
    }
}

public struct ListObjectParentPathsInput: Swift.Sendable {
    /// The ARN of the directory to which the parent path applies.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object whose parent paths are listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

public struct ListObjectParentPathsOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Returns the path to the ObjectIdentifiers that are associated with the directory.
    public var pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]?

    public init(
        nextToken: Swift.String? = nil,
        pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
    )
    {
        self.nextToken = nextToken
        self.pathToObjectIdentifiersList = pathToObjectIdentifiersList
    }
}

/// Cannot list the parents of a [Directory] root.
public struct CannotListParentOfRootException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotListParentOfRootException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListObjectParentsInput: Swift.Sendable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// When set to True, returns all [ListObjectParentsResponse$ParentLinks]. There could be multiple links between a parent-child pair.
    public var includeAllLinksToEachParent: Swift.Bool?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object for which parent objects are being listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        includeAllLinksToEachParent: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.includeAllLinksToEachParent = includeAllLinksToEachParent
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

public struct ListObjectParentsOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Returns a list of parent reference and LinkName Tuples.
    public var parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]?
    /// The parent structure, which is a map with key as the ObjectIdentifier and LinkName as the value.
    public var parents: [Swift.String: Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil,
        parents: [Swift.String: Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.parentLinks = parentLinks
        self.parents = parents
    }
}

public struct ListObjectPoliciesInput: Swift.Sendable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Reference that identifies the object for which policies will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

public struct ListObjectPoliciesOutput: Swift.Sendable {
    /// A list of policy ObjectIdentifiers, that are attached to the object.
    public var attachedPolicyIds: [Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        attachedPolicyIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachedPolicyIds = attachedPolicyIds
        self.nextToken = nextToken
    }
}

public struct ListOutgoingTypedLinksInput: Swift.Sendable {
    /// The consistency level to execute the request at.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) of the directory where you want to list the typed links.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
    public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    /// Filters are interpreted in the order of the attributes defined on the typed link facet, not the order they are supplied to any API calls.
    public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A reference that identifies the object whose attributes will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
        filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

public struct ListOutgoingTypedLinksOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Returns a typed link specifier as output.
    public var typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?

    public init(
        nextToken: Swift.String? = nil,
        typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.typedLinkSpecifiers = typedLinkSpecifiers
    }
}

public struct ListPolicyAttachmentsInput: Swift.Sendable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the policy object.
    /// This member is required.
    public var policyReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyReference = policyReference
    }
}

public struct ListPolicyAttachmentsOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A list of ObjectIdentifiers to which the policy is attached.
    public var objectIdentifiers: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        objectIdentifiers: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectIdentifiers = objectIdentifiers
    }
}

public struct ListPublishedSchemaArnsInput: Swift.Sendable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The response for ListPublishedSchemaArns when this parameter is used will list all minor version ARNs for a major version.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

public struct ListPublishedSchemaArnsOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs of published schemas.
    public var schemaArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

/// Can occur for multiple reasons such as when you tag a resource that doesn’t exist or if you specify a higher number of tags for a resource than the allowed limit. Allowed limit is 50 tags per resource.
public struct InvalidTaggingRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTaggingRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The MaxResults parameter sets the maximum number of results returned in a single page. This is for future use and is not supported currently.
    public var maxResults: Swift.Int?
    /// The pagination token. This is for future use. Currently pagination is not supported for tagging.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension CloudDirectoryClientTypes {

    /// The tag structure that contains a tag key and value.
    public struct Tag: Swift.Sendable {
        /// The key that is associated with the tag.
        public var key: Swift.String?
        /// The value that is associated with the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of tag key value pairs that are associated with the response.
    public var tags: [CloudDirectoryClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [CloudDirectoryClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListTypedLinkFacetAttributesInput: Swift.Sendable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

public struct ListTypedLinkFacetAttributesOutput: Swift.Sendable {
    /// An ordered set of attributes associate with the typed link.
    public var attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

public struct ListTypedLinkFacetNamesInput: Swift.Sendable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

public struct ListTypedLinkFacetNamesOutput: Swift.Sendable {
    /// The names of typed link facets that exist within the schema.
    public var facetNames: [Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        facetNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.facetNames = facetNames
        self.nextToken = nextToken
    }
}

public struct LookupPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// Reference that identifies the object whose policies will be looked up.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

public struct LookupPolicyOutput: Swift.Sendable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Provides list of path to policies. Policies contain PolicyId, ObjectIdentifier, and PolicyType. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
    public var policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]?

    public init(
        nextToken: Swift.String? = nil,
        policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyToPathList = policyToPathList
    }
}

/// Indicates that a schema is already published.
public struct SchemaAlreadyPublishedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SchemaAlreadyPublishedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PublishSchemaInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that is associated with the development schema. For more information, see [arns].
    /// This member is required.
    public var developmentSchemaArn: Swift.String?
    /// The minor version under which the schema will be published. This parameter is recommended. Schemas have both a major and minor version associated with them.
    public var minorVersion: Swift.String?
    /// The new name under which the schema will be published. If this is not provided, the development schema is considered.
    public var name: Swift.String?
    /// The major version under which the schema will be published. Schemas have both a major and minor version associated with them.
    /// This member is required.
    public var version: Swift.String?

    public init(
        developmentSchemaArn: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.developmentSchemaArn = developmentSchemaArn
        self.minorVersion = minorVersion
        self.name = name
        self.version = version
    }
}

public struct PublishSchemaOutput: Swift.Sendable {
    /// The ARN that is associated with the published schema. For more information, see [arns].
    public var publishedSchemaArn: Swift.String?

    public init(
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.publishedSchemaArn = publishedSchemaArn
    }
}

/// Indicates that the provided SchemaDoc value is not valid.
public struct InvalidSchemaDocException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSchemaDocException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutSchemaFromJsonInput: Swift.Sendable {
    /// The replacement JSON schema.
    /// This member is required.
    public var document: Swift.String?
    /// The ARN of the schema to update.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        document: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.document = document
        self.schemaArn = schemaArn
    }
}

public struct PutSchemaFromJsonOutput: Swift.Sendable {
    /// The ARN of the schema to update.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct RemoveFacetFromObjectInput: Swift.Sendable {
    /// The ARN of the directory in which the object resides.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the object to remove the facet from.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// The facet to remove. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

    public init(
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

public struct RemoveFacetFromObjectOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key-value pairs.
    /// This member is required.
    public var tags: [CloudDirectoryClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [CloudDirectoryClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of the tag that need to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// An attempt to modify a [Facet] resulted in an invalid schema exception.
public struct InvalidFacetUpdateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFacetUpdateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CloudDirectoryClientTypes {

    /// A structure that contains information used to update an attribute.
    public struct FacetAttributeUpdate: Swift.Sendable {
        /// The action to perform when updating the attribute.
        public var action: CloudDirectoryClientTypes.UpdateActionType?
        /// The attribute to update.
        public var attribute: CloudDirectoryClientTypes.FacetAttribute?

        public init(
            action: CloudDirectoryClientTypes.UpdateActionType? = nil,
            attribute: CloudDirectoryClientTypes.FacetAttribute? = nil
        )
        {
            self.action = action
            self.attribute = attribute
        }
    }
}

public struct UpdateFacetInput: Swift.Sendable {
    /// List of attributes that need to be updated in a given schema [Facet]. Each attribute is followed by AttributeAction, which specifies the type of update operation to perform.
    public var attributeUpdates: [CloudDirectoryClientTypes.FacetAttributeUpdate]?
    /// The name of the facet.
    /// This member is required.
    public var name: Swift.String?
    /// The object type that is associated with the facet. See [CreateFacetRequest$ObjectType] for more details.
    public var objectType: CloudDirectoryClientTypes.ObjectType?
    /// The Amazon Resource Name (ARN) that is associated with the [Facet]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        attributeUpdates: [CloudDirectoryClientTypes.FacetAttributeUpdate]? = nil,
        name: Swift.String? = nil,
        objectType: CloudDirectoryClientTypes.ObjectType? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.name = name
        self.objectType = objectType
        self.schemaArn = schemaArn
    }
}

public struct UpdateFacetOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateLinkAttributesInput: Swift.Sendable {
    /// The attributes update structure.
    /// This member is required.
    public var attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]?
    /// The Amazon Resource Name (ARN) that is associated with the Directory where the updated typed link resides. For more information, see [arns] or [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Allows a typed link specifier to be accepted as input.
    /// This member is required.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init(
        attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil,
        directoryArn: Swift.String? = nil,
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

public struct UpdateLinkAttributesOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateObjectAttributesInput: Swift.Sendable {
    /// The attributes update structure.
    /// This member is required.
    public var attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The reference that identifies the object.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil,
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

public struct UpdateObjectAttributesOutput: Swift.Sendable {
    /// The ObjectIdentifier of the updated object.
    public var objectIdentifier: Swift.String?

    public init(
        objectIdentifier: Swift.String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

public struct UpdateSchemaInput: Swift.Sendable {
    /// The name of the schema.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the development schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

public struct UpdateSchemaOutput: Swift.Sendable {
    /// The ARN that is associated with the updated schema. For more information, see [arns].
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

extension CloudDirectoryClientTypes {

    /// A typed link facet attribute update.
    public struct TypedLinkFacetAttributeUpdate: Swift.Sendable {
        /// The action to perform when updating the attribute.
        /// This member is required.
        public var action: CloudDirectoryClientTypes.UpdateActionType?
        /// The attribute to update.
        /// This member is required.
        public var attribute: CloudDirectoryClientTypes.TypedLinkAttributeDefinition?

        public init(
            action: CloudDirectoryClientTypes.UpdateActionType? = nil,
            attribute: CloudDirectoryClientTypes.TypedLinkAttributeDefinition? = nil
        )
        {
            self.action = action
            self.attribute = attribute
        }
    }
}

public struct UpdateTypedLinkFacetInput: Swift.Sendable {
    /// Attributes update structure.
    /// This member is required.
    public var attributeUpdates: [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]?
    /// The order of identity attributes for the facet, from most significant to least significant. The ability to filter typed links considers the order that the attributes are defined on the typed link facet. When providing ranges to a typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range. Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls. For more information about identity attributes, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    /// This member is required.
    public var identityAttributeOrder: [Swift.String]?
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        attributeUpdates: [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]? = nil,
        identityAttributeOrder: [Swift.String]? = nil,
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.identityAttributeOrder = identityAttributeOrder
        self.name = name
        self.schemaArn = schemaArn
    }
}

public struct UpdateTypedLinkFacetOutput: Swift.Sendable {

    public init() { }
}

/// Indicates a failure occurred while performing a check for backward compatibility between the specified schema and the schema that is currently applied to the directory.
public struct IncompatibleSchemaException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncompatibleSchemaException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpgradeAppliedSchemaInput: Swift.Sendable {
    /// The ARN for the directory to which the upgraded schema will be applied.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.
    public var dryRun: Swift.Bool?
    /// The revision of the published schema to upgrade the directory to.
    /// This member is required.
    public var publishedSchemaArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil,
        dryRun: Swift.Bool? = false,
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.dryRun = dryRun
        self.publishedSchemaArn = publishedSchemaArn
    }
}

public struct UpgradeAppliedSchemaOutput: Swift.Sendable {
    /// The ARN of the directory that is returned as part of the response.
    public var directoryArn: Swift.String?
    /// The ARN of the upgraded schema that is returned as part of the response.
    public var upgradedSchemaArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil,
        upgradedSchemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.upgradedSchemaArn = upgradedSchemaArn
    }
}

public struct UpgradePublishedSchemaInput: Swift.Sendable {
    /// The ARN of the development schema with the changes used for the upgrade.
    /// This member is required.
    public var developmentSchemaArn: Swift.String?
    /// Used for testing whether the Development schema provided is backwards compatible, or not, with the publish schema provided by the user to be upgraded. If schema compatibility fails, an exception would be thrown else the call would succeed. This parameter is optional and defaults to false.
    public var dryRun: Swift.Bool?
    /// Identifies the minor version of the published schema that will be created. This parameter is NOT optional.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The ARN of the published schema to be upgraded.
    /// This member is required.
    public var publishedSchemaArn: Swift.String?

    public init(
        developmentSchemaArn: Swift.String? = nil,
        dryRun: Swift.Bool? = false,
        minorVersion: Swift.String? = nil,
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.developmentSchemaArn = developmentSchemaArn
        self.dryRun = dryRun
        self.minorVersion = minorVersion
        self.publishedSchemaArn = publishedSchemaArn
    }
}

public struct UpgradePublishedSchemaOutput: Swift.Sendable {
    /// The ARN of the upgraded schema that is returned as part of the response.
    public var upgradedSchemaArn: Swift.String?

    public init(
        upgradedSchemaArn: Swift.String? = nil
    )
    {
        self.upgradedSchemaArn = upgradedSchemaArn
    }
}

extension AddFacetToObjectInput {

    static func urlPathProvider(_ value: AddFacetToObjectInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/facets"
    }
}

extension AddFacetToObjectInput {

    static func headerProvider(_ value: AddFacetToObjectInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ApplySchemaInput {

    static func urlPathProvider(_ value: ApplySchemaInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/apply"
    }
}

extension ApplySchemaInput {

    static func headerProvider(_ value: ApplySchemaInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension AttachObjectInput {

    static func urlPathProvider(_ value: AttachObjectInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/attach"
    }
}

extension AttachObjectInput {

    static func headerProvider(_ value: AttachObjectInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension AttachPolicyInput {

    static func urlPathProvider(_ value: AttachPolicyInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/policy/attach"
    }
}

extension AttachPolicyInput {

    static func headerProvider(_ value: AttachPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension AttachToIndexInput {

    static func urlPathProvider(_ value: AttachToIndexInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/index/attach"
    }
}

extension AttachToIndexInput {

    static func headerProvider(_ value: AttachToIndexInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension AttachTypedLinkInput {

    static func urlPathProvider(_ value: AttachTypedLinkInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/attach"
    }
}

extension AttachTypedLinkInput {

    static func headerProvider(_ value: AttachTypedLinkInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension BatchReadInput {

    static func urlPathProvider(_ value: BatchReadInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/batchread"
    }
}

extension BatchReadInput {

    static func headerProvider(_ value: BatchReadInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension BatchWriteInput {

    static func urlPathProvider(_ value: BatchWriteInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/batchwrite"
    }
}

extension BatchWriteInput {

    static func headerProvider(_ value: BatchWriteInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension CreateDirectoryInput {

    static func urlPathProvider(_ value: CreateDirectoryInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/create"
    }
}

extension CreateDirectoryInput {

    static func headerProvider(_ value: CreateDirectoryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension CreateFacetInput {

    static func urlPathProvider(_ value: CreateFacetInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet/create"
    }
}

extension CreateFacetInput {

    static func headerProvider(_ value: CreateFacetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension CreateIndexInput {

    static func urlPathProvider(_ value: CreateIndexInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/index"
    }
}

extension CreateIndexInput {

    static func headerProvider(_ value: CreateIndexInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension CreateObjectInput {

    static func urlPathProvider(_ value: CreateObjectInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object"
    }
}

extension CreateObjectInput {

    static func headerProvider(_ value: CreateObjectInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension CreateSchemaInput {

    static func urlPathProvider(_ value: CreateSchemaInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/create"
    }
}

extension CreateTypedLinkFacetInput {

    static func urlPathProvider(_ value: CreateTypedLinkFacetInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/create"
    }
}

extension CreateTypedLinkFacetInput {

    static func headerProvider(_ value: CreateTypedLinkFacetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension DeleteDirectoryInput {

    static func urlPathProvider(_ value: DeleteDirectoryInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory"
    }
}

extension DeleteDirectoryInput {

    static func headerProvider(_ value: DeleteDirectoryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DeleteFacetInput {

    static func urlPathProvider(_ value: DeleteFacetInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet/delete"
    }
}

extension DeleteFacetInput {

    static func headerProvider(_ value: DeleteFacetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension DeleteObjectInput {

    static func urlPathProvider(_ value: DeleteObjectInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/delete"
    }
}

extension DeleteObjectInput {

    static func headerProvider(_ value: DeleteObjectInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DeleteSchemaInput {

    static func urlPathProvider(_ value: DeleteSchemaInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema"
    }
}

extension DeleteSchemaInput {

    static func headerProvider(_ value: DeleteSchemaInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension DeleteTypedLinkFacetInput {

    static func urlPathProvider(_ value: DeleteTypedLinkFacetInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/delete"
    }
}

extension DeleteTypedLinkFacetInput {

    static func headerProvider(_ value: DeleteTypedLinkFacetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension DetachFromIndexInput {

    static func urlPathProvider(_ value: DetachFromIndexInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/index/detach"
    }
}

extension DetachFromIndexInput {

    static func headerProvider(_ value: DetachFromIndexInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DetachObjectInput {

    static func urlPathProvider(_ value: DetachObjectInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/detach"
    }
}

extension DetachObjectInput {

    static func headerProvider(_ value: DetachObjectInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DetachPolicyInput {

    static func urlPathProvider(_ value: DetachPolicyInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/policy/detach"
    }
}

extension DetachPolicyInput {

    static func headerProvider(_ value: DetachPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DetachTypedLinkInput {

    static func urlPathProvider(_ value: DetachTypedLinkInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/detach"
    }
}

extension DetachTypedLinkInput {

    static func headerProvider(_ value: DetachTypedLinkInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DisableDirectoryInput {

    static func urlPathProvider(_ value: DisableDirectoryInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/disable"
    }
}

extension DisableDirectoryInput {

    static func headerProvider(_ value: DisableDirectoryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension EnableDirectoryInput {

    static func urlPathProvider(_ value: EnableDirectoryInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/enable"
    }
}

extension EnableDirectoryInput {

    static func headerProvider(_ value: EnableDirectoryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension GetAppliedSchemaVersionInput {

    static func urlPathProvider(_ value: GetAppliedSchemaVersionInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/getappliedschema"
    }
}

extension GetDirectoryInput {

    static func urlPathProvider(_ value: GetDirectoryInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/get"
    }
}

extension GetDirectoryInput {

    static func headerProvider(_ value: GetDirectoryInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension GetFacetInput {

    static func urlPathProvider(_ value: GetFacetInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet"
    }
}

extension GetFacetInput {

    static func headerProvider(_ value: GetFacetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension GetLinkAttributesInput {

    static func urlPathProvider(_ value: GetLinkAttributesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/attributes/get"
    }
}

extension GetLinkAttributesInput {

    static func headerProvider(_ value: GetLinkAttributesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension GetObjectAttributesInput {

    static func urlPathProvider(_ value: GetObjectAttributesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/attributes/get"
    }
}

extension GetObjectAttributesInput {

    static func headerProvider(_ value: GetObjectAttributesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension GetObjectInformationInput {

    static func urlPathProvider(_ value: GetObjectInformationInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/information"
    }
}

extension GetObjectInformationInput {

    static func headerProvider(_ value: GetObjectInformationInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension GetSchemaAsJsonInput {

    static func urlPathProvider(_ value: GetSchemaAsJsonInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/json"
    }
}

extension GetSchemaAsJsonInput {

    static func headerProvider(_ value: GetSchemaAsJsonInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension GetTypedLinkFacetInformationInput {

    static func urlPathProvider(_ value: GetTypedLinkFacetInformationInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/get"
    }
}

extension GetTypedLinkFacetInformationInput {

    static func headerProvider(_ value: GetTypedLinkFacetInformationInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension ListAppliedSchemaArnsInput {

    static func urlPathProvider(_ value: ListAppliedSchemaArnsInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/applied"
    }
}

extension ListAttachedIndicesInput {

    static func urlPathProvider(_ value: ListAttachedIndicesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/indices"
    }
}

extension ListAttachedIndicesInput {

    static func headerProvider(_ value: ListAttachedIndicesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListDevelopmentSchemaArnsInput {

    static func urlPathProvider(_ value: ListDevelopmentSchemaArnsInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/development"
    }
}

extension ListDirectoriesInput {

    static func urlPathProvider(_ value: ListDirectoriesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/list"
    }
}

extension ListFacetAttributesInput {

    static func urlPathProvider(_ value: ListFacetAttributesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet/attributes"
    }
}

extension ListFacetAttributesInput {

    static func headerProvider(_ value: ListFacetAttributesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension ListFacetNamesInput {

    static func urlPathProvider(_ value: ListFacetNamesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet/list"
    }
}

extension ListFacetNamesInput {

    static func headerProvider(_ value: ListFacetNamesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension ListIncomingTypedLinksInput {

    static func urlPathProvider(_ value: ListIncomingTypedLinksInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/incoming"
    }
}

extension ListIncomingTypedLinksInput {

    static func headerProvider(_ value: ListIncomingTypedLinksInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListIndexInput {

    static func urlPathProvider(_ value: ListIndexInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/index/targets"
    }
}

extension ListIndexInput {

    static func headerProvider(_ value: ListIndexInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListManagedSchemaArnsInput {

    static func urlPathProvider(_ value: ListManagedSchemaArnsInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/managed"
    }
}

extension ListObjectAttributesInput {

    static func urlPathProvider(_ value: ListObjectAttributesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/attributes"
    }
}

extension ListObjectAttributesInput {

    static func headerProvider(_ value: ListObjectAttributesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListObjectChildrenInput {

    static func urlPathProvider(_ value: ListObjectChildrenInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/children"
    }
}

extension ListObjectChildrenInput {

    static func headerProvider(_ value: ListObjectChildrenInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListObjectParentPathsInput {

    static func urlPathProvider(_ value: ListObjectParentPathsInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/parentpaths"
    }
}

extension ListObjectParentPathsInput {

    static func headerProvider(_ value: ListObjectParentPathsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListObjectParentsInput {

    static func urlPathProvider(_ value: ListObjectParentsInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/parent"
    }
}

extension ListObjectParentsInput {

    static func headerProvider(_ value: ListObjectParentsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListObjectPoliciesInput {

    static func urlPathProvider(_ value: ListObjectPoliciesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/policy"
    }
}

extension ListObjectPoliciesInput {

    static func headerProvider(_ value: ListObjectPoliciesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListOutgoingTypedLinksInput {

    static func urlPathProvider(_ value: ListOutgoingTypedLinksInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/outgoing"
    }
}

extension ListOutgoingTypedLinksInput {

    static func headerProvider(_ value: ListOutgoingTypedLinksInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListPolicyAttachmentsInput {

    static func urlPathProvider(_ value: ListPolicyAttachmentsInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/policy/attachment"
    }
}

extension ListPolicyAttachmentsInput {

    static func headerProvider(_ value: ListPolicyAttachmentsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let consistencyLevel = value.consistencyLevel {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListPublishedSchemaArnsInput {

    static func urlPathProvider(_ value: ListPublishedSchemaArnsInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/published"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/tags"
    }
}

extension ListTypedLinkFacetAttributesInput {

    static func urlPathProvider(_ value: ListTypedLinkFacetAttributesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/attributes"
    }
}

extension ListTypedLinkFacetAttributesInput {

    static func headerProvider(_ value: ListTypedLinkFacetAttributesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension ListTypedLinkFacetNamesInput {

    static func urlPathProvider(_ value: ListTypedLinkFacetNamesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/list"
    }
}

extension ListTypedLinkFacetNamesInput {

    static func headerProvider(_ value: ListTypedLinkFacetNamesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension LookupPolicyInput {

    static func urlPathProvider(_ value: LookupPolicyInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/policy/lookup"
    }
}

extension LookupPolicyInput {

    static func headerProvider(_ value: LookupPolicyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension PublishSchemaInput {

    static func urlPathProvider(_ value: PublishSchemaInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/publish"
    }
}

extension PublishSchemaInput {

    static func headerProvider(_ value: PublishSchemaInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let developmentSchemaArn = value.developmentSchemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(developmentSchemaArn)))
        }
        return items
    }
}

extension PutSchemaFromJsonInput {

    static func urlPathProvider(_ value: PutSchemaFromJsonInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/json"
    }
}

extension PutSchemaFromJsonInput {

    static func headerProvider(_ value: PutSchemaFromJsonInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension RemoveFacetFromObjectInput {

    static func urlPathProvider(_ value: RemoveFacetFromObjectInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/facets/delete"
    }
}

extension RemoveFacetFromObjectInput {

    static func headerProvider(_ value: RemoveFacetFromObjectInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/tags/add"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/tags/remove"
    }
}

extension UpdateFacetInput {

    static func urlPathProvider(_ value: UpdateFacetInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet"
    }
}

extension UpdateFacetInput {

    static func headerProvider(_ value: UpdateFacetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension UpdateLinkAttributesInput {

    static func urlPathProvider(_ value: UpdateLinkAttributesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/attributes/update"
    }
}

extension UpdateLinkAttributesInput {

    static func headerProvider(_ value: UpdateLinkAttributesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension UpdateObjectAttributesInput {

    static func urlPathProvider(_ value: UpdateObjectAttributesInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/update"
    }
}

extension UpdateObjectAttributesInput {

    static func headerProvider(_ value: UpdateObjectAttributesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let directoryArn = value.directoryArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension UpdateSchemaInput {

    static func urlPathProvider(_ value: UpdateSchemaInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/update"
    }
}

extension UpdateSchemaInput {

    static func headerProvider(_ value: UpdateSchemaInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension UpdateTypedLinkFacetInput {

    static func urlPathProvider(_ value: UpdateTypedLinkFacetInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet"
    }
}

extension UpdateTypedLinkFacetInput {

    static func headerProvider(_ value: UpdateTypedLinkFacetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let schemaArn = value.schemaArn {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension UpgradeAppliedSchemaInput {

    static func urlPathProvider(_ value: UpgradeAppliedSchemaInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/upgradeapplied"
    }
}

extension UpgradePublishedSchemaInput {

    static func urlPathProvider(_ value: UpgradePublishedSchemaInput) -> Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/upgradepublished"
    }
}

extension AddFacetToObjectInput {

    static func write(value: AddFacetToObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectAttributeList"].writeList(value.objectAttributeList, memberWritingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["SchemaFacet"].write(value.schemaFacet, with: CloudDirectoryClientTypes.SchemaFacet.write(value:to:))
    }
}

extension ApplySchemaInput {

    static func write(value: ApplySchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PublishedSchemaArn"].write(value.publishedSchemaArn)
    }
}

extension AttachObjectInput {

    static func write(value: AttachObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChildReference"].write(value.childReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["LinkName"].write(value.linkName)
        try writer["ParentReference"].write(value.parentReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension AttachPolicyInput {

    static func write(value: AttachPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["PolicyReference"].write(value.policyReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension AttachToIndexInput {

    static func write(value: AttachToIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IndexReference"].write(value.indexReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TargetReference"].write(value.targetReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension AttachTypedLinkInput {

    static func write(value: AttachTypedLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeList(value.attributes, memberWritingClosure: CloudDirectoryClientTypes.AttributeNameAndValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceObjectReference"].write(value.sourceObjectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TargetObjectReference"].write(value.targetObjectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TypedLinkFacet"].write(value.typedLinkFacet, with: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.write(value:to:))
    }
}

extension BatchReadInput {

    static func write(value: BatchReadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operations"].writeList(value.operations, memberWritingClosure: CloudDirectoryClientTypes.BatchReadOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchWriteInput {

    static func write(value: BatchWriteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operations"].writeList(value.operations, memberWritingClosure: CloudDirectoryClientTypes.BatchWriteOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDirectoryInput {

    static func write(value: CreateDirectoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension CreateFacetInput {

    static func write(value: CreateFacetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeList(value.attributes, memberWritingClosure: CloudDirectoryClientTypes.FacetAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FacetStyle"].write(value.facetStyle)
        try writer["Name"].write(value.name)
        try writer["ObjectType"].write(value.objectType)
    }
}

extension CreateIndexInput {

    static func write(value: CreateIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsUnique"].write(value.isUnique)
        try writer["LinkName"].write(value.linkName)
        try writer["OrderedIndexedAttributeList"].writeList(value.orderedIndexedAttributeList, memberWritingClosure: CloudDirectoryClientTypes.AttributeKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ParentReference"].write(value.parentReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CreateObjectInput {

    static func write(value: CreateObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LinkName"].write(value.linkName)
        try writer["ObjectAttributeList"].writeList(value.objectAttributeList, memberWritingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ParentReference"].write(value.parentReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["SchemaFacets"].writeList(value.schemaFacets, memberWritingClosure: CloudDirectoryClientTypes.SchemaFacet.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSchemaInput {

    static func write(value: CreateSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension CreateTypedLinkFacetInput {

    static func write(value: CreateTypedLinkFacetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Facet"].write(value.facet, with: CloudDirectoryClientTypes.TypedLinkFacet.write(value:to:))
    }
}

extension DeleteFacetInput {

    static func write(value: DeleteFacetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteObjectInput {

    static func write(value: DeleteObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension DeleteTypedLinkFacetInput {

    static func write(value: DeleteTypedLinkFacetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DetachFromIndexInput {

    static func write(value: DetachFromIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IndexReference"].write(value.indexReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TargetReference"].write(value.targetReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension DetachObjectInput {

    static func write(value: DetachObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LinkName"].write(value.linkName)
        try writer["ParentReference"].write(value.parentReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension DetachPolicyInput {

    static func write(value: DetachPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["PolicyReference"].write(value.policyReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension DetachTypedLinkInput {

    static func write(value: DetachTypedLinkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TypedLinkSpecifier"].write(value.typedLinkSpecifier, with: CloudDirectoryClientTypes.TypedLinkSpecifier.write(value:to:))
    }
}

extension GetAppliedSchemaVersionInput {

    static func write(value: GetAppliedSchemaVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaArn"].write(value.schemaArn)
    }
}

extension GetFacetInput {

    static func write(value: GetFacetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension GetLinkAttributesInput {

    static func write(value: GetLinkAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeNames"].writeList(value.attributeNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConsistencyLevel"].write(value.consistencyLevel)
        try writer["TypedLinkSpecifier"].write(value.typedLinkSpecifier, with: CloudDirectoryClientTypes.TypedLinkSpecifier.write(value:to:))
    }
}

extension GetObjectAttributesInput {

    static func write(value: GetObjectAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeNames"].writeList(value.attributeNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["SchemaFacet"].write(value.schemaFacet, with: CloudDirectoryClientTypes.SchemaFacet.write(value:to:))
    }
}

extension GetObjectInformationInput {

    static func write(value: GetObjectInformationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension GetTypedLinkFacetInformationInput {

    static func write(value: GetTypedLinkFacetInformationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension ListAppliedSchemaArnsInput {

    static func write(value: ListAppliedSchemaArnsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryArn"].write(value.directoryArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SchemaArn"].write(value.schemaArn)
    }
}

extension ListAttachedIndicesInput {

    static func write(value: ListAttachedIndicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TargetReference"].write(value.targetReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension ListDevelopmentSchemaArnsInput {

    static func write(value: ListDevelopmentSchemaArnsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDirectoriesInput {

    static func write(value: ListDirectoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["state"].write(value.state)
    }
}

extension ListFacetAttributesInput {

    static func write(value: ListFacetAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["Name"].write(value.name)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFacetNamesInput {

    static func write(value: ListFacetNamesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListIncomingTypedLinksInput {

    static func write(value: ListIncomingTypedLinksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConsistencyLevel"].write(value.consistencyLevel)
        try writer["FilterAttributeRanges"].writeList(value.filterAttributeRanges, memberWritingClosure: CloudDirectoryClientTypes.TypedLinkAttributeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterTypedLink"].write(value.filterTypedLink, with: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension ListIndexInput {

    static func write(value: ListIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IndexReference"].write(value.indexReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RangesOnIndexedValues"].writeList(value.rangesOnIndexedValues, memberWritingClosure: CloudDirectoryClientTypes.ObjectAttributeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListManagedSchemaArnsInput {

    static func write(value: ListManagedSchemaArnsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SchemaArn"].write(value.schemaArn)
    }
}

extension ListObjectAttributesInput {

    static func write(value: ListObjectAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FacetFilter"].write(value.facetFilter, with: CloudDirectoryClientTypes.SchemaFacet.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension ListObjectChildrenInput {

    static func write(value: ListObjectChildrenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension ListObjectParentPathsInput {

    static func write(value: ListObjectParentPathsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension ListObjectParentsInput {

    static func write(value: ListObjectParentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeAllLinksToEachParent"].write(value.includeAllLinksToEachParent)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension ListObjectPoliciesInput {

    static func write(value: ListObjectPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension ListOutgoingTypedLinksInput {

    static func write(value: ListOutgoingTypedLinksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConsistencyLevel"].write(value.consistencyLevel)
        try writer["FilterAttributeRanges"].writeList(value.filterAttributeRanges, memberWritingClosure: CloudDirectoryClientTypes.TypedLinkAttributeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterTypedLink"].write(value.filterTypedLink, with: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension ListPolicyAttachmentsInput {

    static func write(value: ListPolicyAttachmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PolicyReference"].write(value.policyReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension ListPublishedSchemaArnsInput {

    static func write(value: ListPublishedSchemaArnsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SchemaArn"].write(value.schemaArn)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListTypedLinkFacetAttributesInput {

    static func write(value: ListTypedLinkFacetAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["Name"].write(value.name)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTypedLinkFacetNamesInput {

    static func write(value: ListTypedLinkFacetNamesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension LookupPolicyInput {

    static func write(value: LookupPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension PublishSchemaInput {

    static func write(value: PublishSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MinorVersion"].write(value.minorVersion)
        try writer["Name"].write(value.name)
        try writer["Version"].write(value.version)
    }
}

extension PutSchemaFromJsonInput {

    static func write(value: PutSchemaFromJsonInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Document"].write(value.document)
    }
}

extension RemoveFacetFromObjectInput {

    static func write(value: RemoveFacetFromObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["SchemaFacet"].write(value.schemaFacet, with: CloudDirectoryClientTypes.SchemaFacet.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: CloudDirectoryClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateFacetInput {

    static func write(value: UpdateFacetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeUpdates"].writeList(value.attributeUpdates, memberWritingClosure: CloudDirectoryClientTypes.FacetAttributeUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ObjectType"].write(value.objectType)
    }
}

extension UpdateLinkAttributesInput {

    static func write(value: UpdateLinkAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeUpdates"].writeList(value.attributeUpdates, memberWritingClosure: CloudDirectoryClientTypes.LinkAttributeUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TypedLinkSpecifier"].write(value.typedLinkSpecifier, with: CloudDirectoryClientTypes.TypedLinkSpecifier.write(value:to:))
    }
}

extension UpdateObjectAttributesInput {

    static func write(value: UpdateObjectAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeUpdates"].writeList(value.attributeUpdates, memberWritingClosure: CloudDirectoryClientTypes.ObjectAttributeUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension UpdateSchemaInput {

    static func write(value: UpdateSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateTypedLinkFacetInput {

    static func write(value: UpdateTypedLinkFacetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeUpdates"].writeList(value.attributeUpdates, memberWritingClosure: CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IdentityAttributeOrder"].writeList(value.identityAttributeOrder, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }
}

extension UpgradeAppliedSchemaInput {

    static func write(value: UpgradeAppliedSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryArn"].write(value.directoryArn)
        try writer["DryRun"].write(value.dryRun)
        try writer["PublishedSchemaArn"].write(value.publishedSchemaArn)
    }
}

extension UpgradePublishedSchemaInput {

    static func write(value: UpgradePublishedSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DevelopmentSchemaArn"].write(value.developmentSchemaArn)
        try writer["DryRun"].write(value.dryRun)
        try writer["MinorVersion"].write(value.minorVersion)
        try writer["PublishedSchemaArn"].write(value.publishedSchemaArn)
    }
}

extension AddFacetToObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddFacetToObjectOutput {
        return AddFacetToObjectOutput()
    }
}

extension ApplySchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ApplySchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ApplySchemaOutput()
        value.appliedSchemaArn = try reader["AppliedSchemaArn"].readIfPresent()
        value.directoryArn = try reader["DirectoryArn"].readIfPresent()
        return value
    }
}

extension AttachObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachObjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AttachObjectOutput()
        value.attachedObjectIdentifier = try reader["AttachedObjectIdentifier"].readIfPresent()
        return value
    }
}

extension AttachPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachPolicyOutput {
        return AttachPolicyOutput()
    }
}

extension AttachToIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachToIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AttachToIndexOutput()
        value.attachedObjectIdentifier = try reader["AttachedObjectIdentifier"].readIfPresent()
        return value
    }
}

extension AttachTypedLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachTypedLinkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AttachTypedLinkOutput()
        value.typedLinkSpecifier = try reader["TypedLinkSpecifier"].readIfPresent(with: CloudDirectoryClientTypes.TypedLinkSpecifier.read(from:))
        return value
    }
}

extension BatchReadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchReadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchReadOutput()
        value.responses = try reader["Responses"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.BatchReadOperationResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchWriteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchWriteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchWriteOutput()
        value.responses = try reader["Responses"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.BatchWriteOperationResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateDirectoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDirectoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDirectoryOutput()
        value.appliedSchemaArn = try reader["AppliedSchemaArn"].readIfPresent() ?? ""
        value.directoryArn = try reader["DirectoryArn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension CreateFacetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFacetOutput {
        return CreateFacetOutput()
    }
}

extension CreateIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIndexOutput()
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CreateObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateObjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateObjectOutput()
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CreateSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSchemaOutput()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        return value
    }
}

extension CreateTypedLinkFacetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTypedLinkFacetOutput {
        return CreateTypedLinkFacetOutput()
    }
}

extension DeleteDirectoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDirectoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDirectoryOutput()
        value.directoryArn = try reader["DirectoryArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteFacetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFacetOutput {
        return DeleteFacetOutput()
    }
}

extension DeleteObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteObjectOutput {
        return DeleteObjectOutput()
    }
}

extension DeleteSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSchemaOutput()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        return value
    }
}

extension DeleteTypedLinkFacetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTypedLinkFacetOutput {
        return DeleteTypedLinkFacetOutput()
    }
}

extension DetachFromIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachFromIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DetachFromIndexOutput()
        value.detachedObjectIdentifier = try reader["DetachedObjectIdentifier"].readIfPresent()
        return value
    }
}

extension DetachObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachObjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DetachObjectOutput()
        value.detachedObjectIdentifier = try reader["DetachedObjectIdentifier"].readIfPresent()
        return value
    }
}

extension DetachPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachPolicyOutput {
        return DetachPolicyOutput()
    }
}

extension DetachTypedLinkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachTypedLinkOutput {
        return DetachTypedLinkOutput()
    }
}

extension DisableDirectoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableDirectoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableDirectoryOutput()
        value.directoryArn = try reader["DirectoryArn"].readIfPresent() ?? ""
        return value
    }
}

extension EnableDirectoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableDirectoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableDirectoryOutput()
        value.directoryArn = try reader["DirectoryArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetAppliedSchemaVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppliedSchemaVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppliedSchemaVersionOutput()
        value.appliedSchemaArn = try reader["AppliedSchemaArn"].readIfPresent()
        return value
    }
}

extension GetDirectoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDirectoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDirectoryOutput()
        value.directory = try reader["Directory"].readIfPresent(with: CloudDirectoryClientTypes.Directory.read(from:))
        return value
    }
}

extension GetFacetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFacetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFacetOutput()
        value.facet = try reader["Facet"].readIfPresent(with: CloudDirectoryClientTypes.Facet.read(from:))
        return value
    }
}

extension GetLinkAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLinkAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLinkAttributesOutput()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetObjectAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetObjectAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetObjectAttributesOutput()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetObjectInformationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetObjectInformationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetObjectInformationOutput()
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        value.schemaFacets = try reader["SchemaFacets"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.SchemaFacet.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSchemaAsJsonOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaAsJsonOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaAsJsonOutput()
        value.document = try reader["Document"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GetTypedLinkFacetInformationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTypedLinkFacetInformationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTypedLinkFacetInformationOutput()
        value.identityAttributeOrder = try reader["IdentityAttributeOrder"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAppliedSchemaArnsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppliedSchemaArnsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppliedSchemaArnsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemaArns = try reader["SchemaArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAttachedIndicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttachedIndicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAttachedIndicesOutput()
        value.indexAttachments = try reader["IndexAttachments"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.IndexAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDevelopmentSchemaArnsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevelopmentSchemaArnsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevelopmentSchemaArnsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemaArns = try reader["SchemaArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDirectoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDirectoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDirectoriesOutput()
        value.directories = try reader["Directories"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.Directory.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFacetAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFacetAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFacetAttributesOutput()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.FacetAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFacetNamesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFacetNamesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFacetNamesOutput()
        value.facetNames = try reader["FacetNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListIncomingTypedLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIncomingTypedLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIncomingTypedLinksOutput()
        value.linkSpecifiers = try reader["LinkSpecifiers"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.TypedLinkSpecifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIndexOutput()
        value.indexAttachments = try reader["IndexAttachments"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.IndexAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListManagedSchemaArnsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedSchemaArnsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedSchemaArnsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemaArns = try reader["SchemaArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListObjectAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListObjectAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListObjectAttributesOutput()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListObjectChildrenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListObjectChildrenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListObjectChildrenOutput()
        value.children = try reader["Children"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListObjectParentPathsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListObjectParentPathsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListObjectParentPathsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pathToObjectIdentifiersList = try reader["PathToObjectIdentifiersList"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.PathToObjectIdentifiers.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListObjectParentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListObjectParentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListObjectParentsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.parentLinks = try reader["ParentLinks"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parents = try reader["Parents"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListObjectPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListObjectPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListObjectPoliciesOutput()
        value.attachedPolicyIds = try reader["AttachedPolicyIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOutgoingTypedLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOutgoingTypedLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOutgoingTypedLinksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.typedLinkSpecifiers = try reader["TypedLinkSpecifiers"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.TypedLinkSpecifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPolicyAttachmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyAttachmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPolicyAttachmentsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.objectIdentifiers = try reader["ObjectIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPublishedSchemaArnsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPublishedSchemaArnsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPublishedSchemaArnsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemaArns = try reader["SchemaArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTypedLinkFacetAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTypedLinkFacetAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTypedLinkFacetAttributesOutput()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.TypedLinkAttributeDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTypedLinkFacetNamesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTypedLinkFacetNamesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTypedLinkFacetNamesOutput()
        value.facetNames = try reader["FacetNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension LookupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> LookupPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = LookupPolicyOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.policyToPathList = try reader["PolicyToPathList"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.PolicyToPath.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PublishSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PublishSchemaOutput()
        value.publishedSchemaArn = try reader["PublishedSchemaArn"].readIfPresent()
        return value
    }
}

extension PutSchemaFromJsonOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSchemaFromJsonOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSchemaFromJsonOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension RemoveFacetFromObjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveFacetFromObjectOutput {
        return RemoveFacetFromObjectOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateFacetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFacetOutput {
        return UpdateFacetOutput()
    }
}

extension UpdateLinkAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLinkAttributesOutput {
        return UpdateLinkAttributesOutput()
    }
}

extension UpdateObjectAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateObjectAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateObjectAttributesOutput()
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        return value
    }
}

extension UpdateSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSchemaOutput()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        return value
    }
}

extension UpdateTypedLinkFacetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTypedLinkFacetOutput {
        return UpdateTypedLinkFacetOutput()
    }
}

extension UpgradeAppliedSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpgradeAppliedSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpgradeAppliedSchemaOutput()
        value.directoryArn = try reader["DirectoryArn"].readIfPresent()
        value.upgradedSchemaArn = try reader["UpgradedSchemaArn"].readIfPresent()
        return value
    }
}

extension UpgradePublishedSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpgradePublishedSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpgradePublishedSchemaOutput()
        value.upgradedSchemaArn = try reader["UpgradedSchemaArn"].readIfPresent()
        return value
    }
}

enum AddFacetToObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ApplySchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidAttachmentException": return try InvalidAttachmentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "SchemaAlreadyExistsException": return try SchemaAlreadyExistsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidAttachmentException": return try InvalidAttachmentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "LinkNameAlreadyInUseException": return try LinkNameAlreadyInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotPolicyException": return try NotPolicyException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachToIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "IndexedAttributeMissingException": return try IndexedAttributeMissingException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidAttachmentException": return try InvalidAttachmentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "LinkNameAlreadyInUseException": return try LinkNameAlreadyInUseException.makeError(baseError: baseError)
            case "NotIndexException": return try NotIndexException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachTypedLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidAttachmentException": return try InvalidAttachmentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchReadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchWriteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BatchWriteException": return try BatchWriteException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDirectoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryAlreadyExistsException": return try DirectoryAlreadyExistsException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFacetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetAlreadyExistsException": return try FacetAlreadyExistsException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidRuleException": return try InvalidRuleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "LinkNameAlreadyInUseException": return try LinkNameAlreadyInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "UnsupportedIndexTypeException": return try UnsupportedIndexTypeException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "LinkNameAlreadyInUseException": return try LinkNameAlreadyInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "UnsupportedIndexTypeException": return try UnsupportedIndexTypeException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "SchemaAlreadyExistsException": return try SchemaAlreadyExistsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTypedLinkFacetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetAlreadyExistsException": return try FacetAlreadyExistsException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidRuleException": return try InvalidRuleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDirectoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryDeletedException": return try DirectoryDeletedException.makeError(baseError: baseError)
            case "DirectoryNotDisabledException": return try DirectoryNotDisabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFacetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetInUseException": return try FacetInUseException.makeError(baseError: baseError)
            case "FacetNotFoundException": return try FacetNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ObjectNotDetachedException": return try ObjectNotDetachedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "StillContainsLinksException": return try StillContainsLinksException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTypedLinkFacetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetNotFoundException": return try FacetNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachFromIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotIndexException": return try NotIndexException.makeError(baseError: baseError)
            case "ObjectAlreadyDetachedException": return try ObjectAlreadyDetachedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotNodeException": return try NotNodeException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotPolicyException": return try NotPolicyException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachTypedLinkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableDirectoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryDeletedException": return try DirectoryDeletedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableDirectoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryDeletedException": return try DirectoryDeletedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppliedSchemaVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDirectoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFacetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetNotFoundException": return try FacetNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLinkAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetObjectAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetObjectInformationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaAsJsonOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTypedLinkFacetInformationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetNotFoundException": return try FacetNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppliedSchemaArnsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttachedIndicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevelopmentSchemaArnsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDirectoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFacetAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetNotFoundException": return try FacetNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFacetNamesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIncomingTypedLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotIndexException": return try NotIndexException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedSchemaArnsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListObjectAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListObjectChildrenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotNodeException": return try NotNodeException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListObjectParentPathsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListObjectParentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "CannotListParentOfRootException": return try CannotListParentOfRootException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListObjectPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOutgoingTypedLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyAttachmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotPolicyException": return try NotPolicyException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPublishedSchemaArnsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidTaggingRequestException": return try InvalidTaggingRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTypedLinkFacetAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetNotFoundException": return try FacetNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTypedLinkFacetNamesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum LookupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "SchemaAlreadyPublishedException": return try SchemaAlreadyPublishedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSchemaFromJsonOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidRuleException": return try InvalidRuleException.makeError(baseError: baseError)
            case "InvalidSchemaDocException": return try InvalidSchemaDocException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveFacetFromObjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidTaggingRequestException": return try InvalidTaggingRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidTaggingRequestException": return try InvalidTaggingRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFacetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetNotFoundException": return try FacetNotFoundException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidFacetUpdateException": return try InvalidFacetUpdateException.makeError(baseError: baseError)
            case "InvalidRuleException": return try InvalidRuleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLinkAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateObjectAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DirectoryNotEnabledException": return try DirectoryNotEnabledException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "LinkNameAlreadyInUseException": return try LinkNameAlreadyInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTypedLinkFacetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "FacetNotFoundException": return try FacetNotFoundException.makeError(baseError: baseError)
            case "FacetValidationException": return try FacetValidationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidFacetUpdateException": return try InvalidFacetUpdateException.makeError(baseError: baseError)
            case "InvalidRuleException": return try InvalidRuleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpgradeAppliedSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IncompatibleSchemaException": return try IncompatibleSchemaException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidAttachmentException": return try InvalidAttachmentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "SchemaAlreadyExistsException": return try SchemaAlreadyExistsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpgradePublishedSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IncompatibleSchemaException": return try IncompatibleSchemaException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidArnException": return try InvalidArnException.makeError(baseError: baseError)
            case "InvalidAttachmentException": return try InvalidAttachmentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "RetryableConflictException": return try RetryableConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension FacetValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> FacetValidationException {
        let reader = baseError.errorBodyReader
        var value = FacetValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidArnException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidArnException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RetryableConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RetryableConflictException {
        let reader = baseError.errorBodyReader
        var value = RetryableConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectoryNotEnabledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DirectoryNotEnabledException {
        let reader = baseError.errorBodyReader
        var value = DirectoryNotEnabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SchemaAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SchemaAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = SchemaAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAttachmentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidAttachmentException {
        let reader = baseError.errorBodyReader
        var value = InvalidAttachmentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LinkNameAlreadyInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LinkNameAlreadyInUseException {
        let reader = baseError.errorBodyReader
        var value = LinkNameAlreadyInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotPolicyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotPolicyException {
        let reader = baseError.errorBodyReader
        var value = NotPolicyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotIndexException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotIndexException {
        let reader = baseError.errorBodyReader
        var value = NotIndexException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IndexedAttributeMissingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IndexedAttributeMissingException {
        let reader = baseError.errorBodyReader
        var value = IndexedAttributeMissingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BatchWriteException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BatchWriteException {
        let reader = baseError.errorBodyReader
        var value = BatchWriteException()
        value.properties.index = try reader["Index"].readIfPresent() ?? 0
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.type = try reader["Type"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectoryAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DirectoryAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = DirectoryAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FacetAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> FacetAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = FacetAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRuleException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRuleException {
        let reader = baseError.errorBodyReader
        var value = InvalidRuleException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedIndexTypeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedIndexTypeException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedIndexTypeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectoryNotDisabledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DirectoryNotDisabledException {
        let reader = baseError.errorBodyReader
        var value = DirectoryNotDisabledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectoryDeletedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DirectoryDeletedException {
        let reader = baseError.errorBodyReader
        var value = DirectoryDeletedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FacetNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> FacetNotFoundException {
        let reader = baseError.errorBodyReader
        var value = FacetNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FacetInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> FacetInUseException {
        let reader = baseError.errorBodyReader
        var value = FacetInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ObjectNotDetachedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ObjectNotDetachedException {
        let reader = baseError.errorBodyReader
        var value = ObjectNotDetachedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StillContainsLinksException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> StillContainsLinksException {
        let reader = baseError.errorBodyReader
        var value = StillContainsLinksException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ObjectAlreadyDetachedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ObjectAlreadyDetachedException {
        let reader = baseError.errorBodyReader
        var value = ObjectAlreadyDetachedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotNodeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotNodeException {
        let reader = baseError.errorBodyReader
        var value = NotNodeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CannotListParentOfRootException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CannotListParentOfRootException {
        let reader = baseError.errorBodyReader
        var value = CannotListParentOfRootException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTaggingRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidTaggingRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidTaggingRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SchemaAlreadyPublishedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SchemaAlreadyPublishedException {
        let reader = baseError.errorBodyReader
        var value = SchemaAlreadyPublishedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSchemaDocException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidSchemaDocException {
        let reader = baseError.errorBodyReader
        var value = InvalidSchemaDocException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidFacetUpdateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidFacetUpdateException {
        let reader = baseError.errorBodyReader
        var value = InvalidFacetUpdateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IncompatibleSchemaException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IncompatibleSchemaException {
        let reader = baseError.errorBodyReader
        var value = IncompatibleSchemaException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudDirectoryClientTypes.TypedLinkSpecifier {

    static func write(value: CloudDirectoryClientTypes.TypedLinkSpecifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityAttributeValues"].writeList(value.identityAttributeValues, memberWritingClosure: CloudDirectoryClientTypes.AttributeNameAndValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceObjectReference"].write(value.sourceObjectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TargetObjectReference"].write(value.targetObjectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TypedLinkFacet"].write(value.typedLinkFacet, with: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.TypedLinkSpecifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.TypedLinkSpecifier()
        value.typedLinkFacet = try reader["TypedLinkFacet"].readIfPresent(with: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.read(from:))
        value.sourceObjectReference = try reader["SourceObjectReference"].readIfPresent(with: CloudDirectoryClientTypes.ObjectReference.read(from:))
        value.targetObjectReference = try reader["TargetObjectReference"].readIfPresent(with: CloudDirectoryClientTypes.ObjectReference.read(from:))
        value.identityAttributeValues = try reader["IdentityAttributeValues"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.AttributeNameAndValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CloudDirectoryClientTypes.AttributeNameAndValue {

    static func write(value: CloudDirectoryClientTypes.AttributeNameAndValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["Value"].write(value.value, with: CloudDirectoryClientTypes.TypedAttributeValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.AttributeNameAndValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.AttributeNameAndValue()
        value.attributeName = try reader["AttributeName"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent(with: CloudDirectoryClientTypes.TypedAttributeValue.read(from:))
        return value
    }
}

extension CloudDirectoryClientTypes.TypedAttributeValue {

    static func write(value: CloudDirectoryClientTypes.TypedAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .binaryvalue(binaryvalue):
                try writer["BinaryValue"].write(binaryvalue)
            case let .booleanvalue(booleanvalue):
                try writer["BooleanValue"].write(booleanvalue)
            case let .datetimevalue(datetimevalue):
                try writer["DatetimeValue"].writeTimestamp(datetimevalue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
            case let .numbervalue(numbervalue):
                try writer["NumberValue"].write(numbervalue)
            case let .stringvalue(stringvalue):
                try writer["StringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.TypedAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "StringValue":
                return .stringvalue(try reader["StringValue"].read())
            case "BinaryValue":
                return .binaryvalue(try reader["BinaryValue"].read())
            case "BooleanValue":
                return .booleanvalue(try reader["BooleanValue"].read())
            case "NumberValue":
                return .numbervalue(try reader["NumberValue"].read())
            case "DatetimeValue":
                return .datetimevalue(try reader["DatetimeValue"].readTimestamp(format: SmithyTimestamps.TimestampFormat.epochSeconds))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CloudDirectoryClientTypes.ObjectReference {

    static func write(value: CloudDirectoryClientTypes.ObjectReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Selector"].write(value.selector)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.ObjectReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.ObjectReference()
        value.selector = try reader["Selector"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName {

    static func write(value: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SchemaArn"].write(value.schemaArn)
        try writer["TypedLinkName"].write(value.typedLinkName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName()
        value.schemaArn = try reader["SchemaArn"].readIfPresent() ?? ""
        value.typedLinkName = try reader["TypedLinkName"].readIfPresent() ?? ""
        return value
    }
}

extension CloudDirectoryClientTypes.BatchReadOperationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchReadOperationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchReadOperationResponse()
        value.successfulResponse = try reader["SuccessfulResponse"].readIfPresent(with: CloudDirectoryClientTypes.BatchReadSuccessfulResponse.read(from:))
        value.exceptionResponse = try reader["ExceptionResponse"].readIfPresent(with: CloudDirectoryClientTypes.BatchReadException.read(from:))
        return value
    }
}

extension CloudDirectoryClientTypes.BatchReadException {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchReadException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchReadException()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchReadSuccessfulResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchReadSuccessfulResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchReadSuccessfulResponse()
        value.listObjectAttributes = try reader["ListObjectAttributes"].readIfPresent(with: CloudDirectoryClientTypes.BatchListObjectAttributesResponse.read(from:))
        value.listObjectChildren = try reader["ListObjectChildren"].readIfPresent(with: CloudDirectoryClientTypes.BatchListObjectChildrenResponse.read(from:))
        value.getObjectInformation = try reader["GetObjectInformation"].readIfPresent(with: CloudDirectoryClientTypes.BatchGetObjectInformationResponse.read(from:))
        value.getObjectAttributes = try reader["GetObjectAttributes"].readIfPresent(with: CloudDirectoryClientTypes.BatchGetObjectAttributesResponse.read(from:))
        value.listAttachedIndices = try reader["ListAttachedIndices"].readIfPresent(with: CloudDirectoryClientTypes.BatchListAttachedIndicesResponse.read(from:))
        value.listObjectParentPaths = try reader["ListObjectParentPaths"].readIfPresent(with: CloudDirectoryClientTypes.BatchListObjectParentPathsResponse.read(from:))
        value.listObjectPolicies = try reader["ListObjectPolicies"].readIfPresent(with: CloudDirectoryClientTypes.BatchListObjectPoliciesResponse.read(from:))
        value.listPolicyAttachments = try reader["ListPolicyAttachments"].readIfPresent(with: CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse.read(from:))
        value.lookupPolicy = try reader["LookupPolicy"].readIfPresent(with: CloudDirectoryClientTypes.BatchLookupPolicyResponse.read(from:))
        value.listIndex = try reader["ListIndex"].readIfPresent(with: CloudDirectoryClientTypes.BatchListIndexResponse.read(from:))
        value.listOutgoingTypedLinks = try reader["ListOutgoingTypedLinks"].readIfPresent(with: CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse.read(from:))
        value.listIncomingTypedLinks = try reader["ListIncomingTypedLinks"].readIfPresent(with: CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse.read(from:))
        value.getLinkAttributes = try reader["GetLinkAttributes"].readIfPresent(with: CloudDirectoryClientTypes.BatchGetLinkAttributesResponse.read(from:))
        value.listObjectParents = try reader["ListObjectParents"].readIfPresent(with: CloudDirectoryClientTypes.BatchListObjectParentsResponse.read(from:))
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListObjectParentsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListObjectParentsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListObjectParentsResponse()
        value.parentLinks = try reader["ParentLinks"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple()
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        value.linkName = try reader["LinkName"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchGetLinkAttributesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchGetLinkAttributesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchGetLinkAttributesResponse()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CloudDirectoryClientTypes.AttributeKeyAndValue {

    static func write(value: CloudDirectoryClientTypes.AttributeKeyAndValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key, with: CloudDirectoryClientTypes.AttributeKey.write(value:to:))
        try writer["Value"].write(value.value, with: CloudDirectoryClientTypes.TypedAttributeValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.AttributeKeyAndValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.AttributeKeyAndValue()
        value.key = try reader["Key"].readIfPresent(with: CloudDirectoryClientTypes.AttributeKey.read(from:))
        value.value = try reader["Value"].readIfPresent(with: CloudDirectoryClientTypes.TypedAttributeValue.read(from:))
        return value
    }
}

extension CloudDirectoryClientTypes.AttributeKey {

    static func write(value: CloudDirectoryClientTypes.AttributeKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FacetName"].write(value.facetName)
        try writer["Name"].write(value.name)
        try writer["SchemaArn"].write(value.schemaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.AttributeKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.AttributeKey()
        value.schemaArn = try reader["SchemaArn"].readIfPresent() ?? ""
        value.facetName = try reader["FacetName"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse()
        value.linkSpecifiers = try reader["LinkSpecifiers"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.TypedLinkSpecifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse()
        value.typedLinkSpecifiers = try reader["TypedLinkSpecifiers"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.TypedLinkSpecifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListIndexResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListIndexResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListIndexResponse()
        value.indexAttachments = try reader["IndexAttachments"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.IndexAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.IndexAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.IndexAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.IndexAttachment()
        value.indexedAttributes = try reader["IndexedAttributes"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchLookupPolicyResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchLookupPolicyResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchLookupPolicyResponse()
        value.policyToPathList = try reader["PolicyToPathList"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.PolicyToPath.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.PolicyToPath {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.PolicyToPath {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.PolicyToPath()
        value.path = try reader["Path"].readIfPresent()
        value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.PolicyAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CloudDirectoryClientTypes.PolicyAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.PolicyAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.PolicyAttachment()
        value.policyId = try reader["PolicyId"].readIfPresent()
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        value.policyType = try reader["PolicyType"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse()
        value.objectIdentifiers = try reader["ObjectIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListObjectPoliciesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListObjectPoliciesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListObjectPoliciesResponse()
        value.attachedPolicyIds = try reader["AttachedPolicyIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListObjectParentPathsResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListObjectParentPathsResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListObjectParentPathsResponse()
        value.pathToObjectIdentifiersList = try reader["PathToObjectIdentifiersList"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.PathToObjectIdentifiers.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.PathToObjectIdentifiers {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.PathToObjectIdentifiers {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.PathToObjectIdentifiers()
        value.path = try reader["Path"].readIfPresent()
        value.objectIdentifiers = try reader["ObjectIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListAttachedIndicesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListAttachedIndicesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListAttachedIndicesResponse()
        value.indexAttachments = try reader["IndexAttachments"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.IndexAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchGetObjectAttributesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchGetObjectAttributesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchGetObjectAttributesResponse()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CloudDirectoryClientTypes.BatchGetObjectInformationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchGetObjectInformationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchGetObjectInformationResponse()
        value.schemaFacets = try reader["SchemaFacets"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.SchemaFacet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.SchemaFacet {

    static func write(value: CloudDirectoryClientTypes.SchemaFacet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FacetName"].write(value.facetName)
        try writer["SchemaArn"].write(value.schemaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.SchemaFacet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.SchemaFacet()
        value.schemaArn = try reader["SchemaArn"].readIfPresent()
        value.facetName = try reader["FacetName"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListObjectChildrenResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListObjectChildrenResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListObjectChildrenResponse()
        value.children = try reader["Children"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchListObjectAttributesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchListObjectAttributesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchListObjectAttributesResponse()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchWriteOperationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchWriteOperationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchWriteOperationResponse()
        value.createObject = try reader["CreateObject"].readIfPresent(with: CloudDirectoryClientTypes.BatchCreateObjectResponse.read(from:))
        value.attachObject = try reader["AttachObject"].readIfPresent(with: CloudDirectoryClientTypes.BatchAttachObjectResponse.read(from:))
        value.detachObject = try reader["DetachObject"].readIfPresent(with: CloudDirectoryClientTypes.BatchDetachObjectResponse.read(from:))
        value.updateObjectAttributes = try reader["UpdateObjectAttributes"].readIfPresent(with: CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse.read(from:))
        value.deleteObject = try reader["DeleteObject"].readIfPresent(with: CloudDirectoryClientTypes.BatchDeleteObjectResponse.read(from:))
        value.addFacetToObject = try reader["AddFacetToObject"].readIfPresent(with: CloudDirectoryClientTypes.BatchAddFacetToObjectResponse.read(from:))
        value.removeFacetFromObject = try reader["RemoveFacetFromObject"].readIfPresent(with: CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse.read(from:))
        value.attachPolicy = try reader["AttachPolicy"].readIfPresent(with: CloudDirectoryClientTypes.BatchAttachPolicyResponse.read(from:))
        value.detachPolicy = try reader["DetachPolicy"].readIfPresent(with: CloudDirectoryClientTypes.BatchDetachPolicyResponse.read(from:))
        value.createIndex = try reader["CreateIndex"].readIfPresent(with: CloudDirectoryClientTypes.BatchCreateIndexResponse.read(from:))
        value.attachToIndex = try reader["AttachToIndex"].readIfPresent(with: CloudDirectoryClientTypes.BatchAttachToIndexResponse.read(from:))
        value.detachFromIndex = try reader["DetachFromIndex"].readIfPresent(with: CloudDirectoryClientTypes.BatchDetachFromIndexResponse.read(from:))
        value.attachTypedLink = try reader["AttachTypedLink"].readIfPresent(with: CloudDirectoryClientTypes.BatchAttachTypedLinkResponse.read(from:))
        value.detachTypedLink = try reader["DetachTypedLink"].readIfPresent(with: CloudDirectoryClientTypes.BatchDetachTypedLinkResponse.read(from:))
        value.updateLinkAttributes = try reader["UpdateLinkAttributes"].readIfPresent(with: CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse.read(from:))
        return value
    }
}

extension CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse()
    }
}

extension CloudDirectoryClientTypes.BatchDetachTypedLinkResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchDetachTypedLinkResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return CloudDirectoryClientTypes.BatchDetachTypedLinkResponse()
    }
}

extension CloudDirectoryClientTypes.BatchAttachTypedLinkResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchAttachTypedLinkResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchAttachTypedLinkResponse()
        value.typedLinkSpecifier = try reader["TypedLinkSpecifier"].readIfPresent(with: CloudDirectoryClientTypes.TypedLinkSpecifier.read(from:))
        return value
    }
}

extension CloudDirectoryClientTypes.BatchDetachFromIndexResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchDetachFromIndexResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchDetachFromIndexResponse()
        value.detachedObjectIdentifier = try reader["DetachedObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchAttachToIndexResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchAttachToIndexResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchAttachToIndexResponse()
        value.attachedObjectIdentifier = try reader["AttachedObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchCreateIndexResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchCreateIndexResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchCreateIndexResponse()
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchDetachPolicyResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchDetachPolicyResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return CloudDirectoryClientTypes.BatchDetachPolicyResponse()
    }
}

extension CloudDirectoryClientTypes.BatchAttachPolicyResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchAttachPolicyResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return CloudDirectoryClientTypes.BatchAttachPolicyResponse()
    }
}

extension CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse()
    }
}

extension CloudDirectoryClientTypes.BatchAddFacetToObjectResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchAddFacetToObjectResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return CloudDirectoryClientTypes.BatchAddFacetToObjectResponse()
    }
}

extension CloudDirectoryClientTypes.BatchDeleteObjectResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchDeleteObjectResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return CloudDirectoryClientTypes.BatchDeleteObjectResponse()
    }
}

extension CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse()
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchDetachObjectResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchDetachObjectResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchDetachObjectResponse()
        value.detachedObjectIdentifier = try reader["detachedObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchAttachObjectResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchAttachObjectResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchAttachObjectResponse()
        value.attachedObjectIdentifier = try reader["attachedObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.BatchCreateObjectResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.BatchCreateObjectResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.BatchCreateObjectResponse()
        value.objectIdentifier = try reader["ObjectIdentifier"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.Directory {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.Directory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.Directory()
        value.name = try reader["Name"].readIfPresent()
        value.directoryArn = try reader["DirectoryArn"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.creationDateTime = try reader["CreationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CloudDirectoryClientTypes.Facet {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.Facet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.Facet()
        value.name = try reader["Name"].readIfPresent()
        value.objectType = try reader["ObjectType"].readIfPresent()
        value.facetStyle = try reader["FacetStyle"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.FacetAttribute {

    static func write(value: CloudDirectoryClientTypes.FacetAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeDefinition"].write(value.attributeDefinition, with: CloudDirectoryClientTypes.FacetAttributeDefinition.write(value:to:))
        try writer["AttributeReference"].write(value.attributeReference, with: CloudDirectoryClientTypes.FacetAttributeReference.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RequiredBehavior"].write(value.requiredBehavior)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.FacetAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.FacetAttribute()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.attributeDefinition = try reader["AttributeDefinition"].readIfPresent(with: CloudDirectoryClientTypes.FacetAttributeDefinition.read(from:))
        value.attributeReference = try reader["AttributeReference"].readIfPresent(with: CloudDirectoryClientTypes.FacetAttributeReference.read(from:))
        value.requiredBehavior = try reader["RequiredBehavior"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.FacetAttributeReference {

    static func write(value: CloudDirectoryClientTypes.FacetAttributeReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetAttributeName"].write(value.targetAttributeName)
        try writer["TargetFacetName"].write(value.targetFacetName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.FacetAttributeReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.FacetAttributeReference()
        value.targetFacetName = try reader["TargetFacetName"].readIfPresent() ?? ""
        value.targetAttributeName = try reader["TargetAttributeName"].readIfPresent() ?? ""
        return value
    }
}

extension CloudDirectoryClientTypes.FacetAttributeDefinition {

    static func write(value: CloudDirectoryClientTypes.FacetAttributeDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue, with: CloudDirectoryClientTypes.TypedAttributeValue.write(value:to:))
        try writer["IsImmutable"].write(value.isImmutable)
        try writer["Rules"].writeMap(value.rules, valueWritingClosure: CloudDirectoryClientTypes.Rule.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.FacetAttributeDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.FacetAttributeDefinition()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.defaultValue = try reader["DefaultValue"].readIfPresent(with: CloudDirectoryClientTypes.TypedAttributeValue.read(from:))
        value.isImmutable = try reader["IsImmutable"].readIfPresent() ?? false
        value.rules = try reader["Rules"].readMapIfPresent(valueReadingClosure: CloudDirectoryClientTypes.Rule.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CloudDirectoryClientTypes.Rule {

    static func write(value: CloudDirectoryClientTypes.Rule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.Rule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.Rule()
        value.type = try reader["Type"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CloudDirectoryClientTypes.Tag {

    static func write(value: CloudDirectoryClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension CloudDirectoryClientTypes.TypedLinkAttributeDefinition {

    static func write(value: CloudDirectoryClientTypes.TypedLinkAttributeDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue, with: CloudDirectoryClientTypes.TypedAttributeValue.write(value:to:))
        try writer["IsImmutable"].write(value.isImmutable)
        try writer["Name"].write(value.name)
        try writer["RequiredBehavior"].write(value.requiredBehavior)
        try writer["Rules"].writeMap(value.rules, valueWritingClosure: CloudDirectoryClientTypes.Rule.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CloudDirectoryClientTypes.TypedLinkAttributeDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudDirectoryClientTypes.TypedLinkAttributeDefinition()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.defaultValue = try reader["DefaultValue"].readIfPresent(with: CloudDirectoryClientTypes.TypedAttributeValue.read(from:))
        value.isImmutable = try reader["IsImmutable"].readIfPresent() ?? false
        value.rules = try reader["Rules"].readMapIfPresent(valueReadingClosure: CloudDirectoryClientTypes.Rule.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requiredBehavior = try reader["RequiredBehavior"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CloudDirectoryClientTypes.BatchReadOperation {

    static func write(value: CloudDirectoryClientTypes.BatchReadOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GetLinkAttributes"].write(value.getLinkAttributes, with: CloudDirectoryClientTypes.BatchGetLinkAttributes.write(value:to:))
        try writer["GetObjectAttributes"].write(value.getObjectAttributes, with: CloudDirectoryClientTypes.BatchGetObjectAttributes.write(value:to:))
        try writer["GetObjectInformation"].write(value.getObjectInformation, with: CloudDirectoryClientTypes.BatchGetObjectInformation.write(value:to:))
        try writer["ListAttachedIndices"].write(value.listAttachedIndices, with: CloudDirectoryClientTypes.BatchListAttachedIndices.write(value:to:))
        try writer["ListIncomingTypedLinks"].write(value.listIncomingTypedLinks, with: CloudDirectoryClientTypes.BatchListIncomingTypedLinks.write(value:to:))
        try writer["ListIndex"].write(value.listIndex, with: CloudDirectoryClientTypes.BatchListIndex.write(value:to:))
        try writer["ListObjectAttributes"].write(value.listObjectAttributes, with: CloudDirectoryClientTypes.BatchListObjectAttributes.write(value:to:))
        try writer["ListObjectChildren"].write(value.listObjectChildren, with: CloudDirectoryClientTypes.BatchListObjectChildren.write(value:to:))
        try writer["ListObjectParentPaths"].write(value.listObjectParentPaths, with: CloudDirectoryClientTypes.BatchListObjectParentPaths.write(value:to:))
        try writer["ListObjectParents"].write(value.listObjectParents, with: CloudDirectoryClientTypes.BatchListObjectParents.write(value:to:))
        try writer["ListObjectPolicies"].write(value.listObjectPolicies, with: CloudDirectoryClientTypes.BatchListObjectPolicies.write(value:to:))
        try writer["ListOutgoingTypedLinks"].write(value.listOutgoingTypedLinks, with: CloudDirectoryClientTypes.BatchListOutgoingTypedLinks.write(value:to:))
        try writer["ListPolicyAttachments"].write(value.listPolicyAttachments, with: CloudDirectoryClientTypes.BatchListPolicyAttachments.write(value:to:))
        try writer["LookupPolicy"].write(value.lookupPolicy, with: CloudDirectoryClientTypes.BatchLookupPolicy.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchGetLinkAttributes {

    static func write(value: CloudDirectoryClientTypes.BatchGetLinkAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeNames"].writeList(value.attributeNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TypedLinkSpecifier"].write(value.typedLinkSpecifier, with: CloudDirectoryClientTypes.TypedLinkSpecifier.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListIncomingTypedLinks {

    static func write(value: CloudDirectoryClientTypes.BatchListIncomingTypedLinks?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterAttributeRanges"].writeList(value.filterAttributeRanges, memberWritingClosure: CloudDirectoryClientTypes.TypedLinkAttributeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterTypedLink"].write(value.filterTypedLink, with: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.TypedLinkAttributeRange {

    static func write(value: CloudDirectoryClientTypes.TypedLinkAttributeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["Range"].write(value.range, with: CloudDirectoryClientTypes.TypedAttributeValueRange.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.TypedAttributeValueRange {

    static func write(value: CloudDirectoryClientTypes.TypedAttributeValueRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndMode"].write(value.endMode)
        try writer["EndValue"].write(value.endValue, with: CloudDirectoryClientTypes.TypedAttributeValue.write(value:to:))
        try writer["StartMode"].write(value.startMode)
        try writer["StartValue"].write(value.startValue, with: CloudDirectoryClientTypes.TypedAttributeValue.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListOutgoingTypedLinks {

    static func write(value: CloudDirectoryClientTypes.BatchListOutgoingTypedLinks?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterAttributeRanges"].writeList(value.filterAttributeRanges, memberWritingClosure: CloudDirectoryClientTypes.TypedLinkAttributeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterTypedLink"].write(value.filterTypedLink, with: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListIndex {

    static func write(value: CloudDirectoryClientTypes.BatchListIndex?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IndexReference"].write(value.indexReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RangesOnIndexedValues"].writeList(value.rangesOnIndexedValues, memberWritingClosure: CloudDirectoryClientTypes.ObjectAttributeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CloudDirectoryClientTypes.ObjectAttributeRange {

    static func write(value: CloudDirectoryClientTypes.ObjectAttributeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeKey"].write(value.attributeKey, with: CloudDirectoryClientTypes.AttributeKey.write(value:to:))
        try writer["Range"].write(value.range, with: CloudDirectoryClientTypes.TypedAttributeValueRange.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchLookupPolicy {

    static func write(value: CloudDirectoryClientTypes.BatchLookupPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListPolicyAttachments {

    static func write(value: CloudDirectoryClientTypes.BatchListPolicyAttachments?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PolicyReference"].write(value.policyReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListObjectPolicies {

    static func write(value: CloudDirectoryClientTypes.BatchListObjectPolicies?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListObjectParents {

    static func write(value: CloudDirectoryClientTypes.BatchListObjectParents?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchGetObjectAttributes {

    static func write(value: CloudDirectoryClientTypes.BatchGetObjectAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeNames"].writeList(value.attributeNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["SchemaFacet"].write(value.schemaFacet, with: CloudDirectoryClientTypes.SchemaFacet.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchGetObjectInformation {

    static func write(value: CloudDirectoryClientTypes.BatchGetObjectInformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListObjectParentPaths {

    static func write(value: CloudDirectoryClientTypes.BatchListObjectParentPaths?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListAttachedIndices {

    static func write(value: CloudDirectoryClientTypes.BatchListAttachedIndices?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TargetReference"].write(value.targetReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListObjectChildren {

    static func write(value: CloudDirectoryClientTypes.BatchListObjectChildren?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchListObjectAttributes {

    static func write(value: CloudDirectoryClientTypes.BatchListObjectAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FacetFilter"].write(value.facetFilter, with: CloudDirectoryClientTypes.SchemaFacet.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchWriteOperation {

    static func write(value: CloudDirectoryClientTypes.BatchWriteOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddFacetToObject"].write(value.addFacetToObject, with: CloudDirectoryClientTypes.BatchAddFacetToObject.write(value:to:))
        try writer["AttachObject"].write(value.attachObject, with: CloudDirectoryClientTypes.BatchAttachObject.write(value:to:))
        try writer["AttachPolicy"].write(value.attachPolicy, with: CloudDirectoryClientTypes.BatchAttachPolicy.write(value:to:))
        try writer["AttachToIndex"].write(value.attachToIndex, with: CloudDirectoryClientTypes.BatchAttachToIndex.write(value:to:))
        try writer["AttachTypedLink"].write(value.attachTypedLink, with: CloudDirectoryClientTypes.BatchAttachTypedLink.write(value:to:))
        try writer["CreateIndex"].write(value.createIndex, with: CloudDirectoryClientTypes.BatchCreateIndex.write(value:to:))
        try writer["CreateObject"].write(value.createObject, with: CloudDirectoryClientTypes.BatchCreateObject.write(value:to:))
        try writer["DeleteObject"].write(value.deleteObject, with: CloudDirectoryClientTypes.BatchDeleteObject.write(value:to:))
        try writer["DetachFromIndex"].write(value.detachFromIndex, with: CloudDirectoryClientTypes.BatchDetachFromIndex.write(value:to:))
        try writer["DetachObject"].write(value.detachObject, with: CloudDirectoryClientTypes.BatchDetachObject.write(value:to:))
        try writer["DetachPolicy"].write(value.detachPolicy, with: CloudDirectoryClientTypes.BatchDetachPolicy.write(value:to:))
        try writer["DetachTypedLink"].write(value.detachTypedLink, with: CloudDirectoryClientTypes.BatchDetachTypedLink.write(value:to:))
        try writer["RemoveFacetFromObject"].write(value.removeFacetFromObject, with: CloudDirectoryClientTypes.BatchRemoveFacetFromObject.write(value:to:))
        try writer["UpdateLinkAttributes"].write(value.updateLinkAttributes, with: CloudDirectoryClientTypes.BatchUpdateLinkAttributes.write(value:to:))
        try writer["UpdateObjectAttributes"].write(value.updateObjectAttributes, with: CloudDirectoryClientTypes.BatchUpdateObjectAttributes.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchUpdateLinkAttributes {

    static func write(value: CloudDirectoryClientTypes.BatchUpdateLinkAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeUpdates"].writeList(value.attributeUpdates, memberWritingClosure: CloudDirectoryClientTypes.LinkAttributeUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TypedLinkSpecifier"].write(value.typedLinkSpecifier, with: CloudDirectoryClientTypes.TypedLinkSpecifier.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.LinkAttributeUpdate {

    static func write(value: CloudDirectoryClientTypes.LinkAttributeUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeAction"].write(value.attributeAction, with: CloudDirectoryClientTypes.LinkAttributeAction.write(value:to:))
        try writer["AttributeKey"].write(value.attributeKey, with: CloudDirectoryClientTypes.AttributeKey.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.LinkAttributeAction {

    static func write(value: CloudDirectoryClientTypes.LinkAttributeAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeActionType"].write(value.attributeActionType)
        try writer["AttributeUpdateValue"].write(value.attributeUpdateValue, with: CloudDirectoryClientTypes.TypedAttributeValue.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchDetachTypedLink {

    static func write(value: CloudDirectoryClientTypes.BatchDetachTypedLink?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TypedLinkSpecifier"].write(value.typedLinkSpecifier, with: CloudDirectoryClientTypes.TypedLinkSpecifier.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchAttachTypedLink {

    static func write(value: CloudDirectoryClientTypes.BatchAttachTypedLink?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeList(value.attributes, memberWritingClosure: CloudDirectoryClientTypes.AttributeNameAndValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceObjectReference"].write(value.sourceObjectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TargetObjectReference"].write(value.targetObjectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TypedLinkFacet"].write(value.typedLinkFacet, with: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchDetachFromIndex {

    static func write(value: CloudDirectoryClientTypes.BatchDetachFromIndex?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IndexReference"].write(value.indexReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TargetReference"].write(value.targetReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchAttachToIndex {

    static func write(value: CloudDirectoryClientTypes.BatchAttachToIndex?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IndexReference"].write(value.indexReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["TargetReference"].write(value.targetReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchCreateIndex {

    static func write(value: CloudDirectoryClientTypes.BatchCreateIndex?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BatchReferenceName"].write(value.batchReferenceName)
        try writer["IsUnique"].write(value.isUnique)
        try writer["LinkName"].write(value.linkName)
        try writer["OrderedIndexedAttributeList"].writeList(value.orderedIndexedAttributeList, memberWritingClosure: CloudDirectoryClientTypes.AttributeKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ParentReference"].write(value.parentReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchDetachPolicy {

    static func write(value: CloudDirectoryClientTypes.BatchDetachPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["PolicyReference"].write(value.policyReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchAttachPolicy {

    static func write(value: CloudDirectoryClientTypes.BatchAttachPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["PolicyReference"].write(value.policyReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchRemoveFacetFromObject {

    static func write(value: CloudDirectoryClientTypes.BatchRemoveFacetFromObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["SchemaFacet"].write(value.schemaFacet, with: CloudDirectoryClientTypes.SchemaFacet.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchAddFacetToObject {

    static func write(value: CloudDirectoryClientTypes.BatchAddFacetToObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectAttributeList"].writeList(value.objectAttributeList, memberWritingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["SchemaFacet"].write(value.schemaFacet, with: CloudDirectoryClientTypes.SchemaFacet.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchDeleteObject {

    static func write(value: CloudDirectoryClientTypes.BatchDeleteObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchUpdateObjectAttributes {

    static func write(value: CloudDirectoryClientTypes.BatchUpdateObjectAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeUpdates"].writeList(value.attributeUpdates, memberWritingClosure: CloudDirectoryClientTypes.ObjectAttributeUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ObjectReference"].write(value.objectReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.ObjectAttributeUpdate {

    static func write(value: CloudDirectoryClientTypes.ObjectAttributeUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectAttributeAction"].write(value.objectAttributeAction, with: CloudDirectoryClientTypes.ObjectAttributeAction.write(value:to:))
        try writer["ObjectAttributeKey"].write(value.objectAttributeKey, with: CloudDirectoryClientTypes.AttributeKey.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.ObjectAttributeAction {

    static func write(value: CloudDirectoryClientTypes.ObjectAttributeAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectAttributeActionType"].write(value.objectAttributeActionType)
        try writer["ObjectAttributeUpdateValue"].write(value.objectAttributeUpdateValue, with: CloudDirectoryClientTypes.TypedAttributeValue.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchDetachObject {

    static func write(value: CloudDirectoryClientTypes.BatchDetachObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BatchReferenceName"].write(value.batchReferenceName)
        try writer["LinkName"].write(value.linkName)
        try writer["ParentReference"].write(value.parentReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchAttachObject {

    static func write(value: CloudDirectoryClientTypes.BatchAttachObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChildReference"].write(value.childReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["LinkName"].write(value.linkName)
        try writer["ParentReference"].write(value.parentReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.BatchCreateObject {

    static func write(value: CloudDirectoryClientTypes.BatchCreateObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BatchReferenceName"].write(value.batchReferenceName)
        try writer["LinkName"].write(value.linkName)
        try writer["ObjectAttributeList"].writeList(value.objectAttributeList, memberWritingClosure: CloudDirectoryClientTypes.AttributeKeyAndValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ParentReference"].write(value.parentReference, with: CloudDirectoryClientTypes.ObjectReference.write(value:to:))
        try writer["SchemaFacet"].writeList(value.schemaFacet, memberWritingClosure: CloudDirectoryClientTypes.SchemaFacet.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CloudDirectoryClientTypes.TypedLinkFacet {

    static func write(value: CloudDirectoryClientTypes.TypedLinkFacet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeList(value.attributes, memberWritingClosure: CloudDirectoryClientTypes.TypedLinkAttributeDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IdentityAttributeOrder"].writeList(value.identityAttributeOrder, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }
}

extension CloudDirectoryClientTypes.FacetAttributeUpdate {

    static func write(value: CloudDirectoryClientTypes.FacetAttributeUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Attribute"].write(value.attribute, with: CloudDirectoryClientTypes.FacetAttribute.write(value:to:))
    }
}

extension CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate {

    static func write(value: CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Attribute"].write(value.attribute, with: CloudDirectoryClientTypes.TypedLinkAttributeDefinition.write(value:to:))
    }
}

public enum CloudDirectoryClientTypes {}
