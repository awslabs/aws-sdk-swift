// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access denied or directory not found. Either you don't have permissions for this directory or the directory does not exist. Try calling [ListDirectories] and check your permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddFacetToObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeList = "ObjectAttributeList"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvalue0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvalue0)
            }
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = self.schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }
}

extension AddFacetToObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension AddFacetToObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/facets"
    }
}

public struct AddFacetToObjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Attributes on the facet that you are adding to the object.
    public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    /// A reference to the object you are adding the specified facet to.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifiers for the facet that you are adding to the object. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

    public init(
        directoryArn: Swift.String? = nil,
        objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectAttributeList = objectAttributeList
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

struct AddFacetToObjectInputBody: Swift.Equatable {
    let schemaFacet: CloudDirectoryClientTypes.SchemaFacet?
    let objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension AddFacetToObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeList = "ObjectAttributeList"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension AddFacetToObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AddFacetToObjectOutput: Swift.Equatable {

    public init() { }
}

enum AddFacetToObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplySchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publishedSchemaArn = self.publishedSchemaArn {
            try encodeContainer.encode(publishedSchemaArn, forKey: .publishedSchemaArn)
        }
    }
}

extension ApplySchemaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ApplySchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/apply"
    }
}

public struct ApplySchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] into which the schema is copied. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Published schema Amazon Resource Name (ARN) that needs to be copied. For more information, see [arns].
    /// This member is required.
    public var publishedSchemaArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil,
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct ApplySchemaInputBody: Swift.Equatable {
    let publishedSchemaArn: Swift.String?
}

extension ApplySchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
    }
}

extension ApplySchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ApplySchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.appliedSchemaArn = output.appliedSchemaArn
            self.directoryArn = output.directoryArn
        } else {
            self.appliedSchemaArn = nil
            self.directoryArn = nil
        }
    }
}

public struct ApplySchemaOutput: Swift.Equatable {
    /// The applied schema ARN that is associated with the copied schema in the [Directory]. You can use this ARN to describe the schema information applied on this directory. For more information, see [arns].
    public var appliedSchemaArn: Swift.String?
    /// The ARN that is associated with the [Directory]. For more information, see [arns].
    public var directoryArn: Swift.String?

    public init(
        appliedSchemaArn: Swift.String? = nil,
        directoryArn: Swift.String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
        self.directoryArn = directoryArn
    }
}

struct ApplySchemaOutputBody: Swift.Equatable {
    let appliedSchemaArn: Swift.String?
    let directoryArn: Swift.String?
}

extension ApplySchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedSchemaArn = "AppliedSchemaArn"
        case directoryArn = "DirectoryArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appliedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appliedSchemaArn)
        appliedSchemaArn = appliedSchemaArnDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

enum ApplySchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAttachmentException": return try await InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SchemaAlreadyExistsException": return try await SchemaAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childReference = "ChildReference"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childReference = self.childReference {
            try encodeContainer.encode(childReference, forKey: .childReference)
        }
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = self.parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }
}

extension AttachObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension AttachObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/attach"
    }
}

public struct AttachObjectInput: Swift.Equatable {
    /// The child object reference to be attached to the object.
    /// This member is required.
    public var childReference: CloudDirectoryClientTypes.ObjectReference?
    /// Amazon Resource Name (ARN) that is associated with the [Directory] where both objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The link name with which the child object is attached to the parent.
    /// This member is required.
    public var linkName: Swift.String?
    /// The parent object reference.
    /// This member is required.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        childReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        directoryArn: Swift.String? = nil,
        linkName: Swift.String? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.childReference = childReference
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

struct AttachObjectInputBody: Swift.Equatable {
    let parentReference: CloudDirectoryClientTypes.ObjectReference?
    let childReference: CloudDirectoryClientTypes.ObjectReference?
    let linkName: Swift.String?
}

extension AttachObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childReference = "ChildReference"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let childReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .childReference)
        childReference = childReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension AttachObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AttachObjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedObjectIdentifier = output.attachedObjectIdentifier
        } else {
            self.attachedObjectIdentifier = nil
        }
    }
}

public struct AttachObjectOutput: Swift.Equatable {
    /// The attached ObjectIdentifier, which is the child ObjectIdentifier.
    public var attachedObjectIdentifier: Swift.String?

    public init(
        attachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

struct AttachObjectOutputBody: Swift.Equatable {
    let attachedObjectIdentifier: Swift.String?
}

extension AttachObjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedObjectIdentifier = "AttachedObjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

enum AttachObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAttachmentException": return try await InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LinkNameAlreadyInUseException": return try await LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = self.policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }
}

extension AttachPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension AttachPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/policy/attach"
    }
}

public struct AttachPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where both objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The reference that identifies the object to which the policy will be attached.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// The reference that is associated with the policy object.
    /// This member is required.
    public var policyReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

struct AttachPolicyInputBody: Swift.Equatable {
    let policyReference: CloudDirectoryClientTypes.ObjectReference?
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension AttachPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension AttachPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachPolicyOutput: Swift.Equatable {

    public init() { }
}

enum AttachPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotPolicyException": return try await NotPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachToIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = self.indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = self.targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }
}

extension AttachToIndexInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension AttachToIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/index/attach"
    }
}

public struct AttachToIndexInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the directory where the object and index exist.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the index that you are attaching the object to.
    /// This member is required.
    public var indexReference: CloudDirectoryClientTypes.ObjectReference?
    /// A reference to the object that you are attaching to the index.
    /// This member is required.
    public var targetReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

struct AttachToIndexInputBody: Swift.Equatable {
    let indexReference: CloudDirectoryClientTypes.ObjectReference?
    let targetReference: CloudDirectoryClientTypes.ObjectReference?
}

extension AttachToIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension AttachToIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AttachToIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedObjectIdentifier = output.attachedObjectIdentifier
        } else {
            self.attachedObjectIdentifier = nil
        }
    }
}

public struct AttachToIndexOutput: Swift.Equatable {
    /// The ObjectIdentifier of the object that was attached to the index.
    public var attachedObjectIdentifier: Swift.String?

    public init(
        attachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.attachedObjectIdentifier = attachedObjectIdentifier
    }
}

struct AttachToIndexOutputBody: Swift.Equatable {
    let attachedObjectIdentifier: Swift.String?
}

extension AttachToIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedObjectIdentifier = "AttachedObjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

enum AttachToIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IndexedAttributeMissingException": return try await IndexedAttributeMissingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAttachmentException": return try await InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LinkNameAlreadyInUseException": return try await LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotIndexException": return try await NotIndexException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachTypedLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenameandvalue0 in attributes {
                try attributesContainer.encode(attributenameandvalue0)
            }
        }
        if let sourceObjectReference = self.sourceObjectReference {
            try encodeContainer.encode(sourceObjectReference, forKey: .sourceObjectReference)
        }
        if let targetObjectReference = self.targetObjectReference {
            try encodeContainer.encode(targetObjectReference, forKey: .targetObjectReference)
        }
        if let typedLinkFacet = self.typedLinkFacet {
            try encodeContainer.encode(typedLinkFacet, forKey: .typedLinkFacet)
        }
    }
}

extension AttachTypedLinkInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension AttachTypedLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/attach"
    }
}

public struct AttachTypedLinkInput: Swift.Equatable {
    /// A set of attributes that are associated with the typed link.
    /// This member is required.
    public var attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]?
    /// The Amazon Resource Name (ARN) of the directory where you want to attach the typed link.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Identifies the source object that the typed link will attach to.
    /// This member is required.
    public var sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifies the target object that the typed link will attach to.
    /// This member is required.
    public var targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifies the typed link facet that is associated with the typed link.
    /// This member is required.
    public var typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?

    public init(
        attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]? = nil,
        directoryArn: Swift.String? = nil,
        sourceObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        targetObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil
    )
    {
        self.attributes = attributes
        self.directoryArn = directoryArn
        self.sourceObjectReference = sourceObjectReference
        self.targetObjectReference = targetObjectReference
        self.typedLinkFacet = typedLinkFacet
    }
}

struct AttachTypedLinkInputBody: Swift.Equatable {
    let sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
    let targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
    let typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    let attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]?
}

extension AttachTypedLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .sourceObjectReference)
        sourceObjectReference = sourceObjectReferenceDecoded
        let targetObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetObjectReference)
        targetObjectReference = targetObjectReferenceDecoded
        let typedLinkFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .typedLinkFacet)
        typedLinkFacet = typedLinkFacetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeNameAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeNameAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeNameAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension AttachTypedLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AttachTypedLinkOutputBody = try responseDecoder.decode(responseBody: data)
            self.typedLinkSpecifier = output.typedLinkSpecifier
        } else {
            self.typedLinkSpecifier = nil
        }
    }
}

public struct AttachTypedLinkOutput: Swift.Equatable {
    /// Returns a typed link specifier as output.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init(
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct AttachTypedLinkOutputBody: Swift.Equatable {
    let typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?
}

extension AttachTypedLinkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

enum AttachTypedLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAttachmentException": return try await InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudDirectoryClientTypes.AttributeKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetName = "FacetName"
        case name = "Name"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetName = self.facetName {
            try encodeContainer.encode(facetName, forKey: .facetName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let facetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .facetName)
        facetName = facetNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A unique identifier for an attribute.
    public struct AttributeKey: Swift.Equatable {
        /// The name of the facet that the attribute exists within.
        /// This member is required.
        public var facetName: Swift.String?
        /// The name of the attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema that contains the facet and attribute.
        /// This member is required.
        public var schemaArn: Swift.String?

        public init(
            facetName: Swift.String? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.facetName = facetName
            self.name = name
            self.schemaArn = schemaArn
        }
    }

}

extension CloudDirectoryClientTypes.AttributeKeyAndValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.AttributeKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// The combination of an attribute key and an attribute value.
    public struct AttributeKeyAndValue: Swift.Equatable {
        /// The key of the attribute.
        /// This member is required.
        public var key: CloudDirectoryClientTypes.AttributeKey?
        /// The value of the attribute.
        /// This member is required.
        public var value: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            key: CloudDirectoryClientTypes.AttributeKey? = nil,
            value: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CloudDirectoryClientTypes.AttributeNameAndValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Identifies the attribute name and value for a typed link.
    public struct AttributeNameAndValue: Swift.Equatable {
        /// The attribute name of the typed link.
        /// This member is required.
        public var attributeName: Swift.String?
        /// The value for the typed link.
        /// This member is required.
        public var value: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            attributeName: Swift.String? = nil,
            value: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.attributeName = attributeName
            self.value = value
        }
    }

}

extension CloudDirectoryClientTypes.BatchAddFacetToObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeList = "ObjectAttributeList"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvalue0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvalue0)
            }
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = self.schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a batch add facet to object operation.
    public struct BatchAddFacetToObject: Swift.Equatable {
        /// The attributes to set on the object.
        /// This member is required.
        public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// A reference to the object being mutated.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Represents the facet being added to the object.
        /// This member is required.
        public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

        public init(
            objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
        )
        {
            self.objectAttributeList = objectAttributeList
            self.objectReference = objectReference
            self.schemaFacet = schemaFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchAddFacetToObjectResponse: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes {
    /// The result of a batch add facet to object operation.
    public struct BatchAddFacetToObjectResponse: Swift.Equatable {

        public init() { }
    }

}

extension CloudDirectoryClientTypes.BatchAttachObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childReference = "ChildReference"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childReference = self.childReference {
            try encodeContainer.encode(childReference, forKey: .childReference)
        }
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = self.parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let childReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .childReference)
        childReference = childReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of an [AttachObject] operation.
    public struct BatchAttachObject: Swift.Equatable {
        /// The child object reference that is to be attached to the object.
        /// This member is required.
        public var childReference: CloudDirectoryClientTypes.ObjectReference?
        /// The name of the link.
        /// This member is required.
        public var linkName: Swift.String?
        /// The parent object reference.
        /// This member is required.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            childReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            linkName: Swift.String? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.childReference = childReference
            self.linkName = linkName
            self.parentReference = parentReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachObjectResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedObjectIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedObjectIdentifier = self.attachedObjectIdentifier {
            try encodeContainer.encode(attachedObjectIdentifier, forKey: .attachedObjectIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output batch [AttachObject] response operation.
    public struct BatchAttachObjectResponse: Swift.Equatable {
        /// The ObjectIdentifier of the object that has been attached.
        public var attachedObjectIdentifier: Swift.String?

        public init(
            attachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.attachedObjectIdentifier = attachedObjectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = self.policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Attaches a policy object to a regular object inside a [BatchRead] operation. For more information, see [AttachPolicy] and [BatchReadRequest$Operations].
    public struct BatchAttachPolicy: Swift.Equatable {
        /// The reference that identifies the object to which the policy will be attached.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// The reference that is associated with the policy object.
        /// This member is required.
        public var policyReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
            self.policyReference = policyReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachPolicyResponse: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of an [AttachPolicy] response operation.
    public struct BatchAttachPolicyResponse: Swift.Equatable {

        public init() { }
    }

}

extension CloudDirectoryClientTypes.BatchAttachToIndex: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = self.indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = self.targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Attaches the specified object to the specified index inside a [BatchRead] operation. For more information, see [AttachToIndex] and [BatchReadRequest$Operations].
    public struct BatchAttachToIndex: Swift.Equatable {
        /// A reference to the index that you are attaching the object to.
        /// This member is required.
        public var indexReference: CloudDirectoryClientTypes.ObjectReference?
        /// A reference to the object that you are attaching to the index.
        /// This member is required.
        public var targetReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.indexReference = indexReference
            self.targetReference = targetReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachToIndexResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedObjectIdentifier = "AttachedObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedObjectIdentifier = self.attachedObjectIdentifier {
            try encodeContainer.encode(attachedObjectIdentifier, forKey: .attachedObjectIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachedObjectIdentifier)
        attachedObjectIdentifier = attachedObjectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [AttachToIndex] response operation.
    public struct BatchAttachToIndexResponse: Swift.Equatable {
        /// The ObjectIdentifier of the object that was attached to the index.
        public var attachedObjectIdentifier: Swift.String?

        public init(
            attachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.attachedObjectIdentifier = attachedObjectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachTypedLink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributenameandvalue0 in attributes {
                try attributesContainer.encode(attributenameandvalue0)
            }
        }
        if let sourceObjectReference = self.sourceObjectReference {
            try encodeContainer.encode(sourceObjectReference, forKey: .sourceObjectReference)
        }
        if let targetObjectReference = self.targetObjectReference {
            try encodeContainer.encode(targetObjectReference, forKey: .targetObjectReference)
        }
        if let typedLinkFacet = self.typedLinkFacet {
            try encodeContainer.encode(typedLinkFacet, forKey: .typedLinkFacet)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .sourceObjectReference)
        sourceObjectReference = sourceObjectReferenceDecoded
        let targetObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetObjectReference)
        targetObjectReference = targetObjectReferenceDecoded
        let typedLinkFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .typedLinkFacet)
        typedLinkFacet = typedLinkFacetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeNameAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeNameAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeNameAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Attaches a typed link to a specified source and target object inside a [BatchRead] operation. For more information, see [AttachTypedLink] and [BatchReadRequest$Operations].
    public struct BatchAttachTypedLink: Swift.Equatable {
        /// A set of attributes that are associated with the typed link.
        /// This member is required.
        public var attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]?
        /// Identifies the source object that the typed link will attach to.
        /// This member is required.
        public var sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the target object that the typed link will attach to.
        /// This member is required.
        public var targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the typed link facet that is associated with the typed link.
        /// This member is required.
        public var typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?

        public init(
            attributes: [CloudDirectoryClientTypes.AttributeNameAndValue]? = nil,
            sourceObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil
        )
        {
            self.attributes = attributes
            self.sourceObjectReference = sourceObjectReference
            self.targetObjectReference = targetObjectReference
            self.typedLinkFacet = typedLinkFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchAttachTypedLinkResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typedLinkSpecifier = self.typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [AttachTypedLink] response operation.
    public struct BatchAttachTypedLinkResponse: Swift.Equatable {
        /// Returns a typed link specifier as output.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init(
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchCreateIndex: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchReferenceName = "BatchReferenceName"
        case isUnique = "IsUnique"
        case linkName = "LinkName"
        case orderedIndexedAttributeList = "OrderedIndexedAttributeList"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReferenceName = self.batchReferenceName {
            try encodeContainer.encode(batchReferenceName, forKey: .batchReferenceName)
        }
        if isUnique != false {
            try encodeContainer.encode(isUnique, forKey: .isUnique)
        }
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let orderedIndexedAttributeList = orderedIndexedAttributeList {
            var orderedIndexedAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedIndexedAttributeList)
            for attributekey0 in orderedIndexedAttributeList {
                try orderedIndexedAttributeListContainer.encode(attributekey0)
            }
        }
        if let parentReference = self.parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderedIndexedAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKey?].self, forKey: .orderedIndexedAttributeList)
        var orderedIndexedAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKey]? = nil
        if let orderedIndexedAttributeListContainer = orderedIndexedAttributeListContainer {
            orderedIndexedAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKey]()
            for structure0 in orderedIndexedAttributeListContainer {
                if let structure0 = structure0 {
                    orderedIndexedAttributeListDecoded0?.append(structure0)
                }
            }
        }
        orderedIndexedAttributeList = orderedIndexedAttributeListDecoded0
        let isUniqueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isUnique) ?? false
        isUnique = isUniqueDecoded
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let batchReferenceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchReferenceName)
        batchReferenceName = batchReferenceNameDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Creates an index object inside of a [BatchRead] operation. For more information, see [CreateIndex] and [BatchReadRequest$Operations].
    public struct BatchCreateIndex: Swift.Equatable {
        /// The batch reference name. See [Transaction Support](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html) for more information.
        public var batchReferenceName: Swift.String?
        /// Indicates whether the attribute that is being indexed has unique values or not.
        /// This member is required.
        public var isUnique: Swift.Bool
        /// The name of the link between the parent object and the index object.
        public var linkName: Swift.String?
        /// Specifies the attributes that should be indexed on. Currently only a single attribute is supported.
        /// This member is required.
        public var orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]?
        /// A reference to the parent object that contains the index object.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            batchReferenceName: Swift.String? = nil,
            isUnique: Swift.Bool = false,
            linkName: Swift.String? = nil,
            orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.batchReferenceName = batchReferenceName
            self.isUnique = isUnique
            self.linkName = linkName
            self.orderedIndexedAttributeList = orderedIndexedAttributeList
            self.parentReference = parentReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchCreateIndexResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = self.objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [CreateIndex] response operation.
    public struct BatchCreateIndexResponse: Swift.Equatable {
        /// The ObjectIdentifier of the index created by this operation.
        public var objectIdentifier: Swift.String?

        public init(
            objectIdentifier: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchCreateObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchReferenceName = "BatchReferenceName"
        case linkName = "LinkName"
        case objectAttributeList = "ObjectAttributeList"
        case parentReference = "ParentReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReferenceName = self.batchReferenceName {
            try encodeContainer.encode(batchReferenceName, forKey: .batchReferenceName)
        }
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvalue0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvalue0)
            }
        }
        if let parentReference = self.parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
        if let schemaFacet = schemaFacet {
            var schemaFacetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaFacet)
            for schemafacet0 in schemaFacet {
                try schemaFacetContainer.encode(schemafacet0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.SchemaFacet?].self, forKey: .schemaFacet)
        var schemaFacetDecoded0:[CloudDirectoryClientTypes.SchemaFacet]? = nil
        if let schemaFacetContainer = schemaFacetContainer {
            schemaFacetDecoded0 = [CloudDirectoryClientTypes.SchemaFacet]()
            for structure0 in schemaFacetContainer {
                if let structure0 = structure0 {
                    schemaFacetDecoded0?.append(structure0)
                }
            }
        }
        schemaFacet = schemaFacetDecoded0
        let objectAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let batchReferenceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchReferenceName)
        batchReferenceName = batchReferenceNameDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [CreateObject] operation.
    public struct BatchCreateObject: Swift.Equatable {
        /// The batch reference name. See [Transaction Support](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html) for more information.
        public var batchReferenceName: Swift.String?
        /// The name of the link.
        public var linkName: Swift.String?
        /// An attribute map, which contains an attribute ARN as the key and attribute value as the map value.
        /// This member is required.
        public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// If specified, the parent reference to which this object will be attached.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?
        /// A list of FacetArns that will be associated with the object. For more information, see [arns].
        /// This member is required.
        public var schemaFacet: [CloudDirectoryClientTypes.SchemaFacet]?

        public init(
            batchReferenceName: Swift.String? = nil,
            linkName: Swift.String? = nil,
            objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: [CloudDirectoryClientTypes.SchemaFacet]? = nil
        )
        {
            self.batchReferenceName = batchReferenceName
            self.linkName = linkName
            self.objectAttributeList = objectAttributeList
            self.parentReference = parentReference
            self.schemaFacet = schemaFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchCreateObjectResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = self.objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [CreateObject] response operation.
    public struct BatchCreateObjectResponse: Swift.Equatable {
        /// The ID that is associated with the object.
        public var objectIdentifier: Swift.String?

        public init(
            objectIdentifier: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchDeleteObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DeleteObject] operation.
    public struct BatchDeleteObject: Swift.Equatable {
        /// The reference that identifies the object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchDeleteObjectResponse: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DeleteObject] response operation.
    public struct BatchDeleteObjectResponse: Swift.Equatable {

        public init() { }
    }

}

extension CloudDirectoryClientTypes.BatchDetachFromIndex: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = self.indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = self.targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Detaches the specified object from the specified index inside a [BatchRead] operation. For more information, see [DetachFromIndex] and [BatchReadRequest$Operations].
    public struct BatchDetachFromIndex: Swift.Equatable {
        /// A reference to the index object.
        /// This member is required.
        public var indexReference: CloudDirectoryClientTypes.ObjectReference?
        /// A reference to the object being detached from the index.
        /// This member is required.
        public var targetReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.indexReference = indexReference
            self.targetReference = targetReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachFromIndexResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detachedObjectIdentifier = "DetachedObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detachedObjectIdentifier = self.detachedObjectIdentifier {
            try encodeContainer.encode(detachedObjectIdentifier, forKey: .detachedObjectIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachFromIndex] response operation.
    public struct BatchDetachFromIndexResponse: Swift.Equatable {
        /// The ObjectIdentifier of the object that was detached from the index.
        public var detachedObjectIdentifier: Swift.String?

        public init(
            detachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.detachedObjectIdentifier = detachedObjectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchReferenceName = "BatchReferenceName"
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchReferenceName = self.batchReferenceName {
            try encodeContainer.encode(batchReferenceName, forKey: .batchReferenceName)
        }
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = self.parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
        let batchReferenceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchReferenceName)
        batchReferenceName = batchReferenceNameDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachObject] operation.
    public struct BatchDetachObject: Swift.Equatable {
        /// The batch reference name. See [Transaction Support](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/transaction_support.html) for more information.
        public var batchReferenceName: Swift.String?
        /// The name of the link.
        /// This member is required.
        public var linkName: Swift.String?
        /// Parent reference from which the object with the specified link name is detached.
        /// This member is required.
        public var parentReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            batchReferenceName: Swift.String? = nil,
            linkName: Swift.String? = nil,
            parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.batchReferenceName = batchReferenceName
            self.linkName = linkName
            self.parentReference = parentReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachObjectResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detachedObjectIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detachedObjectIdentifier = self.detachedObjectIdentifier {
            try encodeContainer.encode(detachedObjectIdentifier, forKey: .detachedObjectIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachObject] response operation.
    public struct BatchDetachObjectResponse: Swift.Equatable {
        /// The ObjectIdentifier of the detached object.
        public var detachedObjectIdentifier: Swift.String?

        public init(
            detachedObjectIdentifier: Swift.String? = nil
        )
        {
            self.detachedObjectIdentifier = detachedObjectIdentifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = self.policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Detaches the specified policy from the specified directory inside a [BatchWrite] operation. For more information, see [DetachPolicy] and [BatchWriteRequest$Operations].
    public struct BatchDetachPolicy: Swift.Equatable {
        /// Reference that identifies the object whose policy object will be detached.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Reference that identifies the policy object.
        /// This member is required.
        public var policyReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
            self.policyReference = policyReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachPolicyResponse: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachPolicy] response operation.
    public struct BatchDetachPolicyResponse: Swift.Equatable {

        public init() { }
    }

}

extension CloudDirectoryClientTypes.BatchDetachTypedLink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typedLinkSpecifier = self.typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Detaches a typed link from a specified source and target object inside a [BatchRead] operation. For more information, see [DetachTypedLink] and [BatchReadRequest$Operations].
    public struct BatchDetachTypedLink: Swift.Equatable {
        /// Used to accept a typed link specifier as input.
        /// This member is required.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init(
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchDetachTypedLinkResponse: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [DetachTypedLink] response operation.
    public struct BatchDetachTypedLinkResponse: Swift.Equatable {

        public init() { }
    }

}

extension CloudDirectoryClientTypes.BatchGetLinkAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributename0 in attributeNames {
                try attributeNamesContainer.encode(attributename0)
            }
        }
        if let typedLinkSpecifier = self.typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Retrieves attributes that are associated with a typed link inside a [BatchRead] operation. For more information, see [GetLinkAttributes] and [BatchReadRequest$Operations].
    public struct BatchGetLinkAttributes: Swift.Equatable {
        /// A list of attribute names whose values will be retrieved.
        /// This member is required.
        public var attributeNames: [Swift.String]?
        /// Allows a typed link specifier to be accepted as input.
        /// This member is required.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init(
            attributeNames: [Swift.String]? = nil,
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.attributeNames = attributeNames
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetLinkAttributesResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributekeyandvalue0 in attributes {
                try attributesContainer.encode(attributekeyandvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [GetLinkAttributes] response operation.
    public struct BatchGetLinkAttributesResponse: Swift.Equatable {
        /// The attributes that are associated with the typed link.
        public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

        public init(
            attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetObjectAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributename0 in attributeNames {
                try attributeNamesContainer.encode(attributename0)
            }
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = self.schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Retrieves attributes within a facet that are associated with an object inside an [BatchRead] operation. For more information, see [GetObjectAttributes] and [BatchReadRequest$Operations].
    public struct BatchGetObjectAttributes: Swift.Equatable {
        /// List of attribute names whose values will be retrieved.
        /// This member is required.
        public var attributeNames: [Swift.String]?
        /// Reference that identifies the object whose attributes will be retrieved.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifier for the facet whose attributes will be retrieved. See [SchemaFacet] for details.
        /// This member is required.
        public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

        public init(
            attributeNames: [Swift.String]? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
        )
        {
            self.attributeNames = attributeNames
            self.objectReference = objectReference
            self.schemaFacet = schemaFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetObjectAttributesResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributekeyandvalue0 in attributes {
                try attributesContainer.encode(attributekeyandvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [GetObjectAttributes] response operation.
    public struct BatchGetObjectAttributesResponse: Swift.Equatable {
        /// The attribute values that are associated with an object.
        public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

        public init(
            attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetObjectInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Retrieves metadata about an object inside a [BatchRead] operation. For more information, see [GetObjectInformation] and [BatchReadRequest$Operations].
    public struct BatchGetObjectInformation: Swift.Equatable {
        /// A reference to the object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchGetObjectInformationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
        case schemaFacets = "SchemaFacets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = self.objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
        if let schemaFacets = schemaFacets {
            var schemaFacetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaFacets)
            for schemafacet0 in schemaFacets {
                try schemaFacetsContainer.encode(schemafacet0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.SchemaFacet?].self, forKey: .schemaFacets)
        var schemaFacetsDecoded0:[CloudDirectoryClientTypes.SchemaFacet]? = nil
        if let schemaFacetsContainer = schemaFacetsContainer {
            schemaFacetsDecoded0 = [CloudDirectoryClientTypes.SchemaFacet]()
            for structure0 in schemaFacetsContainer {
                if let structure0 = structure0 {
                    schemaFacetsDecoded0?.append(structure0)
                }
            }
        }
        schemaFacets = schemaFacetsDecoded0
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [GetObjectInformation] response operation.
    public struct BatchGetObjectInformationResponse: Swift.Equatable {
        /// The ObjectIdentifier of the specified object.
        public var objectIdentifier: Swift.String?
        /// The facets attached to the specified object.
        public var schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?

        public init(
            objectIdentifier: Swift.String? = nil,
            schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
            self.schemaFacets = schemaFacets
        }
    }

}

extension CloudDirectoryClientTypes.BatchListAttachedIndices: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetReference = self.targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Lists indices attached to an object inside a [BatchRead] operation. For more information, see [ListAttachedIndices] and [BatchReadRequest$Operations].
    public struct BatchListAttachedIndices: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// A reference to the object that has indices attached.
        /// This member is required.
        public var targetReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetReference = targetReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListAttachedIndicesResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexAttachments = indexAttachments {
            var indexAttachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .indexAttachments)
            for indexattachment0 in indexAttachments {
                try indexAttachmentsContainer.encode(indexattachment0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[CloudDirectoryClientTypes.IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [CloudDirectoryClientTypes.IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListAttachedIndices] response operation.
    public struct BatchListAttachedIndicesResponse: Swift.Equatable {
        /// The indices attached to the specified object.
        public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.indexAttachments = indexAttachments
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListIncomingTypedLinks: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerange0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerange0)
            }
        }
        if let filterTypedLink = self.filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Returns a paginated list of all the incoming [TypedLinkSpecifier] information for an object inside a [BatchRead] operation. For more information, see [ListIncomingTypedLinks] and [BatchReadRequest$Operations].
    public struct BatchListIncomingTypedLinks: Swift.Equatable {
        /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
        public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
        /// Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls.
        public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
            filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.filterAttributeRanges = filterAttributeRanges
            self.filterTypedLink = filterTypedLink
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkSpecifiers = "LinkSpecifiers"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkSpecifiers = linkSpecifiers {
            var linkSpecifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .linkSpecifiers)
            for typedlinkspecifier0 in linkSpecifiers {
                try linkSpecifiersContainer.encode(typedlinkspecifier0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkSpecifiersContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkSpecifier?].self, forKey: .linkSpecifiers)
        var linkSpecifiersDecoded0:[CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        if let linkSpecifiersContainer = linkSpecifiersContainer {
            linkSpecifiersDecoded0 = [CloudDirectoryClientTypes.TypedLinkSpecifier]()
            for structure0 in linkSpecifiersContainer {
                if let structure0 = structure0 {
                    linkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        linkSpecifiers = linkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListIncomingTypedLinks] response operation.
    public struct BatchListIncomingTypedLinksResponse: Swift.Equatable {
        /// Returns one or more typed link specifiers as output.
        public var linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.linkSpecifiers = linkSpecifiers
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListIndex: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rangesOnIndexedValues = "RangesOnIndexedValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = self.indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rangesOnIndexedValues = rangesOnIndexedValues {
            var rangesOnIndexedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rangesOnIndexedValues)
            for objectattributerange0 in rangesOnIndexedValues {
                try rangesOnIndexedValuesContainer.encode(objectattributerange0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangesOnIndexedValuesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectAttributeRange?].self, forKey: .rangesOnIndexedValues)
        var rangesOnIndexedValuesDecoded0:[CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
        if let rangesOnIndexedValuesContainer = rangesOnIndexedValuesContainer {
            rangesOnIndexedValuesDecoded0 = [CloudDirectoryClientTypes.ObjectAttributeRange]()
            for structure0 in rangesOnIndexedValuesContainer {
                if let structure0 = structure0 {
                    rangesOnIndexedValuesDecoded0?.append(structure0)
                }
            }
        }
        rangesOnIndexedValues = rangesOnIndexedValuesDecoded0
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Lists objects attached to the specified index inside a [BatchRead] operation. For more information, see [ListIndex] and [BatchReadRequest$Operations].
    public struct BatchListIndex: Swift.Equatable {
        /// The reference to the index to list.
        /// This member is required.
        public var indexReference: CloudDirectoryClientTypes.ObjectReference?
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Specifies the ranges of indexed values that you want to query.
        public var rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]?

        public init(
            indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
        )
        {
            self.indexReference = indexReference
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.rangesOnIndexedValues = rangesOnIndexedValues
        }
    }

}

extension CloudDirectoryClientTypes.BatchListIndexResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexAttachments = indexAttachments {
            var indexAttachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .indexAttachments)
            for indexattachment0 in indexAttachments {
                try indexAttachmentsContainer.encode(indexattachment0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[CloudDirectoryClientTypes.IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [CloudDirectoryClientTypes.IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListIndex] response operation.
    public struct BatchListIndexResponse: Swift.Equatable {
        /// The objects and indexed values attached to the index.
        public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.indexAttachments = indexAttachments
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetFilter = "FacetFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetFilter = self.facetFilter {
            try encodeContainer.encode(facetFilter, forKey: .facetFilter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let facetFilterDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .facetFilter)
        facetFilter = facetFilterDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectAttributes] operation.
    public struct BatchListObjectAttributes: Swift.Equatable {
        /// Used to filter the list of object attributes that are associated with a certain facet.
        public var facetFilter: CloudDirectoryClientTypes.SchemaFacet?
        /// The maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Reference of the object whose attributes need to be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            facetFilter: CloudDirectoryClientTypes.SchemaFacet? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.facetFilter = facetFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectAttributesResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributekeyandvalue0 in attributes {
                try attributesContainer.encode(attributekeyandvalue0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectAttributes] response operation.
    public struct BatchListObjectAttributesResponse: Swift.Equatable {
        /// The attributes map that is associated with the object. AttributeArn is the key; attribute value is the value.
        public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectChildren: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectChildren] operation.
    public struct BatchListObjectChildren: Swift.Equatable {
        /// Maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Reference of the object for which child objects are being listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectChildrenResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children = "Children"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .children)
            for (dictKey0, linkNameToObjectIdentifierMap0) in children {
                try childrenContainer.encode(linkNameToObjectIdentifierMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let childrenContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .children)
        var childrenDecoded0: [Swift.String:Swift.String]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [Swift.String:Swift.String]()
            for (key0, objectidentifier0) in childrenContainer {
                if let objectidentifier0 = objectidentifier0 {
                    childrenDecoded0?[key0] = objectidentifier0
                }
            }
        }
        children = childrenDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectChildren] response operation.
    public struct BatchListObjectChildrenResponse: Swift.Equatable {
        /// The children structure, which is a map with the key as the LinkName and ObjectIdentifier as the value.
        public var children: [Swift.String:Swift.String]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            children: [Swift.String:Swift.String]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.children = children
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectParentPaths: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects inside a [BatchRead] operation. For more information, see [ListObjectParentPaths] and [BatchReadRequest$Operations].
    public struct BatchListObjectParentPaths: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectParentPathsResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pathToObjectIdentifiersList = "PathToObjectIdentifiersList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pathToObjectIdentifiersList = pathToObjectIdentifiersList {
            var pathToObjectIdentifiersListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pathToObjectIdentifiersList)
            for pathtoobjectidentifiers0 in pathToObjectIdentifiersList {
                try pathToObjectIdentifiersListContainer.encode(pathtoobjectidentifiers0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathToObjectIdentifiersListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PathToObjectIdentifiers?].self, forKey: .pathToObjectIdentifiersList)
        var pathToObjectIdentifiersListDecoded0:[CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
        if let pathToObjectIdentifiersListContainer = pathToObjectIdentifiersListContainer {
            pathToObjectIdentifiersListDecoded0 = [CloudDirectoryClientTypes.PathToObjectIdentifiers]()
            for structure0 in pathToObjectIdentifiersListContainer {
                if let structure0 = structure0 {
                    pathToObjectIdentifiersListDecoded0?.append(structure0)
                }
            }
        }
        pathToObjectIdentifiersList = pathToObjectIdentifiersListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectParentPaths] response operation.
    public struct BatchListObjectParentPathsResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Returns the path to the ObjectIdentifiers that are associated with the directory.
        public var pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]?

        public init(
            nextToken: Swift.String? = nil,
            pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
        )
        {
            self.nextToken = nextToken
            self.pathToObjectIdentifiersList = pathToObjectIdentifiersList
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectParents: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Lists parent objects that are associated with a given object in pagination fashion.
    public struct BatchListObjectParents: Swift.Equatable {
        /// The maximum number of items to be retrieved in a single call. This is an approximate number.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies an object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectParentsResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parentLinks = "ParentLinks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parentLinks = parentLinks {
            var parentLinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentLinks)
            for objectidentifierandlinknametuple0 in parentLinks {
                try parentLinksContainer.encode(objectidentifierandlinknametuple0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentLinksContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple?].self, forKey: .parentLinks)
        var parentLinksDecoded0:[CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil
        if let parentLinksContainer = parentLinksContainer {
            parentLinksDecoded0 = [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]()
            for structure0 in parentLinksContainer {
                if let structure0 = structure0 {
                    parentLinksDecoded0?.append(structure0)
                }
            }
        }
        parentLinks = parentLinksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectParents] response operation.
    public struct BatchListObjectParentsResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Returns a list of parent reference and LinkName Tuples.
        public var parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]?

        public init(
            nextToken: Swift.String? = nil,
            parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil
        )
        {
            self.nextToken = nextToken
            self.parentLinks = parentLinks
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectPolicies: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Returns policies attached to an object in pagination fashion inside a [BatchRead] operation. For more information, see [ListObjectPolicies] and [BatchReadRequest$Operations].
    public struct BatchListObjectPolicies: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListObjectPoliciesResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicyIds = "AttachedPolicyIds"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedPolicyIds = attachedPolicyIds {
            var attachedPolicyIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedPolicyIds)
            for objectidentifier0 in attachedPolicyIds {
                try attachedPolicyIdsContainer.encode(objectidentifier0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedPolicyIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attachedPolicyIds)
        var attachedPolicyIdsDecoded0:[Swift.String]? = nil
        if let attachedPolicyIdsContainer = attachedPolicyIdsContainer {
            attachedPolicyIdsDecoded0 = [Swift.String]()
            for string0 in attachedPolicyIdsContainer {
                if let string0 = string0 {
                    attachedPolicyIdsDecoded0?.append(string0)
                }
            }
        }
        attachedPolicyIds = attachedPolicyIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListObjectPolicies] response operation.
    public struct BatchListObjectPoliciesResponse: Swift.Equatable {
        /// A list of policy ObjectIdentifiers, that are attached to the object.
        public var attachedPolicyIds: [Swift.String]?
        /// The pagination token.
        public var nextToken: Swift.String?

        public init(
            attachedPolicyIds: [Swift.String]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.attachedPolicyIds = attachedPolicyIds
            self.nextToken = nextToken
        }
    }

}

extension CloudDirectoryClientTypes.BatchListOutgoingTypedLinks: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerange0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerange0)
            }
        }
        if let filterTypedLink = self.filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Returns a paginated list of all the outgoing [TypedLinkSpecifier] information for an object inside a [BatchRead] operation. For more information, see [ListOutgoingTypedLinks] and [BatchReadRequest$Operations].
    public struct BatchListOutgoingTypedLinks: Swift.Equatable {
        /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
        public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
        /// Filters are interpreted in the order of the attributes defined on the typed link facet, not the order they are supplied to any API calls.
        public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the object whose attributes will be listed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
            filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.filterAttributeRanges = filterAttributeRanges
            self.filterTypedLink = filterTypedLink
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case typedLinkSpecifiers = "TypedLinkSpecifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let typedLinkSpecifiers = typedLinkSpecifiers {
            var typedLinkSpecifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .typedLinkSpecifiers)
            for typedlinkspecifier0 in typedLinkSpecifiers {
                try typedLinkSpecifiersContainer.encode(typedlinkspecifier0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifiersContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkSpecifier?].self, forKey: .typedLinkSpecifiers)
        var typedLinkSpecifiersDecoded0:[CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        if let typedLinkSpecifiersContainer = typedLinkSpecifiersContainer {
            typedLinkSpecifiersDecoded0 = [CloudDirectoryClientTypes.TypedLinkSpecifier]()
            for structure0 in typedLinkSpecifiersContainer {
                if let structure0 = structure0 {
                    typedLinkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        typedLinkSpecifiers = typedLinkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListOutgoingTypedLinks] response operation.
    public struct BatchListOutgoingTypedLinksResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Returns a typed link specifier as output.
        public var typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?

        public init(
            nextToken: Swift.String? = nil,
            typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        )
        {
            self.nextToken = nextToken
            self.typedLinkSpecifiers = typedLinkSpecifiers
        }
    }

}

extension CloudDirectoryClientTypes.BatchListPolicyAttachments: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyReference = self.policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Returns all of the ObjectIdentifiers to which a given policy is attached inside a [BatchRead] operation. For more information, see [ListPolicyAttachments] and [BatchReadRequest$Operations].
    public struct BatchListPolicyAttachments: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// The reference that identifies the policy object.
        /// This member is required.
        public var policyReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.policyReference = policyReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objectIdentifiers = "ObjectIdentifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectIdentifiers = objectIdentifiers {
            var objectIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIdentifiers)
            for objectidentifier0 in objectIdentifiers {
                try objectIdentifiersContainer.encode(objectidentifier0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectIdentifiers)
        var objectIdentifiersDecoded0:[Swift.String]? = nil
        if let objectIdentifiersContainer = objectIdentifiersContainer {
            objectIdentifiersDecoded0 = [Swift.String]()
            for string0 in objectIdentifiersContainer {
                if let string0 = string0 {
                    objectIdentifiersDecoded0?.append(string0)
                }
            }
        }
        objectIdentifiers = objectIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [ListPolicyAttachments] response operation.
    public struct BatchListPolicyAttachmentsResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// A list of ObjectIdentifiers to which the policy is attached.
        public var objectIdentifiers: [Swift.String]?

        public init(
            nextToken: Swift.String? = nil,
            objectIdentifiers: [Swift.String]? = nil
        )
        {
            self.nextToken = nextToken
            self.objectIdentifiers = objectIdentifiers
        }
    }

}

extension CloudDirectoryClientTypes.BatchLookupPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Lists all policies from the root of the Directory to the object specified inside a [BatchRead] operation. For more information, see [LookupPolicy] and [BatchReadRequest$Operations].
    public struct BatchLookupPolicy: Swift.Equatable {
        /// The maximum number of results to retrieve.
        public var maxResults: Swift.Int?
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Reference that identifies the object whose policies will be looked up.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            maxResults: Swift.Int? = nil,
            nextToken: Swift.String? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchLookupPolicyResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case policyToPathList = "PolicyToPathList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyToPathList = policyToPathList {
            var policyToPathListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyToPathList)
            for policytopath0 in policyToPathList {
                try policyToPathListContainer.encode(policytopath0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyToPathListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PolicyToPath?].self, forKey: .policyToPathList)
        var policyToPathListDecoded0:[CloudDirectoryClientTypes.PolicyToPath]? = nil
        if let policyToPathListContainer = policyToPathListContainer {
            policyToPathListDecoded0 = [CloudDirectoryClientTypes.PolicyToPath]()
            for structure0 in policyToPathListContainer {
                if let structure0 = structure0 {
                    policyToPathListDecoded0?.append(structure0)
                }
            }
        }
        policyToPathList = policyToPathListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [LookupPolicy] response operation.
    public struct BatchLookupPolicyResponse: Swift.Equatable {
        /// The pagination token.
        public var nextToken: Swift.String?
        /// Provides list of path to policies. Policies contain PolicyId, ObjectIdentifier, and PolicyType. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
        public var policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]?

        public init(
            nextToken: Swift.String? = nil,
            policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]? = nil
        )
        {
            self.nextToken = nextToken
            self.policyToPathList = policyToPathList
        }
    }

}

extension CloudDirectoryClientTypes.BatchReadException: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchReadExceptionType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// The batch read exception structure, which contains the exception type and message.
    public struct BatchReadException: Swift.Equatable {
        /// An exception message that is associated with the failure.
        public var message: Swift.String?
        /// A type of exception, such as InvalidArnException.
        public var type: CloudDirectoryClientTypes.BatchReadExceptionType?

        public init(
            message: Swift.String? = nil,
            type: CloudDirectoryClientTypes.BatchReadExceptionType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }

}

extension CloudDirectoryClientTypes {
    public enum BatchReadExceptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case cannotlistparentofrootexception
        case directorynotenabledexception
        case facetvalidationexception
        case internalserviceexception
        case invalidarnexception
        case invalidnexttokenexception
        case limitexceededexception
        case notindexexception
        case notnodeexception
        case notpolicyexception
        case resourcenotfoundexception
        case validationexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchReadExceptionType] {
            return [
                .accessdeniedexception,
                .cannotlistparentofrootexception,
                .directorynotenabledexception,
                .facetvalidationexception,
                .internalserviceexception,
                .invalidarnexception,
                .invalidnexttokenexception,
                .limitexceededexception,
                .notindexexception,
                .notnodeexception,
                .notpolicyexception,
                .resourcenotfoundexception,
                .validationexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .cannotlistparentofrootexception: return "CannotListParentOfRootException"
            case .directorynotenabledexception: return "DirectoryNotEnabledException"
            case .facetvalidationexception: return "FacetValidationException"
            case .internalserviceexception: return "InternalServiceException"
            case .invalidarnexception: return "InvalidArnException"
            case .invalidnexttokenexception: return "InvalidNextTokenException"
            case .limitexceededexception: return "LimitExceededException"
            case .notindexexception: return "NotIndexException"
            case .notnodeexception: return "NotNodeException"
            case .notpolicyexception: return "NotPolicyException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .validationexception: return "ValidationException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchReadExceptionType(rawValue: rawValue) ?? BatchReadExceptionType.sdkUnknown(rawValue)
        }
    }
}

extension BatchReadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for batchreadoperation0 in operations {
                try operationsContainer.encode(batchreadoperation0)
            }
        }
    }
}

extension BatchReadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension BatchReadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/batchread"
    }
}

public struct BatchReadInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A list of operations that are part of the batch.
    /// This member is required.
    public var operations: [CloudDirectoryClientTypes.BatchReadOperation]?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        operations: [CloudDirectoryClientTypes.BatchReadOperation]? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.operations = operations
    }
}

struct BatchReadInputBody: Swift.Equatable {
    let operations: [CloudDirectoryClientTypes.BatchReadOperation]?
}

extension BatchReadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.BatchReadOperation?].self, forKey: .operations)
        var operationsDecoded0:[CloudDirectoryClientTypes.BatchReadOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [CloudDirectoryClientTypes.BatchReadOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchReadOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case getLinkAttributes = "GetLinkAttributes"
        case getObjectAttributes = "GetObjectAttributes"
        case getObjectInformation = "GetObjectInformation"
        case listAttachedIndices = "ListAttachedIndices"
        case listIncomingTypedLinks = "ListIncomingTypedLinks"
        case listIndex = "ListIndex"
        case listObjectAttributes = "ListObjectAttributes"
        case listObjectChildren = "ListObjectChildren"
        case listObjectParentPaths = "ListObjectParentPaths"
        case listObjectParents = "ListObjectParents"
        case listObjectPolicies = "ListObjectPolicies"
        case listOutgoingTypedLinks = "ListOutgoingTypedLinks"
        case listPolicyAttachments = "ListPolicyAttachments"
        case lookupPolicy = "LookupPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let getLinkAttributes = self.getLinkAttributes {
            try encodeContainer.encode(getLinkAttributes, forKey: .getLinkAttributes)
        }
        if let getObjectAttributes = self.getObjectAttributes {
            try encodeContainer.encode(getObjectAttributes, forKey: .getObjectAttributes)
        }
        if let getObjectInformation = self.getObjectInformation {
            try encodeContainer.encode(getObjectInformation, forKey: .getObjectInformation)
        }
        if let listAttachedIndices = self.listAttachedIndices {
            try encodeContainer.encode(listAttachedIndices, forKey: .listAttachedIndices)
        }
        if let listIncomingTypedLinks = self.listIncomingTypedLinks {
            try encodeContainer.encode(listIncomingTypedLinks, forKey: .listIncomingTypedLinks)
        }
        if let listIndex = self.listIndex {
            try encodeContainer.encode(listIndex, forKey: .listIndex)
        }
        if let listObjectAttributes = self.listObjectAttributes {
            try encodeContainer.encode(listObjectAttributes, forKey: .listObjectAttributes)
        }
        if let listObjectChildren = self.listObjectChildren {
            try encodeContainer.encode(listObjectChildren, forKey: .listObjectChildren)
        }
        if let listObjectParentPaths = self.listObjectParentPaths {
            try encodeContainer.encode(listObjectParentPaths, forKey: .listObjectParentPaths)
        }
        if let listObjectParents = self.listObjectParents {
            try encodeContainer.encode(listObjectParents, forKey: .listObjectParents)
        }
        if let listObjectPolicies = self.listObjectPolicies {
            try encodeContainer.encode(listObjectPolicies, forKey: .listObjectPolicies)
        }
        if let listOutgoingTypedLinks = self.listOutgoingTypedLinks {
            try encodeContainer.encode(listOutgoingTypedLinks, forKey: .listOutgoingTypedLinks)
        }
        if let listPolicyAttachments = self.listPolicyAttachments {
            try encodeContainer.encode(listPolicyAttachments, forKey: .listPolicyAttachments)
        }
        if let lookupPolicy = self.lookupPolicy {
            try encodeContainer.encode(lookupPolicy, forKey: .lookupPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectAttributes.self, forKey: .listObjectAttributes)
        listObjectAttributes = listObjectAttributesDecoded
        let listObjectChildrenDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectChildren.self, forKey: .listObjectChildren)
        listObjectChildren = listObjectChildrenDecoded
        let listAttachedIndicesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListAttachedIndices.self, forKey: .listAttachedIndices)
        listAttachedIndices = listAttachedIndicesDecoded
        let listObjectParentPathsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectParentPaths.self, forKey: .listObjectParentPaths)
        listObjectParentPaths = listObjectParentPathsDecoded
        let getObjectInformationDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetObjectInformation.self, forKey: .getObjectInformation)
        getObjectInformation = getObjectInformationDecoded
        let getObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetObjectAttributes.self, forKey: .getObjectAttributes)
        getObjectAttributes = getObjectAttributesDecoded
        let listObjectParentsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectParents.self, forKey: .listObjectParents)
        listObjectParents = listObjectParentsDecoded
        let listObjectPoliciesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectPolicies.self, forKey: .listObjectPolicies)
        listObjectPolicies = listObjectPoliciesDecoded
        let listPolicyAttachmentsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListPolicyAttachments.self, forKey: .listPolicyAttachments)
        listPolicyAttachments = listPolicyAttachmentsDecoded
        let lookupPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchLookupPolicy.self, forKey: .lookupPolicy)
        lookupPolicy = lookupPolicyDecoded
        let listIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListIndex.self, forKey: .listIndex)
        listIndex = listIndexDecoded
        let listOutgoingTypedLinksDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListOutgoingTypedLinks.self, forKey: .listOutgoingTypedLinks)
        listOutgoingTypedLinks = listOutgoingTypedLinksDecoded
        let listIncomingTypedLinksDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListIncomingTypedLinks.self, forKey: .listIncomingTypedLinks)
        listIncomingTypedLinks = listIncomingTypedLinksDecoded
        let getLinkAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetLinkAttributes.self, forKey: .getLinkAttributes)
        getLinkAttributes = getLinkAttributesDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchRead operation.
    public struct BatchReadOperation: Swift.Equatable {
        /// Retrieves attributes that are associated with a typed link.
        public var getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributes?
        /// Retrieves attributes within a facet that are associated with an object.
        public var getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributes?
        /// Retrieves metadata about an object.
        public var getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformation?
        /// Lists indices attached to an object.
        public var listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndices?
        /// Returns a paginated list of all the incoming [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinks?
        /// Lists objects attached to the specified index.
        public var listIndex: CloudDirectoryClientTypes.BatchListIndex?
        /// Lists all attributes that are associated with an object.
        public var listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributes?
        /// Returns a paginated list of child objects that are associated with a given object.
        public var listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildren?
        /// Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects. For more information about objects, see [Directory Structure](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directorystructure.html).
        public var listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPaths?
        /// Lists parent objects that are associated with a given object in pagination fashion.
        public var listObjectParents: CloudDirectoryClientTypes.BatchListObjectParents?
        /// Returns policies attached to an object in pagination fashion.
        public var listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPolicies?
        /// Returns a paginated list of all the outgoing [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinks?
        /// Returns all of the ObjectIdentifiers to which a given policy is attached.
        public var listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachments?
        /// Lists all policies from the root of the [Directory] to the object specified. If there are no policies present, an empty list is returned. If policies are present, and if some objects don't have the policies attached, it returns the ObjectIdentifier for such objects. If policies are present, it returns ObjectIdentifier, policyId, and policyType. Paths that don't lead to the root from the target object are ignored. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
        public var lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicy?

        public init(
            getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributes? = nil,
            getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributes? = nil,
            getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformation? = nil,
            listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndices? = nil,
            listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinks? = nil,
            listIndex: CloudDirectoryClientTypes.BatchListIndex? = nil,
            listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributes? = nil,
            listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildren? = nil,
            listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPaths? = nil,
            listObjectParents: CloudDirectoryClientTypes.BatchListObjectParents? = nil,
            listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPolicies? = nil,
            listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinks? = nil,
            listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachments? = nil,
            lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicy? = nil
        )
        {
            self.getLinkAttributes = getLinkAttributes
            self.getObjectAttributes = getObjectAttributes
            self.getObjectInformation = getObjectInformation
            self.listAttachedIndices = listAttachedIndices
            self.listIncomingTypedLinks = listIncomingTypedLinks
            self.listIndex = listIndex
            self.listObjectAttributes = listObjectAttributes
            self.listObjectChildren = listObjectChildren
            self.listObjectParentPaths = listObjectParentPaths
            self.listObjectParents = listObjectParents
            self.listObjectPolicies = listObjectPolicies
            self.listOutgoingTypedLinks = listOutgoingTypedLinks
            self.listPolicyAttachments = listPolicyAttachments
            self.lookupPolicy = lookupPolicy
        }
    }

}

extension CloudDirectoryClientTypes.BatchReadOperationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionResponse = "ExceptionResponse"
        case successfulResponse = "SuccessfulResponse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionResponse = self.exceptionResponse {
            try encodeContainer.encode(exceptionResponse, forKey: .exceptionResponse)
        }
        if let successfulResponse = self.successfulResponse {
            try encodeContainer.encode(successfulResponse, forKey: .successfulResponse)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulResponseDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchReadSuccessfulResponse.self, forKey: .successfulResponse)
        successfulResponse = successfulResponseDecoded
        let exceptionResponseDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchReadException.self, forKey: .exceptionResponse)
        exceptionResponse = exceptionResponseDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchRead response operation.
    public struct BatchReadOperationResponse: Swift.Equatable {
        /// Identifies which operation in a batch has failed.
        public var exceptionResponse: CloudDirectoryClientTypes.BatchReadException?
        /// Identifies which operation in a batch has succeeded.
        public var successfulResponse: CloudDirectoryClientTypes.BatchReadSuccessfulResponse?

        public init(
            exceptionResponse: CloudDirectoryClientTypes.BatchReadException? = nil,
            successfulResponse: CloudDirectoryClientTypes.BatchReadSuccessfulResponse? = nil
        )
        {
            self.exceptionResponse = exceptionResponse
            self.successfulResponse = successfulResponse
        }
    }

}

extension BatchReadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchReadOutputBody = try responseDecoder.decode(responseBody: data)
            self.responses = output.responses
        } else {
            self.responses = nil
        }
    }
}

public struct BatchReadOutput: Swift.Equatable {
    /// A list of all the responses for each batch read.
    public var responses: [CloudDirectoryClientTypes.BatchReadOperationResponse]?

    public init(
        responses: [CloudDirectoryClientTypes.BatchReadOperationResponse]? = nil
    )
    {
        self.responses = responses
    }
}

struct BatchReadOutputBody: Swift.Equatable {
    let responses: [CloudDirectoryClientTypes.BatchReadOperationResponse]?
}

extension BatchReadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responses = "Responses"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responsesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.BatchReadOperationResponse?].self, forKey: .responses)
        var responsesDecoded0:[CloudDirectoryClientTypes.BatchReadOperationResponse]? = nil
        if let responsesContainer = responsesContainer {
            responsesDecoded0 = [CloudDirectoryClientTypes.BatchReadOperationResponse]()
            for structure0 in responsesContainer {
                if let structure0 = structure0 {
                    responsesDecoded0?.append(structure0)
                }
            }
        }
        responses = responsesDecoded0
    }
}

enum BatchReadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudDirectoryClientTypes.BatchReadSuccessfulResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case getLinkAttributes = "GetLinkAttributes"
        case getObjectAttributes = "GetObjectAttributes"
        case getObjectInformation = "GetObjectInformation"
        case listAttachedIndices = "ListAttachedIndices"
        case listIncomingTypedLinks = "ListIncomingTypedLinks"
        case listIndex = "ListIndex"
        case listObjectAttributes = "ListObjectAttributes"
        case listObjectChildren = "ListObjectChildren"
        case listObjectParentPaths = "ListObjectParentPaths"
        case listObjectParents = "ListObjectParents"
        case listObjectPolicies = "ListObjectPolicies"
        case listOutgoingTypedLinks = "ListOutgoingTypedLinks"
        case listPolicyAttachments = "ListPolicyAttachments"
        case lookupPolicy = "LookupPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let getLinkAttributes = self.getLinkAttributes {
            try encodeContainer.encode(getLinkAttributes, forKey: .getLinkAttributes)
        }
        if let getObjectAttributes = self.getObjectAttributes {
            try encodeContainer.encode(getObjectAttributes, forKey: .getObjectAttributes)
        }
        if let getObjectInformation = self.getObjectInformation {
            try encodeContainer.encode(getObjectInformation, forKey: .getObjectInformation)
        }
        if let listAttachedIndices = self.listAttachedIndices {
            try encodeContainer.encode(listAttachedIndices, forKey: .listAttachedIndices)
        }
        if let listIncomingTypedLinks = self.listIncomingTypedLinks {
            try encodeContainer.encode(listIncomingTypedLinks, forKey: .listIncomingTypedLinks)
        }
        if let listIndex = self.listIndex {
            try encodeContainer.encode(listIndex, forKey: .listIndex)
        }
        if let listObjectAttributes = self.listObjectAttributes {
            try encodeContainer.encode(listObjectAttributes, forKey: .listObjectAttributes)
        }
        if let listObjectChildren = self.listObjectChildren {
            try encodeContainer.encode(listObjectChildren, forKey: .listObjectChildren)
        }
        if let listObjectParentPaths = self.listObjectParentPaths {
            try encodeContainer.encode(listObjectParentPaths, forKey: .listObjectParentPaths)
        }
        if let listObjectParents = self.listObjectParents {
            try encodeContainer.encode(listObjectParents, forKey: .listObjectParents)
        }
        if let listObjectPolicies = self.listObjectPolicies {
            try encodeContainer.encode(listObjectPolicies, forKey: .listObjectPolicies)
        }
        if let listOutgoingTypedLinks = self.listOutgoingTypedLinks {
            try encodeContainer.encode(listOutgoingTypedLinks, forKey: .listOutgoingTypedLinks)
        }
        if let listPolicyAttachments = self.listPolicyAttachments {
            try encodeContainer.encode(listPolicyAttachments, forKey: .listPolicyAttachments)
        }
        if let lookupPolicy = self.lookupPolicy {
            try encodeContainer.encode(lookupPolicy, forKey: .lookupPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectAttributesResponse.self, forKey: .listObjectAttributes)
        listObjectAttributes = listObjectAttributesDecoded
        let listObjectChildrenDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectChildrenResponse.self, forKey: .listObjectChildren)
        listObjectChildren = listObjectChildrenDecoded
        let getObjectInformationDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetObjectInformationResponse.self, forKey: .getObjectInformation)
        getObjectInformation = getObjectInformationDecoded
        let getObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetObjectAttributesResponse.self, forKey: .getObjectAttributes)
        getObjectAttributes = getObjectAttributesDecoded
        let listAttachedIndicesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListAttachedIndicesResponse.self, forKey: .listAttachedIndices)
        listAttachedIndices = listAttachedIndicesDecoded
        let listObjectParentPathsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectParentPathsResponse.self, forKey: .listObjectParentPaths)
        listObjectParentPaths = listObjectParentPathsDecoded
        let listObjectPoliciesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectPoliciesResponse.self, forKey: .listObjectPolicies)
        listObjectPolicies = listObjectPoliciesDecoded
        let listPolicyAttachmentsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse.self, forKey: .listPolicyAttachments)
        listPolicyAttachments = listPolicyAttachmentsDecoded
        let lookupPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchLookupPolicyResponse.self, forKey: .lookupPolicy)
        lookupPolicy = lookupPolicyDecoded
        let listIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListIndexResponse.self, forKey: .listIndex)
        listIndex = listIndexDecoded
        let listOutgoingTypedLinksDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse.self, forKey: .listOutgoingTypedLinks)
        listOutgoingTypedLinks = listOutgoingTypedLinksDecoded
        let listIncomingTypedLinksDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse.self, forKey: .listIncomingTypedLinks)
        listIncomingTypedLinks = listIncomingTypedLinksDecoded
        let getLinkAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchGetLinkAttributesResponse.self, forKey: .getLinkAttributes)
        getLinkAttributes = getLinkAttributesDecoded
        let listObjectParentsDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchListObjectParentsResponse.self, forKey: .listObjectParents)
        listObjectParents = listObjectParentsDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchRead success response operation.
    public struct BatchReadSuccessfulResponse: Swift.Equatable {
        /// The list of attributes to retrieve from the typed link.
        public var getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributesResponse?
        /// Retrieves attributes within a facet that are associated with an object.
        public var getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributesResponse?
        /// Retrieves metadata about an object.
        public var getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformationResponse?
        /// Lists indices attached to an object.
        public var listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndicesResponse?
        /// Returns a paginated list of all the incoming [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse?
        /// Lists objects attached to the specified index.
        public var listIndex: CloudDirectoryClientTypes.BatchListIndexResponse?
        /// Lists all attributes that are associated with an object.
        public var listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributesResponse?
        /// Returns a paginated list of child objects that are associated with a given object.
        public var listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildrenResponse?
        /// Retrieves all available parent paths for any object type such as node, leaf node, policy node, and index node objects. For more information about objects, see [Directory Structure](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directorystructure.html).
        public var listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPathsResponse?
        /// The list of parent objects to retrieve.
        public var listObjectParents: CloudDirectoryClientTypes.BatchListObjectParentsResponse?
        /// Returns policies attached to an object in pagination fashion.
        public var listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPoliciesResponse?
        /// Returns a paginated list of all the outgoing [TypedLinkSpecifier] information for an object. It also supports filtering by typed link facet and identity attributes. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse?
        /// Returns all of the ObjectIdentifiers to which a given policy is attached.
        public var listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse?
        /// Lists all policies from the root of the [Directory] to the object specified. If there are no policies present, an empty list is returned. If policies are present, and if some objects don't have the policies attached, it returns the ObjectIdentifier for such objects. If policies are present, it returns ObjectIdentifier, policyId, and policyType. Paths that don't lead to the root from the target object are ignored. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
        public var lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicyResponse?

        public init(
            getLinkAttributes: CloudDirectoryClientTypes.BatchGetLinkAttributesResponse? = nil,
            getObjectAttributes: CloudDirectoryClientTypes.BatchGetObjectAttributesResponse? = nil,
            getObjectInformation: CloudDirectoryClientTypes.BatchGetObjectInformationResponse? = nil,
            listAttachedIndices: CloudDirectoryClientTypes.BatchListAttachedIndicesResponse? = nil,
            listIncomingTypedLinks: CloudDirectoryClientTypes.BatchListIncomingTypedLinksResponse? = nil,
            listIndex: CloudDirectoryClientTypes.BatchListIndexResponse? = nil,
            listObjectAttributes: CloudDirectoryClientTypes.BatchListObjectAttributesResponse? = nil,
            listObjectChildren: CloudDirectoryClientTypes.BatchListObjectChildrenResponse? = nil,
            listObjectParentPaths: CloudDirectoryClientTypes.BatchListObjectParentPathsResponse? = nil,
            listObjectParents: CloudDirectoryClientTypes.BatchListObjectParentsResponse? = nil,
            listObjectPolicies: CloudDirectoryClientTypes.BatchListObjectPoliciesResponse? = nil,
            listOutgoingTypedLinks: CloudDirectoryClientTypes.BatchListOutgoingTypedLinksResponse? = nil,
            listPolicyAttachments: CloudDirectoryClientTypes.BatchListPolicyAttachmentsResponse? = nil,
            lookupPolicy: CloudDirectoryClientTypes.BatchLookupPolicyResponse? = nil
        )
        {
            self.getLinkAttributes = getLinkAttributes
            self.getObjectAttributes = getObjectAttributes
            self.getObjectInformation = getObjectInformation
            self.listAttachedIndices = listAttachedIndices
            self.listIncomingTypedLinks = listIncomingTypedLinks
            self.listIndex = listIndex
            self.listObjectAttributes = listObjectAttributes
            self.listObjectChildren = listObjectChildren
            self.listObjectParentPaths = listObjectParentPaths
            self.listObjectParents = listObjectParents
            self.listObjectPolicies = listObjectPolicies
            self.listOutgoingTypedLinks = listOutgoingTypedLinks
            self.listPolicyAttachments = listPolicyAttachments
            self.lookupPolicy = lookupPolicy
        }
    }

}

extension CloudDirectoryClientTypes.BatchRemoveFacetFromObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = self.schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A batch operation to remove a facet from an object.
    public struct BatchRemoveFacetFromObject: Swift.Equatable {
        /// A reference to the object whose facet will be removed.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?
        /// The facet to remove from the object.
        /// This member is required.
        public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

        public init(
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
        )
        {
            self.objectReference = objectReference
            self.schemaFacet = schemaFacet
        }
    }

}

extension CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes {
    /// An empty result that represents success.
    public struct BatchRemoveFacetFromObjectResponse: Swift.Equatable {

        public init() { }
    }

}

extension CloudDirectoryClientTypes.BatchUpdateLinkAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for linkattributeupdate0 in attributeUpdates {
                try attributeUpdatesContainer.encode(linkattributeupdate0)
            }
        }
        if let typedLinkSpecifier = self.typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.LinkAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.LinkAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Updates a given typed links attributes inside a [BatchRead] operation. Attributes to be updated must not contribute to the typed links identity, as defined by its IdentityAttributeOrder. For more information, see [UpdateLinkAttributes] and [BatchReadRequest$Operations].
    public struct BatchUpdateLinkAttributes: Swift.Equatable {
        /// The attributes update structure.
        /// This member is required.
        public var attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]?
        /// Allows a typed link specifier to be accepted as input.
        /// This member is required.
        public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

        public init(
            attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil,
            typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
        )
        {
            self.attributeUpdates = attributeUpdates
            self.typedLinkSpecifier = typedLinkSpecifier
        }
    }

}

extension CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a [UpdateLinkAttributes] response operation.
    public struct BatchUpdateLinkAttributesResponse: Swift.Equatable {

        public init() { }
    }

}

extension CloudDirectoryClientTypes.BatchUpdateObjectAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for objectattributeupdate0 in attributeUpdates {
                try attributeUpdatesContainer.encode(objectattributeupdate0)
            }
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.ObjectAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchUpdate operation.
    public struct BatchUpdateObjectAttributes: Swift.Equatable {
        /// Attributes update structure.
        /// This member is required.
        public var attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]?
        /// Reference that identifies the object.
        /// This member is required.
        public var objectReference: CloudDirectoryClientTypes.ObjectReference?

        public init(
            attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil,
            objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
        )
        {
            self.attributeUpdates = attributeUpdates
            self.objectReference = objectReference
        }
    }

}

extension CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = self.objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchUpdate response operation.
    public struct BatchUpdateObjectAttributesResponse: Swift.Equatable {
        /// ID that is associated with the object.
        public var objectIdentifier: Swift.String?

        public init(
            objectIdentifier: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension BatchWriteException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchWriteExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.index = output.index
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.index = 0
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A BatchWrite exception has occurred.
public struct BatchWriteException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var index: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
        public internal(set) var type: CloudDirectoryClientTypes.BatchWriteExceptionType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchWriteException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        index: Swift.Int = 0,
        message: Swift.String? = nil,
        type: CloudDirectoryClientTypes.BatchWriteExceptionType? = nil
    )
    {
        self.properties.index = index
        self.properties.message = message
        self.properties.type = type
    }
}

struct BatchWriteExceptionBody: Swift.Equatable {
    let index: Swift.Int
    let type: CloudDirectoryClientTypes.BatchWriteExceptionType?
    let message: Swift.String?
}

extension BatchWriteExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case index = "Index"
        case message = "Message"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .index) ?? 0
        index = indexDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchWriteExceptionType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes {
    public enum BatchWriteExceptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case directorynotenabledexception
        case facetvalidationexception
        case indexedattributemissingexception
        case internalserviceexception
        case invalidarnexception
        case invalidattachmentexception
        case limitexceededexception
        case linknamealreadyinuseexception
        case notindexexception
        case notnodeexception
        case notpolicyexception
        case objectalreadydetachedexception
        case objectnotdetachedexception
        case resourcenotfoundexception
        case stillcontainslinksexception
        case unsupportedindextypeexception
        case validationexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchWriteExceptionType] {
            return [
                .accessdeniedexception,
                .directorynotenabledexception,
                .facetvalidationexception,
                .indexedattributemissingexception,
                .internalserviceexception,
                .invalidarnexception,
                .invalidattachmentexception,
                .limitexceededexception,
                .linknamealreadyinuseexception,
                .notindexexception,
                .notnodeexception,
                .notpolicyexception,
                .objectalreadydetachedexception,
                .objectnotdetachedexception,
                .resourcenotfoundexception,
                .stillcontainslinksexception,
                .unsupportedindextypeexception,
                .validationexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .directorynotenabledexception: return "DirectoryNotEnabledException"
            case .facetvalidationexception: return "FacetValidationException"
            case .indexedattributemissingexception: return "IndexedAttributeMissingException"
            case .internalserviceexception: return "InternalServiceException"
            case .invalidarnexception: return "InvalidArnException"
            case .invalidattachmentexception: return "InvalidAttachmentException"
            case .limitexceededexception: return "LimitExceededException"
            case .linknamealreadyinuseexception: return "LinkNameAlreadyInUseException"
            case .notindexexception: return "NotIndexException"
            case .notnodeexception: return "NotNodeException"
            case .notpolicyexception: return "NotPolicyException"
            case .objectalreadydetachedexception: return "ObjectAlreadyDetachedException"
            case .objectnotdetachedexception: return "ObjectNotDetachedException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .stillcontainslinksexception: return "StillContainsLinksException"
            case .unsupportedindextypeexception: return "UnsupportedIndexTypeException"
            case .validationexception: return "ValidationException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchWriteExceptionType(rawValue: rawValue) ?? BatchWriteExceptionType.sdkUnknown(rawValue)
        }
    }
}

extension BatchWriteInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for batchwriteoperation0 in operations {
                try operationsContainer.encode(batchwriteoperation0)
            }
        }
    }
}

extension BatchWriteInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension BatchWriteInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/batchwrite"
    }
}

public struct BatchWriteInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A list of operations that are part of the batch.
    /// This member is required.
    public var operations: [CloudDirectoryClientTypes.BatchWriteOperation]?

    public init(
        directoryArn: Swift.String? = nil,
        operations: [CloudDirectoryClientTypes.BatchWriteOperation]? = nil
    )
    {
        self.directoryArn = directoryArn
        self.operations = operations
    }
}

struct BatchWriteInputBody: Swift.Equatable {
    let operations: [CloudDirectoryClientTypes.BatchWriteOperation]?
}

extension BatchWriteInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operations = "Operations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.BatchWriteOperation?].self, forKey: .operations)
        var operationsDecoded0:[CloudDirectoryClientTypes.BatchWriteOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [CloudDirectoryClientTypes.BatchWriteOperation]()
            for structure0 in operationsContainer {
                if let structure0 = structure0 {
                    operationsDecoded0?.append(structure0)
                }
            }
        }
        operations = operationsDecoded0
    }
}

extension CloudDirectoryClientTypes.BatchWriteOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addFacetToObject = "AddFacetToObject"
        case attachObject = "AttachObject"
        case attachPolicy = "AttachPolicy"
        case attachToIndex = "AttachToIndex"
        case attachTypedLink = "AttachTypedLink"
        case createIndex = "CreateIndex"
        case createObject = "CreateObject"
        case deleteObject = "DeleteObject"
        case detachFromIndex = "DetachFromIndex"
        case detachObject = "DetachObject"
        case detachPolicy = "DetachPolicy"
        case detachTypedLink = "DetachTypedLink"
        case removeFacetFromObject = "RemoveFacetFromObject"
        case updateLinkAttributes = "UpdateLinkAttributes"
        case updateObjectAttributes = "UpdateObjectAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addFacetToObject = self.addFacetToObject {
            try encodeContainer.encode(addFacetToObject, forKey: .addFacetToObject)
        }
        if let attachObject = self.attachObject {
            try encodeContainer.encode(attachObject, forKey: .attachObject)
        }
        if let attachPolicy = self.attachPolicy {
            try encodeContainer.encode(attachPolicy, forKey: .attachPolicy)
        }
        if let attachToIndex = self.attachToIndex {
            try encodeContainer.encode(attachToIndex, forKey: .attachToIndex)
        }
        if let attachTypedLink = self.attachTypedLink {
            try encodeContainer.encode(attachTypedLink, forKey: .attachTypedLink)
        }
        if let createIndex = self.createIndex {
            try encodeContainer.encode(createIndex, forKey: .createIndex)
        }
        if let createObject = self.createObject {
            try encodeContainer.encode(createObject, forKey: .createObject)
        }
        if let deleteObject = self.deleteObject {
            try encodeContainer.encode(deleteObject, forKey: .deleteObject)
        }
        if let detachFromIndex = self.detachFromIndex {
            try encodeContainer.encode(detachFromIndex, forKey: .detachFromIndex)
        }
        if let detachObject = self.detachObject {
            try encodeContainer.encode(detachObject, forKey: .detachObject)
        }
        if let detachPolicy = self.detachPolicy {
            try encodeContainer.encode(detachPolicy, forKey: .detachPolicy)
        }
        if let detachTypedLink = self.detachTypedLink {
            try encodeContainer.encode(detachTypedLink, forKey: .detachTypedLink)
        }
        if let removeFacetFromObject = self.removeFacetFromObject {
            try encodeContainer.encode(removeFacetFromObject, forKey: .removeFacetFromObject)
        }
        if let updateLinkAttributes = self.updateLinkAttributes {
            try encodeContainer.encode(updateLinkAttributes, forKey: .updateLinkAttributes)
        }
        if let updateObjectAttributes = self.updateObjectAttributes {
            try encodeContainer.encode(updateObjectAttributes, forKey: .updateObjectAttributes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchCreateObject.self, forKey: .createObject)
        createObject = createObjectDecoded
        let attachObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachObject.self, forKey: .attachObject)
        attachObject = attachObjectDecoded
        let detachObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachObject.self, forKey: .detachObject)
        detachObject = detachObjectDecoded
        let updateObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchUpdateObjectAttributes.self, forKey: .updateObjectAttributes)
        updateObjectAttributes = updateObjectAttributesDecoded
        let deleteObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDeleteObject.self, forKey: .deleteObject)
        deleteObject = deleteObjectDecoded
        let addFacetToObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAddFacetToObject.self, forKey: .addFacetToObject)
        addFacetToObject = addFacetToObjectDecoded
        let removeFacetFromObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchRemoveFacetFromObject.self, forKey: .removeFacetFromObject)
        removeFacetFromObject = removeFacetFromObjectDecoded
        let attachPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachPolicy.self, forKey: .attachPolicy)
        attachPolicy = attachPolicyDecoded
        let detachPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachPolicy.self, forKey: .detachPolicy)
        detachPolicy = detachPolicyDecoded
        let createIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchCreateIndex.self, forKey: .createIndex)
        createIndex = createIndexDecoded
        let attachToIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachToIndex.self, forKey: .attachToIndex)
        attachToIndex = attachToIndexDecoded
        let detachFromIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachFromIndex.self, forKey: .detachFromIndex)
        detachFromIndex = detachFromIndexDecoded
        let attachTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachTypedLink.self, forKey: .attachTypedLink)
        attachTypedLink = attachTypedLinkDecoded
        let detachTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachTypedLink.self, forKey: .detachTypedLink)
        detachTypedLink = detachTypedLinkDecoded
        let updateLinkAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchUpdateLinkAttributes.self, forKey: .updateLinkAttributes)
        updateLinkAttributes = updateLinkAttributesDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchWrite operation.
    public struct BatchWriteOperation: Swift.Equatable {
        /// A batch operation that adds a facet to an object.
        public var addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObject?
        /// Attaches an object to a [Directory].
        public var attachObject: CloudDirectoryClientTypes.BatchAttachObject?
        /// Attaches a policy object to a regular object. An object can have a limited number of attached policies.
        public var attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicy?
        /// Attaches the specified object to the specified index.
        public var attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndex?
        /// Attaches a typed link to a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLink?
        /// Creates an index object. See [Indexing and search](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/indexing_search.htm) for more information.
        public var createIndex: CloudDirectoryClientTypes.BatchCreateIndex?
        /// Creates an object.
        public var createObject: CloudDirectoryClientTypes.BatchCreateObject?
        /// Deletes an object in a [Directory].
        public var deleteObject: CloudDirectoryClientTypes.BatchDeleteObject?
        /// Detaches the specified object from the specified index.
        public var detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndex?
        /// Detaches an object from a [Directory].
        public var detachObject: CloudDirectoryClientTypes.BatchDetachObject?
        /// Detaches a policy from a [Directory].
        public var detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicy?
        /// Detaches a typed link from a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLink?
        /// A batch operation that removes a facet from an object.
        public var removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObject?
        /// Updates a given object's attributes.
        public var updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributes?
        /// Updates a given object's attributes.
        public var updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributes?

        public init(
            addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObject? = nil,
            attachObject: CloudDirectoryClientTypes.BatchAttachObject? = nil,
            attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicy? = nil,
            attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndex? = nil,
            attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLink? = nil,
            createIndex: CloudDirectoryClientTypes.BatchCreateIndex? = nil,
            createObject: CloudDirectoryClientTypes.BatchCreateObject? = nil,
            deleteObject: CloudDirectoryClientTypes.BatchDeleteObject? = nil,
            detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndex? = nil,
            detachObject: CloudDirectoryClientTypes.BatchDetachObject? = nil,
            detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicy? = nil,
            detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLink? = nil,
            removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObject? = nil,
            updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributes? = nil,
            updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributes? = nil
        )
        {
            self.addFacetToObject = addFacetToObject
            self.attachObject = attachObject
            self.attachPolicy = attachPolicy
            self.attachToIndex = attachToIndex
            self.attachTypedLink = attachTypedLink
            self.createIndex = createIndex
            self.createObject = createObject
            self.deleteObject = deleteObject
            self.detachFromIndex = detachFromIndex
            self.detachObject = detachObject
            self.detachPolicy = detachPolicy
            self.detachTypedLink = detachTypedLink
            self.removeFacetFromObject = removeFacetFromObject
            self.updateLinkAttributes = updateLinkAttributes
            self.updateObjectAttributes = updateObjectAttributes
        }
    }

}

extension CloudDirectoryClientTypes.BatchWriteOperationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addFacetToObject = "AddFacetToObject"
        case attachObject = "AttachObject"
        case attachPolicy = "AttachPolicy"
        case attachToIndex = "AttachToIndex"
        case attachTypedLink = "AttachTypedLink"
        case createIndex = "CreateIndex"
        case createObject = "CreateObject"
        case deleteObject = "DeleteObject"
        case detachFromIndex = "DetachFromIndex"
        case detachObject = "DetachObject"
        case detachPolicy = "DetachPolicy"
        case detachTypedLink = "DetachTypedLink"
        case removeFacetFromObject = "RemoveFacetFromObject"
        case updateLinkAttributes = "UpdateLinkAttributes"
        case updateObjectAttributes = "UpdateObjectAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addFacetToObject = self.addFacetToObject {
            try encodeContainer.encode(addFacetToObject, forKey: .addFacetToObject)
        }
        if let attachObject = self.attachObject {
            try encodeContainer.encode(attachObject, forKey: .attachObject)
        }
        if let attachPolicy = self.attachPolicy {
            try encodeContainer.encode(attachPolicy, forKey: .attachPolicy)
        }
        if let attachToIndex = self.attachToIndex {
            try encodeContainer.encode(attachToIndex, forKey: .attachToIndex)
        }
        if let attachTypedLink = self.attachTypedLink {
            try encodeContainer.encode(attachTypedLink, forKey: .attachTypedLink)
        }
        if let createIndex = self.createIndex {
            try encodeContainer.encode(createIndex, forKey: .createIndex)
        }
        if let createObject = self.createObject {
            try encodeContainer.encode(createObject, forKey: .createObject)
        }
        if let deleteObject = self.deleteObject {
            try encodeContainer.encode(deleteObject, forKey: .deleteObject)
        }
        if let detachFromIndex = self.detachFromIndex {
            try encodeContainer.encode(detachFromIndex, forKey: .detachFromIndex)
        }
        if let detachObject = self.detachObject {
            try encodeContainer.encode(detachObject, forKey: .detachObject)
        }
        if let detachPolicy = self.detachPolicy {
            try encodeContainer.encode(detachPolicy, forKey: .detachPolicy)
        }
        if let detachTypedLink = self.detachTypedLink {
            try encodeContainer.encode(detachTypedLink, forKey: .detachTypedLink)
        }
        if let removeFacetFromObject = self.removeFacetFromObject {
            try encodeContainer.encode(removeFacetFromObject, forKey: .removeFacetFromObject)
        }
        if let updateLinkAttributes = self.updateLinkAttributes {
            try encodeContainer.encode(updateLinkAttributes, forKey: .updateLinkAttributes)
        }
        if let updateObjectAttributes = self.updateObjectAttributes {
            try encodeContainer.encode(updateObjectAttributes, forKey: .updateObjectAttributes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchCreateObjectResponse.self, forKey: .createObject)
        createObject = createObjectDecoded
        let attachObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachObjectResponse.self, forKey: .attachObject)
        attachObject = attachObjectDecoded
        let detachObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachObjectResponse.self, forKey: .detachObject)
        detachObject = detachObjectDecoded
        let updateObjectAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse.self, forKey: .updateObjectAttributes)
        updateObjectAttributes = updateObjectAttributesDecoded
        let deleteObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDeleteObjectResponse.self, forKey: .deleteObject)
        deleteObject = deleteObjectDecoded
        let addFacetToObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAddFacetToObjectResponse.self, forKey: .addFacetToObject)
        addFacetToObject = addFacetToObjectDecoded
        let removeFacetFromObjectDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse.self, forKey: .removeFacetFromObject)
        removeFacetFromObject = removeFacetFromObjectDecoded
        let attachPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachPolicyResponse.self, forKey: .attachPolicy)
        attachPolicy = attachPolicyDecoded
        let detachPolicyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachPolicyResponse.self, forKey: .detachPolicy)
        detachPolicy = detachPolicyDecoded
        let createIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchCreateIndexResponse.self, forKey: .createIndex)
        createIndex = createIndexDecoded
        let attachToIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachToIndexResponse.self, forKey: .attachToIndex)
        attachToIndex = attachToIndexDecoded
        let detachFromIndexDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachFromIndexResponse.self, forKey: .detachFromIndex)
        detachFromIndex = detachFromIndexDecoded
        let attachTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchAttachTypedLinkResponse.self, forKey: .attachTypedLink)
        attachTypedLink = attachTypedLinkDecoded
        let detachTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchDetachTypedLinkResponse.self, forKey: .detachTypedLink)
        detachTypedLink = detachTypedLinkDecoded
        let updateLinkAttributesDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse.self, forKey: .updateLinkAttributes)
        updateLinkAttributes = updateLinkAttributesDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the output of a BatchWrite response operation.
    public struct BatchWriteOperationResponse: Swift.Equatable {
        /// The result of an add facet to object batch operation.
        public var addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObjectResponse?
        /// Attaches an object to a [Directory].
        public var attachObject: CloudDirectoryClientTypes.BatchAttachObjectResponse?
        /// Attaches a policy object to a regular object. An object can have a limited number of attached policies.
        public var attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicyResponse?
        /// Attaches the specified object to the specified index.
        public var attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndexResponse?
        /// Attaches a typed link to a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLinkResponse?
        /// Creates an index object. See [Indexing and search](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/indexing_search.htm) for more information.
        public var createIndex: CloudDirectoryClientTypes.BatchCreateIndexResponse?
        /// Creates an object in a [Directory].
        public var createObject: CloudDirectoryClientTypes.BatchCreateObjectResponse?
        /// Deletes an object in a [Directory].
        public var deleteObject: CloudDirectoryClientTypes.BatchDeleteObjectResponse?
        /// Detaches the specified object from the specified index.
        public var detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndexResponse?
        /// Detaches an object from a [Directory].
        public var detachObject: CloudDirectoryClientTypes.BatchDetachObjectResponse?
        /// Detaches a policy from a [Directory].
        public var detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicyResponse?
        /// Detaches a typed link from a specified source and target object. For more information, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
        public var detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLinkResponse?
        /// The result of a batch remove facet from object operation.
        public var removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse?
        /// Represents the output of a BatchWrite response operation.
        public var updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse?
        /// Updates a given objects attributes.
        public var updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse?

        public init(
            addFacetToObject: CloudDirectoryClientTypes.BatchAddFacetToObjectResponse? = nil,
            attachObject: CloudDirectoryClientTypes.BatchAttachObjectResponse? = nil,
            attachPolicy: CloudDirectoryClientTypes.BatchAttachPolicyResponse? = nil,
            attachToIndex: CloudDirectoryClientTypes.BatchAttachToIndexResponse? = nil,
            attachTypedLink: CloudDirectoryClientTypes.BatchAttachTypedLinkResponse? = nil,
            createIndex: CloudDirectoryClientTypes.BatchCreateIndexResponse? = nil,
            createObject: CloudDirectoryClientTypes.BatchCreateObjectResponse? = nil,
            deleteObject: CloudDirectoryClientTypes.BatchDeleteObjectResponse? = nil,
            detachFromIndex: CloudDirectoryClientTypes.BatchDetachFromIndexResponse? = nil,
            detachObject: CloudDirectoryClientTypes.BatchDetachObjectResponse? = nil,
            detachPolicy: CloudDirectoryClientTypes.BatchDetachPolicyResponse? = nil,
            detachTypedLink: CloudDirectoryClientTypes.BatchDetachTypedLinkResponse? = nil,
            removeFacetFromObject: CloudDirectoryClientTypes.BatchRemoveFacetFromObjectResponse? = nil,
            updateLinkAttributes: CloudDirectoryClientTypes.BatchUpdateLinkAttributesResponse? = nil,
            updateObjectAttributes: CloudDirectoryClientTypes.BatchUpdateObjectAttributesResponse? = nil
        )
        {
            self.addFacetToObject = addFacetToObject
            self.attachObject = attachObject
            self.attachPolicy = attachPolicy
            self.attachToIndex = attachToIndex
            self.attachTypedLink = attachTypedLink
            self.createIndex = createIndex
            self.createObject = createObject
            self.deleteObject = deleteObject
            self.detachFromIndex = detachFromIndex
            self.detachObject = detachObject
            self.detachPolicy = detachPolicy
            self.detachTypedLink = detachTypedLink
            self.removeFacetFromObject = removeFacetFromObject
            self.updateLinkAttributes = updateLinkAttributes
            self.updateObjectAttributes = updateObjectAttributes
        }
    }

}

extension BatchWriteOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchWriteOutputBody = try responseDecoder.decode(responseBody: data)
            self.responses = output.responses
        } else {
            self.responses = nil
        }
    }
}

public struct BatchWriteOutput: Swift.Equatable {
    /// A list of all the responses for each batch write.
    public var responses: [CloudDirectoryClientTypes.BatchWriteOperationResponse]?

    public init(
        responses: [CloudDirectoryClientTypes.BatchWriteOperationResponse]? = nil
    )
    {
        self.responses = responses
    }
}

struct BatchWriteOutputBody: Swift.Equatable {
    let responses: [CloudDirectoryClientTypes.BatchWriteOperationResponse]?
}

extension BatchWriteOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responses = "Responses"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responsesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.BatchWriteOperationResponse?].self, forKey: .responses)
        var responsesDecoded0:[CloudDirectoryClientTypes.BatchWriteOperationResponse]? = nil
        if let responsesContainer = responsesContainer {
            responsesDecoded0 = [CloudDirectoryClientTypes.BatchWriteOperationResponse]()
            for structure0 in responsesContainer {
                if let structure0 = structure0 {
                    responsesDecoded0?.append(structure0)
                }
            }
        }
        responses = responsesDecoded0
    }
}

enum BatchWriteOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BatchWriteException": return try await BatchWriteException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CannotListParentOfRootException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CannotListParentOfRootExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cannot list the parents of a [Directory] root.
public struct CannotListParentOfRootException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotListParentOfRootException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CannotListParentOfRootExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CannotListParentOfRootExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes {
    public enum ConsistencyLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventual
        case serializable
        case sdkUnknown(Swift.String)

        public static var allCases: [ConsistencyLevel] {
            return [
                .eventual,
                .serializable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventual: return "EVENTUAL"
            case .serializable: return "SERIALIZABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConsistencyLevel(rawValue: rawValue) ?? ConsistencyLevel.sdkUnknown(rawValue)
        }
    }
}

extension CreateDirectoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateDirectoryInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension CreateDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/create"
    }
}

public struct CreateDirectoryInput: Swift.Equatable {
    /// The name of the [Directory]. Should be unique per account, per region.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the published schema that will be copied into the data [Directory]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct CreateDirectoryInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateDirectoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.appliedSchemaArn = output.appliedSchemaArn
            self.directoryArn = output.directoryArn
            self.name = output.name
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.appliedSchemaArn = nil
            self.directoryArn = nil
            self.name = nil
            self.objectIdentifier = nil
        }
    }
}

public struct CreateDirectoryOutput: Swift.Equatable {
    /// The ARN of the published schema in the [Directory]. Once a published schema is copied into the directory, it has its own ARN, which is referred to applied schema ARN. For more information, see [arns].
    /// This member is required.
    public var appliedSchemaArn: Swift.String?
    /// The ARN that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The name of the [Directory].
    /// This member is required.
    public var name: Swift.String?
    /// The root object node of the created directory.
    /// This member is required.
    public var objectIdentifier: Swift.String?

    public init(
        appliedSchemaArn: Swift.String? = nil,
        directoryArn: Swift.String? = nil,
        name: Swift.String? = nil,
        objectIdentifier: Swift.String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
        self.directoryArn = directoryArn
        self.name = name
        self.objectIdentifier = objectIdentifier
    }
}

struct CreateDirectoryOutputBody: Swift.Equatable {
    let directoryArn: Swift.String?
    let name: Swift.String?
    let objectIdentifier: Swift.String?
    let appliedSchemaArn: Swift.String?
}

extension CreateDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedSchemaArn = "AppliedSchemaArn"
        case directoryArn = "DirectoryArn"
        case name = "Name"
        case objectIdentifier = "ObjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
        let appliedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appliedSchemaArn)
        appliedSchemaArn = appliedSchemaArnDecoded
    }
}

enum CreateDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryAlreadyExistsException": return try await DirectoryAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFacetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case facetStyle = "FacetStyle"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for facetattribute0 in attributes {
                try attributesContainer.encode(facetattribute0)
            }
        }
        if let facetStyle = self.facetStyle {
            try encodeContainer.encode(facetStyle.rawValue, forKey: .facetStyle)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectType = self.objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }
}

extension CreateFacetInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension CreateFacetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet/create"
    }
}

public struct CreateFacetInput: Swift.Equatable {
    /// The attributes that are associated with the [Facet].
    public var attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    /// There are two different styles that you can define on any given facet, Static and Dynamic. For static facets, all attributes must be defined in the schema. For dynamic facets, attributes can be defined during data plane operations.
    public var facetStyle: CloudDirectoryClientTypes.FacetStyle?
    /// The name of the [Facet], which is unique for a given schema.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies whether a given object created from this facet is of type node, leaf node, policy or index.
    ///
    /// * Node: Can have multiple children but one parent.
    ///
    ///
    ///
    ///
    /// * Leaf node: Cannot have children but can have multiple parents.
    ///
    ///
    ///
    ///
    /// * Policy: Allows you to store a policy document and policy type. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
    ///
    ///
    ///
    ///
    /// * Index: Can be created with the Index API.
    public var objectType: CloudDirectoryClientTypes.ObjectType?
    /// The schema ARN in which the new [Facet] will be created. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        attributes: [CloudDirectoryClientTypes.FacetAttribute]? = nil,
        facetStyle: CloudDirectoryClientTypes.FacetStyle? = nil,
        name: Swift.String? = nil,
        objectType: CloudDirectoryClientTypes.ObjectType? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.facetStyle = facetStyle
        self.name = name
        self.objectType = objectType
        self.schemaArn = schemaArn
    }
}

struct CreateFacetInputBody: Swift.Equatable {
    let name: Swift.String?
    let attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    let objectType: CloudDirectoryClientTypes.ObjectType?
    let facetStyle: CloudDirectoryClientTypes.FacetStyle?
}

extension CreateFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case facetStyle = "FacetStyle"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.FacetAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.FacetAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.FacetAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let objectTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectType.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let facetStyleDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetStyle.self, forKey: .facetStyle)
        facetStyle = facetStyleDecoded
    }
}

extension CreateFacetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateFacetOutput: Swift.Equatable {

    public init() { }
}

enum CreateFacetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetAlreadyExistsException": return try await FacetAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuleException": return try await InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isUnique = "IsUnique"
        case linkName = "LinkName"
        case orderedIndexedAttributeList = "OrderedIndexedAttributeList"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isUnique = self.isUnique {
            try encodeContainer.encode(isUnique, forKey: .isUnique)
        }
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let orderedIndexedAttributeList = orderedIndexedAttributeList {
            var orderedIndexedAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedIndexedAttributeList)
            for attributekey0 in orderedIndexedAttributeList {
                try orderedIndexedAttributeListContainer.encode(attributekey0)
            }
        }
        if let parentReference = self.parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }
}

extension CreateIndexInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension CreateIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/index"
    }
}

public struct CreateIndexInput: Swift.Equatable {
    /// The ARN of the directory where the index should be created.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Indicates whether the attribute that is being indexed has unique values or not.
    /// This member is required.
    public var isUnique: Swift.Bool?
    /// The name of the link between the parent object and the index object.
    public var linkName: Swift.String?
    /// Specifies the attributes that should be indexed on. Currently only a single attribute is supported.
    /// This member is required.
    public var orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]?
    /// A reference to the parent object that contains the index object.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        isUnique: Swift.Bool? = nil,
        linkName: Swift.String? = nil,
        orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.isUnique = isUnique
        self.linkName = linkName
        self.orderedIndexedAttributeList = orderedIndexedAttributeList
        self.parentReference = parentReference
    }
}

struct CreateIndexInputBody: Swift.Equatable {
    let orderedIndexedAttributeList: [CloudDirectoryClientTypes.AttributeKey]?
    let isUnique: Swift.Bool?
    let parentReference: CloudDirectoryClientTypes.ObjectReference?
    let linkName: Swift.String?
}

extension CreateIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isUnique = "IsUnique"
        case linkName = "LinkName"
        case orderedIndexedAttributeList = "OrderedIndexedAttributeList"
        case parentReference = "ParentReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderedIndexedAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKey?].self, forKey: .orderedIndexedAttributeList)
        var orderedIndexedAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKey]? = nil
        if let orderedIndexedAttributeListContainer = orderedIndexedAttributeListContainer {
            orderedIndexedAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKey]()
            for structure0 in orderedIndexedAttributeListContainer {
                if let structure0 = structure0 {
                    orderedIndexedAttributeListDecoded0?.append(structure0)
                }
            }
        }
        orderedIndexedAttributeList = orderedIndexedAttributeListDecoded0
        let isUniqueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isUnique)
        isUnique = isUniqueDecoded
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CreateIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.objectIdentifier = nil
        }
    }
}

public struct CreateIndexOutput: Swift.Equatable {
    /// The ObjectIdentifier of the index created by this operation.
    public var objectIdentifier: Swift.String?

    public init(
        objectIdentifier: Swift.String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

struct CreateIndexOutputBody: Swift.Equatable {
    let objectIdentifier: Swift.String?
}

extension CreateIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

enum CreateIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LinkNameAlreadyInUseException": return try await LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedIndexTypeException": return try await UnsupportedIndexTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case objectAttributeList = "ObjectAttributeList"
        case parentReference = "ParentReference"
        case schemaFacets = "SchemaFacets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let objectAttributeList = objectAttributeList {
            var objectAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectAttributeList)
            for attributekeyandvalue0 in objectAttributeList {
                try objectAttributeListContainer.encode(attributekeyandvalue0)
            }
        }
        if let parentReference = self.parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
        if let schemaFacets = schemaFacets {
            var schemaFacetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schemaFacets)
            for schemafacet0 in schemaFacets {
                try schemaFacetsContainer.encode(schemafacet0)
            }
        }
    }
}

extension CreateObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension CreateObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object"
    }
}

public struct CreateObjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] in which the object will be created. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The name of link that is used to attach this object to a parent.
    public var linkName: Swift.String?
    /// The attribute map whose attribute ARN contains the key and attribute value as the map value.
    public var objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    /// If specified, the parent reference to which this object will be attached.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?
    /// A list of schema facets to be associated with the object. Do not provide minor version components. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?

    public init(
        directoryArn: Swift.String? = nil,
        linkName: Swift.String? = nil,
        objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]? = nil
    )
    {
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.objectAttributeList = objectAttributeList
        self.parentReference = parentReference
        self.schemaFacets = schemaFacets
    }
}

struct CreateObjectInputBody: Swift.Equatable {
    let schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?
    let objectAttributeList: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    let parentReference: CloudDirectoryClientTypes.ObjectReference?
    let linkName: Swift.String?
}

extension CreateObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case objectAttributeList = "ObjectAttributeList"
        case parentReference = "ParentReference"
        case schemaFacets = "SchemaFacets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.SchemaFacet?].self, forKey: .schemaFacets)
        var schemaFacetsDecoded0:[CloudDirectoryClientTypes.SchemaFacet]? = nil
        if let schemaFacetsContainer = schemaFacetsContainer {
            schemaFacetsDecoded0 = [CloudDirectoryClientTypes.SchemaFacet]()
            for structure0 in schemaFacetsContainer {
                if let structure0 = structure0 {
                    schemaFacetsDecoded0?.append(structure0)
                }
            }
        }
        schemaFacets = schemaFacetsDecoded0
        let objectAttributeListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .objectAttributeList)
        var objectAttributeListDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let objectAttributeListContainer = objectAttributeListContainer {
            objectAttributeListDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in objectAttributeListContainer {
                if let structure0 = structure0 {
                    objectAttributeListDecoded0?.append(structure0)
                }
            }
        }
        objectAttributeList = objectAttributeListDecoded0
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CreateObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateObjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.objectIdentifier = nil
        }
    }
}

public struct CreateObjectOutput: Swift.Equatable {
    /// The identifier that is associated with the object.
    public var objectIdentifier: Swift.String?

    public init(
        objectIdentifier: Swift.String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

struct CreateObjectOutputBody: Swift.Equatable {
    let objectIdentifier: Swift.String?
}

extension CreateObjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

enum CreateObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LinkNameAlreadyInUseException": return try await LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedIndexTypeException": return try await UnsupportedIndexTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/create"
    }
}

public struct CreateSchemaInput: Swift.Equatable {
    /// The name that is associated with the schema. This is unique to each account and in each region.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateSchemaInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct CreateSchemaOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct CreateSchemaOutputBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension CreateSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

enum CreateSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SchemaAlreadyExistsException": return try await SchemaAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTypedLinkFacetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facet = "Facet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facet = self.facet {
            try encodeContainer.encode(facet, forKey: .facet)
        }
    }
}

extension CreateTypedLinkFacetInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension CreateTypedLinkFacetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/create"
    }
}

public struct CreateTypedLinkFacetInput: Swift.Equatable {
    /// [Facet] structure that is associated with the typed link facet.
    /// This member is required.
    public var facet: CloudDirectoryClientTypes.TypedLinkFacet?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        facet: CloudDirectoryClientTypes.TypedLinkFacet? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.facet = facet
        self.schemaArn = schemaArn
    }
}

struct CreateTypedLinkFacetInputBody: Swift.Equatable {
    let facet: CloudDirectoryClientTypes.TypedLinkFacet?
}

extension CreateTypedLinkFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facet = "Facet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkFacet.self, forKey: .facet)
        facet = facetDecoded
    }
}

extension CreateTypedLinkFacetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateTypedLinkFacetOutput: Swift.Equatable {

    public init() { }
}

enum CreateTypedLinkFacetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetAlreadyExistsException": return try await FacetAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuleException": return try await InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDirectoryInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DeleteDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory"
    }
}

public struct DeleteDirectoryInput: Swift.Equatable {
    /// The ARN of the directory to delete.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DeleteDirectoryInputBody: Swift.Equatable {
}

extension DeleteDirectoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryArn = output.directoryArn
        } else {
            self.directoryArn = nil
        }
    }
}

public struct DeleteDirectoryOutput: Swift.Equatable {
    /// The ARN of the deleted directory.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DeleteDirectoryOutputBody: Swift.Equatable {
    let directoryArn: Swift.String?
}

extension DeleteDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

enum DeleteDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDeletedException": return try await DirectoryDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotDisabledException": return try await DirectoryNotDisabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFacetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteFacetInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension DeleteFacetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet/delete"
    }
}

public struct DeleteFacetInput: Swift.Equatable {
    /// The name of the facet to delete.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the [Facet]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct DeleteFacetInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteFacetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFacetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFacetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetInUseException": return try await FacetInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetNotFoundException": return try await FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension DeleteObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DeleteObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/delete"
    }
}

public struct DeleteObjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference that identifies the object.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

struct DeleteObjectInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension DeleteObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension DeleteObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteObjectOutput: Swift.Equatable {

    public init() { }
}

enum DeleteObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ObjectNotDetachedException": return try await ObjectNotDetachedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSchemaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension DeleteSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema"
    }
}

public struct DeleteSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the development schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaInputBody: Swift.Equatable {
}

extension DeleteSchemaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct DeleteSchemaOutput: Swift.Equatable {
    /// The input ARN that is returned as part of the response. For more information, see [arns].
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaOutputBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension DeleteSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

enum DeleteSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StillContainsLinksException": return try await StillContainsLinksException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTypedLinkFacetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteTypedLinkFacetInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension DeleteTypedLinkFacetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/delete"
    }
}

public struct DeleteTypedLinkFacetInput: Swift.Equatable {
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct DeleteTypedLinkFacetInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteTypedLinkFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTypedLinkFacetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTypedLinkFacetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTypedLinkFacetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetNotFoundException": return try await FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachFromIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = self.indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let targetReference = self.targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }
}

extension DetachFromIndexInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DetachFromIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/index/detach"
    }
}

public struct DetachFromIndexInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the directory the index and object exist in.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the index object.
    /// This member is required.
    public var indexReference: CloudDirectoryClientTypes.ObjectReference?
    /// A reference to the object being detached from the index.
    /// This member is required.
    public var targetReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.targetReference = targetReference
    }
}

struct DetachFromIndexInputBody: Swift.Equatable {
    let indexReference: CloudDirectoryClientTypes.ObjectReference?
    let targetReference: CloudDirectoryClientTypes.ObjectReference?
}

extension DetachFromIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case targetReference = "TargetReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
    }
}

extension DetachFromIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DetachFromIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.detachedObjectIdentifier = output.detachedObjectIdentifier
        } else {
            self.detachedObjectIdentifier = nil
        }
    }
}

public struct DetachFromIndexOutput: Swift.Equatable {
    /// The ObjectIdentifier of the object that was detached from the index.
    public var detachedObjectIdentifier: Swift.String?

    public init(
        detachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

struct DetachFromIndexOutputBody: Swift.Equatable {
    let detachedObjectIdentifier: Swift.String?
}

extension DetachFromIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detachedObjectIdentifier = "DetachedObjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

enum DetachFromIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotIndexException": return try await NotIndexException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ObjectAlreadyDetachedException": return try await ObjectAlreadyDetachedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let parentReference = self.parentReference {
            try encodeContainer.encode(parentReference, forKey: .parentReference)
        }
    }
}

extension DetachObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DetachObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/detach"
    }
}

public struct DetachObjectInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The link name associated with the object that needs to be detached.
    /// This member is required.
    public var linkName: Swift.String?
    /// The parent reference from which the object with the specified link name is detached.
    /// This member is required.
    public var parentReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        linkName: Swift.String? = nil,
        parentReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.linkName = linkName
        self.parentReference = parentReference
    }
}

struct DetachObjectInputBody: Swift.Equatable {
    let parentReference: CloudDirectoryClientTypes.ObjectReference?
    let linkName: Swift.String?
}

extension DetachObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case parentReference = "ParentReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .parentReference)
        parentReference = parentReferenceDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension DetachObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DetachObjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.detachedObjectIdentifier = output.detachedObjectIdentifier
        } else {
            self.detachedObjectIdentifier = nil
        }
    }
}

public struct DetachObjectOutput: Swift.Equatable {
    /// The ObjectIdentifier that was detached from the object.
    public var detachedObjectIdentifier: Swift.String?

    public init(
        detachedObjectIdentifier: Swift.String? = nil
    )
    {
        self.detachedObjectIdentifier = detachedObjectIdentifier
    }
}

struct DetachObjectOutputBody: Swift.Equatable {
    let detachedObjectIdentifier: Swift.String?
}

extension DetachObjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detachedObjectIdentifier = "DetachedObjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detachedObjectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detachedObjectIdentifier)
        detachedObjectIdentifier = detachedObjectIdentifierDecoded
    }
}

enum DetachObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotNodeException": return try await NotNodeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let policyReference = self.policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }
}

extension DetachPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DetachPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/policy/detach"
    }
}

public struct DetachPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where both objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Reference that identifies the object whose policy object will be detached.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Reference that identifies the policy object.
    /// This member is required.
    public var policyReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.policyReference = policyReference
    }
}

struct DetachPolicyInputBody: Swift.Equatable {
    let policyReference: CloudDirectoryClientTypes.ObjectReference?
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension DetachPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case policyReference = "PolicyReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension DetachPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DetachPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotPolicyException": return try await NotPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachTypedLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let typedLinkSpecifier = self.typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }
}

extension DetachTypedLinkInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DetachTypedLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/detach"
    }
}

public struct DetachTypedLinkInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the directory where you want to detach the typed link.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Used to accept a typed link specifier as input.
    /// This member is required.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init(
        directoryArn: Swift.String? = nil,
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct DetachTypedLinkInputBody: Swift.Equatable {
    let typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?
}

extension DetachTypedLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
    }
}

extension DetachTypedLinkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachTypedLinkOutput: Swift.Equatable {

    public init() { }
}

enum DetachTypedLinkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudDirectoryClientTypes.Directory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime = "CreationDateTime"
        case directoryArn = "DirectoryArn"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let directoryArn = self.directoryArn {
            try encodeContainer.encode(directoryArn, forKey: .directoryArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.DirectoryState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Directory structure that includes the directory name and directory ARN.
    public struct Directory: Swift.Equatable {
        /// The date and time when the directory was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) that is associated with the directory. For more information, see [arns].
        public var directoryArn: Swift.String?
        /// The name of the directory.
        public var name: Swift.String?
        /// The state of the directory. Can be either Enabled, Disabled, or Deleted.
        public var state: CloudDirectoryClientTypes.DirectoryState?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            directoryArn: Swift.String? = nil,
            name: Swift.String? = nil,
            state: CloudDirectoryClientTypes.DirectoryState? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.directoryArn = directoryArn
            self.name = name
            self.state = state
        }
    }

}

extension DirectoryAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a [Directory] could not be created due to a naming conflict. Choose a different name and try again.
public struct DirectoryAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DirectoryAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryDeletedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryDeletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A directory that has been deleted and to which access has been attempted. Note: The requested resource will eventually cease to exist.
public struct DirectoryDeletedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryDeletedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DirectoryDeletedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryDeletedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryNotDisabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryNotDisabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An operation can only operate on a disabled directory.
public struct DirectoryNotDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryNotDisabledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DirectoryNotDisabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryNotDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryNotEnabledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DirectoryNotEnabledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Operations are only permitted on enabled directories.
public struct DirectoryNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryNotEnabledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DirectoryNotEnabledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DirectoryNotEnabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes {
    public enum DirectoryState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectoryState] {
            return [
                .deleted,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DirectoryState(rawValue: rawValue) ?? DirectoryState.sdkUnknown(rawValue)
        }
    }
}

extension DisableDirectoryInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension DisableDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/disable"
    }
}

public struct DisableDirectoryInput: Swift.Equatable {
    /// The ARN of the directory to disable.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DisableDirectoryInputBody: Swift.Equatable {
}

extension DisableDirectoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryArn = output.directoryArn
        } else {
            self.directoryArn = nil
        }
    }
}

public struct DisableDirectoryOutput: Swift.Equatable {
    /// The ARN of the directory that has been disabled.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct DisableDirectoryOutputBody: Swift.Equatable {
    let directoryArn: Swift.String?
}

extension DisableDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

enum DisableDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDeletedException": return try await DirectoryDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableDirectoryInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension EnableDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/enable"
    }
}

public struct EnableDirectoryInput: Swift.Equatable {
    /// The ARN of the directory to enable.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct EnableDirectoryInputBody: Swift.Equatable {
}

extension EnableDirectoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension EnableDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryArn = output.directoryArn
        } else {
            self.directoryArn = nil
        }
    }
}

public struct EnableDirectoryOutput: Swift.Equatable {
    /// The ARN of the enabled directory.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct EnableDirectoryOutputBody: Swift.Equatable {
    let directoryArn: Swift.String?
}

extension EnableDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

enum EnableDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryDeletedException": return try await DirectoryDeletedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudDirectoryClientTypes.Facet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetStyle = "FacetStyle"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetStyle = self.facetStyle {
            try encodeContainer.encode(facetStyle.rawValue, forKey: .facetStyle)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectType = self.objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let objectTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectType.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let facetStyleDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetStyle.self, forKey: .facetStyle)
        facetStyle = facetStyleDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A structure that contains Name, ARN, Attributes, [Rule]s, and ObjectTypes. See [Facets](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_whatarefacets.html) for more information.
    public struct Facet: Swift.Equatable {
        /// There are two different styles that you can define on any given facet, Static and Dynamic. For static facets, all attributes must be defined in the schema. For dynamic facets, attributes can be defined during data plane operations.
        public var facetStyle: CloudDirectoryClientTypes.FacetStyle?
        /// The name of the [Facet].
        public var name: Swift.String?
        /// The object type that is associated with the facet. See [CreateFacetRequest$ObjectType] for more details.
        public var objectType: CloudDirectoryClientTypes.ObjectType?

        public init(
            facetStyle: CloudDirectoryClientTypes.FacetStyle? = nil,
            name: Swift.String? = nil,
            objectType: CloudDirectoryClientTypes.ObjectType? = nil
        )
        {
            self.facetStyle = facetStyle
            self.name = name
            self.objectType = objectType
        }
    }

}

extension FacetAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FacetAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A facet with the same name already exists.
public struct FacetAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FacetAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FacetAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FacetAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.FacetAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeDefinition = "AttributeDefinition"
        case attributeReference = "AttributeReference"
        case name = "Name"
        case requiredBehavior = "RequiredBehavior"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeDefinition = self.attributeDefinition {
            try encodeContainer.encode(attributeDefinition, forKey: .attributeDefinition)
        }
        if let attributeReference = self.attributeReference {
            try encodeContainer.encode(attributeReference, forKey: .attributeReference)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredBehavior = self.requiredBehavior {
            try encodeContainer.encode(requiredBehavior.rawValue, forKey: .requiredBehavior)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributeDefinitionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttributeDefinition.self, forKey: .attributeDefinition)
        attributeDefinition = attributeDefinitionDecoded
        let attributeReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttributeReference.self, forKey: .attributeReference)
        attributeReference = attributeReferenceDecoded
        let requiredBehaviorDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RequiredAttributeBehavior.self, forKey: .requiredBehavior)
        requiredBehavior = requiredBehaviorDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// An attribute that is associated with the [Facet].
    public struct FacetAttribute: Swift.Equatable {
        /// A facet attribute consists of either a definition or a reference. This structure contains the attribute definition. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        public var attributeDefinition: CloudDirectoryClientTypes.FacetAttributeDefinition?
        /// An attribute reference that is associated with the attribute. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        public var attributeReference: CloudDirectoryClientTypes.FacetAttributeReference?
        /// The name of the facet attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The required behavior of the FacetAttribute.
        public var requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior?

        public init(
            attributeDefinition: CloudDirectoryClientTypes.FacetAttributeDefinition? = nil,
            attributeReference: CloudDirectoryClientTypes.FacetAttributeReference? = nil,
            name: Swift.String? = nil,
            requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior? = nil
        )
        {
            self.attributeDefinition = attributeDefinition
            self.attributeReference = attributeReference
            self.name = name
            self.requiredBehavior = requiredBehavior
        }
    }

}

extension CloudDirectoryClientTypes.FacetAttributeDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case isImmutable = "IsImmutable"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if isImmutable != false {
            try encodeContainer.encode(isImmutable, forKey: .isImmutable)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .rules)
            for (dictKey0, ruleMap0) in rules {
                try rulesContainer.encode(ruleMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttributeType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let isImmutableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isImmutable) ?? false
        isImmutable = isImmutableDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Swift.String: CloudDirectoryClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0: [Swift.String:CloudDirectoryClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Swift.String:CloudDirectoryClientTypes.Rule]()
            for (key0, rule0) in rulesContainer {
                if let rule0 = rule0 {
                    rulesDecoded0?[key0] = rule0
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// A facet attribute definition. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
    public struct FacetAttributeDefinition: Swift.Equatable {
        /// The default value of the attribute (if configured).
        public var defaultValue: CloudDirectoryClientTypes.TypedAttributeValue?
        /// Whether the attribute is mutable or not.
        public var isImmutable: Swift.Bool
        /// Validation rules attached to the attribute definition.
        public var rules: [Swift.String:CloudDirectoryClientTypes.Rule]?
        /// The type of the attribute.
        /// This member is required.
        public var type: CloudDirectoryClientTypes.FacetAttributeType?

        public init(
            defaultValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil,
            isImmutable: Swift.Bool = false,
            rules: [Swift.String:CloudDirectoryClientTypes.Rule]? = nil,
            type: CloudDirectoryClientTypes.FacetAttributeType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.isImmutable = isImmutable
            self.rules = rules
            self.type = type
        }
    }

}

extension CloudDirectoryClientTypes.FacetAttributeReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetAttributeName = "TargetAttributeName"
        case targetFacetName = "TargetFacetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetAttributeName = self.targetAttributeName {
            try encodeContainer.encode(targetAttributeName, forKey: .targetAttributeName)
        }
        if let targetFacetName = self.targetFacetName {
            try encodeContainer.encode(targetFacetName, forKey: .targetFacetName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetFacetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetFacetName)
        targetFacetName = targetFacetNameDecoded
        let targetAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAttributeName)
        targetAttributeName = targetAttributeNameDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// The facet attribute reference that specifies the attribute definition that contains the attribute facet name and attribute name.
    public struct FacetAttributeReference: Swift.Equatable {
        /// The target attribute name that is associated with the facet reference. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        /// This member is required.
        public var targetAttributeName: Swift.String?
        /// The target facet name that is associated with the facet reference. See [Attribute References](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_attributereferences.html) for more information.
        /// This member is required.
        public var targetFacetName: Swift.String?

        public init(
            targetAttributeName: Swift.String? = nil,
            targetFacetName: Swift.String? = nil
        )
        {
            self.targetAttributeName = targetAttributeName
            self.targetFacetName = targetFacetName
        }
    }

}

extension CloudDirectoryClientTypes {
    public enum FacetAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binary
        case boolean
        case datetime
        case number
        case string
        case variant
        case sdkUnknown(Swift.String)

        public static var allCases: [FacetAttributeType] {
            return [
                .binary,
                .boolean,
                .datetime,
                .number,
                .string,
                .variant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binary: return "BINARY"
            case .boolean: return "BOOLEAN"
            case .datetime: return "DATETIME"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case .variant: return "VARIANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FacetAttributeType(rawValue: rawValue) ?? FacetAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension CloudDirectoryClientTypes.FacetAttributeUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case attribute = "Attribute"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.UpdateActionType.self, forKey: .action)
        action = actionDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A structure that contains information used to update an attribute.
    public struct FacetAttributeUpdate: Swift.Equatable {
        /// The action to perform when updating the attribute.
        public var action: CloudDirectoryClientTypes.UpdateActionType?
        /// The attribute to update.
        public var attribute: CloudDirectoryClientTypes.FacetAttribute?

        public init(
            action: CloudDirectoryClientTypes.UpdateActionType? = nil,
            attribute: CloudDirectoryClientTypes.FacetAttribute? = nil
        )
        {
            self.action = action
            self.attribute = attribute
        }
    }

}

extension FacetInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FacetInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when deleting a facet that contains an attribute that is a target to an attribute reference in a different facet.
public struct FacetInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FacetInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FacetInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FacetInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FacetNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FacetNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified [Facet] could not be found.
public struct FacetNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FacetNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FacetNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FacetNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes {
    public enum FacetStyle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [FacetStyle] {
            return [
                .dynamic,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FacetStyle(rawValue: rawValue) ?? FacetStyle.sdkUnknown(rawValue)
        }
    }
}

extension FacetValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FacetValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The [Facet] that you provided was not well formed or could not be validated with the schema.
public struct FacetValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FacetValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct FacetValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FacetValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAppliedSchemaVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

extension GetAppliedSchemaVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/getappliedschema"
    }
}

public struct GetAppliedSchemaVersionInput: Swift.Equatable {
    /// The ARN of the applied schema.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct GetAppliedSchemaVersionInputBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension GetAppliedSchemaVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension GetAppliedSchemaVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppliedSchemaVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.appliedSchemaArn = output.appliedSchemaArn
        } else {
            self.appliedSchemaArn = nil
        }
    }
}

public struct GetAppliedSchemaVersionOutput: Swift.Equatable {
    /// Current applied schema ARN, including the minor version in use if one was provided.
    public var appliedSchemaArn: Swift.String?

    public init(
        appliedSchemaArn: Swift.String? = nil
    )
    {
        self.appliedSchemaArn = appliedSchemaArn
    }
}

struct GetAppliedSchemaVersionOutputBody: Swift.Equatable {
    let appliedSchemaArn: Swift.String?
}

extension GetAppliedSchemaVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedSchemaArn = "AppliedSchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appliedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appliedSchemaArn)
        appliedSchemaArn = appliedSchemaArnDecoded
    }
}

enum GetAppliedSchemaVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDirectoryInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension GetDirectoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/get"
    }
}

public struct GetDirectoryInput: Swift.Equatable {
    /// The ARN of the directory.
    /// This member is required.
    public var directoryArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
    }
}

struct GetDirectoryInputBody: Swift.Equatable {
}

extension GetDirectoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDirectoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDirectoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.directory = output.directory
        } else {
            self.directory = nil
        }
    }
}

public struct GetDirectoryOutput: Swift.Equatable {
    /// Metadata about the directory.
    /// This member is required.
    public var directory: CloudDirectoryClientTypes.Directory?

    public init(
        directory: CloudDirectoryClientTypes.Directory? = nil
    )
    {
        self.directory = directory
    }
}

struct GetDirectoryOutputBody: Swift.Equatable {
    let directory: CloudDirectoryClientTypes.Directory?
}

extension GetDirectoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directory = "Directory"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.Directory.self, forKey: .directory)
        directory = directoryDecoded
    }
}

enum GetDirectoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFacetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetFacetInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension GetFacetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet"
    }
}

public struct GetFacetInput: Swift.Equatable {
    /// The name of the facet to retrieve.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the [Facet]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct GetFacetInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetFacetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFacetOutputBody = try responseDecoder.decode(responseBody: data)
            self.facet = output.facet
        } else {
            self.facet = nil
        }
    }
}

public struct GetFacetOutput: Swift.Equatable {
    /// The [Facet] structure that is associated with the facet.
    public var facet: CloudDirectoryClientTypes.Facet?

    public init(
        facet: CloudDirectoryClientTypes.Facet? = nil
    )
    {
        self.facet = facet
    }
}

struct GetFacetOutputBody: Swift.Equatable {
    let facet: CloudDirectoryClientTypes.Facet?
}

extension GetFacetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facet = "Facet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.Facet.self, forKey: .facet)
        facet = facetDecoded
    }
}

enum GetFacetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetNotFoundException": return try await FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLinkAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case consistencyLevel = "ConsistencyLevel"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributename0 in attributeNames {
                try attributeNamesContainer.encode(attributename0)
            }
        }
        if let consistencyLevel = self.consistencyLevel {
            try encodeContainer.encode(consistencyLevel.rawValue, forKey: .consistencyLevel)
        }
        if let typedLinkSpecifier = self.typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }
}

extension GetLinkAttributesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension GetLinkAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/attributes/get"
    }
}

public struct GetLinkAttributesInput: Swift.Equatable {
    /// A list of attribute names whose values will be retrieved.
    /// This member is required.
    public var attributeNames: [Swift.String]?
    /// The consistency level at which to retrieve the attributes on a typed link.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the Directory where the typed link resides. For more information, see [arns] or [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Allows a typed link specifier to be accepted as input.
    /// This member is required.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init(
        attributeNames: [Swift.String]? = nil,
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.attributeNames = attributeNames
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct GetLinkAttributesInputBody: Swift.Equatable {
    let typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?
    let attributeNames: [Swift.String]?
    let consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
}

extension GetLinkAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case consistencyLevel = "ConsistencyLevel"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
        let consistencyLevelDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ConsistencyLevel.self, forKey: .consistencyLevel)
        consistencyLevel = consistencyLevelDecoded
    }
}

extension GetLinkAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLinkAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct GetLinkAttributesOutput: Swift.Equatable {
    /// The attributes that are associated with the typed link.
    public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

    public init(
        attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetLinkAttributesOutputBody: Swift.Equatable {
    let attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
}

extension GetLinkAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

enum GetLinkAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetObjectAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeNames = attributeNames {
            var attributeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeNames)
            for attributename0 in attributeNames {
                try attributeNamesContainer.encode(attributename0)
            }
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = self.schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }
}

extension GetObjectAttributesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension GetObjectAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/attributes/get"
    }
}

public struct GetObjectAttributesInput: Swift.Equatable {
    /// List of attribute names whose values will be retrieved.
    /// This member is required.
    public var attributeNames: [Swift.String]?
    /// The consistency level at which to retrieve the attributes on an object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Reference that identifies the object whose attributes will be retrieved.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// Identifier for the facet whose attributes will be retrieved. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

    public init(
        attributeNames: [Swift.String]? = nil,
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
    )
    {
        self.attributeNames = attributeNames
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

struct GetObjectAttributesInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let schemaFacet: CloudDirectoryClientTypes.SchemaFacet?
    let attributeNames: [Swift.String]?
}

extension GetObjectAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeNames = "AttributeNames"
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let attributeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attributeNames)
        var attributeNamesDecoded0:[Swift.String]? = nil
        if let attributeNamesContainer = attributeNamesContainer {
            attributeNamesDecoded0 = [Swift.String]()
            for string0 in attributeNamesContainer {
                if let string0 = string0 {
                    attributeNamesDecoded0?.append(string0)
                }
            }
        }
        attributeNames = attributeNamesDecoded0
    }
}

extension GetObjectAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetObjectAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct GetObjectAttributesOutput: Swift.Equatable {
    /// The attributes that are associated with the object.
    public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?

    public init(
        attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct GetObjectAttributesOutputBody: Swift.Equatable {
    let attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
}

extension GetObjectAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

enum GetObjectAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetObjectInformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension GetObjectInformationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension GetObjectInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/information"
    }
}

public struct GetObjectInformationInput: Swift.Equatable {
    /// The consistency level at which to retrieve the object information.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The ARN of the directory being retrieved.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the object.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

struct GetObjectInformationInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension GetObjectInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension GetObjectInformationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetObjectInformationOutputBody = try responseDecoder.decode(responseBody: data)
            self.objectIdentifier = output.objectIdentifier
            self.schemaFacets = output.schemaFacets
        } else {
            self.objectIdentifier = nil
            self.schemaFacets = nil
        }
    }
}

public struct GetObjectInformationOutput: Swift.Equatable {
    /// The ObjectIdentifier of the specified object.
    public var objectIdentifier: Swift.String?
    /// The facets attached to the specified object. Although the response does not include minor version information, the most recently applied minor version of each Facet is in effect. See [GetAppliedSchemaVersion] for details.
    public var schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?

    public init(
        objectIdentifier: Swift.String? = nil,
        schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
        self.schemaFacets = schemaFacets
    }
}

struct GetObjectInformationOutputBody: Swift.Equatable {
    let schemaFacets: [CloudDirectoryClientTypes.SchemaFacet]?
    let objectIdentifier: Swift.String?
}

extension GetObjectInformationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
        case schemaFacets = "SchemaFacets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.SchemaFacet?].self, forKey: .schemaFacets)
        var schemaFacetsDecoded0:[CloudDirectoryClientTypes.SchemaFacet]? = nil
        if let schemaFacetsContainer = schemaFacetsContainer {
            schemaFacetsDecoded0 = [CloudDirectoryClientTypes.SchemaFacet]()
            for structure0 in schemaFacetsContainer {
                if let structure0 = structure0 {
                    schemaFacetsDecoded0?.append(structure0)
                }
            }
        }
        schemaFacets = schemaFacetsDecoded0
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

enum GetObjectInformationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSchemaAsJsonInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension GetSchemaAsJsonInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/json"
    }
}

public struct GetSchemaAsJsonInput: Swift.Equatable {
    /// The ARN of the schema to retrieve.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct GetSchemaAsJsonInputBody: Swift.Equatable {
}

extension GetSchemaAsJsonInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaAsJsonOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSchemaAsJsonOutputBody = try responseDecoder.decode(responseBody: data)
            self.document = output.document
            self.name = output.name
        } else {
            self.document = nil
            self.name = nil
        }
    }
}

public struct GetSchemaAsJsonOutput: Swift.Equatable {
    /// The JSON representation of the schema document.
    public var document: Swift.String?
    /// The name of the retrieved schema.
    public var name: Swift.String?

    public init(
        document: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.document = document
        self.name = name
    }
}

struct GetSchemaAsJsonOutputBody: Swift.Equatable {
    let name: Swift.String?
    let document: Swift.String?
}

extension GetSchemaAsJsonOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

enum GetSchemaAsJsonOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTypedLinkFacetInformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension GetTypedLinkFacetInformationInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension GetTypedLinkFacetInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/get"
    }
}

public struct GetTypedLinkFacetInformationInput: Swift.Equatable {
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct GetTypedLinkFacetInformationInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension GetTypedLinkFacetInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTypedLinkFacetInformationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTypedLinkFacetInformationOutputBody = try responseDecoder.decode(responseBody: data)
            self.identityAttributeOrder = output.identityAttributeOrder
        } else {
            self.identityAttributeOrder = nil
        }
    }
}

public struct GetTypedLinkFacetInformationOutput: Swift.Equatable {
    /// The order of identity attributes for the facet, from most significant to least significant. The ability to filter typed links considers the order that the attributes are defined on the typed link facet. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range. Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls. For more information about identity attributes, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    public var identityAttributeOrder: [Swift.String]?

    public init(
        identityAttributeOrder: [Swift.String]? = nil
    )
    {
        self.identityAttributeOrder = identityAttributeOrder
    }
}

struct GetTypedLinkFacetInformationOutputBody: Swift.Equatable {
    let identityAttributeOrder: [Swift.String]?
}

extension GetTypedLinkFacetInformationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityAttributeOrder = "IdentityAttributeOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityAttributeOrderContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identityAttributeOrder)
        var identityAttributeOrderDecoded0:[Swift.String]? = nil
        if let identityAttributeOrderContainer = identityAttributeOrderContainer {
            identityAttributeOrderDecoded0 = [Swift.String]()
            for string0 in identityAttributeOrderContainer {
                if let string0 = string0 {
                    identityAttributeOrderDecoded0?.append(string0)
                }
            }
        }
        identityAttributeOrder = identityAttributeOrderDecoded0
    }
}

enum GetTypedLinkFacetInformationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetNotFoundException": return try await FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IncompatibleSchemaException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IncompatibleSchemaExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates a failure occurred while performing a check for backward compatibility between the specified schema and the schema that is currently applied to the directory.
public struct IncompatibleSchemaException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncompatibleSchemaException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IncompatibleSchemaExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IncompatibleSchemaExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.IndexAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexedAttributes = "IndexedAttributes"
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexedAttributes = indexedAttributes {
            var indexedAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .indexedAttributes)
            for attributekeyandvalue0 in indexedAttributes {
                try indexedAttributesContainer.encode(attributekeyandvalue0)
            }
        }
        if let objectIdentifier = self.objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexedAttributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .indexedAttributes)
        var indexedAttributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let indexedAttributesContainer = indexedAttributesContainer {
            indexedAttributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in indexedAttributesContainer {
                if let structure0 = structure0 {
                    indexedAttributesDecoded0?.append(structure0)
                }
            }
        }
        indexedAttributes = indexedAttributesDecoded0
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Represents an index and an attached object.
    public struct IndexAttachment: Swift.Equatable {
        /// The indexed attribute values.
        public var indexedAttributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
        /// In response to [ListIndex], the ObjectIdentifier of the object attached to the index. In response to [ListAttachedIndices], the ObjectIdentifier of the index attached to the object. This field will always contain the ObjectIdentifier of the object on the opposite side of the attachment specified in the query.
        public var objectIdentifier: Swift.String?

        public init(
            indexedAttributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
            objectIdentifier: Swift.String? = nil
        )
        {
            self.indexedAttributes = indexedAttributes
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension IndexedAttributeMissingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IndexedAttributeMissingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An object has been attempted to be attached to an object that does not have the appropriate attribute value.
public struct IndexedAttributeMissingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IndexedAttributeMissingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IndexedAttributeMissingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IndexedAttributeMissingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates a problem that must be resolved by Amazon Web Services. This might be a transient error in which case you can retry your request until it succeeds. Otherwise, go to the [AWS Service Health Dashboard](http://status.aws.amazon.com/) site to see if there are any operational issues with the service.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the provided ARN value is not valid.
public struct InvalidArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArnException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAttachmentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidAttachmentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that an attempt to make an attachment was invalid. For example, attaching two nodes with a link type that is not applicable to the nodes or attempting to apply a schema to a directory a second time.
public struct InvalidAttachmentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAttachmentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidAttachmentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAttachmentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFacetUpdateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidFacetUpdateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An attempt to modify a [Facet] resulted in an invalid schema exception.
public struct InvalidFacetUpdateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFacetUpdateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidFacetUpdateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidFacetUpdateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the NextToken value is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRuleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when any of the rule parameter keys or values are invalid.
public struct InvalidRuleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRuleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRuleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRuleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchemaDocException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSchemaDocExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the provided SchemaDoc value is not valid.
public struct InvalidSchemaDocException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSchemaDocException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidSchemaDocExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSchemaDocExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTaggingRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTaggingRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Can occur for multiple reasons such as when you tag a resource that doesnt exist or if you specify a higher number of tags for a resource than the allowed limit. Allowed limit is 50 tags per resource.
public struct InvalidTaggingRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTaggingRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTaggingRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTaggingRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that limits are exceeded. See [Limits](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html) for more information.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.LinkAttributeAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeActionType = "AttributeActionType"
        case attributeUpdateValue = "AttributeUpdateValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeActionType = self.attributeActionType {
            try encodeContainer.encode(attributeActionType.rawValue, forKey: .attributeActionType)
        }
        if let attributeUpdateValue = self.attributeUpdateValue {
            try encodeContainer.encode(attributeUpdateValue, forKey: .attributeUpdateValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeActionTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.UpdateActionType.self, forKey: .attributeActionType)
        attributeActionType = attributeActionTypeDecoded
        let attributeUpdateValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .attributeUpdateValue)
        attributeUpdateValue = attributeUpdateValueDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// The action to take on a typed link attribute value. Updates are only supported for attributes which dont contribute to link identity.
    public struct LinkAttributeAction: Swift.Equatable {
        /// A type that can be either UPDATE_OR_CREATE or DELETE.
        public var attributeActionType: CloudDirectoryClientTypes.UpdateActionType?
        /// The value that you want to update to.
        public var attributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            attributeActionType: CloudDirectoryClientTypes.UpdateActionType? = nil,
            attributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.attributeActionType = attributeActionType
            self.attributeUpdateValue = attributeUpdateValue
        }
    }

}

extension CloudDirectoryClientTypes.LinkAttributeUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeAction = "AttributeAction"
        case attributeKey = "AttributeKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeAction = self.attributeAction {
            try encodeContainer.encode(attributeAction, forKey: .attributeAction)
        }
        if let attributeKey = self.attributeKey {
            try encodeContainer.encode(attributeKey, forKey: .attributeKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.AttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let attributeActionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.LinkAttributeAction.self, forKey: .attributeAction)
        attributeAction = attributeActionDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Structure that contains attribute update information.
    public struct LinkAttributeUpdate: Swift.Equatable {
        /// The action to perform as part of the attribute update.
        public var attributeAction: CloudDirectoryClientTypes.LinkAttributeAction?
        /// The key of the attribute being updated.
        public var attributeKey: CloudDirectoryClientTypes.AttributeKey?

        public init(
            attributeAction: CloudDirectoryClientTypes.LinkAttributeAction? = nil,
            attributeKey: CloudDirectoryClientTypes.AttributeKey? = nil
        )
        {
            self.attributeAction = attributeAction
            self.attributeKey = attributeKey
        }
    }

}

extension LinkNameAlreadyInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LinkNameAlreadyInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a link could not be created due to a naming conflict. Choose a different name and then try again.
public struct LinkNameAlreadyInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LinkNameAlreadyInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LinkNameAlreadyInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LinkNameAlreadyInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAppliedSchemaArnsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryArn = self.directoryArn {
            try encodeContainer.encode(directoryArn, forKey: .directoryArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

extension ListAppliedSchemaArnsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/applied"
    }
}

public struct ListAppliedSchemaArnsInput: Swift.Equatable {
    /// The ARN of the directory you are listing.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The response for ListAppliedSchemaArns when this parameter is used will list all minor version ARNs for a major version.
    public var schemaArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListAppliedSchemaArnsInputBody: Swift.Equatable {
    let directoryArn: Swift.String?
    let schemaArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppliedSchemaArnsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppliedSchemaArnsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppliedSchemaArnsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListAppliedSchemaArnsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs of schemas that are applied to the directory.
    public var schemaArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListAppliedSchemaArnsOutputBody: Swift.Equatable {
    let schemaArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAppliedSchemaArnsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[Swift.String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [Swift.String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppliedSchemaArnsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAttachedIndicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case targetReference = "TargetReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetReference = self.targetReference {
            try encodeContainer.encode(targetReference, forKey: .targetReference)
        }
    }
}

extension ListAttachedIndicesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListAttachedIndicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/indices"
    }
}

public struct ListAttachedIndicesInput: Swift.Equatable {
    /// The consistency level to use for this operation.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The ARN of the directory.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A reference to the object that has indices attached.
    /// This member is required.
    public var targetReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetReference = targetReference
    }
}

struct ListAttachedIndicesInputBody: Swift.Equatable {
    let targetReference: CloudDirectoryClientTypes.ObjectReference?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAttachedIndicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case targetReference = "TargetReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetReference)
        targetReference = targetReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAttachedIndicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttachedIndicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.indexAttachments = output.indexAttachments
            self.nextToken = output.nextToken
        } else {
            self.indexAttachments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttachedIndicesOutput: Swift.Equatable {
    /// The indices attached to the specified object.
    public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

struct ListAttachedIndicesOutputBody: Swift.Equatable {
    let indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    let nextToken: Swift.String?
}

extension ListAttachedIndicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[CloudDirectoryClientTypes.IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [CloudDirectoryClientTypes.IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAttachedIndicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDevelopmentSchemaArnsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDevelopmentSchemaArnsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/development"
    }
}

public struct ListDevelopmentSchemaArnsInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevelopmentSchemaArnsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDevelopmentSchemaArnsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevelopmentSchemaArnsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDevelopmentSchemaArnsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListDevelopmentSchemaArnsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs of retrieved development schemas.
    public var schemaArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListDevelopmentSchemaArnsOutputBody: Swift.Equatable {
    let schemaArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListDevelopmentSchemaArnsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[Swift.String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [Swift.String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDevelopmentSchemaArnsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDirectoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

extension ListDirectoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/directory/list"
    }
}

public struct ListDirectoriesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The state of the directories in the list. Can be either Enabled, Disabled, or Deleted.
    public var state: CloudDirectoryClientTypes.DirectoryState?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: CloudDirectoryClientTypes.DirectoryState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListDirectoriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let state: CloudDirectoryClientTypes.DirectoryState?
}

extension ListDirectoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.DirectoryState.self, forKey: .state)
        state = stateDecoded
    }
}

extension ListDirectoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDirectoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.directories = output.directories
            self.nextToken = output.nextToken
        } else {
            self.directories = nil
            self.nextToken = nil
        }
    }
}

public struct ListDirectoriesOutput: Swift.Equatable {
    /// Lists all directories that are associated with your account in pagination fashion.
    /// This member is required.
    public var directories: [CloudDirectoryClientTypes.Directory]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        directories: [CloudDirectoryClientTypes.Directory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directories = directories
        self.nextToken = nextToken
    }
}

struct ListDirectoriesOutputBody: Swift.Equatable {
    let directories: [CloudDirectoryClientTypes.Directory]?
    let nextToken: Swift.String?
}

extension ListDirectoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directories = "Directories"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoriesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.Directory?].self, forKey: .directories)
        var directoriesDecoded0:[CloudDirectoryClientTypes.Directory]? = nil
        if let directoriesContainer = directoriesContainer {
            directoriesDecoded0 = [CloudDirectoryClientTypes.Directory]()
            for structure0 in directoriesContainer {
                if let structure0 = structure0 {
                    directoriesDecoded0?.append(structure0)
                }
            }
        }
        directories = directoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDirectoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFacetAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFacetAttributesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension ListFacetAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet/attributes"
    }
}

public struct ListFacetAttributesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The name of the facet whose attributes will be retrieved.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARN of the schema where the facet resides.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListFacetAttributesInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFacetAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFacetAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFacetAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListFacetAttributesOutput: Swift.Equatable {
    /// The attributes attached to the facet.
    public var attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        attributes: [CloudDirectoryClientTypes.FacetAttribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListFacetAttributesOutputBody: Swift.Equatable {
    let attributes: [CloudDirectoryClientTypes.FacetAttribute]?
    let nextToken: Swift.String?
}

extension ListFacetAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.FacetAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.FacetAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.FacetAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFacetAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetNotFoundException": return try await FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFacetNamesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFacetNamesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension ListFacetNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet/list"
    }
}

public struct ListFacetNamesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) to retrieve facet names from.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListFacetNamesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFacetNamesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFacetNamesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFacetNamesOutputBody = try responseDecoder.decode(responseBody: data)
            self.facetNames = output.facetNames
            self.nextToken = output.nextToken
        } else {
            self.facetNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListFacetNamesOutput: Swift.Equatable {
    /// The names of facets that exist within the schema.
    public var facetNames: [Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        facetNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.facetNames = facetNames
        self.nextToken = nextToken
    }
}

struct ListFacetNamesOutputBody: Swift.Equatable {
    let facetNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFacetNamesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetNames = "FacetNames"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .facetNames)
        var facetNamesDecoded0:[Swift.String]? = nil
        if let facetNamesContainer = facetNamesContainer {
            facetNamesDecoded0 = [Swift.String]()
            for string0 in facetNamesContainer {
                if let string0 = string0 {
                    facetNamesDecoded0?.append(string0)
                }
            }
        }
        facetNames = facetNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFacetNamesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIncomingTypedLinksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consistencyLevel = self.consistencyLevel {
            try encodeContainer.encode(consistencyLevel.rawValue, forKey: .consistencyLevel)
        }
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerange0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerange0)
            }
        }
        if let filterTypedLink = self.filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension ListIncomingTypedLinksInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListIncomingTypedLinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/incoming"
    }
}

public struct ListIncomingTypedLinksInput: Swift.Equatable {
    /// The consistency level to execute the request at.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) of the directory where you want to list the typed links.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
    public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    /// Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls.
    public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Reference that identifies the object whose attributes will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
        filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListIncomingTypedLinksInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    let filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
}

extension ListIncomingTypedLinksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let consistencyLevelDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ConsistencyLevel.self, forKey: .consistencyLevel)
        consistencyLevel = consistencyLevelDecoded
    }
}

extension ListIncomingTypedLinksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIncomingTypedLinksOutputBody = try responseDecoder.decode(responseBody: data)
            self.linkSpecifiers = output.linkSpecifiers
            self.nextToken = output.nextToken
        } else {
            self.linkSpecifiers = nil
            self.nextToken = nil
        }
    }
}

public struct ListIncomingTypedLinksOutput: Swift.Equatable {
    /// Returns one or more typed link specifiers as output.
    public var linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.linkSpecifiers = linkSpecifiers
        self.nextToken = nextToken
    }
}

struct ListIncomingTypedLinksOutputBody: Swift.Equatable {
    let linkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
    let nextToken: Swift.String?
}

extension ListIncomingTypedLinksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkSpecifiers = "LinkSpecifiers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkSpecifiersContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkSpecifier?].self, forKey: .linkSpecifiers)
        var linkSpecifiersDecoded0:[CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        if let linkSpecifiersContainer = linkSpecifiersContainer {
            linkSpecifiersDecoded0 = [CloudDirectoryClientTypes.TypedLinkSpecifier]()
            for structure0 in linkSpecifiersContainer {
                if let structure0 = structure0 {
                    linkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        linkSpecifiers = linkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIncomingTypedLinksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIndexInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rangesOnIndexedValues = "RangesOnIndexedValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexReference = self.indexReference {
            try encodeContainer.encode(indexReference, forKey: .indexReference)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rangesOnIndexedValues = rangesOnIndexedValues {
            var rangesOnIndexedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rangesOnIndexedValues)
            for objectattributerange0 in rangesOnIndexedValues {
                try rangesOnIndexedValuesContainer.encode(objectattributerange0)
            }
        }
    }
}

extension ListIndexInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListIndexInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/index/targets"
    }
}

public struct ListIndexInput: Swift.Equatable {
    /// The consistency level to execute the request at.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The ARN of the directory that the index exists in.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The reference to the index to list.
    /// This member is required.
    public var indexReference: CloudDirectoryClientTypes.ObjectReference?
    /// The maximum number of objects in a single page to retrieve from the index during a request. For more information, see [Amazon Cloud Directory Limits](http://docs.aws.amazon.com/clouddirectory/latest/developerguide/limits.html).
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Specifies the ranges of indexed values that you want to query.
    public var rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        indexReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.indexReference = indexReference
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rangesOnIndexedValues = rangesOnIndexedValues
    }
}

struct ListIndexInputBody: Swift.Equatable {
    let rangesOnIndexedValues: [CloudDirectoryClientTypes.ObjectAttributeRange]?
    let indexReference: CloudDirectoryClientTypes.ObjectReference?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIndexInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexReference = "IndexReference"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rangesOnIndexedValues = "RangesOnIndexedValues"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangesOnIndexedValuesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectAttributeRange?].self, forKey: .rangesOnIndexedValues)
        var rangesOnIndexedValuesDecoded0:[CloudDirectoryClientTypes.ObjectAttributeRange]? = nil
        if let rangesOnIndexedValuesContainer = rangesOnIndexedValuesContainer {
            rangesOnIndexedValuesDecoded0 = [CloudDirectoryClientTypes.ObjectAttributeRange]()
            for structure0 in rangesOnIndexedValuesContainer {
                if let structure0 = structure0 {
                    rangesOnIndexedValuesDecoded0?.append(structure0)
                }
            }
        }
        rangesOnIndexedValues = rangesOnIndexedValuesDecoded0
        let indexReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .indexReference)
        indexReference = indexReferenceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIndexOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIndexOutputBody = try responseDecoder.decode(responseBody: data)
            self.indexAttachments = output.indexAttachments
            self.nextToken = output.nextToken
        } else {
            self.indexAttachments = nil
            self.nextToken = nil
        }
    }
}

public struct ListIndexOutput: Swift.Equatable {
    /// The objects and indexed values attached to the index.
    public var indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexAttachments = indexAttachments
        self.nextToken = nextToken
    }
}

struct ListIndexOutputBody: Swift.Equatable {
    let indexAttachments: [CloudDirectoryClientTypes.IndexAttachment]?
    let nextToken: Swift.String?
}

extension ListIndexOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexAttachments = "IndexAttachments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexAttachmentsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.IndexAttachment?].self, forKey: .indexAttachments)
        var indexAttachmentsDecoded0:[CloudDirectoryClientTypes.IndexAttachment]? = nil
        if let indexAttachmentsContainer = indexAttachmentsContainer {
            indexAttachmentsDecoded0 = [CloudDirectoryClientTypes.IndexAttachment]()
            for structure0 in indexAttachmentsContainer {
                if let structure0 = structure0 {
                    indexAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        indexAttachments = indexAttachmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIndexOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotIndexException": return try await NotIndexException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListManagedSchemaArnsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

extension ListManagedSchemaArnsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/managed"
    }
}

public struct ListManagedSchemaArnsInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The response for ListManagedSchemaArns. When this parameter is used, all minor version ARNs for a major version are listed.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListManagedSchemaArnsInputBody: Swift.Equatable {
    let schemaArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListManagedSchemaArnsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListManagedSchemaArnsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListManagedSchemaArnsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListManagedSchemaArnsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs for all AWS managed schemas.
    public var schemaArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListManagedSchemaArnsOutputBody: Swift.Equatable {
    let schemaArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListManagedSchemaArnsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[Swift.String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [Swift.String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListManagedSchemaArnsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListObjectAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetFilter = "FacetFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetFilter = self.facetFilter {
            try encodeContainer.encode(facetFilter, forKey: .facetFilter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension ListObjectAttributesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListObjectAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/attributes"
    }
}

public struct ListObjectAttributesInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Used to filter the list of object attributes that are associated with a certain facet.
    public var facetFilter: CloudDirectoryClientTypes.SchemaFacet?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object whose attributes will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        facetFilter: CloudDirectoryClientTypes.SchemaFacet? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.facetFilter = facetFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectAttributesInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let facetFilter: CloudDirectoryClientTypes.SchemaFacet?
}

extension ListObjectAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetFilter = "FacetFilter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let facetFilterDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .facetFilter)
        facetFilter = facetFilterDecoded
    }
}

extension ListObjectAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListObjectAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListObjectAttributesOutput: Swift.Equatable {
    /// Attributes map that is associated with the object. AttributeArn is the key, and attribute value is the value.
    public var attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListObjectAttributesOutputBody: Swift.Equatable {
    let attributes: [CloudDirectoryClientTypes.AttributeKeyAndValue]?
    let nextToken: Swift.String?
}

extension ListObjectAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeKeyAndValue?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.AttributeKeyAndValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.AttributeKeyAndValue]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListObjectAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListObjectChildrenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension ListObjectChildrenInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListObjectChildrenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/children"
    }
}

public struct ListObjectChildrenInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object for which child objects are being listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectChildrenInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListObjectChildrenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListObjectChildrenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListObjectChildrenOutputBody = try responseDecoder.decode(responseBody: data)
            self.children = output.children
            self.nextToken = output.nextToken
        } else {
            self.children = nil
            self.nextToken = nil
        }
    }
}

public struct ListObjectChildrenOutput: Swift.Equatable {
    /// Children structure, which is a map with key as the LinkName and ObjectIdentifier as the value.
    public var children: [Swift.String:Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        children: [Swift.String:Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.children = children
        self.nextToken = nextToken
    }
}

struct ListObjectChildrenOutputBody: Swift.Equatable {
    let children: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
}

extension ListObjectChildrenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children = "Children"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let childrenContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .children)
        var childrenDecoded0: [Swift.String:Swift.String]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [Swift.String:Swift.String]()
            for (key0, objectidentifier0) in childrenContainer {
                if let objectidentifier0 = objectidentifier0 {
                    childrenDecoded0?[key0] = objectidentifier0
                }
            }
        }
        children = childrenDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListObjectChildrenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotNodeException": return try await NotNodeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListObjectParentPathsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension ListObjectParentPathsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListObjectParentPathsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/parentpaths"
    }
}

public struct ListObjectParentPathsInput: Swift.Equatable {
    /// The ARN of the directory to which the parent path applies.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object whose parent paths are listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectParentPathsInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListObjectParentPathsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListObjectParentPathsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListObjectParentPathsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pathToObjectIdentifiersList = output.pathToObjectIdentifiersList
        } else {
            self.nextToken = nil
            self.pathToObjectIdentifiersList = nil
        }
    }
}

public struct ListObjectParentPathsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Returns the path to the ObjectIdentifiers that are associated with the directory.
    public var pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]?

    public init(
        nextToken: Swift.String? = nil,
        pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
    )
    {
        self.nextToken = nextToken
        self.pathToObjectIdentifiersList = pathToObjectIdentifiersList
    }
}

struct ListObjectParentPathsOutputBody: Swift.Equatable {
    let pathToObjectIdentifiersList: [CloudDirectoryClientTypes.PathToObjectIdentifiers]?
    let nextToken: Swift.String?
}

extension ListObjectParentPathsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pathToObjectIdentifiersList = "PathToObjectIdentifiersList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathToObjectIdentifiersListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PathToObjectIdentifiers?].self, forKey: .pathToObjectIdentifiersList)
        var pathToObjectIdentifiersListDecoded0:[CloudDirectoryClientTypes.PathToObjectIdentifiers]? = nil
        if let pathToObjectIdentifiersListContainer = pathToObjectIdentifiersListContainer {
            pathToObjectIdentifiersListDecoded0 = [CloudDirectoryClientTypes.PathToObjectIdentifiers]()
            for structure0 in pathToObjectIdentifiersListContainer {
                if let structure0 = structure0 {
                    pathToObjectIdentifiersListDecoded0?.append(structure0)
                }
            }
        }
        pathToObjectIdentifiersList = pathToObjectIdentifiersListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListObjectParentPathsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListObjectParentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeAllLinksToEachParent = "IncludeAllLinksToEachParent"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeAllLinksToEachParent = self.includeAllLinksToEachParent {
            try encodeContainer.encode(includeAllLinksToEachParent, forKey: .includeAllLinksToEachParent)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension ListObjectParentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListObjectParentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/parent"
    }
}

public struct ListObjectParentsInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// When set to True, returns all [ListObjectParentsResponse$ParentLinks]. There could be multiple links between a parent-child pair.
    public var includeAllLinksToEachParent: Swift.Bool?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the object for which parent objects are being listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        includeAllLinksToEachParent: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.includeAllLinksToEachParent = includeAllLinksToEachParent
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectParentsInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let includeAllLinksToEachParent: Swift.Bool?
}

extension ListObjectParentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeAllLinksToEachParent = "IncludeAllLinksToEachParent"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let includeAllLinksToEachParentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeAllLinksToEachParent)
        includeAllLinksToEachParent = includeAllLinksToEachParentDecoded
    }
}

extension ListObjectParentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListObjectParentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.parentLinks = output.parentLinks
            self.parents = output.parents
        } else {
            self.nextToken = nil
            self.parentLinks = nil
            self.parents = nil
        }
    }
}

public struct ListObjectParentsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Returns a list of parent reference and LinkName Tuples.
    public var parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]?
    /// The parent structure, which is a map with key as the ObjectIdentifier and LinkName as the value.
    public var parents: [Swift.String:Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil,
        parents: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.parentLinks = parentLinks
        self.parents = parents
    }
}

struct ListObjectParentsOutputBody: Swift.Equatable {
    let parents: [Swift.String:Swift.String]?
    let nextToken: Swift.String?
    let parentLinks: [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]?
}

extension ListObjectParentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case parentLinks = "ParentLinks"
        case parents = "Parents"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parents)
        var parentsDecoded0: [Swift.String:Swift.String]? = nil
        if let parentsContainer = parentsContainer {
            parentsDecoded0 = [Swift.String:Swift.String]()
            for (key0, linkname0) in parentsContainer {
                if let linkname0 = linkname0 {
                    parentsDecoded0?[key0] = linkname0
                }
            }
        }
        parents = parentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parentLinksContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple?].self, forKey: .parentLinks)
        var parentLinksDecoded0:[CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]? = nil
        if let parentLinksContainer = parentLinksContainer {
            parentLinksDecoded0 = [CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple]()
            for structure0 in parentLinksContainer {
                if let structure0 = structure0 {
                    parentLinksDecoded0?.append(structure0)
                }
            }
        }
        parentLinks = parentLinksDecoded0
    }
}

enum ListObjectParentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CannotListParentOfRootException": return try await CannotListParentOfRootException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListObjectPoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension ListObjectPoliciesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListObjectPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/policy"
    }
}

public struct ListObjectPoliciesInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Reference that identifies the object for which policies will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListObjectPoliciesInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListObjectPoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListObjectPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListObjectPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedPolicyIds = output.attachedPolicyIds
            self.nextToken = output.nextToken
        } else {
            self.attachedPolicyIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListObjectPoliciesOutput: Swift.Equatable {
    /// A list of policy ObjectIdentifiers, that are attached to the object.
    public var attachedPolicyIds: [Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        attachedPolicyIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachedPolicyIds = attachedPolicyIds
        self.nextToken = nextToken
    }
}

struct ListObjectPoliciesOutputBody: Swift.Equatable {
    let attachedPolicyIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListObjectPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedPolicyIds = "AttachedPolicyIds"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedPolicyIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attachedPolicyIds)
        var attachedPolicyIdsDecoded0:[Swift.String]? = nil
        if let attachedPolicyIdsContainer = attachedPolicyIdsContainer {
            attachedPolicyIdsDecoded0 = [Swift.String]()
            for string0 in attachedPolicyIdsContainer {
                if let string0 = string0 {
                    attachedPolicyIdsDecoded0?.append(string0)
                }
            }
        }
        attachedPolicyIds = attachedPolicyIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListObjectPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOutgoingTypedLinksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consistencyLevel = self.consistencyLevel {
            try encodeContainer.encode(consistencyLevel.rawValue, forKey: .consistencyLevel)
        }
        if let filterAttributeRanges = filterAttributeRanges {
            var filterAttributeRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterAttributeRanges)
            for typedlinkattributerange0 in filterAttributeRanges {
                try filterAttributeRangesContainer.encode(typedlinkattributerange0)
            }
        }
        if let filterTypedLink = self.filterTypedLink {
            try encodeContainer.encode(filterTypedLink, forKey: .filterTypedLink)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension ListOutgoingTypedLinksInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListOutgoingTypedLinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/outgoing"
    }
}

public struct ListOutgoingTypedLinksInput: Swift.Equatable {
    /// The consistency level to execute the request at.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) of the directory where you want to list the typed links.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Provides range filters for multiple attributes. When providing ranges to typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range.
    public var filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    /// Filters are interpreted in the order of the attributes defined on the typed link facet, not the order they are supplied to any API calls.
    public var filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A reference that identifies the object whose attributes will be listed.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil,
        filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.filterAttributeRanges = filterAttributeRanges
        self.filterTypedLink = filterTypedLink
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct ListOutgoingTypedLinksInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let filterAttributeRanges: [CloudDirectoryClientTypes.TypedLinkAttributeRange]?
    let filterTypedLink: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
}

extension ListOutgoingTypedLinksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consistencyLevel = "ConsistencyLevel"
        case filterAttributeRanges = "FilterAttributeRanges"
        case filterTypedLink = "FilterTypedLink"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let filterAttributeRangesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeRange?].self, forKey: .filterAttributeRanges)
        var filterAttributeRangesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeRange]? = nil
        if let filterAttributeRangesContainer = filterAttributeRangesContainer {
            filterAttributeRangesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeRange]()
            for structure0 in filterAttributeRangesContainer {
                if let structure0 = structure0 {
                    filterAttributeRangesDecoded0?.append(structure0)
                }
            }
        }
        filterAttributeRanges = filterAttributeRangesDecoded0
        let filterTypedLinkDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .filterTypedLink)
        filterTypedLink = filterTypedLinkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let consistencyLevelDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ConsistencyLevel.self, forKey: .consistencyLevel)
        consistencyLevel = consistencyLevelDecoded
    }
}

extension ListOutgoingTypedLinksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOutgoingTypedLinksOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.typedLinkSpecifiers = output.typedLinkSpecifiers
        } else {
            self.nextToken = nil
            self.typedLinkSpecifiers = nil
        }
    }
}

public struct ListOutgoingTypedLinksOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Returns a typed link specifier as output.
    public var typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?

    public init(
        nextToken: Swift.String? = nil,
        typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.typedLinkSpecifiers = typedLinkSpecifiers
    }
}

struct ListOutgoingTypedLinksOutputBody: Swift.Equatable {
    let typedLinkSpecifiers: [CloudDirectoryClientTypes.TypedLinkSpecifier]?
    let nextToken: Swift.String?
}

extension ListOutgoingTypedLinksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case typedLinkSpecifiers = "TypedLinkSpecifiers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifiersContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkSpecifier?].self, forKey: .typedLinkSpecifiers)
        var typedLinkSpecifiersDecoded0:[CloudDirectoryClientTypes.TypedLinkSpecifier]? = nil
        if let typedLinkSpecifiersContainer = typedLinkSpecifiersContainer {
            typedLinkSpecifiersDecoded0 = [CloudDirectoryClientTypes.TypedLinkSpecifier]()
            for structure0 in typedLinkSpecifiersContainer {
                if let structure0 = structure0 {
                    typedLinkSpecifiersDecoded0?.append(structure0)
                }
            }
        }
        typedLinkSpecifiers = typedLinkSpecifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOutgoingTypedLinksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPolicyAttachmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyReference = "PolicyReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let policyReference = self.policyReference {
            try encodeContainer.encode(policyReference, forKey: .policyReference)
        }
    }
}

extension ListPolicyAttachmentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let consistencyLevel = consistencyLevel {
            items.add(Header(name: "x-amz-consistency-level", value: Swift.String(consistencyLevel.rawValue)))
        }
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension ListPolicyAttachmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/policy/attachment"
    }
}

public struct ListPolicyAttachmentsInput: Swift.Equatable {
    /// Represents the manner and timing in which the successful write or update of an object is reflected in a subsequent read operation of that same object.
    public var consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where objects reside. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The reference that identifies the policy object.
    /// This member is required.
    public var policyReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        consistencyLevel: CloudDirectoryClientTypes.ConsistencyLevel? = nil,
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.consistencyLevel = consistencyLevel
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyReference = policyReference
    }
}

struct ListPolicyAttachmentsInputBody: Swift.Equatable {
    let policyReference: CloudDirectoryClientTypes.ObjectReference?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPolicyAttachmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case policyReference = "PolicyReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .policyReference)
        policyReference = policyReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPolicyAttachmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPolicyAttachmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.objectIdentifiers = output.objectIdentifiers
        } else {
            self.nextToken = nil
            self.objectIdentifiers = nil
        }
    }
}

public struct ListPolicyAttachmentsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// A list of ObjectIdentifiers to which the policy is attached.
    public var objectIdentifiers: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        objectIdentifiers: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectIdentifiers = objectIdentifiers
    }
}

struct ListPolicyAttachmentsOutputBody: Swift.Equatable {
    let objectIdentifiers: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPolicyAttachmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objectIdentifiers = "ObjectIdentifiers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectIdentifiers)
        var objectIdentifiersDecoded0:[Swift.String]? = nil
        if let objectIdentifiersContainer = objectIdentifiersContainer {
            objectIdentifiersDecoded0 = [Swift.String]()
            for string0 in objectIdentifiersContainer {
                if let string0 = string0 {
                    objectIdentifiersDecoded0?.append(string0)
                }
            }
        }
        objectIdentifiers = objectIdentifiersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPolicyAttachmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotPolicyException": return try await NotPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPublishedSchemaArnsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

extension ListPublishedSchemaArnsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/published"
    }
}

public struct ListPublishedSchemaArnsInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The response for ListPublishedSchemaArns when this parameter is used will list all minor version ARNs for a major version.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListPublishedSchemaArnsInputBody: Swift.Equatable {
    let schemaArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPublishedSchemaArnsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case schemaArn = "SchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPublishedSchemaArnsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPublishedSchemaArnsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaArns = output.schemaArns
        } else {
            self.nextToken = nil
            self.schemaArns = nil
        }
    }
}

public struct ListPublishedSchemaArnsOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The ARNs of published schemas.
    public var schemaArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        schemaArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaArns = schemaArns
    }
}

struct ListPublishedSchemaArnsOutputBody: Swift.Equatable {
    let schemaArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPublishedSchemaArnsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case schemaArns = "SchemaArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .schemaArns)
        var schemaArnsDecoded0:[Swift.String]? = nil
        if let schemaArnsContainer = schemaArnsContainer {
            schemaArnsDecoded0 = [Swift.String]()
            for string0 in schemaArnsContainer {
                if let string0 = string0 {
                    schemaArnsDecoded0?.append(string0)
                }
            }
        }
        schemaArns = schemaArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPublishedSchemaArnsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The MaxResults parameter sets the maximum number of results returned in a single page. This is for future use and is not supported currently.
    public var maxResults: Swift.Int?
    /// The pagination token. This is for future use. Currently pagination is not supported for tagging.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of tag key value pairs that are associated with the response.
    public var tags: [CloudDirectoryClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [CloudDirectoryClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [CloudDirectoryClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudDirectoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudDirectoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTaggingRequestException": return try await InvalidTaggingRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTypedLinkFacetAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTypedLinkFacetAttributesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension ListTypedLinkFacetAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/attributes"
    }
}

public struct ListTypedLinkFacetAttributesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListTypedLinkFacetAttributesInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTypedLinkFacetAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTypedLinkFacetAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTypedLinkFacetAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
            self.nextToken = output.nextToken
        } else {
            self.attributes = nil
            self.nextToken = nil
        }
    }
}

public struct ListTypedLinkFacetAttributesOutput: Swift.Equatable {
    /// An ordered set of attributes associate with the typed link.
    public var attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.nextToken = nextToken
    }
}

struct ListTypedLinkFacetAttributesOutputBody: Swift.Equatable {
    let attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]?
    let nextToken: Swift.String?
}

extension ListTypedLinkFacetAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeDefinition?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTypedLinkFacetAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetNotFoundException": return try await FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTypedLinkFacetNamesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTypedLinkFacetNamesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension ListTypedLinkFacetNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet/list"
    }
}

public struct ListTypedLinkFacetNamesInput: Swift.Equatable {
    /// The maximum number of results to retrieve.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaArn = schemaArn
    }
}

struct ListTypedLinkFacetNamesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTypedLinkFacetNamesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTypedLinkFacetNamesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTypedLinkFacetNamesOutputBody = try responseDecoder.decode(responseBody: data)
            self.facetNames = output.facetNames
            self.nextToken = output.nextToken
        } else {
            self.facetNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListTypedLinkFacetNamesOutput: Swift.Equatable {
    /// The names of typed link facets that exist within the schema.
    public var facetNames: [Swift.String]?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init(
        facetNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.facetNames = facetNames
        self.nextToken = nextToken
    }
}

struct ListTypedLinkFacetNamesOutputBody: Swift.Equatable {
    let facetNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListTypedLinkFacetNamesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetNames = "FacetNames"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facetNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .facetNames)
        var facetNamesDecoded0:[Swift.String]? = nil
        if let facetNamesContainer = facetNamesContainer {
            facetNamesDecoded0 = [Swift.String]()
            for string0 in facetNamesContainer {
                if let string0 = string0 {
                    facetNamesDecoded0?.append(string0)
                }
            }
        }
        facetNames = facetNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTypedLinkFacetNamesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LookupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension LookupPolicyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension LookupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/policy/lookup"
    }
}

public struct LookupPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the [Directory]. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The maximum number of items to be retrieved in a single call. This is an approximate number.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// Reference that identifies the object whose policies will be looked up.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        directoryArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.directoryArn = directoryArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectReference = objectReference
    }
}

struct LookupPolicyInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension LookupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension LookupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LookupPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyToPathList = output.policyToPathList
        } else {
            self.nextToken = nil
            self.policyToPathList = nil
        }
    }
}

public struct LookupPolicyOutput: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Provides list of path to policies. Policies contain PolicyId, ObjectIdentifier, and PolicyType. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
    public var policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]?

    public init(
        nextToken: Swift.String? = nil,
        policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyToPathList = policyToPathList
    }
}

struct LookupPolicyOutputBody: Swift.Equatable {
    let policyToPathList: [CloudDirectoryClientTypes.PolicyToPath]?
    let nextToken: Swift.String?
}

extension LookupPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case policyToPathList = "PolicyToPathList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyToPathListContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PolicyToPath?].self, forKey: .policyToPathList)
        var policyToPathListDecoded0:[CloudDirectoryClientTypes.PolicyToPath]? = nil
        if let policyToPathListContainer = policyToPathListContainer {
            policyToPathListDecoded0 = [CloudDirectoryClientTypes.PolicyToPath]()
            for structure0 in policyToPathListContainer {
                if let structure0 = structure0 {
                    policyToPathListDecoded0?.append(structure0)
                }
            }
        }
        policyToPathList = policyToPathListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum LookupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotIndexException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotIndexExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the requested operation can only operate on index objects.
public struct NotIndexException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotIndexException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotIndexExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotIndexExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotNodeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotNodeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when any invalid operations are performed on an object that is not a node, such as calling ListObjectChildren for a leaf node object.
public struct NotNodeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotNodeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotNodeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotNodeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotPolicyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the requested operation can only operate on policy objects.
public struct NotPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotPolicyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ObjectAlreadyDetachedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ObjectAlreadyDetachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the object is not attached to the index.
public struct ObjectAlreadyDetachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ObjectAlreadyDetachedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ObjectAlreadyDetachedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ObjectAlreadyDetachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.ObjectAttributeAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeActionType = "ObjectAttributeActionType"
        case objectAttributeUpdateValue = "ObjectAttributeUpdateValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeActionType = self.objectAttributeActionType {
            try encodeContainer.encode(objectAttributeActionType.rawValue, forKey: .objectAttributeActionType)
        }
        if let objectAttributeUpdateValue = self.objectAttributeUpdateValue {
            try encodeContainer.encode(objectAttributeUpdateValue, forKey: .objectAttributeUpdateValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectAttributeActionTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.UpdateActionType.self, forKey: .objectAttributeActionType)
        objectAttributeActionType = objectAttributeActionTypeDecoded
        let objectAttributeUpdateValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .objectAttributeUpdateValue)
        objectAttributeUpdateValue = objectAttributeUpdateValueDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// The action to take on the object attribute.
    public struct ObjectAttributeAction: Swift.Equatable {
        /// A type that can be either Update or Delete.
        public var objectAttributeActionType: CloudDirectoryClientTypes.UpdateActionType?
        /// The value that you want to update to.
        public var objectAttributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            objectAttributeActionType: CloudDirectoryClientTypes.UpdateActionType? = nil,
            objectAttributeUpdateValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.objectAttributeActionType = objectAttributeActionType
            self.objectAttributeUpdateValue = objectAttributeUpdateValue
        }
    }

}

extension CloudDirectoryClientTypes.ObjectAttributeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeKey = "AttributeKey"
        case range = "Range"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKey = self.attributeKey {
            try encodeContainer.encode(attributeKey, forKey: .attributeKey)
        }
        if let range = self.range {
            try encodeContainer.encode(range, forKey: .range)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.AttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValueRange.self, forKey: .range)
        range = rangeDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A range of attributes.
    public struct ObjectAttributeRange: Swift.Equatable {
        /// The key of the attribute that the attribute range covers.
        public var attributeKey: CloudDirectoryClientTypes.AttributeKey?
        /// The range of attribute values being selected.
        public var range: CloudDirectoryClientTypes.TypedAttributeValueRange?

        public init(
            attributeKey: CloudDirectoryClientTypes.AttributeKey? = nil,
            range: CloudDirectoryClientTypes.TypedAttributeValueRange? = nil
        )
        {
            self.attributeKey = attributeKey
            self.range = range
        }
    }

}

extension CloudDirectoryClientTypes.ObjectAttributeUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectAttributeAction = "ObjectAttributeAction"
        case objectAttributeKey = "ObjectAttributeKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectAttributeAction = self.objectAttributeAction {
            try encodeContainer.encode(objectAttributeAction, forKey: .objectAttributeAction)
        }
        if let objectAttributeKey = self.objectAttributeKey {
            try encodeContainer.encode(objectAttributeKey, forKey: .objectAttributeKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectAttributeKeyDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.AttributeKey.self, forKey: .objectAttributeKey)
        objectAttributeKey = objectAttributeKeyDecoded
        let objectAttributeActionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectAttributeAction.self, forKey: .objectAttributeAction)
        objectAttributeAction = objectAttributeActionDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Structure that contains attribute update information.
    public struct ObjectAttributeUpdate: Swift.Equatable {
        /// The action to perform as part of the attribute update.
        public var objectAttributeAction: CloudDirectoryClientTypes.ObjectAttributeAction?
        /// The key of the attribute being updated.
        public var objectAttributeKey: CloudDirectoryClientTypes.AttributeKey?

        public init(
            objectAttributeAction: CloudDirectoryClientTypes.ObjectAttributeAction? = nil,
            objectAttributeKey: CloudDirectoryClientTypes.AttributeKey? = nil
        )
        {
            self.objectAttributeAction = objectAttributeAction
            self.objectAttributeKey = objectAttributeKey
        }
    }

}

extension CloudDirectoryClientTypes.ObjectIdentifierAndLinkNameTuple: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkName = "LinkName"
        case objectIdentifier = "ObjectIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
        if let objectIdentifier = self.objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A pair of ObjectIdentifier and LinkName.
    public struct ObjectIdentifierAndLinkNameTuple: Swift.Equatable {
        /// The name of the link between the parent and the child object.
        public var linkName: Swift.String?
        /// The ID that is associated with the object.
        public var objectIdentifier: Swift.String?

        public init(
            linkName: Swift.String? = nil,
            objectIdentifier: Swift.String? = nil
        )
        {
            self.linkName = linkName
            self.objectIdentifier = objectIdentifier
        }
    }

}

extension ObjectNotDetachedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ObjectNotDetachedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the requested operation cannot be completed because the object has not been detached from the tree.
public struct ObjectNotDetachedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ObjectNotDetachedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ObjectNotDetachedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ObjectNotDetachedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.ObjectReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selector = "Selector"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selector = self.selector {
            try encodeContainer.encode(selector, forKey: .selector)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selector)
        selector = selectorDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// The reference that identifies an object.
    public struct ObjectReference: Swift.Equatable {
        /// A path selector supports easy selection of an object by the parent/child links leading to it from the directory root. Use the link names from each parent/child link to construct the path. Path selectors start with a slash (/) and link names are separated by slashes. For more information about paths, see [Access Objects](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_access_objects.html). You can identify an object in one of the following ways:
        ///
        /// * $ObjectIdentifier - An object identifier is an opaque string provided by Amazon Cloud Directory. When creating objects, the system will provide you with the identifier of the created object. An objects identifier is immutable and no two objects will ever share the same object identifier. To identify an object with ObjectIdentifier, the ObjectIdentifier must be wrapped in double quotes.
        ///
        /// * /some/path - Identifies the object based on path
        ///
        /// * #SomeBatchReference - Identifies the object in a batch call
        public var selector: Swift.String?

        public init(
            selector: Swift.String? = nil
        )
        {
            self.selector = selector
        }
    }

}

extension CloudDirectoryClientTypes {
    public enum ObjectType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case index
        case leafNode
        case node
        case policy
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectType] {
            return [
                .index,
                .leafNode,
                .node,
                .policy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .index: return "INDEX"
            case .leafNode: return "LEAF_NODE"
            case .node: return "NODE"
            case .policy: return "POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectType(rawValue: rawValue) ?? ObjectType.sdkUnknown(rawValue)
        }
    }
}

extension CloudDirectoryClientTypes.PathToObjectIdentifiers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifiers = "ObjectIdentifiers"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifiers = objectIdentifiers {
            var objectIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectIdentifiers)
            for objectidentifier0 in objectIdentifiers {
                try objectIdentifiersContainer.encode(objectidentifier0)
            }
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let objectIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectIdentifiers)
        var objectIdentifiersDecoded0:[Swift.String]? = nil
        if let objectIdentifiersContainer = objectIdentifiersContainer {
            objectIdentifiersDecoded0 = [Swift.String]()
            for string0 in objectIdentifiersContainer {
                if let string0 = string0 {
                    objectIdentifiersDecoded0?.append(string0)
                }
            }
        }
        objectIdentifiers = objectIdentifiersDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Returns the path to the ObjectIdentifiers that is associated with the directory.
    public struct PathToObjectIdentifiers: Swift.Equatable {
        /// Lists ObjectIdentifiers starting from directory root to the object in the request.
        public var objectIdentifiers: [Swift.String]?
        /// The path that is used to identify the object starting from directory root.
        public var path: Swift.String?

        public init(
            objectIdentifiers: [Swift.String]? = nil,
            path: Swift.String? = nil
        )
        {
            self.objectIdentifiers = objectIdentifiers
            self.path = path
        }
    }

}

extension CloudDirectoryClientTypes.PolicyAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
        case policyId = "PolicyId"
        case policyType = "PolicyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectIdentifier = self.objectIdentifier {
            try encodeContainer.encode(objectIdentifier, forKey: .objectIdentifier)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyType = self.policyType {
            try encodeContainer.encode(policyType, forKey: .policyType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyType)
        policyType = policyTypeDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Contains the PolicyType, PolicyId, and the ObjectIdentifier to which it is attached. For more information, see [Policies](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/key_concepts_directory.html#key_concepts_policies).
    public struct PolicyAttachment: Swift.Equatable {
        /// The ObjectIdentifier that is associated with PolicyAttachment.
        public var objectIdentifier: Swift.String?
        /// The ID of PolicyAttachment.
        public var policyId: Swift.String?
        /// The type of policy that can be associated with PolicyAttachment.
        public var policyType: Swift.String?

        public init(
            objectIdentifier: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyType: Swift.String? = nil
        )
        {
            self.objectIdentifier = objectIdentifier
            self.policyId = policyId
            self.policyType = policyType
        }
    }

}

extension CloudDirectoryClientTypes.PolicyToPath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
        case policies = "Policies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let policies = policies {
            var policiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policies)
            for policyattachment0 in policies {
                try policiesContainer.encode(policyattachment0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let policiesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.PolicyAttachment?].self, forKey: .policies)
        var policiesDecoded0:[CloudDirectoryClientTypes.PolicyAttachment]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [CloudDirectoryClientTypes.PolicyAttachment]()
            for structure0 in policiesContainer {
                if let structure0 = structure0 {
                    policiesDecoded0?.append(structure0)
                }
            }
        }
        policies = policiesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Used when a regular object exists in a [Directory] and you want to find all of the policies that are associated with that object and the parent to that object.
    public struct PolicyToPath: Swift.Equatable {
        /// The path that is referenced from the root.
        public var path: Swift.String?
        /// List of policy objects.
        public var policies: [CloudDirectoryClientTypes.PolicyAttachment]?

        public init(
            path: Swift.String? = nil,
            policies: [CloudDirectoryClientTypes.PolicyAttachment]? = nil
        )
        {
            self.path = path
            self.policies = policies
        }
    }

}

extension PublishSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minorVersion = "MinorVersion"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension PublishSchemaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let developmentSchemaArn = developmentSchemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(developmentSchemaArn)))
        }
        return items
    }
}

extension PublishSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/publish"
    }
}

public struct PublishSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that is associated with the development schema. For more information, see [arns].
    /// This member is required.
    public var developmentSchemaArn: Swift.String?
    /// The minor version under which the schema will be published. This parameter is recommended. Schemas have both a major and minor version associated with them.
    public var minorVersion: Swift.String?
    /// The new name under which the schema will be published. If this is not provided, the development schema is considered.
    public var name: Swift.String?
    /// The major version under which the schema will be published. Schemas have both a major and minor version associated with them.
    /// This member is required.
    public var version: Swift.String?

    public init(
        developmentSchemaArn: Swift.String? = nil,
        minorVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.developmentSchemaArn = developmentSchemaArn
        self.minorVersion = minorVersion
        self.name = name
        self.version = version
    }
}

struct PublishSchemaInputBody: Swift.Equatable {
    let version: Swift.String?
    let minorVersion: Swift.String?
    let name: Swift.String?
}

extension PublishSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minorVersion = "MinorVersion"
        case name = "Name"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension PublishSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PublishSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.publishedSchemaArn = output.publishedSchemaArn
        } else {
            self.publishedSchemaArn = nil
        }
    }
}

public struct PublishSchemaOutput: Swift.Equatable {
    /// The ARN that is associated with the published schema. For more information, see [arns].
    public var publishedSchemaArn: Swift.String?

    public init(
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct PublishSchemaOutputBody: Swift.Equatable {
    let publishedSchemaArn: Swift.String?
}

extension PublishSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
    }
}

enum PublishSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SchemaAlreadyPublishedException": return try await SchemaAlreadyPublishedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutSchemaFromJsonInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
    }
}

extension PutSchemaFromJsonInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension PutSchemaFromJsonInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/json"
    }
}

public struct PutSchemaFromJsonInput: Swift.Equatable {
    /// The replacement JSON schema.
    /// This member is required.
    public var document: Swift.String?
    /// The ARN of the schema to update.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        document: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.document = document
        self.schemaArn = schemaArn
    }
}

struct PutSchemaFromJsonInputBody: Swift.Equatable {
    let document: Swift.String?
}

extension PutSchemaFromJsonInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document = "Document"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

extension PutSchemaFromJsonOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSchemaFromJsonOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct PutSchemaFromJsonOutput: Swift.Equatable {
    /// The ARN of the schema to update.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct PutSchemaFromJsonOutputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension PutSchemaFromJsonOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum PutSchemaFromJsonOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuleException": return try await InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSchemaDocException": return try await InvalidSchemaDocException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudDirectoryClientTypes {
    public enum RangeMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exclusive
        case first
        case inclusive
        case last
        case lastBeforeMissingValues
        case sdkUnknown(Swift.String)

        public static var allCases: [RangeMode] {
            return [
                .exclusive,
                .first,
                .inclusive,
                .last,
                .lastBeforeMissingValues,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exclusive: return "EXCLUSIVE"
            case .first: return "FIRST"
            case .inclusive: return "INCLUSIVE"
            case .last: return "LAST"
            case .lastBeforeMissingValues: return "LAST_BEFORE_MISSING_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RangeMode(rawValue: rawValue) ?? RangeMode.sdkUnknown(rawValue)
        }
    }
}

extension RemoveFacetFromObjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
        if let schemaFacet = self.schemaFacet {
            try encodeContainer.encode(schemaFacet, forKey: .schemaFacet)
        }
    }
}

extension RemoveFacetFromObjectInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension RemoveFacetFromObjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/facets/delete"
    }
}

public struct RemoveFacetFromObjectInput: Swift.Equatable {
    /// The ARN of the directory in which the object resides.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// A reference to the object to remove the facet from.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?
    /// The facet to remove. See [SchemaFacet] for details.
    /// This member is required.
    public var schemaFacet: CloudDirectoryClientTypes.SchemaFacet?

    public init(
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
        schemaFacet: CloudDirectoryClientTypes.SchemaFacet? = nil
    )
    {
        self.directoryArn = directoryArn
        self.objectReference = objectReference
        self.schemaFacet = schemaFacet
    }
}

struct RemoveFacetFromObjectInputBody: Swift.Equatable {
    let schemaFacet: CloudDirectoryClientTypes.SchemaFacet?
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
}

extension RemoveFacetFromObjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectReference = "ObjectReference"
        case schemaFacet = "SchemaFacet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.SchemaFacet.self, forKey: .schemaFacet)
        schemaFacet = schemaFacetDecoded
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
    }
}

extension RemoveFacetFromObjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveFacetFromObjectOutput: Swift.Equatable {

    public init() { }
}

enum RemoveFacetFromObjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudDirectoryClientTypes {
    public enum RequiredAttributeBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notRequired
        case requiredAlways
        case sdkUnknown(Swift.String)

        public static var allCases: [RequiredAttributeBehavior] {
            return [
                .notRequired,
                .requiredAlways,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notRequired: return "NOT_REQUIRED"
            case .requiredAlways: return "REQUIRED_ALWAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequiredAttributeBehavior(rawValue: rawValue) ?? RequiredAttributeBehavior.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetryableConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RetryableConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. For example, if a write operation occurs on an object and then an attempt is made to read the object using SERIALIZABLE consistency, this exception may result. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct RetryableConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RetryableConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RetryableConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RetryableConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ruleParameterMap0) in parameters {
                try parametersContainer.encode(ruleParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RuleType.self, forKey: .type)
        type = typeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, ruleparametervalue0) in parametersContainer {
                if let ruleparametervalue0 = ruleparametervalue0 {
                    parametersDecoded0?[key0] = ruleparametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Contains an Amazon Resource Name (ARN) and parameters that are associated with the rule.
    public struct Rule: Swift.Equatable {
        /// The minimum and maximum parameters that are associated with the rule.
        public var parameters: [Swift.String:Swift.String]?
        /// The type of attribute validation rule.
        public var type: CloudDirectoryClientTypes.RuleType?

        public init(
            parameters: [Swift.String:Swift.String]? = nil,
            type: CloudDirectoryClientTypes.RuleType? = nil
        )
        {
            self.parameters = parameters
            self.type = type
        }
    }

}

extension CloudDirectoryClientTypes {
    public enum RuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binaryLength
        case numberComparison
        case stringFromSet
        case stringLength
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleType] {
            return [
                .binaryLength,
                .numberComparison,
                .stringFromSet,
                .stringLength,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binaryLength: return "BINARY_LENGTH"
            case .numberComparison: return "NUMBER_COMPARISON"
            case .stringFromSet: return "STRING_FROM_SET"
            case .stringLength: return "STRING_LENGTH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleType(rawValue: rawValue) ?? RuleType.sdkUnknown(rawValue)
        }
    }
}

extension SchemaAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SchemaAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a schema could not be created due to a naming conflict. Please select a different name and then try again.
public struct SchemaAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SchemaAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SchemaAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SchemaAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SchemaAlreadyPublishedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SchemaAlreadyPublishedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a schema is already published.
public struct SchemaAlreadyPublishedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SchemaAlreadyPublishedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct SchemaAlreadyPublishedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SchemaAlreadyPublishedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.SchemaFacet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facetName = "FacetName"
        case schemaArn = "SchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facetName = self.facetName {
            try encodeContainer.encode(facetName, forKey: .facetName)
        }
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let facetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .facetName)
        facetName = facetNameDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A facet.
    public struct SchemaFacet: Swift.Equatable {
        /// The name of the facet. If this value is set, SchemaArn must also be set.
        public var facetName: Swift.String?
        /// The ARN of the schema that contains the facet with no minor component. See [arns] and [In-Place Schema Upgrade](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/schemas_inplaceschemaupgrade.html) for a description of when to provide minor versions. If this value is set, FacetName must also be set.
        public var schemaArn: Swift.String?

        public init(
            facetName: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.facetName = facetName
            self.schemaArn = schemaArn
        }
    }

}

extension StillContainsLinksException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StillContainsLinksExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The object could not be deleted because links still exist. Remove the links and then try the operation again.
public struct StillContainsLinksException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StillContainsLinksException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct StillContainsLinksExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension StillContainsLinksExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudDirectoryClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// The tag structure that contains a tag key and value.
    public struct Tag: Swift.Equatable {
        /// The key that is associated with the tag.
        public var key: Swift.String?
        /// The value that is associated with the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/tags/add"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key-value pairs.
    /// This member is required.
    public var tags: [CloudDirectoryClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [CloudDirectoryClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [CloudDirectoryClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CloudDirectoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CloudDirectoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTaggingRequestException": return try await InvalidTaggingRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudDirectoryClientTypes.TypedAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryvalue = "BinaryValue"
        case booleanvalue = "BooleanValue"
        case datetimevalue = "DatetimeValue"
        case numbervalue = "NumberValue"
        case stringvalue = "StringValue"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .binaryvalue(binaryvalue):
                try container.encode(binaryvalue.base64EncodedString(), forKey: .binaryvalue)
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .datetimevalue(datetimevalue):
                try container.encodeTimestamp(datetimevalue, format: .epochSeconds, forKey: .datetimevalue)
            case let .numbervalue(numbervalue):
                try container.encode(numbervalue, forKey: .numbervalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let binaryvalueDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .binaryvalue)
        if let binaryvalue = binaryvalueDecoded {
            self = .binaryvalue(binaryvalue)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        let numbervalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .numbervalue)
        if let numbervalue = numbervalueDecoded {
            self = .numbervalue(numbervalue)
            return
        }
        let datetimevalueDecoded = try values.decodeTimestampIfPresent(.epochSeconds, forKey: .datetimevalue)
        if let datetimevalue = datetimevalueDecoded {
            self = .datetimevalue(datetimevalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CloudDirectoryClientTypes {
    /// Represents the data for a typed attribute. You can set one, and only one, of the elements. Each attribute in an item is a name-value pair. Attributes have a single value.
    public enum TypedAttributeValue: Swift.Equatable {
        /// A string data value.
        case stringvalue(Swift.String)
        /// A binary data value.
        case binaryvalue(ClientRuntime.Data)
        /// A Boolean data value.
        case booleanvalue(Swift.Bool)
        /// A number data value.
        case numbervalue(Swift.String)
        /// A date and time value.
        case datetimevalue(ClientRuntime.Date)
        case sdkUnknown(Swift.String)
    }

}

extension CloudDirectoryClientTypes.TypedAttributeValueRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endMode = "EndMode"
        case endValue = "EndValue"
        case startMode = "StartMode"
        case startValue = "StartValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endMode = self.endMode {
            try encodeContainer.encode(endMode.rawValue, forKey: .endMode)
        }
        if let endValue = self.endValue {
            try encodeContainer.encode(endValue, forKey: .endValue)
        }
        if let startMode = self.startMode {
            try encodeContainer.encode(startMode.rawValue, forKey: .startMode)
        }
        if let startValue = self.startValue {
            try encodeContainer.encode(startValue, forKey: .startValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startModeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RangeMode.self, forKey: .startMode)
        startMode = startModeDecoded
        let startValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .startValue)
        startValue = startValueDecoded
        let endModeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RangeMode.self, forKey: .endMode)
        endMode = endModeDecoded
        let endValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .endValue)
        endValue = endValueDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A range of attribute values. For more information, see [Range Filters](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_range_filters.html).
    public struct TypedAttributeValueRange: Swift.Equatable {
        /// The inclusive or exclusive range end.
        /// This member is required.
        public var endMode: CloudDirectoryClientTypes.RangeMode?
        /// The attribute value to terminate the range at.
        public var endValue: CloudDirectoryClientTypes.TypedAttributeValue?
        /// The inclusive or exclusive range start.
        /// This member is required.
        public var startMode: CloudDirectoryClientTypes.RangeMode?
        /// The value to start the range at.
        public var startValue: CloudDirectoryClientTypes.TypedAttributeValue?

        public init(
            endMode: CloudDirectoryClientTypes.RangeMode? = nil,
            endValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil,
            startMode: CloudDirectoryClientTypes.RangeMode? = nil,
            startValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil
        )
        {
            self.endMode = endMode
            self.endValue = endValue
            self.startMode = startMode
            self.startValue = startValue
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkAttributeDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case isImmutable = "IsImmutable"
        case name = "Name"
        case requiredBehavior = "RequiredBehavior"
        case rules = "Rules"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if isImmutable != false {
            try encodeContainer.encode(isImmutable, forKey: .isImmutable)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiredBehavior = self.requiredBehavior {
            try encodeContainer.encode(requiredBehavior.rawValue, forKey: .requiredBehavior)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .rules)
            for (dictKey0, ruleMap0) in rules {
                try rulesContainer.encode(ruleMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.FacetAttributeType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValue.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let isImmutableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isImmutable) ?? false
        isImmutable = isImmutableDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Swift.String: CloudDirectoryClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0: [Swift.String:CloudDirectoryClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Swift.String:CloudDirectoryClientTypes.Rule]()
            for (key0, rule0) in rulesContainer {
                if let rule0 = rule0 {
                    rulesDecoded0?[key0] = rule0
                }
            }
        }
        rules = rulesDecoded0
        let requiredBehaviorDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.RequiredAttributeBehavior.self, forKey: .requiredBehavior)
        requiredBehavior = requiredBehaviorDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A typed link attribute definition.
    public struct TypedLinkAttributeDefinition: Swift.Equatable {
        /// The default value of the attribute (if configured).
        public var defaultValue: CloudDirectoryClientTypes.TypedAttributeValue?
        /// Whether the attribute is mutable or not.
        public var isImmutable: Swift.Bool
        /// The unique name of the typed link attribute.
        /// This member is required.
        public var name: Swift.String?
        /// The required behavior of the TypedLinkAttributeDefinition.
        /// This member is required.
        public var requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior?
        /// Validation rules that are attached to the attribute definition.
        public var rules: [Swift.String:CloudDirectoryClientTypes.Rule]?
        /// The type of the attribute.
        /// This member is required.
        public var type: CloudDirectoryClientTypes.FacetAttributeType?

        public init(
            defaultValue: CloudDirectoryClientTypes.TypedAttributeValue? = nil,
            isImmutable: Swift.Bool = false,
            name: Swift.String? = nil,
            requiredBehavior: CloudDirectoryClientTypes.RequiredAttributeBehavior? = nil,
            rules: [Swift.String:CloudDirectoryClientTypes.Rule]? = nil,
            type: CloudDirectoryClientTypes.FacetAttributeType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.isImmutable = isImmutable
            self.name = name
            self.requiredBehavior = requiredBehavior
            self.rules = rules
            self.type = type
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkAttributeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case range = "Range"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let range = self.range {
            try encodeContainer.encode(range, forKey: .range)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedAttributeValueRange.self, forKey: .range)
        range = rangeDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Identifies the range of attributes that are used by a specified filter.
    public struct TypedLinkAttributeRange: Swift.Equatable {
        /// The unique name of the typed link attribute.
        public var attributeName: Swift.String?
        /// The range of attribute values that are being selected.
        /// This member is required.
        public var range: CloudDirectoryClientTypes.TypedAttributeValueRange?

        public init(
            attributeName: Swift.String? = nil,
            range: CloudDirectoryClientTypes.TypedAttributeValueRange? = nil
        )
        {
            self.attributeName = attributeName
            self.range = range
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkFacet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case identityAttributeOrder = "IdentityAttributeOrder"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for typedlinkattributedefinition0 in attributes {
                try attributesContainer.encode(typedlinkattributedefinition0)
            }
        }
        if let identityAttributeOrder = identityAttributeOrder {
            var identityAttributeOrderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityAttributeOrder)
            for attributename0 in identityAttributeOrder {
                try identityAttributeOrderContainer.encode(attributename0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkAttributeDefinition?].self, forKey: .attributes)
        var attributesDecoded0:[CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let identityAttributeOrderContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identityAttributeOrder)
        var identityAttributeOrderDecoded0:[Swift.String]? = nil
        if let identityAttributeOrderContainer = identityAttributeOrderContainer {
            identityAttributeOrderDecoded0 = [Swift.String]()
            for string0 in identityAttributeOrderContainer {
                if let string0 = string0 {
                    identityAttributeOrderDecoded0?.append(string0)
                }
            }
        }
        identityAttributeOrder = identityAttributeOrderDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Defines the typed links structure and its attributes. To create a typed link facet, use the [CreateTypedLinkFacet] API.
    public struct TypedLinkFacet: Swift.Equatable {
        /// A set of key-value pairs associated with the typed link. Typed link attributes are used when you have data values that are related to the link itself, and not to one of the two objects being linked. Identity attributes also serve to distinguish the link from others of the same type between the same objects.
        /// This member is required.
        public var attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]?
        /// The set of attributes that distinguish links made from this facet from each other, in the order of significance. Listing typed links can filter on the values of these attributes. See [ListOutgoingTypedLinks] and [ListIncomingTypedLinks] for details.
        /// This member is required.
        public var identityAttributeOrder: [Swift.String]?
        /// The unique name of the typed link facet.
        /// This member is required.
        public var name: Swift.String?

        public init(
            attributes: [CloudDirectoryClientTypes.TypedLinkAttributeDefinition]? = nil,
            identityAttributeOrder: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.identityAttributeOrder = identityAttributeOrder
            self.name = name
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case attribute = "Attribute"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkAttributeDefinition.self, forKey: .attribute)
        attribute = attributeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.UpdateActionType.self, forKey: .action)
        action = actionDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// A typed link facet attribute update.
    public struct TypedLinkFacetAttributeUpdate: Swift.Equatable {
        /// The action to perform when updating the attribute.
        /// This member is required.
        public var action: CloudDirectoryClientTypes.UpdateActionType?
        /// The attribute to update.
        /// This member is required.
        public var attribute: CloudDirectoryClientTypes.TypedLinkAttributeDefinition?

        public init(
            action: CloudDirectoryClientTypes.UpdateActionType? = nil,
            attribute: CloudDirectoryClientTypes.TypedLinkAttributeDefinition? = nil
        )
        {
            self.action = action
            self.attribute = attribute
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
        case typedLinkName = "TypedLinkName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = self.schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let typedLinkName = self.typedLinkName {
            try encodeContainer.encode(typedLinkName, forKey: .typedLinkName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let typedLinkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typedLinkName)
        typedLinkName = typedLinkNameDecoded
    }
}

extension CloudDirectoryClientTypes {
    /// Identifies the schema Amazon Resource Name (ARN) and facet name for the typed link.
    public struct TypedLinkSchemaAndFacetName: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
        /// This member is required.
        public var schemaArn: Swift.String?
        /// The unique name of the typed link facet.
        /// This member is required.
        public var typedLinkName: Swift.String?

        public init(
            schemaArn: Swift.String? = nil,
            typedLinkName: Swift.String? = nil
        )
        {
            self.schemaArn = schemaArn
            self.typedLinkName = typedLinkName
        }
    }

}

extension CloudDirectoryClientTypes.TypedLinkSpecifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityAttributeValues = "IdentityAttributeValues"
        case sourceObjectReference = "SourceObjectReference"
        case targetObjectReference = "TargetObjectReference"
        case typedLinkFacet = "TypedLinkFacet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityAttributeValues = identityAttributeValues {
            var identityAttributeValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityAttributeValues)
            for attributenameandvalue0 in identityAttributeValues {
                try identityAttributeValuesContainer.encode(attributenameandvalue0)
            }
        }
        if let sourceObjectReference = self.sourceObjectReference {
            try encodeContainer.encode(sourceObjectReference, forKey: .sourceObjectReference)
        }
        if let targetObjectReference = self.targetObjectReference {
            try encodeContainer.encode(targetObjectReference, forKey: .targetObjectReference)
        }
        if let typedLinkFacet = self.typedLinkFacet {
            try encodeContainer.encode(typedLinkFacet, forKey: .typedLinkFacet)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkFacetDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName.self, forKey: .typedLinkFacet)
        typedLinkFacet = typedLinkFacetDecoded
        let sourceObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .sourceObjectReference)
        sourceObjectReference = sourceObjectReferenceDecoded
        let targetObjectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .targetObjectReference)
        targetObjectReference = targetObjectReferenceDecoded
        let identityAttributeValuesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.AttributeNameAndValue?].self, forKey: .identityAttributeValues)
        var identityAttributeValuesDecoded0:[CloudDirectoryClientTypes.AttributeNameAndValue]? = nil
        if let identityAttributeValuesContainer = identityAttributeValuesContainer {
            identityAttributeValuesDecoded0 = [CloudDirectoryClientTypes.AttributeNameAndValue]()
            for structure0 in identityAttributeValuesContainer {
                if let structure0 = structure0 {
                    identityAttributeValuesDecoded0?.append(structure0)
                }
            }
        }
        identityAttributeValues = identityAttributeValuesDecoded0
    }
}

extension CloudDirectoryClientTypes {
    /// Contains all the information that is used to uniquely identify a typed link. The parameters discussed in this topic are used to uniquely specify the typed link being operated on. The [AttachTypedLink] API returns a typed link specifier while the [DetachTypedLink] API accepts one as input. Similarly, the [ListIncomingTypedLinks] and [ListOutgoingTypedLinks] API operations provide typed link specifiers as output. You can also construct a typed link specifier from scratch.
    public struct TypedLinkSpecifier: Swift.Equatable {
        /// Identifies the attribute value to update.
        /// This member is required.
        public var identityAttributeValues: [CloudDirectoryClientTypes.AttributeNameAndValue]?
        /// Identifies the source object that the typed link will attach to.
        /// This member is required.
        public var sourceObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the target object that the typed link will attach to.
        /// This member is required.
        public var targetObjectReference: CloudDirectoryClientTypes.ObjectReference?
        /// Identifies the typed link facet that is associated with the typed link.
        /// This member is required.
        public var typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName?

        public init(
            identityAttributeValues: [CloudDirectoryClientTypes.AttributeNameAndValue]? = nil,
            sourceObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            targetObjectReference: CloudDirectoryClientTypes.ObjectReference? = nil,
            typedLinkFacet: CloudDirectoryClientTypes.TypedLinkSchemaAndFacetName? = nil
        )
        {
            self.identityAttributeValues = identityAttributeValues
            self.sourceObjectReference = sourceObjectReference
            self.targetObjectReference = targetObjectReference
            self.typedLinkFacet = typedLinkFacet
        }
    }

}

extension UnsupportedIndexTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedIndexTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the requested index type is not supported.
public struct UnsupportedIndexTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedIndexTypeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedIndexTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedIndexTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/tags/remove"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. Tagging is only supported for directories.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of the tag that need to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTaggingRequestException": return try await InvalidTaggingRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudDirectoryClientTypes {
    public enum UpdateActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createOrUpdate
        case delete
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateActionType] {
            return [
                .createOrUpdate,
                .delete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createOrUpdate: return "CREATE_OR_UPDATE"
            case .delete: return "DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateActionType(rawValue: rawValue) ?? UpdateActionType.sdkUnknown(rawValue)
        }
    }
}

extension UpdateFacetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for facetattributeupdate0 in attributeUpdates {
                try attributeUpdatesContainer.encode(facetattributeupdate0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objectType = self.objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }
}

extension UpdateFacetInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension UpdateFacetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/facet"
    }
}

public struct UpdateFacetInput: Swift.Equatable {
    /// List of attributes that need to be updated in a given schema [Facet]. Each attribute is followed by AttributeAction, which specifies the type of update operation to perform.
    public var attributeUpdates: [CloudDirectoryClientTypes.FacetAttributeUpdate]?
    /// The name of the facet.
    /// This member is required.
    public var name: Swift.String?
    /// The object type that is associated with the facet. See [CreateFacetRequest$ObjectType] for more details.
    public var objectType: CloudDirectoryClientTypes.ObjectType?
    /// The Amazon Resource Name (ARN) that is associated with the [Facet]. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        attributeUpdates: [CloudDirectoryClientTypes.FacetAttributeUpdate]? = nil,
        name: Swift.String? = nil,
        objectType: CloudDirectoryClientTypes.ObjectType? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.name = name
        self.objectType = objectType
        self.schemaArn = schemaArn
    }
}

struct UpdateFacetInputBody: Swift.Equatable {
    let name: Swift.String?
    let attributeUpdates: [CloudDirectoryClientTypes.FacetAttributeUpdate]?
    let objectType: CloudDirectoryClientTypes.ObjectType?
}

extension UpdateFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case name = "Name"
        case objectType = "ObjectType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.FacetAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.FacetAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.FacetAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
        let objectTypeDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectType.self, forKey: .objectType)
        objectType = objectTypeDecoded
    }
}

extension UpdateFacetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFacetOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFacetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetNotFoundException": return try await FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFacetUpdateException": return try await InvalidFacetUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuleException": return try await InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLinkAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for linkattributeupdate0 in attributeUpdates {
                try attributeUpdatesContainer.encode(linkattributeupdate0)
            }
        }
        if let typedLinkSpecifier = self.typedLinkSpecifier {
            try encodeContainer.encode(typedLinkSpecifier, forKey: .typedLinkSpecifier)
        }
    }
}

extension UpdateLinkAttributesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension UpdateLinkAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/attributes/update"
    }
}

public struct UpdateLinkAttributesInput: Swift.Equatable {
    /// The attributes update structure.
    /// This member is required.
    public var attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]?
    /// The Amazon Resource Name (ARN) that is associated with the Directory where the updated typed link resides. For more information, see [arns] or [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Allows a typed link specifier to be accepted as input.
    /// This member is required.
    public var typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?

    public init(
        attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil,
        directoryArn: Swift.String? = nil,
        typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.directoryArn = directoryArn
        self.typedLinkSpecifier = typedLinkSpecifier
    }
}

struct UpdateLinkAttributesInputBody: Swift.Equatable {
    let typedLinkSpecifier: CloudDirectoryClientTypes.TypedLinkSpecifier?
    let attributeUpdates: [CloudDirectoryClientTypes.LinkAttributeUpdate]?
}

extension UpdateLinkAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case typedLinkSpecifier = "TypedLinkSpecifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typedLinkSpecifierDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.TypedLinkSpecifier.self, forKey: .typedLinkSpecifier)
        typedLinkSpecifier = typedLinkSpecifierDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.LinkAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.LinkAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.LinkAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension UpdateLinkAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLinkAttributesOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLinkAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateObjectAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case objectReference = "ObjectReference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for objectattributeupdate0 in attributeUpdates {
                try attributeUpdatesContainer.encode(objectattributeupdate0)
            }
        }
        if let objectReference = self.objectReference {
            try encodeContainer.encode(objectReference, forKey: .objectReference)
        }
    }
}

extension UpdateObjectAttributesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let directoryArn = directoryArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(directoryArn)))
        }
        return items
    }
}

extension UpdateObjectAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/object/update"
    }
}

public struct UpdateObjectAttributesInput: Swift.Equatable {
    /// The attributes update structure.
    /// This member is required.
    public var attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]?
    /// The Amazon Resource Name (ARN) that is associated with the [Directory] where the object resides. For more information, see [arns].
    /// This member is required.
    public var directoryArn: Swift.String?
    /// The reference that identifies the object.
    /// This member is required.
    public var objectReference: CloudDirectoryClientTypes.ObjectReference?

    public init(
        attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil,
        directoryArn: Swift.String? = nil,
        objectReference: CloudDirectoryClientTypes.ObjectReference? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.directoryArn = directoryArn
        self.objectReference = objectReference
    }
}

struct UpdateObjectAttributesInputBody: Swift.Equatable {
    let objectReference: CloudDirectoryClientTypes.ObjectReference?
    let attributeUpdates: [CloudDirectoryClientTypes.ObjectAttributeUpdate]?
}

extension UpdateObjectAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case objectReference = "ObjectReference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectReferenceDecoded = try containerValues.decodeIfPresent(CloudDirectoryClientTypes.ObjectReference.self, forKey: .objectReference)
        objectReference = objectReferenceDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.ObjectAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.ObjectAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.ObjectAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
    }
}

extension UpdateObjectAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateObjectAttributesOutputBody = try responseDecoder.decode(responseBody: data)
            self.objectIdentifier = output.objectIdentifier
        } else {
            self.objectIdentifier = nil
        }
    }
}

public struct UpdateObjectAttributesOutput: Swift.Equatable {
    /// The ObjectIdentifier of the updated object.
    public var objectIdentifier: Swift.String?

    public init(
        objectIdentifier: Swift.String? = nil
    )
    {
        self.objectIdentifier = objectIdentifier
    }
}

struct UpdateObjectAttributesOutputBody: Swift.Equatable {
    let objectIdentifier: Swift.String?
}

extension UpdateObjectAttributesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectIdentifier = "ObjectIdentifier"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectIdentifier)
        objectIdentifier = objectIdentifierDecoded
    }
}

enum UpdateObjectAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DirectoryNotEnabledException": return try await DirectoryNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LinkNameAlreadyInUseException": return try await LinkNameAlreadyInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateSchemaInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension UpdateSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/update"
    }
}

public struct UpdateSchemaInput: Swift.Equatable {
    /// The name of the schema.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the development schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct UpdateSchemaInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct UpdateSchemaOutput: Swift.Equatable {
    /// The ARN that is associated with the updated schema. For more information, see [arns].
    public var schemaArn: Swift.String?

    public init(
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct UpdateSchemaOutputBody: Swift.Equatable {
    let schemaArn: Swift.String?
}

extension UpdateSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn = "SchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

enum UpdateSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTypedLinkFacetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case identityAttributeOrder = "IdentityAttributeOrder"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdates = attributeUpdates {
            var attributeUpdatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeUpdates)
            for typedlinkfacetattributeupdate0 in attributeUpdates {
                try attributeUpdatesContainer.encode(typedlinkfacetattributeupdate0)
            }
        }
        if let identityAttributeOrder = identityAttributeOrder {
            var identityAttributeOrderContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityAttributeOrder)
            for attributename0 in identityAttributeOrder {
                try identityAttributeOrderContainer.encode(attributename0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateTypedLinkFacetInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let schemaArn = schemaArn {
            items.add(Header(name: "x-amz-data-partition", value: Swift.String(schemaArn)))
        }
        return items
    }
}

extension UpdateTypedLinkFacetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/typedlink/facet"
    }
}

public struct UpdateTypedLinkFacetInput: Swift.Equatable {
    /// Attributes update structure.
    /// This member is required.
    public var attributeUpdates: [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]?
    /// The order of identity attributes for the facet, from most significant to least significant. The ability to filter typed links considers the order that the attributes are defined on the typed link facet. When providing ranges to a typed link selection, any inexact ranges must be specified at the end. Any attributes that do not have a range specified are presumed to match the entire range. Filters are interpreted in the order of the attributes on the typed link facet, not the order in which they are supplied to any API calls. For more information about identity attributes, see [Typed Links](https://docs.aws.amazon.com/clouddirectory/latest/developerguide/directory_objects_links.html#directory_objects_links_typedlink).
    /// This member is required.
    public var identityAttributeOrder: [Swift.String]?
    /// The unique name of the typed link facet.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that is associated with the schema. For more information, see [arns].
    /// This member is required.
    public var schemaArn: Swift.String?

    public init(
        attributeUpdates: [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]? = nil,
        identityAttributeOrder: [Swift.String]? = nil,
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.attributeUpdates = attributeUpdates
        self.identityAttributeOrder = identityAttributeOrder
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct UpdateTypedLinkFacetInputBody: Swift.Equatable {
    let name: Swift.String?
    let attributeUpdates: [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]?
    let identityAttributeOrder: [Swift.String]?
}

extension UpdateTypedLinkFacetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdates = "AttributeUpdates"
        case identityAttributeOrder = "IdentityAttributeOrder"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let attributeUpdatesContainer = try containerValues.decodeIfPresent([CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate?].self, forKey: .attributeUpdates)
        var attributeUpdatesDecoded0:[CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]? = nil
        if let attributeUpdatesContainer = attributeUpdatesContainer {
            attributeUpdatesDecoded0 = [CloudDirectoryClientTypes.TypedLinkFacetAttributeUpdate]()
            for structure0 in attributeUpdatesContainer {
                if let structure0 = structure0 {
                    attributeUpdatesDecoded0?.append(structure0)
                }
            }
        }
        attributeUpdates = attributeUpdatesDecoded0
        let identityAttributeOrderContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identityAttributeOrder)
        var identityAttributeOrderDecoded0:[Swift.String]? = nil
        if let identityAttributeOrderContainer = identityAttributeOrderContainer {
            identityAttributeOrderDecoded0 = [Swift.String]()
            for string0 in identityAttributeOrderContainer {
                if let string0 = string0 {
                    identityAttributeOrderDecoded0?.append(string0)
                }
            }
        }
        identityAttributeOrder = identityAttributeOrderDecoded0
    }
}

extension UpdateTypedLinkFacetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateTypedLinkFacetOutput: Swift.Equatable {

    public init() { }
}

enum UpdateTypedLinkFacetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetNotFoundException": return try await FacetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FacetValidationException": return try await FacetValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidFacetUpdateException": return try await InvalidFacetUpdateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRuleException": return try await InvalidRuleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpgradeAppliedSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case dryRun = "DryRun"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryArn = self.directoryArn {
            try encodeContainer.encode(directoryArn, forKey: .directoryArn)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let publishedSchemaArn = self.publishedSchemaArn {
            try encodeContainer.encode(publishedSchemaArn, forKey: .publishedSchemaArn)
        }
    }
}

extension UpgradeAppliedSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/upgradeapplied"
    }
}

public struct UpgradeAppliedSchemaInput: Swift.Equatable {
    /// The ARN for the directory to which the upgraded schema will be applied.
    /// This member is required.
    public var directoryArn: Swift.String?
    /// Used for testing whether the major version schemas are backward compatible or not. If schema compatibility fails, an exception would be thrown else the call would succeed but no changes will be saved. This parameter is optional.
    public var dryRun: Swift.Bool?
    /// The revision of the published schema to upgrade the directory to.
    /// This member is required.
    public var publishedSchemaArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.dryRun = dryRun
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct UpgradeAppliedSchemaInputBody: Swift.Equatable {
    let publishedSchemaArn: Swift.String?
    let directoryArn: Swift.String?
    let dryRun: Swift.Bool?
}

extension UpgradeAppliedSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case dryRun = "DryRun"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension UpgradeAppliedSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpgradeAppliedSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.directoryArn = output.directoryArn
            self.upgradedSchemaArn = output.upgradedSchemaArn
        } else {
            self.directoryArn = nil
            self.upgradedSchemaArn = nil
        }
    }
}

public struct UpgradeAppliedSchemaOutput: Swift.Equatable {
    /// The ARN of the directory that is returned as part of the response.
    public var directoryArn: Swift.String?
    /// The ARN of the upgraded schema that is returned as part of the response.
    public var upgradedSchemaArn: Swift.String?

    public init(
        directoryArn: Swift.String? = nil,
        upgradedSchemaArn: Swift.String? = nil
    )
    {
        self.directoryArn = directoryArn
        self.upgradedSchemaArn = upgradedSchemaArn
    }
}

struct UpgradeAppliedSchemaOutputBody: Swift.Equatable {
    let upgradedSchemaArn: Swift.String?
    let directoryArn: Swift.String?
}

extension UpgradeAppliedSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryArn = "DirectoryArn"
        case upgradedSchemaArn = "UpgradedSchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upgradedSchemaArn)
        upgradedSchemaArn = upgradedSchemaArnDecoded
        let directoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryArn)
        directoryArn = directoryArnDecoded
    }
}

enum UpgradeAppliedSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleSchemaException": return try await IncompatibleSchemaException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAttachmentException": return try await InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SchemaAlreadyExistsException": return try await SchemaAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpgradePublishedSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developmentSchemaArn = "DevelopmentSchemaArn"
        case dryRun = "DryRun"
        case minorVersion = "MinorVersion"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developmentSchemaArn = self.developmentSchemaArn {
            try encodeContainer.encode(developmentSchemaArn, forKey: .developmentSchemaArn)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let minorVersion = self.minorVersion {
            try encodeContainer.encode(minorVersion, forKey: .minorVersion)
        }
        if let publishedSchemaArn = self.publishedSchemaArn {
            try encodeContainer.encode(publishedSchemaArn, forKey: .publishedSchemaArn)
        }
    }
}

extension UpgradePublishedSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/amazonclouddirectory/2017-01-11/schema/upgradepublished"
    }
}

public struct UpgradePublishedSchemaInput: Swift.Equatable {
    /// The ARN of the development schema with the changes used for the upgrade.
    /// This member is required.
    public var developmentSchemaArn: Swift.String?
    /// Used for testing whether the Development schema provided is backwards compatible, or not, with the publish schema provided by the user to be upgraded. If schema compatibility fails, an exception would be thrown else the call would succeed. This parameter is optional and defaults to false.
    public var dryRun: Swift.Bool?
    /// Identifies the minor version of the published schema that will be created. This parameter is NOT optional.
    /// This member is required.
    public var minorVersion: Swift.String?
    /// The ARN of the published schema to be upgraded.
    /// This member is required.
    public var publishedSchemaArn: Swift.String?

    public init(
        developmentSchemaArn: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        minorVersion: Swift.String? = nil,
        publishedSchemaArn: Swift.String? = nil
    )
    {
        self.developmentSchemaArn = developmentSchemaArn
        self.dryRun = dryRun
        self.minorVersion = minorVersion
        self.publishedSchemaArn = publishedSchemaArn
    }
}

struct UpgradePublishedSchemaInputBody: Swift.Equatable {
    let developmentSchemaArn: Swift.String?
    let publishedSchemaArn: Swift.String?
    let minorVersion: Swift.String?
    let dryRun: Swift.Bool?
}

extension UpgradePublishedSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developmentSchemaArn = "DevelopmentSchemaArn"
        case dryRun = "DryRun"
        case minorVersion = "MinorVersion"
        case publishedSchemaArn = "PublishedSchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let developmentSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developmentSchemaArn)
        developmentSchemaArn = developmentSchemaArnDecoded
        let publishedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publishedSchemaArn)
        publishedSchemaArn = publishedSchemaArnDecoded
        let minorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minorVersion)
        minorVersion = minorVersionDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension UpgradePublishedSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpgradePublishedSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.upgradedSchemaArn = output.upgradedSchemaArn
        } else {
            self.upgradedSchemaArn = nil
        }
    }
}

public struct UpgradePublishedSchemaOutput: Swift.Equatable {
    /// The ARN of the upgraded schema that is returned as part of the response.
    public var upgradedSchemaArn: Swift.String?

    public init(
        upgradedSchemaArn: Swift.String? = nil
    )
    {
        self.upgradedSchemaArn = upgradedSchemaArn
    }
}

struct UpgradePublishedSchemaOutputBody: Swift.Equatable {
    let upgradedSchemaArn: Swift.String?
}

extension UpgradePublishedSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case upgradedSchemaArn = "UpgradedSchemaArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradedSchemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upgradedSchemaArn)
        upgradedSchemaArn = upgradedSchemaArnDecoded
    }
}

enum UpgradePublishedSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncompatibleSchemaException": return try await IncompatibleSchemaException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArnException": return try await InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidAttachmentException": return try await InvalidAttachmentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RetryableConflictException": return try await RetryableConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that your request is malformed in some manner. See the exception message.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
