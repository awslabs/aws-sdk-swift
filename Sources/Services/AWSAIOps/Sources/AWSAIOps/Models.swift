//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem


public struct DeleteInvestigationGroupOutput: Swift.Sendable {

    public init() { }
}

/// You don't have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This operation couldn't be completed because of a conflict in resource states.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Access id denied for this operation, or this operation is not valid for the specified resource.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An internal server error occurred. You can try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified resource doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// This quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource that caused the quota exception.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the quota exception.
        public internal(set) var resourceType: Swift.String? = nil
        /// This name of the service associated with the error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was throttled because of quota limits. You can try again later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This operation or its parameters aren't formatted correctly.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension AIOpsClientTypes {

    /// This structure contains information about the cross-account configuration in the account.
    public struct CrossAccountConfiguration: Swift.Sendable {
        /// The ARN of an existing role which will be used to do investigations on your behalf.
        public var sourceRoleArn: Swift.String?

        public init(
            sourceRoleArn: Swift.String? = nil
        ) {
            self.sourceRoleArn = sourceRoleArn
        }
    }
}

extension AIOpsClientTypes {

    public enum EncryptionConfigurationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsOwnedKey
        case customerManagedKmsKey
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionConfigurationType] {
            return [
                .awsOwnedKey,
                .customerManagedKmsKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKey: return "AWS_OWNED_KEY"
            case .customerManagedKmsKey: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AIOpsClientTypes {

    /// Use this structure to specify a customer managed KMS key to use to encrypt investigation data.
    public struct EncryptionConfiguration: Swift.Sendable {
        /// If the investigation group uses a customer managed key for encryption, this field displays the ID of that key.
        public var kmsKeyId: Swift.String?
        /// Displays whether investigation data is encrypted by a customer managed key or an Amazon Web Services owned key.
        public var type: AIOpsClientTypes.EncryptionConfigurationType?

        public init(
            kmsKeyId: Swift.String? = nil,
            type: AIOpsClientTypes.EncryptionConfigurationType? = nil
        ) {
            self.kmsKeyId = kmsKeyId
            self.type = type
        }
    }
}

public struct CreateInvestigationGroupInput: Swift.Sendable {
    /// Use this structure to integrate CloudWatch investigations with chat applications. This structure is a string array. For the first string, specify the ARN of an Amazon SNS topic. For the array of strings, specify the ARNs of one or more chat applications configurations that you want to associate with that topic. For more information about these configuration ARNs, see [Getting started with Amazon Q in chat applications](https://docs.aws.amazon.com/chatbot/latest/adminguide/getting-started.html) and [Resource type defined by Amazon Web Services Chatbot](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awschatbot.html#awschatbot-resources-for-iam-policies).
    public var chatbotNotificationChannel: [Swift.String: [Swift.String]]?
    /// List of sourceRoleArn values that have been configured for cross-account access.
    public var crossAccountConfigurations: [AIOpsClientTypes.CrossAccountConfiguration]?
    /// Use this structure if you want to use a customer managed KMS key to encrypt your investigation data. If you omit this parameter, CloudWatch investigations will use an Amazon Web Services key to encrypt the data. For more information, see [Encryption of investigation data](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Investigations-Security.html#Investigations-KMS).
    public var encryptionConfiguration: AIOpsClientTypes.EncryptionConfiguration?
    /// Specify true to enable CloudWatch investigations to have access to change events that are recorded by CloudTrail. The default is true.
    public var isCloudTrailEventHistoryEnabled: Swift.Bool?
    /// Provides a name for the investigation group.
    /// This member is required.
    public var name: Swift.String?
    /// Specify how long that investigation data is kept. For more information, see [Operational investigation data retention](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Investigations-Retention.html). If you omit this parameter, the default of 90 days is used.
    public var retentionInDays: Swift.Int?
    /// Specify the ARN of the IAM role that CloudWatch investigations will use when it gathers investigation data. The permissions in this role determine which of your resources that CloudWatch investigations will have access to during investigations. For more information, see [How to control what data CloudWatch investigations has access to during investigations](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Investigations-Security.html#Investigations-Security-Data).
    /// This member is required.
    public var roleArn: Swift.String?
    /// Enter the existing custom tag keys for custom applications in your system. Resource tags help CloudWatch investigations narrow the search space when it is unable to discover definite relationships between resources. For example, to discover that an Amazon ECS service depends on an Amazon RDS database, CloudWatch investigations can discover this relationship using data sources such as X-Ray and CloudWatch Application Signals. However, if you haven't deployed these features, CloudWatch investigations will attempt to identify possible relationships. Tag boundaries can be used to narrow the resources that will be discovered by CloudWatch investigations in these cases. You don't need to enter tags created by myApplications or CloudFormation, because CloudWatch investigations can automatically detect those tags.
    public var tagKeyBoundaries: [Swift.String]?
    /// A list of key-value pairs to associate with the investigation group. You can associate as many as 50 tags with an investigation group. To be able to associate tags when you create the investigation group, you must have the cloudwatch:TagResource permission. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values.
    public var tags: [Swift.String: Swift.String]?

    public init(
        chatbotNotificationChannel: [Swift.String: [Swift.String]]? = nil,
        crossAccountConfigurations: [AIOpsClientTypes.CrossAccountConfiguration]? = nil,
        encryptionConfiguration: AIOpsClientTypes.EncryptionConfiguration? = nil,
        isCloudTrailEventHistoryEnabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        retentionInDays: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        tagKeyBoundaries: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.chatbotNotificationChannel = chatbotNotificationChannel
        self.crossAccountConfigurations = crossAccountConfigurations
        self.encryptionConfiguration = encryptionConfiguration
        self.isCloudTrailEventHistoryEnabled = isCloudTrailEventHistoryEnabled
        self.name = name
        self.retentionInDays = retentionInDays
        self.roleArn = roleArn
        self.tagKeyBoundaries = tagKeyBoundaries
        self.tags = tags
    }
}

public struct CreateInvestigationGroupOutput: Swift.Sendable {
    /// The ARN of the investigation group that you just created.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DeleteInvestigationGroupInput: Swift.Sendable {
    /// Specify either the name or the ARN of the investigation group that you want to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetInvestigationGroupInput: Swift.Sendable {
    /// Specify either the name or the ARN of the investigation group that you want to view. This is used to set the name of the investigation group.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetInvestigationGroupOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the investigation group.
    public var arn: Swift.String?
    /// This structure is a string array. The first string is the ARN of a Amazon SNS topic. The array of strings display the ARNs of chat applications configurations that are associated with that topic. For more information about these configuration ARNs, see [Getting started with Amazon Q in chat applications](https://docs.aws.amazon.com/chatbot/latest/adminguide/getting-started.html) and [Resource type defined by Amazon Web Services Chatbot](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awschatbot.html#awschatbot-resources-for-iam-policies).
    public var chatbotNotificationChannel: [Swift.String: [Swift.String]]?
    /// The date and time that the investigation group was created.
    public var createdAt: Swift.Int?
    /// The name of the user who created the investigation group.
    public var createdBy: Swift.String?
    /// Lists the AWSAccountId of the accounts configured for cross-account access and the results of the last scan performed on each account.
    public var crossAccountConfigurations: [AIOpsClientTypes.CrossAccountConfiguration]?
    /// Specifies the customer managed KMS key that the investigation group uses to encrypt data, if there is one. If not, the investigation group uses an Amazon Web Services key to encrypt the data.
    public var encryptionConfiguration: AIOpsClientTypes.EncryptionConfiguration?
    /// Specifies whether CloudWatch investigationshas access to change events that are recorded by CloudTrail.
    public var isCloudTrailEventHistoryEnabled: Swift.Bool?
    /// The date and time that the investigation group was most recently modified.
    public var lastModifiedAt: Swift.Int?
    /// The name of the user who created the investigation group.
    public var lastModifiedBy: Swift.String?
    /// The name of the investigation group.
    public var name: Swift.String?
    /// Specifies how long that investigation data is kept.
    public var retentionInDays: Swift.Int?
    /// The ARN of the IAM role that the investigation group uses for permissions to gather data.
    public var roleArn: Swift.String?
    /// Displays the custom tag keys for custom applications in your system that you have specified in the investigation group. Resource tags help CloudWatch investigations narrow the search space when it is unable to discover definite relationships between resources.
    public var tagKeyBoundaries: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        chatbotNotificationChannel: [Swift.String: [Swift.String]]? = nil,
        createdAt: Swift.Int? = nil,
        createdBy: Swift.String? = nil,
        crossAccountConfigurations: [AIOpsClientTypes.CrossAccountConfiguration]? = nil,
        encryptionConfiguration: AIOpsClientTypes.EncryptionConfiguration? = nil,
        isCloudTrailEventHistoryEnabled: Swift.Bool? = nil,
        lastModifiedAt: Swift.Int? = nil,
        lastModifiedBy: Swift.String? = nil,
        name: Swift.String? = nil,
        retentionInDays: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        tagKeyBoundaries: [Swift.String]? = nil
    ) {
        self.arn = arn
        self.chatbotNotificationChannel = chatbotNotificationChannel
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.crossAccountConfigurations = crossAccountConfigurations
        self.encryptionConfiguration = encryptionConfiguration
        self.isCloudTrailEventHistoryEnabled = isCloudTrailEventHistoryEnabled
        self.lastModifiedAt = lastModifiedAt
        self.lastModifiedBy = lastModifiedBy
        self.name = name
        self.retentionInDays = retentionInDays
        self.roleArn = roleArn
        self.tagKeyBoundaries = tagKeyBoundaries
    }
}

public struct ListInvestigationGroupsInput: Swift.Sendable {
    /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// Include this value, if it was returned by the previous operation, to get the next set of service operations.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListInvestigationGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInvestigationGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension AIOpsClientTypes {

    /// This structure contains information about one investigation group in the account.
    public struct ListInvestigationGroupsModel: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the investigation group.
        public var arn: Swift.String?
        /// The name of the investigation group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.name = name
        }
    }
}

public struct ListInvestigationGroupsOutput: Swift.Sendable {
    /// An array of structures, where each structure contains the information about one investigation group in the account.
    public var investigationGroups: [AIOpsClientTypes.ListInvestigationGroupsModel]?
    /// Include this value in your next use of this operation to get the next set of service operations.
    public var nextToken: Swift.String?

    public init(
        investigationGroups: [AIOpsClientTypes.ListInvestigationGroupsModel]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.investigationGroups = investigationGroups
        self.nextToken = nextToken
    }
}

extension ListInvestigationGroupsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInvestigationGroupsOutput(investigationGroups: \(Swift.String(describing: investigationGroups)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct UpdateInvestigationGroupInput: Swift.Sendable {
    /// Use this structure to integrate CloudWatch investigations with chat applications. This structure is a string array. For the first string, specify the ARN of an Amazon SNS topic. For the array of strings, specify the ARNs of one or more chat applications configurations that you want to associate with that topic. For more information about these configuration ARNs, see [Getting started with Amazon Q in chat applications](https://docs.aws.amazon.com/chatbot/latest/adminguide/getting-started.html) and [Resource type defined by Amazon Web Services Chatbot](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awschatbot.html#awschatbot-resources-for-iam-policies).
    public var chatbotNotificationChannel: [Swift.String: [Swift.String]]?
    /// Used to configure cross-account access for an investigation group. It allows the investigation group to access resources in other accounts.
    public var crossAccountConfigurations: [AIOpsClientTypes.CrossAccountConfiguration]?
    /// Use this structure if you want to use a customer managed KMS key to encrypt your investigation data. If you omit this parameter, CloudWatch investigations will use an Amazon Web Services key to encrypt the data. For more information, see [Encryption of investigation data](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Investigations-Security.html#Investigations-KMS).
    public var encryptionConfiguration: AIOpsClientTypes.EncryptionConfiguration?
    /// Specify either the name or the ARN of the investigation group that you want to modify.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specify true to enable CloudWatch investigations to have access to change events that are recorded by CloudTrail. The default is true.
    public var isCloudTrailEventHistoryEnabled: Swift.Bool?
    /// Specify this field if you want to change the IAM role that CloudWatch investigations will use when it gathers investigation data. To do so, specify the ARN of the new role. The permissions in this role determine which of your resources that CloudWatch investigations will have access to during investigations. For more information, see [How to control what data CloudWatch investigations has access to during investigations](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Investigations-Security.html#Investigations-Security-Data).
    public var roleArn: Swift.String?
    /// Enter the existing custom tag keys for custom applications in your system. Resource tags help CloudWatch investigations narrow the search space when it is unable to discover definite relationships between resources. For example, to discover that an Amazon ECS service depends on an Amazon RDS database, CloudWatch investigations can discover this relationship using data sources such as X-Ray and CloudWatch Application Signals. However, if you haven't deployed these features, CloudWatch investigations will attempt to identify possible relationships. Tag boundaries can be used to narrow the resources that will be discovered by CloudWatch investigations in these cases. You don't need to enter tags created by myApplications or CloudFormation, because CloudWatch investigations can automatically detect those tags.
    public var tagKeyBoundaries: [Swift.String]?

    public init(
        chatbotNotificationChannel: [Swift.String: [Swift.String]]? = nil,
        crossAccountConfigurations: [AIOpsClientTypes.CrossAccountConfiguration]? = nil,
        encryptionConfiguration: AIOpsClientTypes.EncryptionConfiguration? = nil,
        identifier: Swift.String? = nil,
        isCloudTrailEventHistoryEnabled: Swift.Bool? = nil,
        roleArn: Swift.String? = nil,
        tagKeyBoundaries: [Swift.String]? = nil
    ) {
        self.chatbotNotificationChannel = chatbotNotificationChannel
        self.crossAccountConfigurations = crossAccountConfigurations
        self.encryptionConfiguration = encryptionConfiguration
        self.identifier = identifier
        self.isCloudTrailEventHistoryEnabled = isCloudTrailEventHistoryEnabled
        self.roleArn = roleArn
        self.tagKeyBoundaries = tagKeyBoundaries
    }
}

public struct UpdateInvestigationGroupOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteInvestigationGroupPolicyInput: Swift.Sendable {
    /// Specify either the name or the ARN of the investigation group that you want to remove the policy from.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct DeleteInvestigationGroupPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct GetInvestigationGroupPolicyInput: Swift.Sendable {
    /// Specify either the name or the ARN of the investigation group that you want to view the policy of.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetInvestigationGroupPolicyOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the investigation group that you want to view the policy of.
    public var investigationGroupArn: Swift.String?
    /// The policy, in JSON format.
    public var policy: Swift.String?

    public init(
        investigationGroupArn: Swift.String? = nil,
        policy: Swift.String? = nil
    ) {
        self.investigationGroupArn = investigationGroupArn
        self.policy = policy
    }
}

public struct PutInvestigationGroupPolicyInput: Swift.Sendable {
    /// Specify either the name or the ARN of the investigation group that you want to assign the policy to.
    /// This member is required.
    public var identifier: Swift.String?
    /// The policy, in JSON format.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        policy: Swift.String? = nil
    ) {
        self.identifier = identifier
        self.policy = policy
    }
}

public struct PutInvestigationGroupPolicyOutput: Swift.Sendable {
    /// The ARN of the investigation group that will use this policy.
    public var investigationGroupArn: Swift.String?

    public init(
        investigationGroupArn: Swift.String? = nil
    ) {
        self.investigationGroupArn = investigationGroupArn
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the CloudWatch investigations resource that you want to view tags for. You can use the ListInvestigationGroups operation to find the ARNs of investigation groups. The ARN format for an investigation group is arn:aws:aiops:Region:account-id:investigation-group:investigation-group-id .
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tag keys and values associated with the resource you specified.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to apply the tags to. You can use the ListInvestigationGroups operation to find the ARNs of investigation groups.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove the tags from. You can use theListInvestigationGroups operation to find the ARNs of investigation groups.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateInvestigationGroupInput {

    static func urlPathProvider(_ value: CreateInvestigationGroupInput) -> Swift.String? {
        return "/investigationGroups"
    }
}

extension DeleteInvestigationGroupInput {

    static func urlPathProvider(_ value: DeleteInvestigationGroupInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/investigationGroups/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteInvestigationGroupPolicyInput {

    static func urlPathProvider(_ value: DeleteInvestigationGroupPolicyInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/investigationGroups/\(identifier.urlPercentEncoding())/policy"
    }
}

extension GetInvestigationGroupInput {

    static func urlPathProvider(_ value: GetInvestigationGroupInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/investigationGroups/\(identifier.urlPercentEncoding())"
    }
}

extension GetInvestigationGroupPolicyInput {

    static func urlPathProvider(_ value: GetInvestigationGroupPolicyInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/investigationGroups/\(identifier.urlPercentEncoding())/policy"
    }
}

extension ListInvestigationGroupsInput {

    static func urlPathProvider(_ value: ListInvestigationGroupsInput) -> Swift.String? {
        return "/investigationGroups"
    }
}

extension ListInvestigationGroupsInput {

    static func queryItemProvider(_ value: ListInvestigationGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutInvestigationGroupPolicyInput {

    static func urlPathProvider(_ value: PutInvestigationGroupPolicyInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/investigationGroups/\(identifier.urlPercentEncoding())/policy"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateInvestigationGroupInput {

    static func urlPathProvider(_ value: UpdateInvestigationGroupInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/investigationGroups/\(identifier.urlPercentEncoding())"
    }
}

extension CreateInvestigationGroupInput {

    static func write(value: CreateInvestigationGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chatbotNotificationChannel"].writeMap(value.chatbotNotificationChannel, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["crossAccountConfigurations"].writeList(value.crossAccountConfigurations, memberWritingClosure: AIOpsClientTypes.CrossAccountConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: AIOpsClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["isCloudTrailEventHistoryEnabled"].write(value.isCloudTrailEventHistoryEnabled)
        try writer["name"].write(value.name)
        try writer["retentionInDays"].write(value.retentionInDays)
        try writer["roleArn"].write(value.roleArn)
        try writer["tagKeyBoundaries"].writeList(value.tagKeyBoundaries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PutInvestigationGroupPolicyInput {

    static func write(value: PutInvestigationGroupPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateInvestigationGroupInput {

    static func write(value: UpdateInvestigationGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chatbotNotificationChannel"].writeMap(value.chatbotNotificationChannel, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["crossAccountConfigurations"].writeList(value.crossAccountConfigurations, memberWritingClosure: AIOpsClientTypes.CrossAccountConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: AIOpsClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["isCloudTrailEventHistoryEnabled"].write(value.isCloudTrailEventHistoryEnabled)
        try writer["roleArn"].write(value.roleArn)
        try writer["tagKeyBoundaries"].writeList(value.tagKeyBoundaries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateInvestigationGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInvestigationGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInvestigationGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension DeleteInvestigationGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInvestigationGroupOutput {
        return DeleteInvestigationGroupOutput()
    }
}

extension DeleteInvestigationGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInvestigationGroupPolicyOutput {
        return DeleteInvestigationGroupPolicyOutput()
    }
}

extension GetInvestigationGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInvestigationGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvestigationGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.chatbotNotificationChannel = try reader["chatbotNotificationChannel"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdAt = try reader["createdAt"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.crossAccountConfigurations = try reader["crossAccountConfigurations"].readListIfPresent(memberReadingClosure: AIOpsClientTypes.CrossAccountConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: AIOpsClientTypes.EncryptionConfiguration.read(from:))
        value.isCloudTrailEventHistoryEnabled = try reader["isCloudTrailEventHistoryEnabled"].readIfPresent()
        value.lastModifiedAt = try reader["lastModifiedAt"].readIfPresent()
        value.lastModifiedBy = try reader["lastModifiedBy"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.retentionInDays = try reader["retentionInDays"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.tagKeyBoundaries = try reader["tagKeyBoundaries"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetInvestigationGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInvestigationGroupPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvestigationGroupPolicyOutput()
        value.investigationGroupArn = try reader["investigationGroupArn"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        return value
    }
}

extension ListInvestigationGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvestigationGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvestigationGroupsOutput()
        value.investigationGroups = try reader["investigationGroups"].readListIfPresent(memberReadingClosure: AIOpsClientTypes.ListInvestigationGroupsModel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutInvestigationGroupPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutInvestigationGroupPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutInvestigationGroupPolicyOutput()
        value.investigationGroupArn = try reader["investigationGroupArn"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateInvestigationGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInvestigationGroupOutput {
        return UpdateInvestigationGroupOutput()
    }
}

func httpServiceError(baseError: AWSClientRuntime.RestJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
        case "ConflictException": return try ConflictException.makeError(baseError: baseError)
        case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

enum CreateInvestigationGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInvestigationGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInvestigationGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInvestigationGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInvestigationGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvestigationGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutInvestigationGroupPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInvestigationGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AIOpsClientTypes.EncryptionConfiguration {

    static func write(value: AIOpsClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AIOpsClientTypes.EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AIOpsClientTypes.EncryptionConfiguration()
        value.type = try reader["type"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension AIOpsClientTypes.CrossAccountConfiguration {

    static func write(value: AIOpsClientTypes.CrossAccountConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceRoleArn"].write(value.sourceRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AIOpsClientTypes.CrossAccountConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AIOpsClientTypes.CrossAccountConfiguration()
        value.sourceRoleArn = try reader["sourceRoleArn"].readIfPresent()
        return value
    }
}

extension AIOpsClientTypes.ListInvestigationGroupsModel {

    static func read(from reader: SmithyJSON.Reader) throws -> AIOpsClientTypes.ListInvestigationGroupsModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AIOpsClientTypes.ListInvestigationGroupsModel()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

public enum AIOpsClientTypes {}
