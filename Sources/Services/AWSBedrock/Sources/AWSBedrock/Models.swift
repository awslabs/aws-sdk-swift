//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Error occurred because of a conflict while performing an operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchDeleteEvaluationJobInput {
    /// An array of model evaluation job ARNs to be deleted.
    /// This member is required.
    public var jobIdentifiers: [Swift.String]?

    public init(
        jobIdentifiers: [Swift.String]? = nil
    )
    {
        self.jobIdentifiers = jobIdentifiers
    }
}

extension BatchDeleteEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteEvaluationJobInput(jobIdentifiers: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {
    /// A JSON array that provides the status of the model evaluation jobs being deleted.
    public struct BatchDeleteEvaluationJobError {
        /// A HTTP status code of the model evaluation job being deleted.
        /// This member is required.
        public var code: Swift.String?
        /// The ARN of the model evaluation job being deleted.
        /// This member is required.
        public var jobIdentifier: Swift.String?
        /// A status message about the model evaluation job deletion.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            jobIdentifier: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.jobIdentifier = jobIdentifier
            self.message = message
        }
    }

}

extension BedrockClientTypes.BatchDeleteEvaluationJobError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteEvaluationJobError(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), jobIdentifier: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum EvaluationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case deleting
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationJobStatus] {
            return [
                .completed,
                .deleting,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// An array of model evaluation jobs to be deleted, and their associated statuses.
    public struct BatchDeleteEvaluationJobItem {
        /// The ARN of model evaluation job to be deleted.
        /// This member is required.
        public var jobIdentifier: Swift.String?
        /// The status of the job's deletion.
        /// This member is required.
        public var jobStatus: BedrockClientTypes.EvaluationJobStatus?

        public init(
            jobIdentifier: Swift.String? = nil,
            jobStatus: BedrockClientTypes.EvaluationJobStatus? = nil
        )
        {
            self.jobIdentifier = jobIdentifier
            self.jobStatus = jobStatus
        }
    }

}

extension BedrockClientTypes.BatchDeleteEvaluationJobItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteEvaluationJobItem(jobStatus: \(Swift.String(describing: jobStatus)), jobIdentifier: \"CONTENT_REDACTED\")"}
}

public struct BatchDeleteEvaluationJobOutput {
    /// A JSON object containing the HTTP status codes and the ARNs of model evaluation jobs that failed to be deleted.
    /// This member is required.
    public var errors: [BedrockClientTypes.BatchDeleteEvaluationJobError]?
    /// The list of model evaluation jobs to be deleted.
    /// This member is required.
    public var evaluationJobs: [BedrockClientTypes.BatchDeleteEvaluationJobItem]?

    public init(
        errors: [BedrockClientTypes.BatchDeleteEvaluationJobError]? = nil,
        evaluationJobs: [BedrockClientTypes.BatchDeleteEvaluationJobItem]? = nil
    )
    {
        self.errors = errors
        self.evaluationJobs = evaluationJobs
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockClientTypes {
    /// The location in Amazon S3 where your prompt dataset is stored.
    public enum EvaluationDatasetLocation {
        /// The S3 URI of the S3 bucket specified in the job.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes {
    /// Used to specify the name of a built-in prompt dataset and optionally, the Amazon S3 bucket where a custom prompt dataset is saved.
    public struct EvaluationDataset {
        /// For custom prompt datasets, you must specify the location in Amazon S3 where the prompt dataset is saved.
        public var datasetLocation: BedrockClientTypes.EvaluationDatasetLocation?
        /// Used to specify supported built-in prompt datasets. Valid values are Builtin.Bold, Builtin.BoolQ, Builtin.NaturalQuestions, Builtin.Gigaword, Builtin.RealToxicityPrompts, Builtin.TriviaQA, Builtin.T-Rex, Builtin.WomensEcommerceClothingReviews and Builtin.Wikitext2.
        /// This member is required.
        public var name: Swift.String?

        public init(
            datasetLocation: BedrockClientTypes.EvaluationDatasetLocation? = nil,
            name: Swift.String? = nil
        )
        {
            self.datasetLocation = datasetLocation
            self.name = name
        }
    }

}

extension BedrockClientTypes.EvaluationDataset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationDataset(datasetLocation: \(Swift.String(describing: datasetLocation)), name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum EvaluationTaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case classification
        case custom
        case generation
        case questionAndAnswer
        case summarization
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationTaskType] {
            return [
                .classification,
                .custom,
                .generation,
                .questionAndAnswer,
                .summarization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .classification: return "Classification"
            case .custom: return "Custom"
            case .generation: return "Generation"
            case .questionAndAnswer: return "QuestionAndAnswer"
            case .summarization: return "Summarization"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// Defines the built-in prompt datasets, built-in metric names and custom metric names, and the task type.
    public struct EvaluationDatasetMetricConfig {
        /// Specifies the prompt dataset.
        /// This member is required.
        public var dataset: BedrockClientTypes.EvaluationDataset?
        /// The names of the metrics used. For automated model evaluation jobs valid values are "Builtin.Accuracy", "Builtin.Robustness", and "Builtin.Toxicity". In human-based model evaluation jobs the array of strings must match the name parameter specified in HumanEvaluationCustomMetric.
        /// This member is required.
        public var metricNames: [Swift.String]?
        /// The task type you want the model to carry out.
        /// This member is required.
        public var taskType: BedrockClientTypes.EvaluationTaskType?

        public init(
            dataset: BedrockClientTypes.EvaluationDataset? = nil,
            metricNames: [Swift.String]? = nil,
            taskType: BedrockClientTypes.EvaluationTaskType? = nil
        )
        {
            self.dataset = dataset
            self.metricNames = metricNames
            self.taskType = taskType
        }
    }

}

extension BedrockClientTypes.EvaluationDatasetMetricConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationDatasetMetricConfig(dataset: \(Swift.String(describing: dataset)), taskType: \(Swift.String(describing: taskType)), metricNames: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {
    /// Use to specify a automatic model evaluation job. The EvaluationDatasetMetricConfig object is used to specify the prompt datasets, task type, and metric names.
    public struct AutomatedEvaluationConfig {
        /// Specifies the required elements for an automatic model evaluation job.
        /// This member is required.
        public var datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]?

        public init(
            datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]? = nil
        )
        {
            self.datasetMetricConfigs = datasetMetricConfigs
        }
    }

}

extension BedrockClientTypes {
    /// In a model evaluation job that uses human workers you must define the name of the metric, and how you want that metric rated ratingMethod, and an optional description of the metric.
    public struct HumanEvaluationCustomMetric {
        /// An optional description of the metric. Use this parameter to provide more details about the metric.
        public var description: Swift.String?
        /// The name of the metric. Your human evaluators will see this name in the evaluation UI.
        /// This member is required.
        public var name: Swift.String?
        /// Choose how you want your human workers to evaluation your model. Valid values for rating methods are ThumbsUpDown, IndividualLikertScale,ComparisonLikertScale, ComparisonChoice, and ComparisonRank
        /// This member is required.
        public var ratingMethod: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ratingMethod: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.ratingMethod = ratingMethod
        }
    }

}

extension BedrockClientTypes.HumanEvaluationCustomMetric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanEvaluationCustomMetric(ratingMethod: \(Swift.String(describing: ratingMethod)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {
    /// Contains SageMakerFlowDefinition object. The object is used to specify the prompt dataset, task type, rating method and metric names.
    public struct HumanWorkflowConfig {
        /// The Amazon Resource Number (ARN) for the flow definition
        /// This member is required.
        public var flowDefinitionArn: Swift.String?
        /// Instructions for the flow definition
        public var instructions: Swift.String?

        public init(
            flowDefinitionArn: Swift.String? = nil,
            instructions: Swift.String? = nil
        )
        {
            self.flowDefinitionArn = flowDefinitionArn
            self.instructions = instructions
        }
    }

}

extension BedrockClientTypes.HumanWorkflowConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanWorkflowConfig(flowDefinitionArn: \(Swift.String(describing: flowDefinitionArn)), instructions: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {
    /// Specifies the custom metrics, how tasks will be rated, the flow definition ARN, and your custom prompt datasets. Model evaluation jobs use human workers only support the use of custom prompt datasets. To learn more about custom prompt datasets and the required format, see [Custom prompt datasets](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-prompt-datasets-custom.html). When you create custom metrics in HumanEvaluationCustomMetric you must specify the metric's name. The list of names specified in the HumanEvaluationCustomMetric array, must match the metricNames array of strings specified in EvaluationDatasetMetricConfig. For example, if in the HumanEvaluationCustomMetric array your specified the names "accuracy", "toxicity", "readability" as custom metrics then the metricNames array would need to look like the following ["accuracy", "toxicity", "readability"] in EvaluationDatasetMetricConfig.
    public struct HumanEvaluationConfig {
        /// A HumanEvaluationCustomMetric object. It contains the names the metrics, how the metrics are to be evaluated, an optional description.
        public var customMetrics: [BedrockClientTypes.HumanEvaluationCustomMetric]?
        /// Use to specify the metrics, task, and prompt dataset to be used in your model evaluation job.
        /// This member is required.
        public var datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]?
        /// The parameters of the human workflow.
        public var humanWorkflowConfig: BedrockClientTypes.HumanWorkflowConfig?

        public init(
            customMetrics: [BedrockClientTypes.HumanEvaluationCustomMetric]? = nil,
            datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]? = nil,
            humanWorkflowConfig: BedrockClientTypes.HumanWorkflowConfig? = nil
        )
        {
            self.customMetrics = customMetrics
            self.datasetMetricConfigs = datasetMetricConfigs
            self.humanWorkflowConfig = humanWorkflowConfig
        }
    }

}

extension BedrockClientTypes {
    /// Used to specify either a AutomatedEvaluationConfig or HumanEvaluationConfig object.
    public enum EvaluationConfig {
        /// Used to specify an automated model evaluation job. See AutomatedEvaluationConfig to view the required parameters.
        case automated(BedrockClientTypes.AutomatedEvaluationConfig)
        /// Used to specify a model evaluation job that uses human workers.See HumanEvaluationConfig to view the required parameters.
        case human(BedrockClientTypes.HumanEvaluationConfig)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes {
    /// Contains the ARN of the Amazon Bedrock models specified in your model evaluation job. Each Amazon Bedrock model supports different inferenceParams. To learn more about supported inference parameters for Amazon Bedrock models, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). The inferenceParams are specified using JSON. To successfully insert JSON as string make sure that all quotations are properly escaped. For example, "temperature":"0.25" key value pair would need to be formatted as \"temperature\":\"0.25\" to successfully accepted in the request.
    public struct EvaluationBedrockModel {
        /// Each Amazon Bedrock support different inference parameters that change how the model behaves during inference.
        /// This member is required.
        public var inferenceParams: Swift.String?
        /// The ARN of the Amazon Bedrock model specified.
        /// This member is required.
        public var modelIdentifier: Swift.String?

        public init(
            inferenceParams: Swift.String? = nil,
            modelIdentifier: Swift.String? = nil
        )
        {
            self.inferenceParams = inferenceParams
            self.modelIdentifier = modelIdentifier
        }
    }

}

extension BedrockClientTypes.EvaluationBedrockModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationBedrockModel(modelIdentifier: \(Swift.String(describing: modelIdentifier)), inferenceParams: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {
    /// Defines the models used in the model evaluation job.
    public enum EvaluationModelConfig {
        /// Defines the Amazon Bedrock model and inference parameters you want used.
        case bedrockmodel(BedrockClientTypes.EvaluationBedrockModel)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes {
    /// Used to define the models you want used in your model evaluation job. Automated model evaluation jobs support only a single model. In a human-based model evaluation job, your annotator can compare the responses for up to two different models.
    public enum EvaluationInferenceConfig {
        /// Used to specify the models.
        case models([BedrockClientTypes.EvaluationModelConfig])
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes {
    /// Definition of the key/value pair for a tag.
    public struct Tag {
        /// Key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// Value for the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension BedrockClientTypes {
    /// The Amazon S3 location where the results of your model evaluation job are saved.
    public struct EvaluationOutputDataConfig {
        /// The Amazon S3 URI where the results of model evaluation job are saved.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

public struct CreateEvaluationJobInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// Specify your customer managed key ARN that will be used to encrypt your model evaluation job.
    public var customerEncryptionKeyId: Swift.String?
    /// Specifies whether the model evaluation job is automatic or uses human worker.
    /// This member is required.
    public var evaluationConfig: BedrockClientTypes.EvaluationConfig?
    /// Specify the models you want to use in your model evaluation job. Automatic model evaluation jobs support a single model, and model evaluation job that use human workers support two models.
    /// This member is required.
    public var inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig?
    /// A description of the model evaluation job.
    public var jobDescription: Swift.String?
    /// The name of the model evaluation job. Model evaluation job names must unique with your AWS account, and your account's AWS region.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to the model evaluation job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// An object that defines where the results of model evaluation job will be saved in Amazon S3.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can assume to perform tasks on your behalf. The service role must have Amazon Bedrock as the service principal, and provide access to any Amazon S3 buckets specified in the EvaluationConfig object. To pass this role to Amazon Bedrock, the caller of this API must have the iam:PassRole permission. To learn more about the required permissions, see [Required permissions](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-security.html).
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        customerEncryptionKeyId: Swift.String? = nil,
        evaluationConfig: BedrockClientTypes.EvaluationConfig? = nil,
        inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig? = nil,
        jobDescription: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.customerEncryptionKeyId = customerEncryptionKeyId
        self.evaluationConfig = evaluationConfig
        self.inferenceConfig = inferenceConfig
        self.jobDescription = jobDescription
        self.jobName = jobName
        self.jobTags = jobTags
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
    }
}

extension CreateEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEvaluationJobInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), customerEncryptionKeyId: \(Swift.String(describing: customerEncryptionKeyId)), evaluationConfig: \(Swift.String(describing: evaluationConfig)), inferenceConfig: \(Swift.String(describing: inferenceConfig)), jobName: \(Swift.String(describing: jobName)), jobTags: \(Swift.String(describing: jobTags)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), jobDescription: \"CONTENT_REDACTED\")"}
}

public struct CreateEvaluationJobOutput {
    /// The ARN of the model evaluation job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct GetEvaluationJobInput {
    /// The Amazon Resource Name (ARN) of the model evaluation job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension GetEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvaluationJobInput(jobIdentifier: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum EvaluationJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automated
        case human
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationJobType] {
            return [
                .automated,
                .human
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automated: return "Automated"
            case .human: return "Human"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetEvaluationJobOutput {
    /// When the model evaluation job was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the customer managed key specified when the model evaluation job was created.
    public var customerEncryptionKeyId: Swift.String?
    /// Contains details about the type of model evaluation job, the metrics used, the task type selected, the datasets used, and any custom metrics you defined.
    /// This member is required.
    public var evaluationConfig: BedrockClientTypes.EvaluationConfig?
    /// An array of strings the specify why the model evaluation job has failed.
    public var failureMessages: [Swift.String]?
    /// Details about the models you specified in your model evaluation job.
    /// This member is required.
    public var inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig?
    /// The Amazon Resource Name (ARN) of the model evaluation job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The description of the model evaluation job.
    public var jobDescription: Swift.String?
    /// The name of the model evaluation job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The type of model evaluation job.
    /// This member is required.
    public var jobType: BedrockClientTypes.EvaluationJobType?
    /// When the model evaluation job was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// Amazon S3 location for where output data is saved.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the IAM service role used in the model evaluation job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the model evaluation job.
    /// This member is required.
    public var status: BedrockClientTypes.EvaluationJobStatus?

    public init(
        creationTime: Foundation.Date? = nil,
        customerEncryptionKeyId: Swift.String? = nil,
        evaluationConfig: BedrockClientTypes.EvaluationConfig? = nil,
        failureMessages: [Swift.String]? = nil,
        inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig? = nil,
        jobArn: Swift.String? = nil,
        jobDescription: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobType: BedrockClientTypes.EvaluationJobType? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.EvaluationJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.customerEncryptionKeyId = customerEncryptionKeyId
        self.evaluationConfig = evaluationConfig
        self.failureMessages = failureMessages
        self.inferenceConfig = inferenceConfig
        self.jobArn = jobArn
        self.jobDescription = jobDescription
        self.jobName = jobName
        self.jobType = jobType
        self.lastModifiedTime = lastModifiedTime
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.status = status
    }
}

extension GetEvaluationJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvaluationJobOutput(creationTime: \(Swift.String(describing: creationTime)), customerEncryptionKeyId: \(Swift.String(describing: customerEncryptionKeyId)), evaluationConfig: \(Swift.String(describing: evaluationConfig)), failureMessages: \(Swift.String(describing: failureMessages)), inferenceConfig: \(Swift.String(describing: inferenceConfig)), jobArn: \(Swift.String(describing: jobArn)), jobName: \(Swift.String(describing: jobName)), jobType: \(Swift.String(describing: jobType)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), jobDescription: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum SortJobsBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortJobsBy] {
            return [
                .creationTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListEvaluationJobsInput {
    /// A filter that includes model evaluation jobs created after the time specified.
    public var creationTimeAfter: Foundation.Date?
    /// A filter that includes model evaluation jobs created prior to the time specified.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// Query parameter string for model evaluation job names.
    public var nameContains: Swift.String?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?
    /// Allows you to sort model evaluation jobs by when they were created.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// How you want the order of jobs sorted.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Only return jobs where the status condition is met.
    public var statusEquals: BedrockClientTypes.EvaluationJobStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.EvaluationJobStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {
    /// A summary of the model evaluation job.
    public struct EvaluationSummary {
        /// When the model evaluation job was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// What task type was used in the model evaluation job.
        /// This member is required.
        public var evaluationTaskTypes: [BedrockClientTypes.EvaluationTaskType]?
        /// The Amazon Resource Name (ARN) of the model evaluation job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name of the model evaluation job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The type, either human or automatic, of model evaluation job.
        /// This member is required.
        public var jobType: BedrockClientTypes.EvaluationJobType?
        /// The Amazon Resource Names (ARNs) of the model(s) used in the model evaluation job.
        /// This member is required.
        public var modelIdentifiers: [Swift.String]?
        /// The current status of the model evaluation job.
        /// This member is required.
        public var status: BedrockClientTypes.EvaluationJobStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            evaluationTaskTypes: [BedrockClientTypes.EvaluationTaskType]? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobType: BedrockClientTypes.EvaluationJobType? = nil,
            modelIdentifiers: [Swift.String]? = nil,
            status: BedrockClientTypes.EvaluationJobStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.evaluationTaskTypes = evaluationTaskTypes
            self.jobArn = jobArn
            self.jobName = jobName
            self.jobType = jobType
            self.modelIdentifiers = modelIdentifiers
            self.status = status
        }
    }

}

public struct ListEvaluationJobsOutput {
    /// A summary of the model evaluation jobs.
    public var jobSummaries: [BedrockClientTypes.EvaluationSummary]?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [BedrockClientTypes.EvaluationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

public struct StopEvaluationJobInput {
    /// The ARN of the model evaluation job you want to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension StopEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopEvaluationJobInput(jobIdentifier: \"CONTENT_REDACTED\")"}
}

public struct StopEvaluationJobOutput {

    public init() { }
}

/// The request contains more tags than can be associated with a resource (50 tags per resource). The maximum number of tags includes both existing tags and those included in your current request.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource with too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension BedrockClientTypes {

    public enum GuardrailFilterStrength: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailFilterStrength] {
            return [
                .high,
                .low,
                .medium,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailContentFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hate
        case insults
        case misconduct
        case promptAttack
        case sexual
        case violence
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterType] {
            return [
                .hate,
                .insults,
                .misconduct,
                .promptAttack,
                .sexual,
                .violence
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hate: return "HATE"
            case .insults: return "INSULTS"
            case .misconduct: return "MISCONDUCT"
            case .promptAttack: return "PROMPT_ATTACK"
            case .sexual: return "SEXUAL"
            case .violence: return "VIOLENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// Contains filter strengths for harmful content. Guardrails support the following content filters to detect and filter harmful user inputs and FM-generated outputs.
    ///
    /// * Hate – Describes language or a statement that discriminates, criticizes, insults, denounces, or dehumanizes a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
    ///
    /// * Insults – Describes language or a statement that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
    ///
    /// * Sexual – Describes language or a statement that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
    ///
    /// * Violence – Describes language or a statement that includes glorification of or threats to inflict physical pain, hurt, or injury toward a person, group or thing.
    ///
    ///
    /// Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as Hate with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as Hate with HIGH confidence, Insults with LOW confidence, Sexual with NONE confidence, and Violence with MEDIUM confidence. For more information, see [Guardrails content filters](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-filters.html).
    public struct GuardrailContentFilterConfig {
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var inputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var outputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The harmful category that the content filter is applied to.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContentFilterType?

        public init(
            inputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            outputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            type: BedrockClientTypes.GuardrailContentFilterType? = nil
        )
        {
            self.inputStrength = inputStrength
            self.outputStrength = outputStrength
            self.type = type
        }
    }

}

extension BedrockClientTypes {
    /// Contains details about how to handle harmful content.
    public struct GuardrailContentPolicyConfig {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        /// This member is required.
        public var filtersConfig: [BedrockClientTypes.GuardrailContentFilterConfig]?

        public init(
            filtersConfig: [BedrockClientTypes.GuardrailContentFilterConfig]? = nil
        )
        {
            self.filtersConfig = filtersConfig
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailContextualGroundingFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case grounding
        case relevance
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContextualGroundingFilterType] {
            return [
                .grounding,
                .relevance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grounding: return "GROUNDING"
            case .relevance: return "RELEVANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// The filter configuration details for the guardrails contextual grounding filter.
    public struct GuardrailContextualGroundingFilterConfig {
        /// The threshold details for the guardrails contextual grounding filter.
        /// This member is required.
        public var threshold: Swift.Double?
        /// The filter details for the guardrails contextual grounding filter.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContextualGroundingFilterType?

        public init(
            threshold: Swift.Double? = nil,
            type: BedrockClientTypes.GuardrailContextualGroundingFilterType? = nil
        )
        {
            self.threshold = threshold
            self.type = type
        }
    }

}

extension BedrockClientTypes {
    /// The policy configuration details for the guardrails contextual grounding policy.
    public struct GuardrailContextualGroundingPolicyConfig {
        /// The filter configuration details for the guardrails contextual grounding policy.
        /// This member is required.
        public var filtersConfig: [BedrockClientTypes.GuardrailContextualGroundingFilterConfig]?

        public init(
            filtersConfig: [BedrockClientTypes.GuardrailContextualGroundingFilterConfig]? = nil
        )
        {
            self.filtersConfig = filtersConfig
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailSensitiveInformationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymize
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailSensitiveInformationAction] {
            return [
                .anonymize,
                .block
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymize: return "ANONYMIZE"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailPiiEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case age
        case awsAccessKey
        case awsSecretKey
        case caHealthNumber
        case caSocialInsuranceNumber
        case creditDebitCardCvv
        case creditDebitCardExpiry
        case creditDebitCardNumber
        case driverId
        case email
        case internationalBankAccountNumber
        case ipAddress
        case licensePlate
        case macAddress
        case name
        case password
        case phone
        case pin
        case swiftCode
        case ukNationalHealthServiceNumber
        case ukNationalInsuranceNumber
        case ukUniqueTaxpayerReferenceNumber
        case url
        case username
        case usBankAccountNumber
        case usBankRoutingNumber
        case usIndividualTaxIdentificationNumber
        case usPassportNumber
        case usSocialSecurityNumber
        case vehicleIdentificationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailPiiEntityType] {
            return [
                .address,
                .age,
                .awsAccessKey,
                .awsSecretKey,
                .caHealthNumber,
                .caSocialInsuranceNumber,
                .creditDebitCardCvv,
                .creditDebitCardExpiry,
                .creditDebitCardNumber,
                .driverId,
                .email,
                .internationalBankAccountNumber,
                .ipAddress,
                .licensePlate,
                .macAddress,
                .name,
                .password,
                .phone,
                .pin,
                .swiftCode,
                .ukNationalHealthServiceNumber,
                .ukNationalInsuranceNumber,
                .ukUniqueTaxpayerReferenceNumber,
                .url,
                .username,
                .usBankAccountNumber,
                .usBankRoutingNumber,
                .usIndividualTaxIdentificationNumber,
                .usPassportNumber,
                .usSocialSecurityNumber,
                .vehicleIdentificationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .awsAccessKey: return "AWS_ACCESS_KEY"
            case .awsSecretKey: return "AWS_SECRET_KEY"
            case .caHealthNumber: return "CA_HEALTH_NUMBER"
            case .caSocialInsuranceNumber: return "CA_SOCIAL_INSURANCE_NUMBER"
            case .creditDebitCardCvv: return "CREDIT_DEBIT_CARD_CVV"
            case .creditDebitCardExpiry: return "CREDIT_DEBIT_CARD_EXPIRY"
            case .creditDebitCardNumber: return "CREDIT_DEBIT_CARD_NUMBER"
            case .driverId: return "DRIVER_ID"
            case .email: return "EMAIL"
            case .internationalBankAccountNumber: return "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
            case .ipAddress: return "IP_ADDRESS"
            case .licensePlate: return "LICENSE_PLATE"
            case .macAddress: return "MAC_ADDRESS"
            case .name: return "NAME"
            case .password: return "PASSWORD"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .swiftCode: return "SWIFT_CODE"
            case .ukNationalHealthServiceNumber: return "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
            case .ukNationalInsuranceNumber: return "UK_NATIONAL_INSURANCE_NUMBER"
            case .ukUniqueTaxpayerReferenceNumber: return "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
            case .url: return "URL"
            case .username: return "USERNAME"
            case .usBankAccountNumber: return "US_BANK_ACCOUNT_NUMBER"
            case .usBankRoutingNumber: return "US_BANK_ROUTING_NUMBER"
            case .usIndividualTaxIdentificationNumber: return "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            case .usPassportNumber: return "US_PASSPORT_NUMBER"
            case .usSocialSecurityNumber: return "US_SOCIAL_SECURITY_NUMBER"
            case .vehicleIdentificationNumber: return "VEHICLE_IDENTIFICATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// The PII entity to configure for the guardrail.
    public struct GuardrailPiiEntityConfig {
        /// Configure guardrail action when the PII entity is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Configure guardrail type when the PII entity is detected. The following PIIs are used to block or mask sensitive information:
        ///
        /// * General
        ///
        /// * ADDRESS A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
        ///
        /// * AGE An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guarrails recognizes "40 years" as an age.
        ///
        /// * NAME An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
        ///
        /// * EMAIL An email address, such as marymajor@email.com.
        ///
        /// * PHONE A phone number. This entity type also includes fax and pager numbers.
        ///
        /// * USERNAME A user name that identifies an account, such as a login name, screen name, nick name, or handle.
        ///
        /// * PASSWORD An alphanumeric string that is used as a password, such as "*very20special#pass*".
        ///
        /// * DRIVER_ID The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
        ///
        /// * LICENSE_PLATE A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
        ///
        /// * VEHICLE_IDENTIFICATION_NUMBER A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the ISO 3779 specification. Each country has specific codes and formats for VINs.
        ///
        ///
        ///
        ///
        /// * Finance
        ///
        /// * REDIT_DEBIT_CARD_CVV A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
        ///
        /// * CREDIT_DEBIT_CARD_EXPIRY The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as month/year or MM/YY. Guardrails recognizes expiration dates such as 01/21, 01/2021, and Jan 2021.
        ///
        /// * CREDIT_DEBIT_CARD_NUMBER The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
        ///
        /// * PIN A four-digit personal identification number (PIN) with which you can access your bank account.
        ///
        /// * INTERNATIONAL_BANK_ACCOUNT_NUMBER An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://www.iban.com/structure).
        ///
        /// * SWIFT_CODE A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers. SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
        ///
        ///
        ///
        ///
        /// * IT
        ///
        /// * IP_ADDRESS An IPv4 address, such as 198.51.100.0.
        ///
        /// * MAC_ADDRESS A media access control (MAC) address is a unique identifier assigned to a network interface controller (NIC).
        ///
        /// * URL A web address, such as www.example.com.
        ///
        /// * AWS_ACCESS_KEY A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.
        ///
        /// * AWS_SECRET_KEY A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.
        ///
        ///
        ///
        ///
        /// * USA specific
        ///
        /// * US_BANK_ACCOUNT_NUMBER A US bank account number, which is typically 10 to 12 digits long.
        ///
        /// * US_BANK_ROUTING_NUMBER A US bank account routing number. These are typically nine digits long,
        ///
        /// * US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
        ///
        /// * US_PASSPORT_NUMBER A US passport number. Passport numbers range from six to nine alphanumeric characters.
        ///
        /// * US_SOCIAL_SECURITY_NUMBER A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
        ///
        ///
        ///
        ///
        /// * Canada specific
        ///
        /// * CA_HEALTH_NUMBER A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
        ///
        /// * CA_SOCIAL_INSURANCE_NUMBER A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits. The SIN is formatted as three groups of three digits, such as 123-456-789. A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://www.wikipedia.org/wiki/Luhn_algorithm).
        ///
        ///
        ///
        ///
        /// * UK Specific
        ///
        /// * UK_NATIONAL_HEALTH_SERVICE_NUMBER A UK National Health Service Number is a 10-17 digit number, such as 485 777 3456. The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
        ///
        /// * UK_NATIONAL_INSURANCE_NUMBER A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system. The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
        ///
        /// * UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
        ///
        ///
        ///
        ///
        /// * Custom
        ///
        /// * Regex filter - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            type: BedrockClientTypes.GuardrailPiiEntityType? = nil
        )
        {
            self.action = action
            self.type = type
        }
    }

}

extension BedrockClientTypes {
    /// The regular expression to configure for the guardrail.
    public struct GuardrailRegexConfig {
        /// The guardrail action to configure when matching regular expression is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The description of the regular expression to configure for the guardrail.
        public var description: Swift.String?
        /// The name of the regular expression to configure for the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The regular expression pattern to configure for the guardrail.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            pattern: Swift.String? = nil
        )
        {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }
    }

}

extension BedrockClientTypes {
    /// Contains details about PII entities and regular expressions to configure for the guardrail.
    public struct GuardrailSensitiveInformationPolicyConfig {
        /// A list of PII entities to configure to the guardrail.
        public var piiEntitiesConfig: [BedrockClientTypes.GuardrailPiiEntityConfig]?
        /// A list of regular expressions to configure to the guardrail.
        public var regexesConfig: [BedrockClientTypes.GuardrailRegexConfig]?

        public init(
            piiEntitiesConfig: [BedrockClientTypes.GuardrailPiiEntityConfig]? = nil,
            regexesConfig: [BedrockClientTypes.GuardrailRegexConfig]? = nil
        )
        {
            self.piiEntitiesConfig = piiEntitiesConfig
            self.regexesConfig = regexesConfig
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailTopicType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicType] {
            return [
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// Details about topics for the guardrail to identify and deny.
    public struct GuardrailTopicConfig {
        /// A definition of the topic to deny.
        /// This member is required.
        public var definition: Swift.String?
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public var examples: [Swift.String]?
        /// The name of the topic to deny.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies to deny the topic.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailTopicType?

        public init(
            definition: Swift.String? = nil,
            examples: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: BedrockClientTypes.GuardrailTopicType? = nil
        )
        {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }
    }

}

extension BedrockClientTypes.GuardrailTopicConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopicConfig(type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", examples: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {
    /// Contains details about topics that the guardrail should identify and deny.
    public struct GuardrailTopicPolicyConfig {
        /// A list of policies related to topics that the guardrail should deny.
        /// This member is required.
        public var topicsConfig: [BedrockClientTypes.GuardrailTopicConfig]?

        public init(
            topicsConfig: [BedrockClientTypes.GuardrailTopicConfig]? = nil
        )
        {
            self.topicsConfig = topicsConfig
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailManagedWordsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profanity
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailManagedWordsType] {
            return [
                .profanity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profanity: return "PROFANITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// The managed word list to configure for the guardrail.
    public struct GuardrailManagedWordsConfig {
        /// The managed word type to configure for the guardrail.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailManagedWordsType?

        public init(
            type: BedrockClientTypes.GuardrailManagedWordsType? = nil
        )
        {
            self.type = type
        }
    }

}

extension BedrockClientTypes {
    /// A word to configure for the guardrail.
    public struct GuardrailWordConfig {
        /// Text of the word configured for the guardrail to block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockClientTypes {
    /// Contains details about the word policy to configured for the guardrail.
    public struct GuardrailWordPolicyConfig {
        /// A list of managed words to configure for the guardrail.
        public var managedWordListsConfig: [BedrockClientTypes.GuardrailManagedWordsConfig]?
        /// A list of words to configure for the guardrail.
        public var wordsConfig: [BedrockClientTypes.GuardrailWordConfig]?

        public init(
            managedWordListsConfig: [BedrockClientTypes.GuardrailManagedWordsConfig]? = nil,
            wordsConfig: [BedrockClientTypes.GuardrailWordConfig]? = nil
        )
        {
            self.managedWordListsConfig = managedWordListsConfig
            self.wordsConfig = wordsConfig
        }
    }

}

public struct CreateGuardrailInput {
    /// The message to return when the guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// The content filter policies to configure for the guardrail.
    public var contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig?
    /// The contextual grounding policy configuration used to create a guardrail.
    public var contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig?
    /// A description of the guardrail.
    public var description: Swift.String?
    /// The ARN of the KMS key that you use to encrypt the guardrail.
    public var kmsKeyId: Swift.String?
    /// The name to give the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy to configure for the guardrail.
    public var sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?
    /// The tags that you want to attach to the guardrail.
    public var tags: [BedrockClientTypes.Tag]?
    /// The topic policies to configure for the guardrail.
    public var topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig?
    /// The word policy you configure for the guardrail.
    public var wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig?

    public init(
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig? = nil,
        contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig? = nil,
        tags: [BedrockClientTypes.Tag]? = nil,
        topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig? = nil,
        wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig? = nil
    )
    {
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.clientRequestToken = clientRequestToken
        self.contentPolicyConfig = contentPolicyConfig
        self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.tags = tags
        self.topicPolicyConfig = topicPolicyConfig
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension CreateGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGuardrailInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), contextualGroundingPolicyConfig: \(Swift.String(describing: contextualGroundingPolicyConfig)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), tags: \(Swift.String(describing: tags)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateGuardrailOutput {
    /// The time at which the guardrail was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ARN of the guardrail.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail that was created.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The version of the guardrail that was created. This value will always be DRAFT.
    /// This member is required.
    public var version: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.version = version
    }
}

public struct CreateGuardrailVersionInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// A description of the guardrail version.
    public var description: Swift.String?
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.guardrailIdentifier = guardrailIdentifier
    }
}

extension CreateGuardrailVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGuardrailVersionInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateGuardrailVersionOutput {
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The number of the version of the guardrail.
    /// This member is required.
    public var version: Swift.String?

    public init(
        guardrailId: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.guardrailId = guardrailId
        self.version = version
    }
}

public struct DeleteGuardrailInput {
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The version of the guardrail.
    public var guardrailVersion: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil
    )
    {
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
    }
}

public struct DeleteGuardrailOutput {

    public init() { }
}

public struct GetGuardrailInput {
    /// The unique identifier of the guardrail for which to get details. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The version of the guardrail for which to get details. If you don't specify a version, the response returns details for the DRAFT version.
    public var guardrailVersion: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil
    )
    {
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
    }
}

extension BedrockClientTypes {
    /// Contains filter strengths for harmful content. Guardrails support the following content filters to detect and filter harmful user inputs and FM-generated outputs.
    ///
    /// * Hate – Describes language or a statement that discriminates, criticizes, insults, denounces, or dehumanizes a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
    ///
    /// * Insults – Describes language or a statement that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
    ///
    /// * Sexual – Describes language or a statement that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
    ///
    /// * Violence – Describes language or a statement that includes glorification of or threats to inflict physical pain, hurt, or injury toward a person, group or thing.
    ///
    ///
    /// Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as Hate with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as Hate with HIGH confidence, Insults with LOW confidence, Sexual with NONE confidence, and Violence with MEDIUM confidence. For more information, see [Guardrails content filters](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-filters.html). This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailContentFilter {
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var inputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var outputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The harmful category that the content filter is applied to.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContentFilterType?

        public init(
            inputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            outputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            type: BedrockClientTypes.GuardrailContentFilterType? = nil
        )
        {
            self.inputStrength = inputStrength
            self.outputStrength = outputStrength
            self.type = type
        }
    }

}

extension BedrockClientTypes {
    /// Contains details about how to handle harmful content. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailContentPolicy {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        public var filters: [BedrockClientTypes.GuardrailContentFilter]?

        public init(
            filters: [BedrockClientTypes.GuardrailContentFilter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension BedrockClientTypes {
    /// The details for the guardrails contextual grounding filter.
    public struct GuardrailContextualGroundingFilter {
        /// The threshold details for the guardrails contextual grounding filter.
        /// This member is required.
        public var threshold: Swift.Double?
        /// The filter type details for the guardrails contextual grounding filter.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContextualGroundingFilterType?

        public init(
            threshold: Swift.Double? = nil,
            type: BedrockClientTypes.GuardrailContextualGroundingFilterType? = nil
        )
        {
            self.threshold = threshold
            self.type = type
        }
    }

}

extension BedrockClientTypes {
    /// The details for the guardrails contextual grounding policy.
    public struct GuardrailContextualGroundingPolicy {
        /// The filter details for the guardrails contextual grounding policy.
        /// This member is required.
        public var filters: [BedrockClientTypes.GuardrailContextualGroundingFilter]?

        public init(
            filters: [BedrockClientTypes.GuardrailContextualGroundingFilter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

extension BedrockClientTypes {
    /// The PII entity configured for the guardrail.
    public struct GuardrailPiiEntity {
        /// The configured guardrail action when PII entity is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The type of PII entity. For exampvle, Social Security Number.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            type: BedrockClientTypes.GuardrailPiiEntityType? = nil
        )
        {
            self.action = action
            self.type = type
        }
    }

}

extension BedrockClientTypes {
    /// The regular expression configured for the guardrail.
    public struct GuardrailRegex {
        /// The action taken when a match to the regular expression is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The description of the regular expression for the guardrail.
        public var description: Swift.String?
        /// The name of the regular expression for the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The pattern of the regular expression configured for the guardrail.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            pattern: Swift.String? = nil
        )
        {
            self.action = action
            self.description = description
            self.name = name
            self.pattern = pattern
        }
    }

}

extension BedrockClientTypes {
    /// Contains details about PII entities and regular expressions configured for the guardrail.
    public struct GuardrailSensitiveInformationPolicy {
        /// The list of PII entities configured for the guardrail.
        public var piiEntities: [BedrockClientTypes.GuardrailPiiEntity]?
        /// The list of regular expressions configured for the guardrail.
        public var regexes: [BedrockClientTypes.GuardrailRegex]?

        public init(
            piiEntities: [BedrockClientTypes.GuardrailPiiEntity]? = nil,
            regexes: [BedrockClientTypes.GuardrailRegex]? = nil
        )
        {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }
    }

}

extension BedrockClientTypes {

    public enum GuardrailStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case ready
        case updating
        case versioning
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .ready,
                .updating,
                .versioning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .ready: return "READY"
            case .updating: return "UPDATING"
            case .versioning: return "VERSIONING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// Details about topics for the guardrail to identify and deny. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailTopic {
        /// A definition of the topic to deny.
        /// This member is required.
        public var definition: Swift.String?
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public var examples: [Swift.String]?
        /// The name of the topic to deny.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies to deny the topic.
        public var type: BedrockClientTypes.GuardrailTopicType?

        public init(
            definition: Swift.String? = nil,
            examples: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: BedrockClientTypes.GuardrailTopicType? = nil
        )
        {
            self.definition = definition
            self.examples = examples
            self.name = name
            self.type = type
        }
    }

}

extension BedrockClientTypes.GuardrailTopic: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopic(type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", examples: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {
    /// Contains details about topics that the guardrail should identify and deny. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailTopicPolicy {
        /// A list of policies related to topics that the guardrail should deny.
        /// This member is required.
        public var topics: [BedrockClientTypes.GuardrailTopic]?

        public init(
            topics: [BedrockClientTypes.GuardrailTopic]? = nil
        )
        {
            self.topics = topics
        }
    }

}

extension BedrockClientTypes {
    /// The managed word list that was configured for the guardrail. (This is a list of words that are pre-defined and managed by guardrails only.)
    public struct GuardrailManagedWords {
        /// ManagedWords$type The managed word type that was configured for the guardrail. (For now, we only offer profanity word list)
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailManagedWordsType?

        public init(
            type: BedrockClientTypes.GuardrailManagedWordsType? = nil
        )
        {
            self.type = type
        }
    }

}

extension BedrockClientTypes {
    /// A word configured for the guardrail.
    public struct GuardrailWord {
        /// Text of the word configured for the guardrail to block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension BedrockClientTypes {
    /// Contains details about the word policy configured for the guardrail.
    public struct GuardrailWordPolicy {
        /// A list of managed words configured for the guardrail.
        public var managedWordLists: [BedrockClientTypes.GuardrailManagedWords]?
        /// A list of words configured for the guardrail.
        public var words: [BedrockClientTypes.GuardrailWord]?

        public init(
            managedWordLists: [BedrockClientTypes.GuardrailManagedWords]? = nil,
            words: [BedrockClientTypes.GuardrailWord]? = nil
        )
        {
            self.managedWordLists = managedWordLists
            self.words = words
        }
    }

}

public struct GetGuardrailOutput {
    /// The message that the guardrail returns when it blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message that the guardrail returns when it blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// The content policy that was configured for the guardrail.
    public var contentPolicy: BedrockClientTypes.GuardrailContentPolicy?
    /// The contextual grounding policy used in the guardrail.
    public var contextualGroundingPolicy: BedrockClientTypes.GuardrailContextualGroundingPolicy?
    /// The date and time at which the guardrail was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the guardrail.
    public var description: Swift.String?
    /// Appears if the status of the guardrail is FAILED. A list of recommendations to carry out before retrying the request.
    public var failureRecommendations: [Swift.String]?
    /// The ARN of the guardrail.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The ARN of the KMS key that encrypts the guardrail.
    public var kmsKeyArn: Swift.String?
    /// The name of the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy that was configured for the guardrail.
    public var sensitiveInformationPolicy: BedrockClientTypes.GuardrailSensitiveInformationPolicy?
    /// The status of the guardrail.
    /// This member is required.
    public var status: BedrockClientTypes.GuardrailStatus?
    /// Appears if the status is FAILED. A list of reasons for why the guardrail failed to be created, updated, versioned, or deleted.
    public var statusReasons: [Swift.String]?
    /// The topic policy that was configured for the guardrail.
    public var topicPolicy: BedrockClientTypes.GuardrailTopicPolicy?
    /// The date and time at which the guardrail was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version of the guardrail.
    /// This member is required.
    public var version: Swift.String?
    /// The word policy that was configured for the guardrail.
    public var wordPolicy: BedrockClientTypes.GuardrailWordPolicy?

    public init(
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        contentPolicy: BedrockClientTypes.GuardrailContentPolicy? = nil,
        contextualGroundingPolicy: BedrockClientTypes.GuardrailContextualGroundingPolicy? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        failureRecommendations: [Swift.String]? = nil,
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicy: BedrockClientTypes.GuardrailSensitiveInformationPolicy? = nil,
        status: BedrockClientTypes.GuardrailStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        topicPolicy: BedrockClientTypes.GuardrailTopicPolicy? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil,
        wordPolicy: BedrockClientTypes.GuardrailWordPolicy? = nil
    )
    {
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.contentPolicy = contentPolicy
        self.contextualGroundingPolicy = contextualGroundingPolicy
        self.createdAt = createdAt
        self.description = description
        self.failureRecommendations = failureRecommendations
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.sensitiveInformationPolicy = sensitiveInformationPolicy
        self.status = status
        self.statusReasons = statusReasons
        self.topicPolicy = topicPolicy
        self.updatedAt = updatedAt
        self.version = version
        self.wordPolicy = wordPolicy
    }
}

extension GetGuardrailOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGuardrailOutput(contentPolicy: \(Swift.String(describing: contentPolicy)), contextualGroundingPolicy: \(Swift.String(describing: contextualGroundingPolicy)), createdAt: \(Swift.String(describing: createdAt)), guardrailArn: \(Swift.String(describing: guardrailArn)), guardrailId: \(Swift.String(describing: guardrailId)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), sensitiveInformationPolicy: \(Swift.String(describing: sensitiveInformationPolicy)), status: \(Swift.String(describing: status)), topicPolicy: \(Swift.String(describing: topicPolicy)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), wordPolicy: \(Swift.String(describing: wordPolicy)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", failureRecommendations: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", statusReasons: \"CONTENT_REDACTED\")"}
}

public struct ListGuardrailsInput {
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    public var guardrailIdentifier: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
    public var nextToken: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.guardrailIdentifier = guardrailIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {
    /// Contains details about a guardrail. This data type is used in the following API operations:
    ///
    /// * [ListGuardrails response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListGuardrails.html#API_ListGuardrails_ResponseSyntax)
    public struct GuardrailSummary {
        /// The ARN of the guardrail.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time at which the guardrail was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A description of the guardrail.
        public var description: Swift.String?
        /// The unique identifier of the guardrail.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the guardrail.
        /// This member is required.
        public var status: BedrockClientTypes.GuardrailStatus?
        /// The date and time at which the guardrail was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The version of the guardrail.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockClientTypes.GuardrailStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }
    }

}

extension BedrockClientTypes.GuardrailSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListGuardrailsOutput {
    /// A list of objects, each of which contains details about a guardrail.
    /// This member is required.
    public var guardrails: [BedrockClientTypes.GuardrailSummary]?
    /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
    public var nextToken: Swift.String?

    public init(
        guardrails: [BedrockClientTypes.GuardrailSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.guardrails = guardrails
        self.nextToken = nextToken
    }
}

public struct UpdateGuardrailInput {
    /// The message to return when the guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// The content policy to configure for the guardrail.
    public var contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig?
    /// The contextual grounding policy configuration used to update a guardrail.
    public var contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig?
    /// A description of the guardrail.
    public var description: Swift.String?
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The ARN of the KMS key with which to encrypt the guardrail.
    public var kmsKeyId: Swift.String?
    /// A name for the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy to configure for the guardrail.
    public var sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?
    /// The topic policy to configure for the guardrail.
    public var topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig?
    /// The word policy to configure for the guardrail.
    public var wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig?

    public init(
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig? = nil,
        contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig? = nil,
        description: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig? = nil,
        topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig? = nil,
        wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig? = nil
    )
    {
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.contentPolicyConfig = contentPolicyConfig
        self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
        self.description = description
        self.guardrailIdentifier = guardrailIdentifier
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.topicPolicyConfig = topicPolicyConfig
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension UpdateGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGuardrailInput(contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), contextualGroundingPolicyConfig: \(Swift.String(describing: contextualGroundingPolicyConfig)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateGuardrailOutput {
    /// The ARN of the guardrail.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The date and time at which the guardrail was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version of the guardrail.
    /// This member is required.
    public var version: Swift.String?

    public init(
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil
    )
    {
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.updatedAt = updatedAt
        self.version = version
    }
}

public struct GetInferenceProfileInput {
    /// The unique identifier of the inference profile.
    /// This member is required.
    public var inferenceProfileIdentifier: Swift.String?

    public init(
        inferenceProfileIdentifier: Swift.String? = nil
    )
    {
        self.inferenceProfileIdentifier = inferenceProfileIdentifier
    }
}

extension BedrockClientTypes {
    /// Contains information about a model.
    public struct InferenceProfileModel {
        /// The Amazon Resource Name (ARN) of the model.
        public var modelArn: Swift.String?

        public init(
            modelArn: Swift.String? = nil
        )
        {
            self.modelArn = modelArn
        }
    }

}

extension BedrockClientTypes {

    public enum InferenceProfileStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceProfileStatus] {
            return [
                .active
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum InferenceProfileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case systemDefined
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceProfileType] {
            return [
                .systemDefined
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .systemDefined: return "SYSTEM_DEFINED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetInferenceProfileOutput {
    /// The time at which the inference profile was created.
    public var createdAt: Foundation.Date?
    /// The description of the inference profile.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the inference profile.
    /// This member is required.
    public var inferenceProfileArn: Swift.String?
    /// The unique identifier of the inference profile.
    /// This member is required.
    public var inferenceProfileId: Swift.String?
    /// The name of the inference profile.
    /// This member is required.
    public var inferenceProfileName: Swift.String?
    /// A list of information about each model in the inference profile.
    /// This member is required.
    public var models: [BedrockClientTypes.InferenceProfileModel]?
    /// The status of the inference profile. ACTIVE means that the inference profile is available to use.
    /// This member is required.
    public var status: BedrockClientTypes.InferenceProfileStatus?
    /// The type of the inference profile. SYSTEM_DEFINED means that the inference profile is defined by Amazon Bedrock.
    /// This member is required.
    public var type: BedrockClientTypes.InferenceProfileType?
    /// The time at which the inference profile was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        inferenceProfileArn: Swift.String? = nil,
        inferenceProfileId: Swift.String? = nil,
        inferenceProfileName: Swift.String? = nil,
        models: [BedrockClientTypes.InferenceProfileModel]? = nil,
        status: BedrockClientTypes.InferenceProfileStatus? = nil,
        type: BedrockClientTypes.InferenceProfileType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.inferenceProfileArn = inferenceProfileArn
        self.inferenceProfileId = inferenceProfileId
        self.inferenceProfileName = inferenceProfileName
        self.models = models
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

public struct ListInferenceProfilesInput {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {
    /// Contains information about an inference profile.
    public struct InferenceProfileSummary {
        /// The time at which the inference profile was created.
        public var createdAt: Foundation.Date?
        /// The description of the inference profile.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the inference profile.
        /// This member is required.
        public var inferenceProfileArn: Swift.String?
        /// The unique identifier of the inference profile.
        /// This member is required.
        public var inferenceProfileId: Swift.String?
        /// The name of the inference profile.
        /// This member is required.
        public var inferenceProfileName: Swift.String?
        /// A list of information about each model in the inference profile.
        /// This member is required.
        public var models: [BedrockClientTypes.InferenceProfileModel]?
        /// The status of the inference profile. ACTIVE means that the inference profile is available to use.
        /// This member is required.
        public var status: BedrockClientTypes.InferenceProfileStatus?
        /// The type of the inference profile. SYSTEM_DEFINED means that the inference profile is defined by Amazon Bedrock.
        /// This member is required.
        public var type: BedrockClientTypes.InferenceProfileType?
        /// The time at which the inference profile was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            inferenceProfileArn: Swift.String? = nil,
            inferenceProfileId: Swift.String? = nil,
            inferenceProfileName: Swift.String? = nil,
            models: [BedrockClientTypes.InferenceProfileModel]? = nil,
            status: BedrockClientTypes.InferenceProfileStatus? = nil,
            type: BedrockClientTypes.InferenceProfileType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.inferenceProfileArn = inferenceProfileArn
            self.inferenceProfileId = inferenceProfileId
            self.inferenceProfileName = inferenceProfileName
            self.models = models
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

public struct ListInferenceProfilesOutput {
    /// A list of information about each inference profile that you can use.
    public var inferenceProfileSummaries: [BedrockClientTypes.InferenceProfileSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        inferenceProfileSummaries: [BedrockClientTypes.InferenceProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inferenceProfileSummaries = inferenceProfileSummaries
        self.nextToken = nextToken
    }
}

public struct DeleteModelInvocationLoggingConfigurationInput {

    public init() { }
}

public struct DeleteModelInvocationLoggingConfigurationOutput {

    public init() { }
}

public struct GetModelInvocationLoggingConfigurationInput {

    public init() { }
}

extension BedrockClientTypes {
    /// S3 configuration for storing log data.
    public struct S3Config {
        /// S3 bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// S3 prefix.
        public var keyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            keyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
        }
    }

}

extension BedrockClientTypes {
    /// CloudWatch logging configuration.
    public struct CloudWatchConfig {
        /// S3 configuration for delivering a large amount of data.
        public var largeDataDeliveryS3Config: BedrockClientTypes.S3Config?
        /// The log group name.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The role Amazon Resource Name (ARN).
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            largeDataDeliveryS3Config: BedrockClientTypes.S3Config? = nil,
            logGroupName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.largeDataDeliveryS3Config = largeDataDeliveryS3Config
            self.logGroupName = logGroupName
            self.roleArn = roleArn
        }
    }

}

extension BedrockClientTypes {
    /// Configuration fields for invocation logging.
    public struct LoggingConfig {
        /// CloudWatch logging configuration.
        public var cloudWatchConfig: BedrockClientTypes.CloudWatchConfig?
        /// Set to include embeddings data in the log delivery.
        public var embeddingDataDeliveryEnabled: Swift.Bool?
        /// Set to include image data in the log delivery.
        public var imageDataDeliveryEnabled: Swift.Bool?
        /// S3 configuration for storing log data.
        public var s3Config: BedrockClientTypes.S3Config?
        /// Set to include text data in the log delivery.
        public var textDataDeliveryEnabled: Swift.Bool?

        public init(
            cloudWatchConfig: BedrockClientTypes.CloudWatchConfig? = nil,
            embeddingDataDeliveryEnabled: Swift.Bool? = nil,
            imageDataDeliveryEnabled: Swift.Bool? = nil,
            s3Config: BedrockClientTypes.S3Config? = nil,
            textDataDeliveryEnabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchConfig = cloudWatchConfig
            self.embeddingDataDeliveryEnabled = embeddingDataDeliveryEnabled
            self.imageDataDeliveryEnabled = imageDataDeliveryEnabled
            self.s3Config = s3Config
            self.textDataDeliveryEnabled = textDataDeliveryEnabled
        }
    }

}

public struct GetModelInvocationLoggingConfigurationOutput {
    /// The current configuration values.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    )
    {
        self.loggingConfig = loggingConfig
    }
}

public struct PutModelInvocationLoggingConfigurationInput {
    /// The logging configuration values to set.
    /// This member is required.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    )
    {
        self.loggingConfig = loggingConfig
    }
}

public struct PutModelInvocationLoggingConfigurationOutput {

    public init() { }
}

public struct CreateModelCopyJobInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The ARN of the KMS key that you use to encrypt the model copy.
    public var modelKmsKeyId: Swift.String?
    /// The Amazon Resource Name (ARN) of the model to be copied.
    /// This member is required.
    public var sourceModelArn: Swift.String?
    /// A name for the copied model.
    /// This member is required.
    public var targetModelName: Swift.String?
    /// Tags to associate with the target model. For more information, see [Tag resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var targetModelTags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        modelKmsKeyId: Swift.String? = nil,
        sourceModelArn: Swift.String? = nil,
        targetModelName: Swift.String? = nil,
        targetModelTags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.modelKmsKeyId = modelKmsKeyId
        self.sourceModelArn = sourceModelArn
        self.targetModelName = targetModelName
        self.targetModelTags = targetModelTags
    }
}

public struct CreateModelCopyJobOutput {
    /// The Amazon Resource Name (ARN) of the model copy job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct GetModelCopyJobInput {
    /// The Amazon Resource Name (ARN) of the model copy job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

extension BedrockClientTypes {

    public enum ModelCopyJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCopyJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelCopyJobOutput {
    /// The time at which the model copy job was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// An error message for why the model copy job failed.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the model copy job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The unique identifier of the account that the model being copied originated from.
    /// This member is required.
    public var sourceAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the original model being copied.
    /// This member is required.
    public var sourceModelArn: Swift.String?
    /// The name of the original model being copied.
    public var sourceModelName: Swift.String?
    /// The status of the model copy job.
    /// This member is required.
    public var status: BedrockClientTypes.ModelCopyJobStatus?
    /// The Amazon Resource Name (ARN) of the copied model.
    /// This member is required.
    public var targetModelArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key encrypting the copied model.
    public var targetModelKmsKeyArn: Swift.String?
    /// The name of the copied model.
    public var targetModelName: Swift.String?
    /// The tags associated with the copied model.
    public var targetModelTags: [BedrockClientTypes.Tag]?

    public init(
        creationTime: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        sourceAccountId: Swift.String? = nil,
        sourceModelArn: Swift.String? = nil,
        sourceModelName: Swift.String? = nil,
        status: BedrockClientTypes.ModelCopyJobStatus? = nil,
        targetModelArn: Swift.String? = nil,
        targetModelKmsKeyArn: Swift.String? = nil,
        targetModelName: Swift.String? = nil,
        targetModelTags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.creationTime = creationTime
        self.failureMessage = failureMessage
        self.jobArn = jobArn
        self.sourceAccountId = sourceAccountId
        self.sourceModelArn = sourceModelArn
        self.sourceModelName = sourceModelName
        self.status = status
        self.targetModelArn = targetModelArn
        self.targetModelKmsKeyArn = targetModelKmsKeyArn
        self.targetModelName = targetModelName
        self.targetModelTags = targetModelTags
    }
}

public struct ListModelCopyJobsInput {
    /// Filters for model copy jobs created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Filters for model copy jobs created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of model copy jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the results in ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Filters for model copy jobs in which the account that the source model belongs to is equal to the value that you specify.
    public var sourceAccountEquals: Swift.String?
    /// Filters for model copy jobs in which the Amazon Resource Name (ARN) of the source model to is equal to the value that you specify.
    public var sourceModelArnEquals: Swift.String?
    /// Filters for model copy jobs whose status matches the value that you specify.
    public var statusEquals: BedrockClientTypes.ModelCopyJobStatus?
    /// Filters for model copy jobs in which the name of the copied model contains the string that you specify.
    public var targetModelNameContains: Swift.String?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        sourceAccountEquals: Swift.String? = nil,
        sourceModelArnEquals: Swift.String? = nil,
        statusEquals: BedrockClientTypes.ModelCopyJobStatus? = nil,
        targetModelNameContains: Swift.String? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.sourceAccountEquals = sourceAccountEquals
        self.sourceModelArnEquals = sourceModelArnEquals
        self.statusEquals = statusEquals
        self.targetModelNameContains = targetModelNameContains
    }
}

extension BedrockClientTypes {
    /// Contains details about each model copy job. This data type is used in the following API operations:
    ///
    /// * [ListModelCopyJobs response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListModelCopyJobs.html#API_ListModelCopyJobs_ResponseSyntax)
    public struct ModelCopyJobSummary {
        /// The time that the model copy job was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// If a model fails to be copied, a message describing why the job failed is included here.
        public var failureMessage: Swift.String?
        /// The Amazon Resoource Name (ARN) of the model copy job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The unique identifier of the account that the model being copied originated from.
        /// This member is required.
        public var sourceAccountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the original model being copied.
        /// This member is required.
        public var sourceModelArn: Swift.String?
        /// The name of the original model being copied.
        public var sourceModelName: Swift.String?
        /// The status of the model copy job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelCopyJobStatus?
        /// The Amazon Resource Name (ARN) of the copied model.
        /// This member is required.
        public var targetModelArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the copied model.
        public var targetModelKmsKeyArn: Swift.String?
        /// The name of the copied model.
        public var targetModelName: Swift.String?
        /// Tags associated with the copied model.
        public var targetModelTags: [BedrockClientTypes.Tag]?

        public init(
            creationTime: Foundation.Date? = nil,
            failureMessage: Swift.String? = nil,
            jobArn: Swift.String? = nil,
            sourceAccountId: Swift.String? = nil,
            sourceModelArn: Swift.String? = nil,
            sourceModelName: Swift.String? = nil,
            status: BedrockClientTypes.ModelCopyJobStatus? = nil,
            targetModelArn: Swift.String? = nil,
            targetModelKmsKeyArn: Swift.String? = nil,
            targetModelName: Swift.String? = nil,
            targetModelTags: [BedrockClientTypes.Tag]? = nil
        )
        {
            self.creationTime = creationTime
            self.failureMessage = failureMessage
            self.jobArn = jobArn
            self.sourceAccountId = sourceAccountId
            self.sourceModelArn = sourceModelArn
            self.sourceModelName = sourceModelName
            self.status = status
            self.targetModelArn = targetModelArn
            self.targetModelKmsKeyArn = targetModelKmsKeyArn
            self.targetModelName = targetModelName
            self.targetModelTags = targetModelTags
        }
    }

}

public struct ListModelCopyJobsOutput {
    /// A list of information about each model copy job.
    public var modelCopyJobSummaries: [BedrockClientTypes.ModelCopyJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelCopyJobSummaries: [BedrockClientTypes.ModelCopyJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelCopyJobSummaries = modelCopyJobSummaries
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {
    /// The Amazon S3 data source of the imported job.
    public struct S3DataSource {
        /// The URI of the Amazon S3 data source.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes {
    /// Data source for the imported model.
    public enum ModelDataSource {
        /// The Amazon S3 data source of the imported model.
        case s3datasource(BedrockClientTypes.S3DataSource)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes {
    /// The configuration of a virtual private cloud (VPC). For more information, see [Protect your data using Amazon Virtual Private Cloud and Amazon Web Services PrivateLink](https://docs.aws.amazon.com/bedrock/latest/userguide/usingVPC.html).
    public struct VpcConfig {
        /// An array of IDs for each security group in the VPC to use.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// An array of IDs for each subnet in the VPC to use.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

public struct CreateModelImportJobInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The imported model is encrypted at rest using this key.
    public var importedModelKmsKeyId: Swift.String?
    /// The name of the imported model.
    /// This member is required.
    public var importedModelName: Swift.String?
    /// Tags to attach to the imported model.
    public var importedModelTags: [BedrockClientTypes.Tag]?
    /// The name of the import job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to this import job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// The data source for the imported model.
    /// This member is required.
    public var modelDataSource: BedrockClientTypes.ModelDataSource?
    /// The Amazon Resource Name (ARN) of the model import job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// VPC configuration parameters for the private Virtual Private Cloud (VPC) that contains the resources you are using for the import job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        importedModelKmsKeyId: Swift.String? = nil,
        importedModelName: Swift.String? = nil,
        importedModelTags: [BedrockClientTypes.Tag]? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        modelDataSource: BedrockClientTypes.ModelDataSource? = nil,
        roleArn: Swift.String? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.importedModelKmsKeyId = importedModelKmsKeyId
        self.importedModelName = importedModelName
        self.importedModelTags = importedModelTags
        self.jobName = jobName
        self.jobTags = jobTags
        self.modelDataSource = modelDataSource
        self.roleArn = roleArn
        self.vpcConfig = vpcConfig
    }
}

public struct CreateModelImportJobOutput {
    /// The Amazon Resource Name (ARN) of the model import job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct DeleteImportedModelInput {
    /// Name of the imported model to delete.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

public struct DeleteImportedModelOutput {

    public init() { }
}

public struct GetImportedModelInput {
    /// Name or Amazon Resource Name (ARN) of the imported model.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

public struct GetImportedModelOutput {
    /// Creation time of the imported model.
    public var creationTime: Foundation.Date?
    /// Job Amazon Resource Name (ARN) associated with the imported model.
    public var jobArn: Swift.String?
    /// Job name associated with the imported model.
    public var jobName: Swift.String?
    /// The architecture of the imported model.
    public var modelArchitecture: Swift.String?
    /// The Amazon Resource Name (ARN) associated with this imported model.
    public var modelArn: Swift.String?
    /// The data source for this imported model.
    public var modelDataSource: BedrockClientTypes.ModelDataSource?
    /// The imported model is encrypted at rest using this key.
    public var modelKmsKeyArn: Swift.String?
    /// The name of the imported model.
    public var modelName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelArchitecture: Swift.String? = nil,
        modelArn: Swift.String? = nil,
        modelDataSource: BedrockClientTypes.ModelDataSource? = nil,
        modelKmsKeyArn: Swift.String? = nil,
        modelName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.jobArn = jobArn
        self.jobName = jobName
        self.modelArchitecture = modelArchitecture
        self.modelArn = modelArn
        self.modelDataSource = modelDataSource
        self.modelKmsKeyArn = modelKmsKeyArn
        self.modelName = modelName
    }
}

public struct GetModelImportJobInput {
    /// The identifier of the import job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelImportJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelImportJobOutput {
    /// The time the resource was created.
    public var creationTime: Foundation.Date?
    /// Time that the resource transitioned to terminal state.
    public var endTime: Foundation.Date?
    /// Information about why the import job failed.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the imported model.
    public var importedModelArn: Swift.String?
    /// The imported model is encrypted at rest using this key.
    public var importedModelKmsKeyArn: Swift.String?
    /// The name of the imported model.
    public var importedModelName: Swift.String?
    /// The Amazon Resource Name (ARN) of the import job.
    public var jobArn: Swift.String?
    /// The name of the import job.
    public var jobName: Swift.String?
    /// Time the resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The data source for the imported model.
    public var modelDataSource: BedrockClientTypes.ModelDataSource?
    /// The Amazon Resource Name (ARN) of the IAM role associated with this job.
    public var roleArn: Swift.String?
    /// The status of the job. A successful job transitions from in-progress to completed when the imported model is ready to use. If the job failed, the failure message contains information about why the job failed.
    public var status: BedrockClientTypes.ModelImportJobStatus?
    /// The Virtual Private Cloud (VPC) configuration of the import model job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        creationTime: Foundation.Date? = nil,
        endTime: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        importedModelArn: Swift.String? = nil,
        importedModelKmsKeyArn: Swift.String? = nil,
        importedModelName: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        modelDataSource: BedrockClientTypes.ModelDataSource? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelImportJobStatus? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.creationTime = creationTime
        self.endTime = endTime
        self.failureMessage = failureMessage
        self.importedModelArn = importedModelArn
        self.importedModelKmsKeyArn = importedModelKmsKeyArn
        self.importedModelName = importedModelName
        self.jobArn = jobArn
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.modelDataSource = modelDataSource
        self.roleArn = roleArn
        self.status = status
        self.vpcConfig = vpcConfig
    }
}

extension BedrockClientTypes {

    public enum SortModelsBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortModelsBy] {
            return [
                .creationTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListImportedModelsInput {
    /// Return imported models that were created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return imported models that created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return imported models only if the model name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of imported models.
    public var sortBy: BedrockClientTypes.SortModelsBy?
    /// Specifies whetehr to sort the results in ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortModelsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension BedrockClientTypes {
    /// Information about tne imported model.
    public struct ImportedModelSummary {
        /// Creation time of the imported model.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the imported model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Name of the imported model.
        /// This member is required.
        public var modelName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            modelArn: Swift.String? = nil,
            modelName: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.modelArn = modelArn
            self.modelName = modelName
        }
    }

}

public struct ListImportedModelsOutput {
    /// Model summaries.
    public var modelSummaries: [BedrockClientTypes.ImportedModelSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelSummaries: [BedrockClientTypes.ImportedModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelSummaries = modelSummaries
        self.nextToken = nextToken
    }
}

public struct ListModelImportJobsInput {
    /// Return import jobs that were created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return import jobs that were created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return imported jobs only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of imported jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the results in ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Return imported jobs with the specified status.
    public var statusEquals: BedrockClientTypes.ModelImportJobStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ModelImportJobStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {
    /// Information about the import job.
    public struct ModelImportJobSummary {
        /// The time import job was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The time when import job ended.
        public var endTime: Foundation.Date?
        /// The Amazon resource Name (ARN) of the imported model.
        public var importedModelArn: Swift.String?
        /// The name of the imported model.
        public var importedModelName: Swift.String?
        /// The Amazon Resource Name (ARN) of the import job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name of the import job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The time when the import job was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The status of the imported job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelImportJobStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            endTime: Foundation.Date? = nil,
            importedModelArn: Swift.String? = nil,
            importedModelName: Swift.String? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: BedrockClientTypes.ModelImportJobStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.endTime = endTime
            self.importedModelArn = importedModelArn
            self.importedModelName = importedModelName
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }

}

public struct ListModelImportJobsOutput {
    /// Import job summaries.
    public var modelImportJobSummaries: [BedrockClientTypes.ModelImportJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelImportJobSummaries: [BedrockClientTypes.ModelImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelImportJobSummaries = modelImportJobSummaries
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {

    public enum S3InputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jsonl
        case sdkUnknown(Swift.String)

        public static var allCases: [S3InputFormat] {
            return [
                .jsonl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jsonl: return "JSONL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// Contains the configuration of the S3 location of the input data.
    public struct ModelInvocationJobS3InputDataConfig {
        /// The ID of the Amazon Web Services account that owns the S3 bucket containing the input data.
        public var s3BucketOwner: Swift.String?
        /// The format of the input data.
        public var s3InputFormat: BedrockClientTypes.S3InputFormat?
        /// The S3 location of the input data.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3BucketOwner: Swift.String? = nil,
            s3InputFormat: BedrockClientTypes.S3InputFormat? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.s3BucketOwner = s3BucketOwner
            self.s3InputFormat = s3InputFormat
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes {
    /// Details about the location of the input to the batch inference job.
    public enum ModelInvocationJobInputDataConfig {
        /// Contains the configuration of the S3 location of the input data.
        case s3inputdataconfig(BedrockClientTypes.ModelInvocationJobS3InputDataConfig)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockClientTypes {
    /// Contains the configuration of the S3 location of the output data.
    public struct ModelInvocationJobS3OutputDataConfig {
        /// The ID of the Amazon Web Services account that owns the S3 bucket containing the output data.
        public var s3BucketOwner: Swift.String?
        /// The unique identifier of the key that encrypts the S3 location of the output data.
        public var s3EncryptionKeyId: Swift.String?
        /// The S3 location of the output data.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3BucketOwner: Swift.String? = nil,
            s3EncryptionKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.s3BucketOwner = s3BucketOwner
            self.s3EncryptionKeyId = s3EncryptionKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes {
    /// Contains the configuration of the S3 location of the output data.
    public enum ModelInvocationJobOutputDataConfig {
        /// Contains the configuration of the S3 location of the output data.
        case s3outputdataconfig(BedrockClientTypes.ModelInvocationJobS3OutputDataConfig)
        case sdkUnknown(Swift.String)
    }

}

public struct CreateModelInvocationJobInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// Details about the location of the input to the batch inference job.
    /// This member is required.
    public var inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig?
    /// A name to give the batch inference job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The unique identifier of the foundation model to use for the batch inference job.
    /// This member is required.
    public var modelId: Swift.String?
    /// Details about the location of the output of the batch inference job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at [Create a service role for batch inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
    /// This member is required.
    public var roleArn: Swift.String?
    /// Any tags to associate with the batch inference job. For more information, see [Tagging Amazon Bedrock resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html).
    public var tags: [BedrockClientTypes.Tag]?
    /// The number of hours after which to force the batch inference job to time out.
    public var timeoutDurationInHours: Swift.Int?
    /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see [Protect batch inference jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-vpc).
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig? = nil,
        jobName: Swift.String? = nil,
        modelId: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil,
        timeoutDurationInHours: Swift.Int? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.modelId = modelId
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.tags = tags
        self.timeoutDurationInHours = timeoutDurationInHours
        self.vpcConfig = vpcConfig
    }
}

public struct CreateModelInvocationJobOutput {
    /// The Amazon Resource Name (ARN) of the batch inference job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct GetModelInvocationJobInput {
    /// The Amazon Resource Name (ARN) of the batch inference job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelInvocationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case expired
        case failed
        case inProgress
        case partiallyCompleted
        case scheduled
        case stopped
        case stopping
        case submitted
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelInvocationJobStatus] {
            return [
                .completed,
                .expired,
                .failed,
                .inProgress,
                .partiallyCompleted,
                .scheduled,
                .stopped,
                .stopping,
                .submitted,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .expired: return "Expired"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .partiallyCompleted: return "PartiallyCompleted"
            case .scheduled: return "Scheduled"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case .submitted: return "Submitted"
            case .validating: return "Validating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelInvocationJobOutput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The time at which the batch inference job ended.
    public var endTime: Foundation.Date?
    /// Details about the location of the input to the batch inference job.
    /// This member is required.
    public var inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig?
    /// The Amazon Resource Name (ARN) of the batch inference job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The time at which the batch inference job times or timed out.
    public var jobExpirationTime: Foundation.Date?
    /// The name of the batch inference job.
    public var jobName: Swift.String?
    /// The time at which the batch inference job was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// If the batch inference job failed, this field contains a message describing why the job failed.
    public var message: Swift.String?
    /// The unique identifier of the foundation model used for model inference.
    /// This member is required.
    public var modelId: Swift.String?
    /// Details about the location of the output of the batch inference job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at [Create a service role for batch inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the batch inference job.
    public var status: BedrockClientTypes.ModelInvocationJobStatus?
    /// The time at which the batch inference job was submitted.
    /// This member is required.
    public var submitTime: Foundation.Date?
    /// The number of hours after which batch inference job was set to time out.
    public var timeoutDurationInHours: Swift.Int?
    /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see [Protect batch inference jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-vpc).
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig? = nil,
        jobArn: Swift.String? = nil,
        jobExpirationTime: Foundation.Date? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        modelId: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelInvocationJobStatus? = nil,
        submitTime: Foundation.Date? = nil,
        timeoutDurationInHours: Swift.Int? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobArn = jobArn
        self.jobExpirationTime = jobExpirationTime
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.message = message
        self.modelId = modelId
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.status = status
        self.submitTime = submitTime
        self.timeoutDurationInHours = timeoutDurationInHours
        self.vpcConfig = vpcConfig
    }
}

extension GetModelInvocationJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetModelInvocationJobOutput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), endTime: \(Swift.String(describing: endTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobArn: \(Swift.String(describing: jobArn)), jobExpirationTime: \(Swift.String(describing: jobExpirationTime)), jobName: \(Swift.String(describing: jobName)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modelId: \(Swift.String(describing: modelId)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), submitTime: \(Swift.String(describing: submitTime)), timeoutDurationInHours: \(Swift.String(describing: timeoutDurationInHours)), vpcConfig: \(Swift.String(describing: vpcConfig)), message: \"CONTENT_REDACTED\")"}
}

public struct ListModelInvocationJobsInput {
    /// The maximum number of results to return. If there are more results than the number that you specify, a nextToken value is returned. Use the nextToken in a request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Specify a string to filter for batch inference jobs whose names contain the string.
    public var nameContains: Swift.String?
    /// If there were more results than the value you specified in the maxResults field in a previous ListModelInvocationJobs request, the response would have returned a nextToken value. To see the next batch of results, send the nextToken value in another request.
    public var nextToken: Swift.String?
    /// An attribute by which to sort the results.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the results by ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Specify a status to filter for batch inference jobs whose statuses match the string you specify.
    public var statusEquals: BedrockClientTypes.ModelInvocationJobStatus?
    /// Specify a time to filter for batch inference jobs that were submitted after the time you specify.
    public var submitTimeAfter: Foundation.Date?
    /// Specify a time to filter for batch inference jobs that were submitted before the time you specify.
    public var submitTimeBefore: Foundation.Date?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ModelInvocationJobStatus? = nil,
        submitTimeAfter: Foundation.Date? = nil,
        submitTimeBefore: Foundation.Date? = nil
    )
    {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension BedrockClientTypes {
    /// A summary of a batch inference job.
    public struct ModelInvocationJobSummary {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientRequestToken: Swift.String?
        /// The time at which the batch inference job ended.
        public var endTime: Foundation.Date?
        /// Details about the location of the input to the batch inference job.
        /// This member is required.
        public var inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig?
        /// The Amazon Resource Name (ARN) of the batch inference job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The time at which the batch inference job times or timed out.
        public var jobExpirationTime: Foundation.Date?
        /// The name of the batch inference job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The time at which the batch inference job was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// If the batch inference job failed, this field contains a message describing why the job failed.
        public var message: Swift.String?
        /// The unique identifier of the foundation model used for model inference.
        /// This member is required.
        public var modelId: Swift.String?
        /// Details about the location of the output of the batch inference job.
        /// This member is required.
        public var outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig?
        /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at [Create a service role for batch inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the batch inference job.
        public var status: BedrockClientTypes.ModelInvocationJobStatus?
        /// The time at which the batch inference job was submitted.
        /// This member is required.
        public var submitTime: Foundation.Date?
        /// The number of hours after which the batch inference job was set to time out.
        public var timeoutDurationInHours: Swift.Int?
        /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see [Protect batch inference jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-vpc).
        public var vpcConfig: BedrockClientTypes.VpcConfig?

        public init(
            clientRequestToken: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig? = nil,
            jobArn: Swift.String? = nil,
            jobExpirationTime: Foundation.Date? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            modelId: Swift.String? = nil,
            outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig? = nil,
            roleArn: Swift.String? = nil,
            status: BedrockClientTypes.ModelInvocationJobStatus? = nil,
            submitTime: Foundation.Date? = nil,
            timeoutDurationInHours: Swift.Int? = nil,
            vpcConfig: BedrockClientTypes.VpcConfig? = nil
        )
        {
            self.clientRequestToken = clientRequestToken
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobArn = jobArn
            self.jobExpirationTime = jobExpirationTime
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.message = message
            self.modelId = modelId
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.status = status
            self.submitTime = submitTime
            self.timeoutDurationInHours = timeoutDurationInHours
            self.vpcConfig = vpcConfig
        }
    }

}

extension BedrockClientTypes.ModelInvocationJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelInvocationJobSummary(clientRequestToken: \(Swift.String(describing: clientRequestToken)), endTime: \(Swift.String(describing: endTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobArn: \(Swift.String(describing: jobArn)), jobExpirationTime: \(Swift.String(describing: jobExpirationTime)), jobName: \(Swift.String(describing: jobName)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modelId: \(Swift.String(describing: modelId)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), submitTime: \(Swift.String(describing: submitTime)), timeoutDurationInHours: \(Swift.String(describing: timeoutDurationInHours)), vpcConfig: \(Swift.String(describing: vpcConfig)), message: \"CONTENT_REDACTED\")"}
}

public struct ListModelInvocationJobsOutput {
    /// A list of items, each of which contains a summary about a batch inference job.
    public var invocationJobSummaries: [BedrockClientTypes.ModelInvocationJobSummary]?
    /// If there are more results than can fit in the response, a nextToken is returned. Use the nextToken in a request to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        invocationJobSummaries: [BedrockClientTypes.ModelInvocationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invocationJobSummaries = invocationJobSummaries
        self.nextToken = nextToken
    }
}

public struct StopModelInvocationJobInput {
    /// The Amazon Resource Name (ARN) of the batch inference job to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

public struct StopModelInvocationJobOutput {

    public init() { }
}

public struct DeleteCustomModelInput {
    /// Name of the model to delete.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

public struct DeleteCustomModelOutput {

    public init() { }
}

public struct GetCustomModelInput {
    /// Name or Amazon Resource Name (ARN) of the custom model.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

extension BedrockClientTypes {

    public enum CustomizationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuedPreTraining
        case fineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomizationType] {
            return [
                .continuedPreTraining,
                .fineTuning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .fineTuning: return "FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// S3 Location of the output data.
    public struct OutputDataConfig {
        /// The S3 URI where the output data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes {
    /// S3 Location of the training data.
    public struct TrainingDataConfig {
        /// The S3 URI where the training data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes {
    /// Metrics associated with the custom job.
    public struct TrainingMetrics {
        /// Loss metric associated with the custom job.
        public var trainingLoss: Swift.Float?

        public init(
            trainingLoss: Swift.Float? = nil
        )
        {
            self.trainingLoss = trainingLoss
        }
    }

}

extension BedrockClientTypes {
    /// Information about a validator.
    public struct Validator {
        /// The S3 URI where the validation data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension BedrockClientTypes {
    /// Array of up to 10 validators.
    public struct ValidationDataConfig {
        /// Information about the validators.
        /// This member is required.
        public var validators: [BedrockClientTypes.Validator]?

        public init(
            validators: [BedrockClientTypes.Validator]? = nil
        )
        {
            self.validators = validators
        }
    }

}

extension BedrockClientTypes {
    /// The metric for the validator.
    public struct ValidatorMetric {
        /// The validation loss associated with this validator.
        public var validationLoss: Swift.Float?

        public init(
            validationLoss: Swift.Float? = nil
        )
        {
            self.validationLoss = validationLoss
        }
    }

}

public struct GetCustomModelOutput {
    /// Amazon Resource Name (ARN) of the base model.
    /// This member is required.
    public var baseModelArn: Swift.String?
    /// Creation time of the model.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Hyperparameter values associated with this model. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    public var hyperParameters: [Swift.String: Swift.String]?
    /// Job Amazon Resource Name (ARN) associated with this model.
    /// This member is required.
    public var jobArn: Swift.String?
    /// Job name associated with this model.
    public var jobName: Swift.String?
    /// Amazon Resource Name (ARN) associated with this model.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var modelKmsKeyArn: Swift.String?
    /// Model name associated with this model.
    /// This member is required.
    public var modelName: Swift.String?
    /// Output data configuration associated with this custom model.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// Contains information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Contains training metrics from the job creation.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Contains information about the validation dataset.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The validation metrics from the job creation.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?

    public init(
        baseModelArn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelArn: Swift.String? = nil,
        modelKmsKeyArn: Swift.String? = nil,
        modelName: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil
    )
    {
        self.baseModelArn = baseModelArn
        self.creationTime = creationTime
        self.customizationType = customizationType
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.modelArn = modelArn
        self.modelKmsKeyArn = modelKmsKeyArn
        self.modelName = modelName
        self.outputDataConfig = outputDataConfig
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
    }
}

public struct GetFoundationModelInput {
    /// The model identifier.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    )
    {
        self.modelIdentifier = modelIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelCustomization: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuedPreTraining
        case fineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomization] {
            return [
                .continuedPreTraining,
                .fineTuning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .fineTuning: return "FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum InferenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case onDemand
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceType] {
            return [
                .onDemand,
                .provisioned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .onDemand: return "ON_DEMAND"
            case .provisioned: return "PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum ModelModality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case embedding
        case image
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelModality] {
            return [
                .embedding,
                .image,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .embedding: return "EMBEDDING"
            case .image: return "IMAGE"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum FoundationModelLifecycleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case legacy
        case sdkUnknown(Swift.String)

        public static var allCases: [FoundationModelLifecycleStatus] {
            return [
                .active,
                .legacy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .legacy: return "LEGACY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {
    /// Details about whether a model version is available or deprecated.
    public struct FoundationModelLifecycle {
        /// Specifies whether a model version is available (ACTIVE) or deprecated (LEGACY.
        /// This member is required.
        public var status: BedrockClientTypes.FoundationModelLifecycleStatus?

        public init(
            status: BedrockClientTypes.FoundationModelLifecycleStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension BedrockClientTypes {
    /// Information about a foundation model.
    public struct FoundationModelDetails {
        /// The customization that the model supports.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The model Amazon Resource Name (ARN).
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model identifier.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The model name.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// The model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        )
        {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }

}

public struct GetFoundationModelOutput {
    /// Information about the foundation model.
    public var modelDetails: BedrockClientTypes.FoundationModelDetails?

    public init(
        modelDetails: BedrockClientTypes.FoundationModelDetails? = nil
    )
    {
        self.modelDetails = modelDetails
    }
}

public struct ListCustomModelsInput {
    /// Return custom models only if the base model Amazon Resource Name (ARN) matches this parameter.
    public var baseModelArnEquals: Swift.String?
    /// Return custom models created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return custom models created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// Return custom models only if the foundation model Amazon Resource Name (ARN) matches this parameter.
    public var foundationModelArnEquals: Swift.String?
    /// Return custom models depending on if the current account owns them (true) or if they were shared with the current account (false).
    public var isOwned: Swift.Bool?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return custom models only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of models.
    public var sortBy: BedrockClientTypes.SortModelsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?

    public init(
        baseModelArnEquals: Swift.String? = nil,
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        foundationModelArnEquals: Swift.String? = nil,
        isOwned: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortModelsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil
    )
    {
        self.baseModelArnEquals = baseModelArnEquals
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.foundationModelArnEquals = foundationModelArnEquals
        self.isOwned = isOwned
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension BedrockClientTypes {
    /// Summary information for a custom model.
    public struct CustomModelSummary {
        /// The base model Amazon Resource Name (ARN).
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// The base model name.
        /// This member is required.
        public var baseModelName: Swift.String?
        /// Creation time of the model.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// The Amazon Resource Name (ARN) of the custom model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The name of the custom model.
        /// This member is required.
        public var modelName: Swift.String?
        /// The unique identifier of the account that owns the model.
        public var ownerAccountId: Swift.String?

        public init(
            baseModelArn: Swift.String? = nil,
            baseModelName: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            modelArn: Swift.String? = nil,
            modelName: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil
        )
        {
            self.baseModelArn = baseModelArn
            self.baseModelName = baseModelName
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.modelArn = modelArn
            self.modelName = modelName
            self.ownerAccountId = ownerAccountId
        }
    }

}

public struct ListCustomModelsOutput {
    /// Model summaries.
    public var modelSummaries: [BedrockClientTypes.CustomModelSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelSummaries: [BedrockClientTypes.CustomModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelSummaries = modelSummaries
        self.nextToken = nextToken
    }
}

public struct ListFoundationModelsInput {
    /// Return models that support the customization type that you specify. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var byCustomizationType: BedrockClientTypes.ModelCustomization?
    /// Return models that support the inference type that you specify. For more information, see [Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var byInferenceType: BedrockClientTypes.InferenceType?
    /// Return models that support the output modality that you specify.
    public var byOutputModality: BedrockClientTypes.ModelModality?
    /// Return models belonging to the model provider that you specify.
    public var byProvider: Swift.String?

    public init(
        byCustomizationType: BedrockClientTypes.ModelCustomization? = nil,
        byInferenceType: BedrockClientTypes.InferenceType? = nil,
        byOutputModality: BedrockClientTypes.ModelModality? = nil,
        byProvider: Swift.String? = nil
    )
    {
        self.byCustomizationType = byCustomizationType
        self.byInferenceType = byInferenceType
        self.byOutputModality = byOutputModality
        self.byProvider = byProvider
    }
}

extension BedrockClientTypes {
    /// Summary information for a foundation model.
    public struct FoundationModelSummary {
        /// Whether the model supports fine-tuning or continual pre-training.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The Amazon Resource Name (ARN) of the foundation model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model ID of the foundation model.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated.
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The name of the model.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// The model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        )
        {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }

}

public struct ListFoundationModelsOutput {
    /// A list of Amazon Bedrock foundation models.
    public var modelSummaries: [BedrockClientTypes.FoundationModelSummary]?

    public init(
        modelSummaries: [BedrockClientTypes.FoundationModelSummary]? = nil
    )
    {
        self.modelSummaries = modelSummaries
    }
}

extension BedrockClientTypes {

    public enum CommitmentDuration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneMonth
        case sixMonths
        case sdkUnknown(Swift.String)

        public static var allCases: [CommitmentDuration] {
            return [
                .oneMonth,
                .sixMonths
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneMonth: return "OneMonth"
            case .sixMonths: return "SixMonths"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProvisionedModelThroughputInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// The commitment duration requested for the Provisioned Throughput. Billing occurs hourly and is discounted for longer commitment terms. To request a no-commit Provisioned Throughput, omit this field. Custom models support all levels of commitment. To see which base models support no commitment, see [Supported regions and models for Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/pt-supported.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html)
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// The Amazon Resource Name (ARN) or name of the model to associate with this Provisioned Throughput. For a list of models for which you can purchase Provisioned Throughput, see [Amazon Bedrock model IDs for purchasing Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#prov-throughput-models) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    /// This member is required.
    public var modelId: Swift.String?
    /// Number of model units to allocate. A model unit delivers a specific throughput level for the specified model. The throughput level of a model unit specifies the total number of input and output tokens that it can process and generate within a span of one minute. By default, your account has no model units for purchasing Provisioned Throughputs with commitment. You must first visit the [Amazon Web Services support center](https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase) to request MUs. For model unit quotas, see [Provisioned Throughput quotas](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html#prov-thru-quotas) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html). For more information about what an MU specifies, contact your Amazon Web Services account manager.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// The name for this Provisioned Throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// Tags to associate with this Provisioned Throughput.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        modelId: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelName: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.commitmentDuration = commitmentDuration
        self.modelId = modelId
        self.modelUnits = modelUnits
        self.provisionedModelName = provisionedModelName
        self.tags = tags
    }
}

public struct CreateProvisionedModelThroughputOutput {
    /// The Amazon Resource Name (ARN) for this Provisioned Throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?

    public init(
        provisionedModelArn: Swift.String? = nil
    )
    {
        self.provisionedModelArn = provisionedModelArn
    }
}

public struct DeleteProvisionedModelThroughputInput {
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    )
    {
        self.provisionedModelId = provisionedModelId
    }
}

public struct DeleteProvisionedModelThroughputOutput {

    public init() { }
}

public struct GetProvisionedModelThroughputInput {
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    )
    {
        self.provisionedModelId = provisionedModelId
    }
}

extension BedrockClientTypes {

    public enum ProvisionedModelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case failed
        case inService
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedModelStatus] {
            return [
                .creating,
                .failed,
                .inService,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .failed: return "Failed"
            case .inService: return "InService"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetProvisionedModelThroughputOutput {
    /// Commitment duration of the Provisioned Throughput.
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// The timestamp for when the commitment term for the Provisioned Throughput expires.
    public var commitmentExpirationTime: Foundation.Date?
    /// The timestamp of the creation time for this Provisioned Throughput.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
    /// This member is required.
    public var desiredModelArn: Swift.String?
    /// The number of model units that was requested for this Provisioned Throughput.
    /// This member is required.
    public var desiredModelUnits: Swift.Int?
    /// A failure message for any issues that occurred during creation, updating, or deletion of the Provisioned Throughput.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
    /// This member is required.
    public var foundationModelArn: Swift.String?
    /// The timestamp of the last time that this Provisioned Throughput was modified.
    /// This member is required.
    public var lastModifiedTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the model associated with this Provisioned Throughput.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The number of model units allocated to this Provisioned Throughput.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?
    /// The name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// The status of the Provisioned Throughput.
    /// This member is required.
    public var status: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        commitmentExpirationTime: Foundation.Date? = nil,
        creationTime: Foundation.Date? = nil,
        desiredModelArn: Swift.String? = nil,
        desiredModelUnits: Swift.Int? = nil,
        failureMessage: Swift.String? = nil,
        foundationModelArn: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        modelArn: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelArn: Swift.String? = nil,
        provisionedModelName: Swift.String? = nil,
        status: BedrockClientTypes.ProvisionedModelStatus? = nil
    )
    {
        self.commitmentDuration = commitmentDuration
        self.commitmentExpirationTime = commitmentExpirationTime
        self.creationTime = creationTime
        self.desiredModelArn = desiredModelArn
        self.desiredModelUnits = desiredModelUnits
        self.failureMessage = failureMessage
        self.foundationModelArn = foundationModelArn
        self.lastModifiedTime = lastModifiedTime
        self.modelArn = modelArn
        self.modelUnits = modelUnits
        self.provisionedModelArn = provisionedModelArn
        self.provisionedModelName = provisionedModelName
        self.status = status
    }
}

extension BedrockClientTypes {

    public enum SortByProvisionedModels: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortByProvisionedModels] {
            return [
                .creationTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListProvisionedModelThroughputsInput {
    /// A filter that returns Provisioned Throughputs created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// A filter that returns Provisioned Throughputs created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// THe maximum number of results to return in the response. If there are more results than the number you specified, the response returns a nextToken value. To see the next batch of results, send the nextToken value in another list request.
    public var maxResults: Swift.Int?
    /// A filter that returns Provisioned Throughputs whose model Amazon Resource Name (ARN) is equal to the value that you specify.
    public var modelArnEquals: Swift.String?
    /// A filter that returns Provisioned Throughputs if their name contains the expression that you specify.
    public var nameContains: Swift.String?
    /// If there are more results than the number you specified in the maxResults field, the response returns a nextToken value. To see the next batch of results, specify the nextToken value in this field.
    public var nextToken: Swift.String?
    /// The field by which to sort the returned list of Provisioned Throughputs.
    public var sortBy: BedrockClientTypes.SortByProvisionedModels?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// A filter that returns Provisioned Throughputs if their statuses matches the value that you specify.
    public var statusEquals: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        modelArnEquals: Swift.String? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortByProvisionedModels? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ProvisionedModelStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.modelArnEquals = modelArnEquals
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {
    /// A summary of information about a Provisioned Throughput. This data type is used in the following API operations:
    ///
    /// * [ListProvisionedThroughputs response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListProvisionedModelThroughputs.html#API_ListProvisionedModelThroughputs_ResponseSyntax)
    public struct ProvisionedModelSummary {
        /// The duration for which the Provisioned Throughput was committed.
        public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
        /// The timestamp for when the commitment term of the Provisioned Throughput expires.
        public var commitmentExpirationTime: Foundation.Date?
        /// The time that the Provisioned Throughput was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
        /// This member is required.
        public var desiredModelArn: Swift.String?
        /// The number of model units that was requested to be allocated to the Provisioned Throughput.
        /// This member is required.
        public var desiredModelUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
        /// This member is required.
        public var foundationModelArn: Swift.String?
        /// The time that the Provisioned Throughput was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the model associated with the Provisioned Throughput.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The number of model units allocated to the Provisioned Throughput.
        /// This member is required.
        public var modelUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
        /// This member is required.
        public var provisionedModelArn: Swift.String?
        /// The name of the Provisioned Throughput.
        /// This member is required.
        public var provisionedModelName: Swift.String?
        /// The status of the Provisioned Throughput.
        /// This member is required.
        public var status: BedrockClientTypes.ProvisionedModelStatus?

        public init(
            commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
            commitmentExpirationTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            desiredModelArn: Swift.String? = nil,
            desiredModelUnits: Swift.Int? = nil,
            foundationModelArn: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            modelArn: Swift.String? = nil,
            modelUnits: Swift.Int? = nil,
            provisionedModelArn: Swift.String? = nil,
            provisionedModelName: Swift.String? = nil,
            status: BedrockClientTypes.ProvisionedModelStatus? = nil
        )
        {
            self.commitmentDuration = commitmentDuration
            self.commitmentExpirationTime = commitmentExpirationTime
            self.creationTime = creationTime
            self.desiredModelArn = desiredModelArn
            self.desiredModelUnits = desiredModelUnits
            self.foundationModelArn = foundationModelArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.modelUnits = modelUnits
            self.provisionedModelArn = provisionedModelArn
            self.provisionedModelName = provisionedModelName
            self.status = status
        }
    }

}

public struct ListProvisionedModelThroughputsOutput {
    /// If there are more results than the number you specified in the maxResults field, this value is returned. To see the next batch of results, include this value in the nextToken field in another list request.
    public var nextToken: Swift.String?
    /// A list of summaries, one for each Provisioned Throughput in the response.
    public var provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]?

    public init(
        nextToken: Swift.String? = nil,
        provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.provisionedModelSummaries = provisionedModelSummaries
    }
}

public struct UpdateProvisionedModelThroughputInput {
    /// The Amazon Resource Name (ARN) of the new model to associate with this Provisioned Throughput. You can't specify this field if this Provisioned Throughput is associated with a base model. If this Provisioned Throughput is associated with a custom model, you can specify one of the following options:
    ///
    /// * The base model from which the custom model was customized.
    ///
    /// * Another custom model that was customized from the same base model as the custom model.
    public var desiredModelId: Swift.String?
    /// The new name for this Provisioned Throughput.
    public var desiredProvisionedModelName: Swift.String?
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput to update.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        desiredModelId: Swift.String? = nil,
        desiredProvisionedModelName: Swift.String? = nil,
        provisionedModelId: Swift.String? = nil
    )
    {
        self.desiredModelId = desiredModelId
        self.desiredProvisionedModelName = desiredProvisionedModelName
        self.provisionedModelId = provisionedModelId
    }
}

public struct UpdateProvisionedModelThroughputOutput {

    public init() { }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// An array of the tags associated with this resource.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tags to associate with the resource.
    /// This member is required.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to untag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tag keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct CreateModelCustomizationJobInput {
    /// Name of the base model.
    /// This member is required.
    public var baseModelIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var customModelKmsKeyId: Swift.String?
    /// A name for the resulting custom model.
    /// This member is required.
    public var customModelName: Swift.String?
    /// Tags to attach to the resulting custom model.
    public var customModelTags: [BedrockClientTypes.Tag]?
    /// The customization type.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Parameters related to tuning the model. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    /// This member is required.
    public var hyperParameters: [Swift.String: Swift.String]?
    /// A name for the fine-tuning job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to the job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// S3 location for the output data.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can assume to perform tasks on your behalf. For example, during model training, Amazon Bedrock needs your permission to read input data from an S3 bucket, write model artifacts to an S3 bucket. To pass this role to Amazon Bedrock, the caller of this API must have the iam:PassRole permission.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Information about the validation dataset.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The configuration of the Virtual Private Cloud (VPC) that contains the resources that you're using for this job. For more information, see [Protect your model customization jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/vpc-model-customization.html).
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelIdentifier: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        customModelKmsKeyId: Swift.String? = nil,
        customModelName: Swift.String? = nil,
        customModelTags: [BedrockClientTypes.Tag]? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.baseModelIdentifier = baseModelIdentifier
        self.clientRequestToken = clientRequestToken
        self.customModelKmsKeyId = customModelKmsKeyId
        self.customModelName = customModelName
        self.customModelTags = customModelTags
        self.customizationType = customizationType
        self.hyperParameters = hyperParameters
        self.jobName = jobName
        self.jobTags = jobTags
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.trainingDataConfig = trainingDataConfig
        self.validationDataConfig = validationDataConfig
        self.vpcConfig = vpcConfig
    }
}

public struct CreateModelCustomizationJobOutput {
    /// Amazon Resource Name (ARN) of the fine tuning job
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    )
    {
        self.jobArn = jobArn
    }
}

public struct GetModelCustomizationJobInput {
    /// Identifier for the customization job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelCustomizationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomizationJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelCustomizationJobOutput {
    /// Amazon Resource Name (ARN) of the base model.
    /// This member is required.
    public var baseModelArn: Swift.String?
    /// The token that you specified in the CreateCustomizationJob request.
    public var clientRequestToken: Swift.String?
    /// Time that the resource was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Time that the resource transitioned to terminal state.
    public var endTime: Foundation.Date?
    /// Information about why the job failed.
    public var failureMessage: Swift.String?
    /// The hyperparameter values for the job. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    /// This member is required.
    public var hyperParameters: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the customization job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The name of the customization job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Time that the resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// Output data configuration
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The Amazon Resource Name (ARN) of the output model.
    public var outputModelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var outputModelKmsKeyArn: Swift.String?
    /// The name of the output model.
    /// This member is required.
    public var outputModelName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the job. A successful job transitions from in-progress to completed when the output model is ready to use. If the job failed, the failure message contains information about why the job failed.
    public var status: BedrockClientTypes.ModelCustomizationJobStatus?
    /// Contains information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Contains training metrics from the job creation.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Contains information about the validation dataset.
    /// This member is required.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The loss metric for each validator that you provided in the createjob request.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?
    /// VPC configuration for the custom model job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        endTime: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        outputModelArn: Swift.String? = nil,
        outputModelKmsKeyArn: Swift.String? = nil,
        outputModelName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelCustomizationJobStatus? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    )
    {
        self.baseModelArn = baseModelArn
        self.clientRequestToken = clientRequestToken
        self.creationTime = creationTime
        self.customizationType = customizationType
        self.endTime = endTime
        self.failureMessage = failureMessage
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.outputDataConfig = outputDataConfig
        self.outputModelArn = outputModelArn
        self.outputModelKmsKeyArn = outputModelKmsKeyArn
        self.outputModelName = outputModelName
        self.roleArn = roleArn
        self.status = status
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
        self.vpcConfig = vpcConfig
    }
}

extension BedrockClientTypes {

    public enum FineTuningJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [FineTuningJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListModelCustomizationJobsInput {
    /// Return customization jobs created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return customization jobs created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return customization jobs only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Return customization jobs with the specified status.
    public var statusEquals: BedrockClientTypes.FineTuningJobStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.FineTuningJobStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {
    /// Information about one customization job
    public struct ModelCustomizationJobSummary {
        /// Amazon Resource Name (ARN) of the base model.
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// Creation time of the custom model.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of the custom model.
        public var customModelArn: Swift.String?
        /// Name of the custom model.
        public var customModelName: Swift.String?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// Time that the customization job ended.
        public var endTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of the customization job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// Name of the customization job.
        /// This member is required.
        public var jobName: Swift.String?
        /// Time that the customization job was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// Status of the customization job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelCustomizationJobStatus?

        public init(
            baseModelArn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            customModelArn: Swift.String? = nil,
            customModelName: Swift.String? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            endTime: Foundation.Date? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: BedrockClientTypes.ModelCustomizationJobStatus? = nil
        )
        {
            self.baseModelArn = baseModelArn
            self.creationTime = creationTime
            self.customModelArn = customModelArn
            self.customModelName = customModelName
            self.customizationType = customizationType
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }

}

public struct ListModelCustomizationJobsOutput {
    /// Job summaries.
    public var modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelCustomizationJobSummaries = modelCustomizationJobSummaries
        self.nextToken = nextToken
    }
}

public struct StopModelCustomizationJobInput {
    /// Job identifier of the job to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    )
    {
        self.jobIdentifier = jobIdentifier
    }
}

public struct StopModelCustomizationJobOutput {

    public init() { }
}

extension BatchDeleteEvaluationJobInput {

    static func urlPathProvider(_ value: BatchDeleteEvaluationJobInput) -> Swift.String? {
        return "/evaluation-jobs/batch-delete"
    }
}

extension CreateEvaluationJobInput {

    static func urlPathProvider(_ value: CreateEvaluationJobInput) -> Swift.String? {
        return "/evaluation-jobs"
    }
}

extension CreateGuardrailInput {

    static func urlPathProvider(_ value: CreateGuardrailInput) -> Swift.String? {
        return "/guardrails"
    }
}

extension CreateGuardrailVersionInput {

    static func urlPathProvider(_ value: CreateGuardrailVersionInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension CreateModelCopyJobInput {

    static func urlPathProvider(_ value: CreateModelCopyJobInput) -> Swift.String? {
        return "/model-copy-jobs"
    }
}

extension CreateModelCustomizationJobInput {

    static func urlPathProvider(_ value: CreateModelCustomizationJobInput) -> Swift.String? {
        return "/model-customization-jobs"
    }
}

extension CreateModelImportJobInput {

    static func urlPathProvider(_ value: CreateModelImportJobInput) -> Swift.String? {
        return "/model-import-jobs"
    }
}

extension CreateModelInvocationJobInput {

    static func urlPathProvider(_ value: CreateModelInvocationJobInput) -> Swift.String? {
        return "/model-invocation-job"
    }
}

extension CreateProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: CreateProvisionedModelThroughputInput) -> Swift.String? {
        return "/provisioned-model-throughput"
    }
}

extension DeleteCustomModelInput {

    static func urlPathProvider(_ value: DeleteCustomModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension DeleteGuardrailInput {

    static func urlPathProvider(_ value: DeleteGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension DeleteGuardrailInput {

    static func queryItemProvider(_ value: DeleteGuardrailInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let guardrailVersion = value.guardrailVersion {
            let guardrailVersionQueryItem = Smithy.URIQueryItem(name: "guardrailVersion".urlPercentEncoding(), value: Swift.String(guardrailVersion).urlPercentEncoding())
            items.append(guardrailVersionQueryItem)
        }
        return items
    }
}

extension DeleteImportedModelInput {

    static func urlPathProvider(_ value: DeleteImportedModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/imported-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension DeleteModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: DeleteModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension DeleteProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: DeleteProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension GetCustomModelInput {

    static func urlPathProvider(_ value: GetCustomModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension GetEvaluationJobInput {

    static func urlPathProvider(_ value: GetEvaluationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/evaluation-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetFoundationModelInput {

    static func urlPathProvider(_ value: GetFoundationModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/foundation-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension GetGuardrailInput {

    static func urlPathProvider(_ value: GetGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension GetGuardrailInput {

    static func queryItemProvider(_ value: GetGuardrailInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let guardrailVersion = value.guardrailVersion {
            let guardrailVersionQueryItem = Smithy.URIQueryItem(name: "guardrailVersion".urlPercentEncoding(), value: Swift.String(guardrailVersion).urlPercentEncoding())
            items.append(guardrailVersionQueryItem)
        }
        return items
    }
}

extension GetImportedModelInput {

    static func urlPathProvider(_ value: GetImportedModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/imported-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension GetInferenceProfileInput {

    static func urlPathProvider(_ value: GetInferenceProfileInput) -> Swift.String? {
        guard let inferenceProfileIdentifier = value.inferenceProfileIdentifier else {
            return nil
        }
        return "/inference-profiles/\(inferenceProfileIdentifier.urlPercentEncoding())"
    }
}

extension GetModelCopyJobInput {

    static func urlPathProvider(_ value: GetModelCopyJobInput) -> Swift.String? {
        guard let jobArn = value.jobArn else {
            return nil
        }
        return "/model-copy-jobs/\(jobArn.urlPercentEncoding())"
    }
}

extension GetModelCustomizationJobInput {

    static func urlPathProvider(_ value: GetModelCustomizationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetModelImportJobInput {

    static func urlPathProvider(_ value: GetModelImportJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-import-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetModelInvocationJobInput {

    static func urlPathProvider(_ value: GetModelInvocationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-invocation-job/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: GetModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension GetProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: GetProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension ListCustomModelsInput {

    static func urlPathProvider(_ value: ListCustomModelsInput) -> Swift.String? {
        return "/custom-models"
    }
}

extension ListCustomModelsInput {

    static func queryItemProvider(_ value: ListCustomModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let isOwned = value.isOwned {
            let isOwnedQueryItem = Smithy.URIQueryItem(name: "isOwned".urlPercentEncoding(), value: Swift.String(isOwned).urlPercentEncoding())
            items.append(isOwnedQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let baseModelArnEquals = value.baseModelArnEquals {
            let baseModelArnEqualsQueryItem = Smithy.URIQueryItem(name: "baseModelArnEquals".urlPercentEncoding(), value: Swift.String(baseModelArnEquals).urlPercentEncoding())
            items.append(baseModelArnEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let foundationModelArnEquals = value.foundationModelArnEquals {
            let foundationModelArnEqualsQueryItem = Smithy.URIQueryItem(name: "foundationModelArnEquals".urlPercentEncoding(), value: Swift.String(foundationModelArnEquals).urlPercentEncoding())
            items.append(foundationModelArnEqualsQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListEvaluationJobsInput {

    static func urlPathProvider(_ value: ListEvaluationJobsInput) -> Swift.String? {
        return "/evaluation-jobs"
    }
}

extension ListEvaluationJobsInput {

    static func queryItemProvider(_ value: ListEvaluationJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListFoundationModelsInput {

    static func urlPathProvider(_ value: ListFoundationModelsInput) -> Swift.String? {
        return "/foundation-models"
    }
}

extension ListFoundationModelsInput {

    static func queryItemProvider(_ value: ListFoundationModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let byOutputModality = value.byOutputModality {
            let byOutputModalityQueryItem = Smithy.URIQueryItem(name: "byOutputModality".urlPercentEncoding(), value: Swift.String(byOutputModality.rawValue).urlPercentEncoding())
            items.append(byOutputModalityQueryItem)
        }
        if let byCustomizationType = value.byCustomizationType {
            let byCustomizationTypeQueryItem = Smithy.URIQueryItem(name: "byCustomizationType".urlPercentEncoding(), value: Swift.String(byCustomizationType.rawValue).urlPercentEncoding())
            items.append(byCustomizationTypeQueryItem)
        }
        if let byProvider = value.byProvider {
            let byProviderQueryItem = Smithy.URIQueryItem(name: "byProvider".urlPercentEncoding(), value: Swift.String(byProvider).urlPercentEncoding())
            items.append(byProviderQueryItem)
        }
        if let byInferenceType = value.byInferenceType {
            let byInferenceTypeQueryItem = Smithy.URIQueryItem(name: "byInferenceType".urlPercentEncoding(), value: Swift.String(byInferenceType.rawValue).urlPercentEncoding())
            items.append(byInferenceTypeQueryItem)
        }
        return items
    }
}

extension ListGuardrailsInput {

    static func urlPathProvider(_ value: ListGuardrailsInput) -> Swift.String? {
        return "/guardrails"
    }
}

extension ListGuardrailsInput {

    static func queryItemProvider(_ value: ListGuardrailsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            let guardrailIdentifierQueryItem = Smithy.URIQueryItem(name: "guardrailIdentifier".urlPercentEncoding(), value: Swift.String(guardrailIdentifier).urlPercentEncoding())
            items.append(guardrailIdentifierQueryItem)
        }
        return items
    }
}

extension ListImportedModelsInput {

    static func urlPathProvider(_ value: ListImportedModelsInput) -> Swift.String? {
        return "/imported-models"
    }
}

extension ListImportedModelsInput {

    static func queryItemProvider(_ value: ListImportedModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListInferenceProfilesInput {

    static func urlPathProvider(_ value: ListInferenceProfilesInput) -> Swift.String? {
        return "/inference-profiles"
    }
}

extension ListInferenceProfilesInput {

    static func queryItemProvider(_ value: ListInferenceProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListModelCopyJobsInput {

    static func urlPathProvider(_ value: ListModelCopyJobsInput) -> Swift.String? {
        return "/model-copy-jobs"
    }
}

extension ListModelCopyJobsInput {

    static func queryItemProvider(_ value: ListModelCopyJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sourceModelArnEquals = value.sourceModelArnEquals {
            let sourceModelArnEqualsQueryItem = Smithy.URIQueryItem(name: "sourceModelArnEquals".urlPercentEncoding(), value: Swift.String(sourceModelArnEquals).urlPercentEncoding())
            items.append(sourceModelArnEqualsQueryItem)
        }
        if let sourceAccountEquals = value.sourceAccountEquals {
            let sourceAccountEqualsQueryItem = Smithy.URIQueryItem(name: "sourceAccountEquals".urlPercentEncoding(), value: Swift.String(sourceAccountEquals).urlPercentEncoding())
            items.append(sourceAccountEqualsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let targetModelNameContains = value.targetModelNameContains {
            let targetModelNameContainsQueryItem = Smithy.URIQueryItem(name: "outputModelNameContains".urlPercentEncoding(), value: Swift.String(targetModelNameContains).urlPercentEncoding())
            items.append(targetModelNameContainsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelCustomizationJobsInput {

    static func urlPathProvider(_ value: ListModelCustomizationJobsInput) -> Swift.String? {
        return "/model-customization-jobs"
    }
}

extension ListModelCustomizationJobsInput {

    static func queryItemProvider(_ value: ListModelCustomizationJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelImportJobsInput {

    static func urlPathProvider(_ value: ListModelImportJobsInput) -> Swift.String? {
        return "/model-import-jobs"
    }
}

extension ListModelImportJobsInput {

    static func queryItemProvider(_ value: ListModelImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelInvocationJobsInput {

    static func urlPathProvider(_ value: ListModelInvocationJobsInput) -> Swift.String? {
        return "/model-invocation-jobs"
    }
}

extension ListModelInvocationJobsInput {

    static func queryItemProvider(_ value: ListModelInvocationJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let submitTimeAfter = value.submitTimeAfter {
            let submitTimeAfterQueryItem = Smithy.URIQueryItem(name: "submitTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: submitTimeAfter)).urlPercentEncoding())
            items.append(submitTimeAfterQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let submitTimeBefore = value.submitTimeBefore {
            let submitTimeBeforeQueryItem = Smithy.URIQueryItem(name: "submitTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: submitTimeBefore)).urlPercentEncoding())
            items.append(submitTimeBeforeQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        return items
    }
}

extension ListProvisionedModelThroughputsInput {

    static func urlPathProvider(_ value: ListProvisionedModelThroughputsInput) -> Swift.String? {
        return "/provisioned-model-throughputs"
    }
}

extension ListProvisionedModelThroughputsInput {

    static func queryItemProvider(_ value: ListProvisionedModelThroughputsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let modelArnEquals = value.modelArnEquals {
            let modelArnEqualsQueryItem = Smithy.URIQueryItem(name: "modelArnEquals".urlPercentEncoding(), value: Swift.String(modelArnEquals).urlPercentEncoding())
            items.append(modelArnEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/listTagsForResource"
    }
}

extension PutModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: PutModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension StopEvaluationJobInput {

    static func urlPathProvider(_ value: StopEvaluationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/evaluation-job/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

extension StopModelCustomizationJobInput {

    static func urlPathProvider(_ value: StopModelCustomizationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

extension StopModelInvocationJobInput {

    static func urlPathProvider(_ value: StopModelInvocationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-invocation-job/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/untagResource"
    }
}

extension UpdateGuardrailInput {

    static func urlPathProvider(_ value: UpdateGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension UpdateProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: UpdateProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension BatchDeleteEvaluationJobInput {

    static func write(value: BatchDeleteEvaluationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobIdentifiers"].writeList(value.jobIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEvaluationJobInput {

    static func write(value: CreateEvaluationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["customerEncryptionKeyId"].write(value.customerEncryptionKeyId)
        try writer["evaluationConfig"].write(value.evaluationConfig, with: BedrockClientTypes.EvaluationConfig.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockClientTypes.EvaluationInferenceConfig.write(value:to:))
        try writer["jobDescription"].write(value.jobDescription)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.EvaluationOutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }
}

extension CreateGuardrailInput {

    static func write(value: CreateGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: BedrockClientTypes.GuardrailContentPolicyConfig.write(value:to:))
        try writer["contextualGroundingPolicyConfig"].write(value.contextualGroundingPolicyConfig, with: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: BedrockClientTypes.GuardrailTopicPolicyConfig.write(value:to:))
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: BedrockClientTypes.GuardrailWordPolicyConfig.write(value:to:))
    }
}

extension CreateGuardrailVersionInput {

    static func write(value: CreateGuardrailVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
    }
}

extension CreateModelCopyJobInput {

    static func write(value: CreateModelCopyJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["modelKmsKeyId"].write(value.modelKmsKeyId)
        try writer["sourceModelArn"].write(value.sourceModelArn)
        try writer["targetModelName"].write(value.targetModelName)
        try writer["targetModelTags"].writeList(value.targetModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateModelCustomizationJobInput {

    static func write(value: CreateModelCustomizationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseModelIdentifier"].write(value.baseModelIdentifier)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["customModelKmsKeyId"].write(value.customModelKmsKeyId)
        try writer["customModelName"].write(value.customModelName)
        try writer["customModelTags"].writeList(value.customModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["customizationType"].write(value.customizationType)
        try writer["hyperParameters"].writeMap(value.hyperParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.OutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["trainingDataConfig"].write(value.trainingDataConfig, with: BedrockClientTypes.TrainingDataConfig.write(value:to:))
        try writer["validationDataConfig"].write(value.validationDataConfig, with: BedrockClientTypes.ValidationDataConfig.write(value:to:))
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateModelImportJobInput {

    static func write(value: CreateModelImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["importedModelKmsKeyId"].write(value.importedModelKmsKeyId)
        try writer["importedModelName"].write(value.importedModelName)
        try writer["importedModelTags"].writeList(value.importedModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modelDataSource"].write(value.modelDataSource, with: BedrockClientTypes.ModelDataSource.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateModelInvocationJobInput {

    static func write(value: CreateModelInvocationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["inputDataConfig"].write(value.inputDataConfig, with: BedrockClientTypes.ModelInvocationJobInputDataConfig.write(value:to:))
        try writer["jobName"].write(value.jobName)
        try writer["modelId"].write(value.modelId)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.ModelInvocationJobOutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeoutDurationInHours"].write(value.timeoutDurationInHours)
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateProvisionedModelThroughputInput {

    static func write(value: CreateProvisionedModelThroughputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["commitmentDuration"].write(value.commitmentDuration)
        try writer["modelId"].write(value.modelId)
        try writer["modelUnits"].write(value.modelUnits)
        try writer["provisionedModelName"].write(value.provisionedModelName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
    }
}

extension PutModelInvocationLoggingConfigurationInput {

    static func write(value: PutModelInvocationLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["loggingConfig"].write(value.loggingConfig, with: BedrockClientTypes.LoggingConfig.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateGuardrailInput {

    static func write(value: UpdateGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: BedrockClientTypes.GuardrailContentPolicyConfig.write(value:to:))
        try writer["contextualGroundingPolicyConfig"].write(value.contextualGroundingPolicyConfig, with: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: BedrockClientTypes.GuardrailTopicPolicyConfig.write(value:to:))
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: BedrockClientTypes.GuardrailWordPolicyConfig.write(value:to:))
    }
}

extension UpdateProvisionedModelThroughputInput {

    static func write(value: UpdateProvisionedModelThroughputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredModelId"].write(value.desiredModelId)
        try writer["desiredProvisionedModelName"].write(value.desiredProvisionedModelName)
    }
}

extension BatchDeleteEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteEvaluationJobOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BedrockClientTypes.BatchDeleteEvaluationJobError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.evaluationJobs = try reader["evaluationJobs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.BatchDeleteEvaluationJobItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEvaluationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGuardrailOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.guardrailArn = try reader["guardrailArn"].readIfPresent() ?? ""
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateGuardrailVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGuardrailVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGuardrailVersionOutput()
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelCopyJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelCopyJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelCopyJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelCustomizationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelCustomizationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelImportJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelInvocationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelInvocationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelInvocationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisionedModelThroughputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisionedModelThroughputOutput()
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteCustomModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomModelOutput {
        return DeleteCustomModelOutput()
    }
}

extension DeleteGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGuardrailOutput {
        return DeleteGuardrailOutput()
    }
}

extension DeleteImportedModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImportedModelOutput {
        return DeleteImportedModelOutput()
    }
}

extension DeleteModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelInvocationLoggingConfigurationOutput {
        return DeleteModelInvocationLoggingConfigurationOutput()
    }
}

extension DeleteProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisionedModelThroughputOutput {
        return DeleteProvisionedModelThroughputOutput()
    }
}

extension GetCustomModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomModelOutput()
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelKmsKeyArn = try reader["modelKmsKeyArn"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent() ?? ""
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.OutputDataConfig.read(from:))
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: BedrockClientTypes.TrainingDataConfig.read(from:))
        value.trainingMetrics = try reader["trainingMetrics"].readIfPresent(with: BedrockClientTypes.TrainingMetrics.read(from:))
        value.validationDataConfig = try reader["validationDataConfig"].readIfPresent(with: BedrockClientTypes.ValidationDataConfig.read(from:))
        value.validationMetrics = try reader["validationMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ValidatorMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvaluationJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyId = try reader["customerEncryptionKeyId"].readIfPresent()
        value.evaluationConfig = try reader["evaluationConfig"].readIfPresent(with: BedrockClientTypes.EvaluationConfig.read(from:))
        value.failureMessages = try reader["failureMessages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceConfig = try reader["inferenceConfig"].readIfPresent(with: BedrockClientTypes.EvaluationInferenceConfig.read(from:))
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobDescription = try reader["jobDescription"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.jobType = try reader["jobType"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.EvaluationOutputDataConfig.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetFoundationModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFoundationModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFoundationModelOutput()
        value.modelDetails = try reader["modelDetails"].readIfPresent(with: BedrockClientTypes.FoundationModelDetails.read(from:))
        return value
    }
}

extension GetGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGuardrailOutput()
        value.blockedInputMessaging = try reader["blockedInputMessaging"].readIfPresent() ?? ""
        value.blockedOutputsMessaging = try reader["blockedOutputsMessaging"].readIfPresent() ?? ""
        value.contentPolicy = try reader["contentPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailContentPolicy.read(from:))
        value.contextualGroundingPolicy = try reader["contextualGroundingPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailContextualGroundingPolicy.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.failureRecommendations = try reader["failureRecommendations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.guardrailArn = try reader["guardrailArn"].readIfPresent() ?? ""
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sensitiveInformationPolicy = try reader["sensitiveInformationPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailSensitiveInformationPolicy.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.topicPolicy = try reader["topicPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailTopicPolicy.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        value.wordPolicy = try reader["wordPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailWordPolicy.read(from:))
        return value
    }
}

extension GetImportedModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportedModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportedModelOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.modelArchitecture = try reader["modelArchitecture"].readIfPresent()
        value.modelArn = try reader["modelArn"].readIfPresent()
        value.modelDataSource = try reader["modelDataSource"].readIfPresent(with: BedrockClientTypes.ModelDataSource.read(from:))
        value.modelKmsKeyArn = try reader["modelKmsKeyArn"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent()
        return value
    }
}

extension GetInferenceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInferenceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInferenceProfileOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.inferenceProfileArn = try reader["inferenceProfileArn"].readIfPresent() ?? ""
        value.inferenceProfileId = try reader["inferenceProfileId"].readIfPresent() ?? ""
        value.inferenceProfileName = try reader["inferenceProfileName"].readIfPresent() ?? ""
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceProfileModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetModelCopyJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelCopyJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelCopyJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.sourceAccountId = try reader["sourceAccountId"].readIfPresent() ?? ""
        value.sourceModelArn = try reader["sourceModelArn"].readIfPresent() ?? ""
        value.sourceModelName = try reader["sourceModelName"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.targetModelArn = try reader["targetModelArn"].readIfPresent() ?? ""
        value.targetModelKmsKeyArn = try reader["targetModelKmsKeyArn"].readIfPresent()
        value.targetModelName = try reader["targetModelName"].readIfPresent()
        value.targetModelTags = try reader["targetModelTags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelCustomizationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelCustomizationJobOutput()
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.OutputDataConfig.read(from:))
        value.outputModelArn = try reader["outputModelArn"].readIfPresent()
        value.outputModelKmsKeyArn = try reader["outputModelKmsKeyArn"].readIfPresent()
        value.outputModelName = try reader["outputModelName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: BedrockClientTypes.TrainingDataConfig.read(from:))
        value.trainingMetrics = try reader["trainingMetrics"].readIfPresent(with: BedrockClientTypes.TrainingMetrics.read(from:))
        value.validationDataConfig = try reader["validationDataConfig"].readIfPresent(with: BedrockClientTypes.ValidationDataConfig.read(from:))
        value.validationMetrics = try reader["validationMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ValidatorMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension GetModelImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelImportJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.importedModelArn = try reader["importedModelArn"].readIfPresent()
        value.importedModelKmsKeyArn = try reader["importedModelKmsKeyArn"].readIfPresent()
        value.importedModelName = try reader["importedModelName"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.modelDataSource = try reader["modelDataSource"].readIfPresent(with: BedrockClientTypes.ModelDataSource.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension GetModelInvocationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelInvocationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelInvocationJobOutput()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.inputDataConfig = try reader["inputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobInputDataConfig.read(from:))
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobExpirationTime = try reader["jobExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.jobName = try reader["jobName"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.message = try reader["message"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobOutputDataConfig.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.submitTime = try reader["submitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timeoutDurationInHours = try reader["timeoutDurationInHours"].readIfPresent()
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension GetModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelInvocationLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelInvocationLoggingConfigurationOutput()
        value.loggingConfig = try reader["loggingConfig"].readIfPresent(with: BedrockClientTypes.LoggingConfig.read(from:))
        return value
    }
}

extension GetProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProvisionedModelThroughputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProvisionedModelThroughputOutput()
        value.commitmentDuration = try reader["commitmentDuration"].readIfPresent()
        value.commitmentExpirationTime = try reader["commitmentExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.desiredModelArn = try reader["desiredModelArn"].readIfPresent() ?? ""
        value.desiredModelUnits = try reader["desiredModelUnits"].readIfPresent() ?? 0
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.foundationModelArn = try reader["foundationModelArn"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelUnits = try reader["modelUnits"].readIfPresent() ?? 0
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent() ?? ""
        value.provisionedModelName = try reader["provisionedModelName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListCustomModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.CustomModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEvaluationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEvaluationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEvaluationJobsOutput()
        value.jobSummaries = try reader["jobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFoundationModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFoundationModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFoundationModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.FoundationModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListGuardrailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGuardrailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGuardrailsOutput()
        value.guardrails = try reader["guardrails"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImportedModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportedModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportedModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ImportedModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListInferenceProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInferenceProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInferenceProfilesOutput()
        value.inferenceProfileSummaries = try reader["inferenceProfileSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelCopyJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelCopyJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelCopyJobsOutput()
        value.modelCopyJobSummaries = try reader["modelCopyJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelCopyJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelCustomizationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelCustomizationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelCustomizationJobsOutput()
        value.modelCustomizationJobSummaries = try reader["modelCustomizationJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelCustomizationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelImportJobsOutput()
        value.modelImportJobSummaries = try reader["modelImportJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelImportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelInvocationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelInvocationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelInvocationJobsOutput()
        value.invocationJobSummaries = try reader["invocationJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelInvocationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListProvisionedModelThroughputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisionedModelThroughputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisionedModelThroughputsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.provisionedModelSummaries = try reader["provisionedModelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ProvisionedModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutModelInvocationLoggingConfigurationOutput {
        return PutModelInvocationLoggingConfigurationOutput()
    }
}

extension StopEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopEvaluationJobOutput {
        return StopEvaluationJobOutput()
    }
}

extension StopModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopModelCustomizationJobOutput {
        return StopModelCustomizationJobOutput()
    }
}

extension StopModelInvocationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopModelInvocationJobOutput {
        return StopModelInvocationJobOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGuardrailOutput()
        value.guardrailArn = try reader["guardrailArn"].readIfPresent() ?? ""
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProvisionedModelThroughputOutput {
        return UpdateProvisionedModelThroughputOutput()
    }
}

enum BatchDeleteEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGuardrailVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelCopyJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelCustomizationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelInvocationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImportedModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFoundationModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportedModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInferenceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelCopyJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelCustomizationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelInvocationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEvaluationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFoundationModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGuardrailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportedModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInferenceProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelCopyJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelCustomizationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelInvocationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisionedModelThroughputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopModelCustomizationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopModelInvocationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobError {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.BatchDeleteEvaluationJobError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.BatchDeleteEvaluationJobError()
        value.jobIdentifier = try reader["jobIdentifier"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.BatchDeleteEvaluationJobItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.BatchDeleteEvaluationJobItem()
        value.jobIdentifier = try reader["jobIdentifier"].readIfPresent() ?? ""
        value.jobStatus = try reader["jobStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.TrainingDataConfig {

    static func write(value: BedrockClientTypes.TrainingDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TrainingDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TrainingDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.ValidationDataConfig {

    static func write(value: BedrockClientTypes.ValidationDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["validators"].writeList(value.validators, memberWritingClosure: BedrockClientTypes.Validator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidationDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidationDataConfig()
        value.validators = try reader["validators"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Validator.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.Validator {

    static func write(value: BedrockClientTypes.Validator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.Validator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.Validator()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.OutputDataConfig {

    static func write(value: BedrockClientTypes.OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.OutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.TrainingMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TrainingMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TrainingMetrics()
        value.trainingLoss = try reader["trainingLoss"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ValidatorMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidatorMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidatorMetric()
        value.validationLoss = try reader["validationLoss"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.EvaluationConfig {

    static func write(value: BedrockClientTypes.EvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .automated(automated):
                try writer["automated"].write(automated, with: BedrockClientTypes.AutomatedEvaluationConfig.write(value:to:))
            case let .human(human):
                try writer["human"].write(human, with: BedrockClientTypes.HumanEvaluationConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "automated":
                return .automated(try reader["automated"].read(with: BedrockClientTypes.AutomatedEvaluationConfig.read(from:)))
            case "human":
                return .human(try reader["human"].read(with: BedrockClientTypes.HumanEvaluationConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.HumanEvaluationConfig {

    static func write(value: BedrockClientTypes.HumanEvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customMetrics"].writeList(value.customMetrics, memberWritingClosure: BedrockClientTypes.HumanEvaluationCustomMetric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["datasetMetricConfigs"].writeList(value.datasetMetricConfigs, memberWritingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["humanWorkflowConfig"].write(value.humanWorkflowConfig, with: BedrockClientTypes.HumanWorkflowConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanEvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanEvaluationConfig()
        value.humanWorkflowConfig = try reader["humanWorkflowConfig"].readIfPresent(with: BedrockClientTypes.HumanWorkflowConfig.read(from:))
        value.customMetrics = try reader["customMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.HumanEvaluationCustomMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.datasetMetricConfigs = try reader["datasetMetricConfigs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.EvaluationDatasetMetricConfig {

    static func write(value: BedrockClientTypes.EvaluationDatasetMetricConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataset"].write(value.dataset, with: BedrockClientTypes.EvaluationDataset.write(value:to:))
        try writer["metricNames"].writeList(value.metricNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taskType"].write(value.taskType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDatasetMetricConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationDatasetMetricConfig()
        value.taskType = try reader["taskType"].readIfPresent() ?? .sdkUnknown("")
        value.dataset = try reader["dataset"].readIfPresent(with: BedrockClientTypes.EvaluationDataset.read(from:))
        value.metricNames = try reader["metricNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.EvaluationDataset {

    static func write(value: BedrockClientTypes.EvaluationDataset?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetLocation"].write(value.datasetLocation, with: BedrockClientTypes.EvaluationDatasetLocation.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDataset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationDataset()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.datasetLocation = try reader["datasetLocation"].readIfPresent(with: BedrockClientTypes.EvaluationDatasetLocation.read(from:))
        return value
    }
}

extension BedrockClientTypes.EvaluationDatasetLocation {

    static func write(value: BedrockClientTypes.EvaluationDatasetLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3uri(s3uri):
                try writer["s3Uri"].write(s3uri)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDatasetLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3Uri":
                return .s3uri(try reader["s3Uri"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.HumanEvaluationCustomMetric {

    static func write(value: BedrockClientTypes.HumanEvaluationCustomMetric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["ratingMethod"].write(value.ratingMethod)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanEvaluationCustomMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanEvaluationCustomMetric()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.ratingMethod = try reader["ratingMethod"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.HumanWorkflowConfig {

    static func write(value: BedrockClientTypes.HumanWorkflowConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowDefinitionArn"].write(value.flowDefinitionArn)
        try writer["instructions"].write(value.instructions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanWorkflowConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanWorkflowConfig()
        value.flowDefinitionArn = try reader["flowDefinitionArn"].readIfPresent() ?? ""
        value.instructions = try reader["instructions"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedEvaluationConfig {

    static func write(value: BedrockClientTypes.AutomatedEvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetMetricConfigs"].writeList(value.datasetMetricConfigs, memberWritingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedEvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedEvaluationConfig()
        value.datasetMetricConfigs = try reader["datasetMetricConfigs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.EvaluationInferenceConfig {

    static func write(value: BedrockClientTypes.EvaluationInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .models(models):
                try writer["models"].writeList(models, memberWritingClosure: BedrockClientTypes.EvaluationModelConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationInferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "models":
                return .models(try reader["models"].readList(memberReadingClosure: BedrockClientTypes.EvaluationModelConfig.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.EvaluationModelConfig {

    static func write(value: BedrockClientTypes.EvaluationModelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bedrockmodel(bedrockmodel):
                try writer["bedrockModel"].write(bedrockmodel, with: BedrockClientTypes.EvaluationBedrockModel.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationModelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bedrockModel":
                return .bedrockmodel(try reader["bedrockModel"].read(with: BedrockClientTypes.EvaluationBedrockModel.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.EvaluationBedrockModel {

    static func write(value: BedrockClientTypes.EvaluationBedrockModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inferenceParams"].write(value.inferenceParams)
        try writer["modelIdentifier"].write(value.modelIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationBedrockModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationBedrockModel()
        value.modelIdentifier = try reader["modelIdentifier"].readIfPresent() ?? ""
        value.inferenceParams = try reader["inferenceParams"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.EvaluationOutputDataConfig {

    static func write(value: BedrockClientTypes.EvaluationOutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationOutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationOutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.FoundationModelDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelDetails()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseStreamingSupported = try reader["responseStreamingSupported"].readIfPresent()
        value.customizationsSupported = try reader["customizationsSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelCustomization>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceTypesSupported = try reader["inferenceTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.InferenceType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelLifecycle = try reader["modelLifecycle"].readIfPresent(with: BedrockClientTypes.FoundationModelLifecycle.read(from:))
        return value
    }
}

extension BedrockClientTypes.FoundationModelLifecycle {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelLifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelLifecycle()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailTopicPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailTopicPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailTopicPolicy()
        value.topics = try reader["topics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailTopic.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.GuardrailTopic {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailTopic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailTopic()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.definition = try reader["definition"].readIfPresent() ?? ""
        value.examples = try reader["examples"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailContentPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContentPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContentPolicy()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailContentFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailContentFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContentFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContentFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.inputStrength = try reader["inputStrength"].readIfPresent() ?? .sdkUnknown("")
        value.outputStrength = try reader["outputStrength"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailWordPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailWordPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailWordPolicy()
        value.words = try reader["words"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailWord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedWordLists = try reader["managedWordLists"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailManagedWords.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailManagedWords {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailManagedWords {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailManagedWords()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailWord()
        value.text = try reader["text"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.GuardrailSensitiveInformationPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailSensitiveInformationPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailSensitiveInformationPolicy()
        value.piiEntities = try reader["piiEntities"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailPiiEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.regexes = try reader["regexes"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailRegex.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailRegex {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailRegex {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailRegex()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.pattern = try reader["pattern"].readIfPresent() ?? ""
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailPiiEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailPiiEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailPiiEntity()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContextualGroundingPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContextualGroundingPolicy()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailContextualGroundingFilter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContextualGroundingFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContextualGroundingFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.threshold = try reader["threshold"].readIfPresent() ?? 0.0
        return value
    }
}

extension BedrockClientTypes.ModelDataSource {

    static func write(value: BedrockClientTypes.ModelDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3datasource(s3datasource):
                try writer["s3DataSource"].write(s3datasource, with: BedrockClientTypes.S3DataSource.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelDataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3DataSource":
                return .s3datasource(try reader["s3DataSource"].read(with: BedrockClientTypes.S3DataSource.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.S3DataSource {

    static func write(value: BedrockClientTypes.S3DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.S3DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.S3DataSource()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.InferenceProfileModel {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InferenceProfileModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.InferenceProfileModel()
        value.modelArn = try reader["modelArn"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.Tag {

    static func write(value: BedrockClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.VpcConfig {

    static func write(value: BedrockClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.VpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.VpcConfig()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.ModelInvocationJobInputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobInputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3inputdataconfig(s3inputdataconfig):
                try writer["s3InputDataConfig"].write(s3inputdataconfig, with: BedrockClientTypes.ModelInvocationJobS3InputDataConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobInputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3InputDataConfig":
                return .s3inputdataconfig(try reader["s3InputDataConfig"].read(with: BedrockClientTypes.ModelInvocationJobS3InputDataConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.ModelInvocationJobS3InputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobS3InputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketOwner"].write(value.s3BucketOwner)
        try writer["s3InputFormat"].write(value.s3InputFormat)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobS3InputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelInvocationJobS3InputDataConfig()
        value.s3InputFormat = try reader["s3InputFormat"].readIfPresent()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        value.s3BucketOwner = try reader["s3BucketOwner"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelInvocationJobOutputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobOutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3outputdataconfig(s3outputdataconfig):
                try writer["s3OutputDataConfig"].write(s3outputdataconfig, with: BedrockClientTypes.ModelInvocationJobS3OutputDataConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobOutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3OutputDataConfig":
                return .s3outputdataconfig(try reader["s3OutputDataConfig"].read(with: BedrockClientTypes.ModelInvocationJobS3OutputDataConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.ModelInvocationJobS3OutputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobS3OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketOwner"].write(value.s3BucketOwner)
        try writer["s3EncryptionKeyId"].write(value.s3EncryptionKeyId)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobS3OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelInvocationJobS3OutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        value.s3EncryptionKeyId = try reader["s3EncryptionKeyId"].readIfPresent()
        value.s3BucketOwner = try reader["s3BucketOwner"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.LoggingConfig {

    static func write(value: BedrockClientTypes.LoggingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchConfig"].write(value.cloudWatchConfig, with: BedrockClientTypes.CloudWatchConfig.write(value:to:))
        try writer["embeddingDataDeliveryEnabled"].write(value.embeddingDataDeliveryEnabled)
        try writer["imageDataDeliveryEnabled"].write(value.imageDataDeliveryEnabled)
        try writer["s3Config"].write(value.s3Config, with: BedrockClientTypes.S3Config.write(value:to:))
        try writer["textDataDeliveryEnabled"].write(value.textDataDeliveryEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.LoggingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.LoggingConfig()
        value.cloudWatchConfig = try reader["cloudWatchConfig"].readIfPresent(with: BedrockClientTypes.CloudWatchConfig.read(from:))
        value.s3Config = try reader["s3Config"].readIfPresent(with: BedrockClientTypes.S3Config.read(from:))
        value.textDataDeliveryEnabled = try reader["textDataDeliveryEnabled"].readIfPresent()
        value.imageDataDeliveryEnabled = try reader["imageDataDeliveryEnabled"].readIfPresent()
        value.embeddingDataDeliveryEnabled = try reader["embeddingDataDeliveryEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.S3Config {

    static func write(value: BedrockClientTypes.S3Config?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["keyPrefix"].write(value.keyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.S3Config {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.S3Config()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.keyPrefix = try reader["keyPrefix"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.CloudWatchConfig {

    static func write(value: BedrockClientTypes.CloudWatchConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["largeDataDeliveryS3Config"].write(value.largeDataDeliveryS3Config, with: BedrockClientTypes.S3Config.write(value:to:))
        try writer["logGroupName"].write(value.logGroupName)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CloudWatchConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CloudWatchConfig()
        value.logGroupName = try reader["logGroupName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.largeDataDeliveryS3Config = try reader["largeDataDeliveryS3Config"].readIfPresent(with: BedrockClientTypes.S3Config.read(from:))
        return value
    }
}

extension BedrockClientTypes.CustomModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.baseModelName = try reader["baseModelName"].readIfPresent() ?? ""
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.EvaluationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobType = try reader["jobType"].readIfPresent() ?? .sdkUnknown("")
        value.evaluationTaskTypes = try reader["evaluationTaskTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.EvaluationTaskType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.modelIdentifiers = try reader["modelIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.FoundationModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseStreamingSupported = try reader["responseStreamingSupported"].readIfPresent()
        value.customizationsSupported = try reader["customizationsSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelCustomization>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceTypesSupported = try reader["inferenceTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.InferenceType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelLifecycle = try reader["modelLifecycle"].readIfPresent(with: BedrockClientTypes.FoundationModelLifecycle.read(from:))
        return value
    }
}

extension BedrockClientTypes.GuardrailSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.version = try reader["version"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.ImportedModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ImportedModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ImportedModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.InferenceProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InferenceProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.InferenceProfileSummary()
        value.inferenceProfileName = try reader["inferenceProfileName"].readIfPresent() ?? ""
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceProfileModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.inferenceProfileArn = try reader["inferenceProfileArn"].readIfPresent() ?? ""
        value.inferenceProfileId = try reader["inferenceProfileId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.ModelCopyJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelCopyJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelCopyJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.targetModelArn = try reader["targetModelArn"].readIfPresent() ?? ""
        value.targetModelName = try reader["targetModelName"].readIfPresent()
        value.sourceAccountId = try reader["sourceAccountId"].readIfPresent() ?? ""
        value.sourceModelArn = try reader["sourceModelArn"].readIfPresent() ?? ""
        value.targetModelKmsKeyArn = try reader["targetModelKmsKeyArn"].readIfPresent()
        value.targetModelTags = try reader["targetModelTags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.sourceModelName = try reader["sourceModelName"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelCustomizationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelCustomizationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelCustomizationJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customModelArn = try reader["customModelArn"].readIfPresent()
        value.customModelName = try reader["customModelName"].readIfPresent()
        value.customizationType = try reader["customizationType"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelImportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelImportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelImportJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.importedModelArn = try reader["importedModelArn"].readIfPresent()
        value.importedModelName = try reader["importedModelName"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelInvocationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelInvocationJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.submitTime = try reader["submitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.inputDataConfig = try reader["inputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobInputDataConfig.read(from:))
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobOutputDataConfig.read(from:))
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        value.timeoutDurationInHours = try reader["timeoutDurationInHours"].readIfPresent()
        value.jobExpirationTime = try reader["jobExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockClientTypes.ProvisionedModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ProvisionedModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ProvisionedModelSummary()
        value.provisionedModelName = try reader["provisionedModelName"].readIfPresent() ?? ""
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent() ?? ""
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.desiredModelArn = try reader["desiredModelArn"].readIfPresent() ?? ""
        value.foundationModelArn = try reader["foundationModelArn"].readIfPresent() ?? ""
        value.modelUnits = try reader["modelUnits"].readIfPresent() ?? 0
        value.desiredModelUnits = try reader["desiredModelUnits"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.commitmentDuration = try reader["commitmentDuration"].readIfPresent()
        value.commitmentExpirationTime = try reader["commitmentExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.GuardrailTopicPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailTopicPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["topicsConfig"].writeList(value.topicsConfig, memberWritingClosure: BedrockClientTypes.GuardrailTopicConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailTopicConfig {

    static func write(value: BedrockClientTypes.GuardrailTopicConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["examples"].writeList(value.examples, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailContentPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailContentPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filtersConfig"].writeList(value.filtersConfig, memberWritingClosure: BedrockClientTypes.GuardrailContentFilterConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailContentFilterConfig {

    static func write(value: BedrockClientTypes.GuardrailContentFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputStrength"].write(value.inputStrength)
        try writer["outputStrength"].write(value.outputStrength)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailWordPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailWordPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["managedWordListsConfig"].writeList(value.managedWordListsConfig, memberWritingClosure: BedrockClientTypes.GuardrailManagedWordsConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["wordsConfig"].writeList(value.wordsConfig, memberWritingClosure: BedrockClientTypes.GuardrailWordConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailManagedWordsConfig {

    static func write(value: BedrockClientTypes.GuardrailManagedWordsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailWordConfig {

    static func write(value: BedrockClientTypes.GuardrailWordConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["text"].write(value.text)
    }
}

extension BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["piiEntitiesConfig"].writeList(value.piiEntitiesConfig, memberWritingClosure: BedrockClientTypes.GuardrailPiiEntityConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["regexesConfig"].writeList(value.regexesConfig, memberWritingClosure: BedrockClientTypes.GuardrailRegexConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailRegexConfig {

    static func write(value: BedrockClientTypes.GuardrailRegexConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["pattern"].write(value.pattern)
    }
}

extension BedrockClientTypes.GuardrailPiiEntityConfig {

    static func write(value: BedrockClientTypes.GuardrailPiiEntityConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filtersConfig"].writeList(value.filtersConfig, memberWritingClosure: BedrockClientTypes.GuardrailContextualGroundingFilterConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingFilterConfig {

    static func write(value: BedrockClientTypes.GuardrailContextualGroundingFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["threshold"].write(value.threshold)
        try writer["type"].write(value.type)
    }
}

public enum BedrockClientTypes {}
