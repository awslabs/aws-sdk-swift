//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockClientTypes {

    public enum InputTags: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case honor
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [InputTags] {
            return [
                .honor,
                .ignore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .honor: return "HONOR"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Account-level enforced guardrail input configuration.
    public struct AccountEnforcedGuardrailInferenceInputConfiguration: Swift.Sendable {
        /// Identifier for the guardrail, could be the ID or the ARN.
        /// This member is required.
        public var guardrailIdentifier: Swift.String?
        /// Numerical guardrail version.
        /// This member is required.
        public var guardrailVersion: Swift.String?
        /// Whether to honor or ignore input tags at runtime.
        /// This member is required.
        public var inputTags: BedrockClientTypes.InputTags?

        public init(
            guardrailIdentifier: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil,
            inputTags: BedrockClientTypes.InputTags? = nil
        ) {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.inputTags = inputTags
        }
    }
}

extension BedrockClientTypes {

    public enum ConfigurationOwner: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Configuration owned by the account
        case account
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationOwner] {
            return [
                .account
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Account enforced guardrail output configuration.
    public struct AccountEnforcedGuardrailOutputConfiguration: Swift.Sendable {
        /// Unique ID for the account enforced configuration.
        public var configId: Swift.String?
        /// Timestamp.
        public var createdAt: Foundation.Date?
        /// The ARN of the role used to update the configuration.
        public var createdBy: Swift.String?
        /// ARN representation for the guardrail.
        public var guardrailArn: Swift.String?
        /// Unique ID for the guardrail.
        public var guardrailId: Swift.String?
        /// Numerical guardrail version.
        public var guardrailVersion: Swift.String?
        /// Whether to honor or ignore input tags at runtime.
        public var inputTags: BedrockClientTypes.InputTags?
        /// Configuration owner type.
        public var owner: BedrockClientTypes.ConfigurationOwner?
        /// Timestamp.
        public var updatedAt: Foundation.Date?
        /// The ARN of the role used to update the configuration.
        public var updatedBy: Swift.String?

        public init(
            configId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            guardrailArn: Swift.String? = nil,
            guardrailId: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil,
            inputTags: BedrockClientTypes.InputTags? = nil,
            owner: BedrockClientTypes.ConfigurationOwner? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        ) {
            self.configId = configId
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.guardrailArn = guardrailArn
            self.guardrailId = guardrailId
            self.guardrailVersion = guardrailVersion
            self.inputTags = inputTags
            self.owner = owner
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

extension BedrockClientTypes {

    public enum AgreementStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case error
        case notAvailable
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [AgreementStatus] {
            return [
                .available,
                .error,
                .notAvailable,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Information about the agreement availability
    public struct AgreementAvailability: Swift.Sendable {
        /// Error message.
        public var errorMessage: Swift.String?
        /// Status of the agreement.
        /// This member is required.
        public var status: BedrockClientTypes.AgreementStatus?

        public init(
            errorMessage: Swift.String? = nil,
            status: BedrockClientTypes.AgreementStatus? = nil
        ) {
            self.errorMessage = errorMessage
            self.status = status
        }
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct GetUseCaseForModelAccessInput: Swift.Sendable {

    public init() { }
}

public struct GetUseCaseForModelAccessOutput: Swift.Sendable {
    /// Get customer profile Response.
    /// This member is required.
    public var formData: Foundation.Data?

    public init(
        formData: Foundation.Data? = nil
    ) {
        self.formData = formData
    }
}

public struct PutUseCaseForModelAccessInput: Swift.Sendable {
    /// Put customer profile Request.
    /// This member is required.
    public var formData: Foundation.Data?

    public init(
        formData: Foundation.Data? = nil
    ) {
        self.formData = formData
    }
}

public struct PutUseCaseForModelAccessOutput: Swift.Sendable {

    public init() { }
}

public struct CancelAutomatedReasoningPolicyBuildWorkflowInput: Swift.Sendable {
    /// The unique identifier of the build workflow to cancel. You can get this ID from the StartAutomatedReasoningPolicyBuildWorkflow response or by listing build workflows.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy whose build workflow you want to cancel.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        buildWorkflowId: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.policyArn = policyArn
    }
}

public struct CancelAutomatedReasoningPolicyBuildWorkflowOutput: Swift.Sendable {

    public init() { }
}

/// Error occurred because of a conflict while performing an operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request contains more tags than can be associated with a resource (50 tags per resource). The maximum number of tags includes both existing tags and those included in your current request.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource with too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension BedrockClientTypes {

    /// Represents a formal logic rule in an Automated Reasoning policy. For example, rules can be expressed as if-then statements that define logical constraints.
    public struct AutomatedReasoningPolicyDefinitionRule: Swift.Sendable {
        /// The human-readable form of the rule expression, often in natural language or simplified notation.
        public var alternateExpression: Swift.String?
        /// The formal logic expression of the rule.
        /// This member is required.
        public var expression: Swift.String?
        /// The unique identifier of the rule within the policy.
        /// This member is required.
        public var id: Swift.String?

        public init(
            alternateExpression: Swift.String? = nil,
            expression: Swift.String? = nil,
            id: Swift.String? = nil
        ) {
            self.alternateExpression = alternateExpression
            self.expression = expression
            self.id = id
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDefinitionRule(id: \(Swift.String(describing: id)), alternateExpression: \"CONTENT_REDACTED\", expression: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Represents a single value within a custom type definition, including its identifier and description.
    public struct AutomatedReasoningPolicyDefinitionTypeValue: Swift.Sendable {
        /// A human-readable description explaining what this type value represents and when it should be used.
        public var description: Swift.String?
        /// The actual value or identifier for this type value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            description: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.description = description
            self.value = value
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDefinitionTypeValue(value: \(Swift.String(describing: value)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Represents a custom user-defined viarble type in an Automated Reasoning policy. Types are enum-based and provide additional context beyond predefined variable types.
    public struct AutomatedReasoningPolicyDefinitionType: Swift.Sendable {
        /// The description of what the custom type represents.
        public var description: Swift.String?
        /// The name of the custom type.
        /// This member is required.
        public var name: Swift.String?
        /// The possible values for this enum-based type, each with its own description.
        /// This member is required.
        public var values: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            values: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue]? = nil
        ) {
            self.description = description
            self.name = name
            self.values = values
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDefinitionType(values: \(Swift.String(describing: values)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Represents a variable in an Automated Reasoning policy. Variables represent concepts that can have values assigned during natural language translation.
    public struct AutomatedReasoningPolicyDefinitionVariable: Swift.Sendable {
        /// The description of the variable that explains what it represents and how users might refer to it. Clear and comprehensive descriptions are essential for accurate natural language translation.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the variable. Use descriptive names that clearly indicate the concept being represented.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the variable. Valid types include bool, int, real, enum, and custom types that you can provide.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        ) {
            self.description = description
            self.name = name
            self.type = type
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDefinitionVariable(description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains the formal logic rules, variables, and custom variable types that define an Automated Reasoning policy. The policy definition specifies the constraints used to validate foundation model responses for accuracy and logical consistency.
    public struct AutomatedReasoningPolicyDefinition: Swift.Sendable {
        /// The formal logic rules extracted from the source document. Rules define the logical constraints that determine whether model responses are valid, invalid, or satisfiable.
        public var rules: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule]?
        /// The custom user-defined vairable types used in the policy. Types are enum-based variable types that provide additional context beyond the predefined variable types.
        public var types: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionType]?
        /// The variables that represent concepts in the policy. Variables can have values assigned when translating natural language into formal logic. Their descriptions are crucial for accurate translation.
        public var variables: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable]?
        /// The version of the policy definition format.
        public var version: Swift.String?

        public init(
            rules: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule]? = nil,
            types: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionType]? = nil,
            variables: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable]? = nil,
            version: Swift.String? = "1"
        ) {
            self.rules = rules
            self.types = types
            self.variables = variables
            self.version = version
        }
    }
}

extension BedrockClientTypes {

    /// Definition of the key/value pair for a tag.
    public struct Tag: Swift.Sendable {
        /// Key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// Value for the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateAutomatedReasoningPolicyInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request but doesn't return an error.
    public var clientRequestToken: Swift.String?
    /// A description of the Automated Reasoning policy. Use this to provide context about the policy's purpose and the types of validations it performs.
    public var description: Swift.String?
    /// The identifier of the KMS key to use for encrypting the automated reasoning policy and its associated artifacts. If you don't specify a KMS key, Amazon Bedrock uses an KMS managed key for encryption. For enhanced security and control, you can specify a customer managed KMS key.
    public var kmsKeyId: Swift.String?
    /// A unique name for the Automated Reasoning policy. The name must be between 1 and 63 characters and can contain letters, numbers, hyphens, and underscores.
    /// This member is required.
    public var name: Swift.String?
    /// The policy definition that contains the formal logic rules, variables, and custom variable types used to validate foundation model responses in your application.
    public var policyDefinition: BedrockClientTypes.AutomatedReasoningPolicyDefinition?
    /// A list of tags to associate with the Automated Reasoning policy. Tags help you organize and manage your policies.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        policyDefinition: BedrockClientTypes.AutomatedReasoningPolicyDefinition? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.policyDefinition = policyDefinition
        self.tags = tags
    }
}

extension CreateAutomatedReasoningPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAutomatedReasoningPolicyInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), policyDefinition: \(Swift.String(describing: policyDefinition)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateAutomatedReasoningPolicyOutput: Swift.Sendable {
    /// The timestamp when the policy was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The hash of the policy definition. This is used as a concurrency token for creating policy versions that you can use in your application.
    public var definitionHash: Swift.String?
    /// The description of the Automated Reasoning policy.
    public var description: Swift.String?
    /// The name of the Automated Reasoning policy.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy that you created.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The timestamp when the policy was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version number of the newly created Automated Reasoning policy. The initial version is always DRAFT.
    /// This member is required.
    public var version: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        definitionHash: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.definitionHash = definitionHash
        self.description = description
        self.name = name
        self.policyArn = policyArn
        self.updatedAt = updatedAt
        self.version = version
    }
}

extension CreateAutomatedReasoningPolicyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAutomatedReasoningPolicyOutput(createdAt: \(Swift.String(describing: createdAt)), definitionHash: \(Swift.String(describing: definitionHash)), policyArn: \(Swift.String(describing: policyArn)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum AutomatedReasoningCheckResult: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case impossible
        case invalid
        case noTranslation
        case satisfiable
        case tooComplex
        case translationAmbiguous
        case valid
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningCheckResult] {
            return [
                .impossible,
                .invalid,
                .noTranslation,
                .satisfiable,
                .tooComplex,
                .translationAmbiguous,
                .valid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .impossible: return "IMPOSSIBLE"
            case .invalid: return "INVALID"
            case .noTranslation: return "NO_TRANSLATION"
            case .satisfiable: return "SATISFIABLE"
            case .tooComplex: return "TOO_COMPLEX"
            case .translationAmbiguous: return "TRANSLATION_AMBIGUOUS"
            case .valid: return "VALID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAutomatedReasoningPolicyTestCaseInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    public var clientRequestToken: Swift.String?
    /// The minimum confidence level for logic validation. Content that meets the threshold is considered a high-confidence finding that can be validated.
    public var confidenceThreshold: Swift.Double?
    /// The expected result of the Automated Reasoning check. Valid values include: , TOO_COMPLEX, and NO_TRANSLATIONS.
    ///
    /// * VALID - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.
    ///
    /// * INVALID - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.
    ///
    /// * SATISFIABLE - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.
    ///
    /// * IMPOSSIBLE - Automated Reasoning canâ€™t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.
    ///
    /// * TRANSLATION_AMBIGUOUS - Detected an ambiguity in the translation meant it would be unsound to continue with validity checking. Additional context or follow-up questions might be needed to get translation to succeed.
    ///
    /// * TOO_COMPLEX - The input contains too much information for Automated Reasoning to process within its latency limits.
    ///
    /// * NO_TRANSLATIONS - Identifies that some or all of the input prompt wasn't translated into logic. This can happen if the input isn't relevant to the Automated Reasoning policy, or if the policy doesn't have variables to model relevant input. If Automated Reasoning can't translate anything, you get a single NO_TRANSLATIONS finding. You might also see a NO_TRANSLATIONS (along with other findings) if some part of the validation isn't translated.
    /// This member is required.
    public var expectedAggregatedFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult?
    /// The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.
    /// This member is required.
    public var guardContent: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy for which to create the test.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The input query or prompt that generated the content. This provides context for the validation.
    public var queryContent: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        confidenceThreshold: Swift.Double? = nil,
        expectedAggregatedFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult? = nil,
        guardContent: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        queryContent: Swift.String? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.confidenceThreshold = confidenceThreshold
        self.expectedAggregatedFindingsResult = expectedAggregatedFindingsResult
        self.guardContent = guardContent
        self.policyArn = policyArn
        self.queryContent = queryContent
    }
}

extension CreateAutomatedReasoningPolicyTestCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAutomatedReasoningPolicyTestCaseInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), confidenceThreshold: \(Swift.String(describing: confidenceThreshold)), expectedAggregatedFindingsResult: \(Swift.String(describing: expectedAggregatedFindingsResult)), policyArn: \(Swift.String(describing: policyArn)), guardContent: \"CONTENT_REDACTED\", queryContent: \"CONTENT_REDACTED\")"}
}

public struct CreateAutomatedReasoningPolicyTestCaseOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the policy for which the test was created.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The unique identifier of the created test.
    /// This member is required.
    public var testCaseId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        testCaseId: Swift.String? = nil
    ) {
        self.policyArn = policyArn
        self.testCaseId = testCaseId
    }
}

public struct CreateAutomatedReasoningPolicyVersionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    public var clientRequestToken: Swift.String?
    /// The hash of the current policy definition used as a concurrency token to ensure the policy hasn't been modified since you last retrieved it.
    /// This member is required.
    public var lastUpdatedDefinitionHash: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy for which to create a version.
    /// This member is required.
    public var policyArn: Swift.String?
    /// A list of tags to associate with the policy version.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        lastUpdatedDefinitionHash: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.lastUpdatedDefinitionHash = lastUpdatedDefinitionHash
        self.policyArn = policyArn
        self.tags = tags
    }
}

public struct CreateAutomatedReasoningPolicyVersionOutput: Swift.Sendable {
    /// The timestamp when the policy version was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The hash of the policy definition for this version.
    /// This member is required.
    public var definitionHash: Swift.String?
    /// The description of the policy version.
    public var description: Swift.String?
    /// The name of the policy version.
    /// This member is required.
    public var name: Swift.String?
    /// The versioned Amazon Resource Name (ARN) of the policy version.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The version number of the policy version.
    /// This member is required.
    public var version: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        definitionHash: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        version: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.definitionHash = definitionHash
        self.description = description
        self.name = name
        self.policyArn = policyArn
        self.version = version
    }
}

extension CreateAutomatedReasoningPolicyVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAutomatedReasoningPolicyVersionOutput(createdAt: \(Swift.String(describing: createdAt)), definitionHash: \(Swift.String(describing: definitionHash)), policyArn: \(Swift.String(describing: policyArn)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

/// Thrown when attempting to delete or modify a resource that is currently being used by other resources or operations. For example, trying to delete an Automated Reasoning policy that is referenced by an active guardrail.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DeleteAutomatedReasoningPolicyInput: Swift.Sendable {
    /// Specifies whether to force delete the automated reasoning policy even if it has active resources. When false, Amazon Bedrock validates if all artifacts have been deleted (e.g. policy version, test case, test result) for a policy before deletion. When true, Amazon Bedrock will delete the policy and all its artifacts without validation. Default is false.
    public var force: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy to delete.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.force = force
        self.policyArn = policyArn
    }
}

public struct DeleteAutomatedReasoningPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAutomatedReasoningPolicyBuildWorkflowInput: Swift.Sendable {
    /// The unique identifier of the build workflow to delete.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The timestamp when the build workflow was last updated. This is used for optimistic concurrency control to prevent accidental deletion of workflows that have been modified.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy whose build workflow you want to delete.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        buildWorkflowId: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.lastUpdatedAt = lastUpdatedAt
        self.policyArn = policyArn
    }
}

public struct DeleteAutomatedReasoningPolicyBuildWorkflowOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAutomatedReasoningPolicyTestCaseInput: Swift.Sendable {
    /// The timestamp when the test was last updated. This is used as a concurrency token to prevent conflicting modifications.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy that contains the test.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The unique identifier of the test to delete.
    /// This member is required.
    public var testCaseId: Swift.String?

    public init(
        lastUpdatedAt: Foundation.Date? = nil,
        policyArn: Swift.String? = nil,
        testCaseId: Swift.String? = nil
    ) {
        self.lastUpdatedAt = lastUpdatedAt
        self.policyArn = policyArn
        self.testCaseId = testCaseId
    }
}

public struct DeleteAutomatedReasoningPolicyTestCaseOutput: Swift.Sendable {

    public init() { }
}

public struct ExportAutomatedReasoningPolicyVersionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy to export. Can be either the unversioned ARN for the draft policy or a versioned ARN for a specific policy version.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    ) {
        self.policyArn = policyArn
    }
}

public struct ExportAutomatedReasoningPolicyVersionOutput: Swift.Sendable {
    /// The exported policy definition containing the formal logic rules, variables, and custom variable types.
    /// This member is required.
    public var policyDefinition: BedrockClientTypes.AutomatedReasoningPolicyDefinition?

    public init(
        policyDefinition: BedrockClientTypes.AutomatedReasoningPolicyDefinition? = nil
    ) {
        self.policyDefinition = policyDefinition
    }
}

public struct GetAutomatedReasoningPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy to retrieve. Can be either the unversioned ARN for the draft policy or an ARN for a specific policy version.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    ) {
        self.policyArn = policyArn
    }
}

public struct GetAutomatedReasoningPolicyOutput: Swift.Sendable {
    /// The timestamp when the policy was created.
    public var createdAt: Foundation.Date?
    /// The hash of the policy definition used as a concurrency token.
    /// This member is required.
    public var definitionHash: Swift.String?
    /// The description of the policy.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the automated reasoning policy and its associated artifacts. If a KMS key is not provided during the initial CreateAutomatedReasoningPolicyRequest, the kmsKeyArn won't be included in the GetAutomatedReasoningPolicyResponse.
    public var kmsKeyArn: Swift.String?
    /// The name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the policy.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The unique identifier of the policy.
    /// This member is required.
    public var policyId: Swift.String?
    /// The timestamp when the policy was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version of the policy.
    /// This member is required.
    public var version: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        definitionHash: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        policyId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.definitionHash = definitionHash
        self.description = description
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.policyArn = policyArn
        self.policyId = policyId
        self.updatedAt = updatedAt
        self.version = version
    }
}

extension GetAutomatedReasoningPolicyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAutomatedReasoningPolicyOutput(createdAt: \(Swift.String(describing: createdAt)), definitionHash: \(Swift.String(describing: definitionHash)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), policyArn: \(Swift.String(describing: policyArn)), policyId: \(Swift.String(describing: policyId)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct GetAutomatedReasoningPolicyAnnotationsInput: Swift.Sendable {
    /// The unique identifier of the build workflow whose annotations you want to retrieve.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy whose annotations you want to retrieve.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        buildWorkflowId: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.policyArn = policyArn
    }
}

extension BedrockClientTypes {

    /// An annotation for adding a new rule to an Automated Reasoning policy using a formal logical expression.
    public struct AutomatedReasoningPolicyAddRuleAnnotation: Swift.Sendable {
        /// The formal logical expression that defines the rule, using mathematical notation and referencing policy variables and types.
        /// This member is required.
        public var expression: Swift.String?

        public init(
            expression: Swift.String? = nil
        ) {
            self.expression = expression
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddRuleAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyAddRuleAnnotation(expression: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for adding a new rule to the policy by converting a natural language description into a formal logical expression.
    public struct AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation: Swift.Sendable {
        /// The natural language description of the rule that should be converted into a formal logical expression.
        /// This member is required.
        public var naturalLanguage: Swift.String?

        public init(
            naturalLanguage: Swift.String? = nil
        ) {
            self.naturalLanguage = naturalLanguage
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation(naturalLanguage: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for adding a new custom type to an Automated Reasoning policy, defining a set of possible values for variables.
    public struct AutomatedReasoningPolicyAddTypeAnnotation: Swift.Sendable {
        /// A description of what the custom type represents and how it should be used in the policy.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the new custom type. This name will be used to reference the type in variable definitions and rules.
        /// This member is required.
        public var name: Swift.String?
        /// The list of possible values that variables of this type can take, each with its own description and identifier.
        /// This member is required.
        public var values: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            values: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue]? = nil
        ) {
            self.description = description
            self.name = name
            self.values = values
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddTypeAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyAddTypeAnnotation(values: \(Swift.String(describing: values)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for adding a new variable to an Automated Reasoning policy, which can be used in rule expressions.
    public struct AutomatedReasoningPolicyAddVariableAnnotation: Swift.Sendable {
        /// A description of what the variable represents and how it should be used in rules.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the new variable. This name will be used to reference the variable in rule expressions.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the variable, which can be a built-in type (like string or number) or a custom type defined in the policy.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        ) {
            self.description = description
            self.name = name
            self.type = type
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddVariableAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyAddVariableAnnotation(description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", type: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for removing a rule from an Automated Reasoning policy.
    public struct AutomatedReasoningPolicyDeleteRuleAnnotation: Swift.Sendable {
        /// The unique identifier of the rule to delete from the policy.
        /// This member is required.
        public var ruleId: Swift.String?

        public init(
            ruleId: Swift.String? = nil
        ) {
            self.ruleId = ruleId
        }
    }
}

extension BedrockClientTypes {

    /// An annotation for removing a custom type from an Automated Reasoning policy.
    public struct AutomatedReasoningPolicyDeleteTypeAnnotation: Swift.Sendable {
        /// The name of the custom type to delete from the policy. The type must not be referenced by any variables or rules.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDeleteTypeAnnotation(name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for removing a variable from an Automated Reasoning policy.
    public struct AutomatedReasoningPolicyDeleteVariableAnnotation: Swift.Sendable {
        /// The name of the variable to delete from the policy. The variable must not be referenced by any rules.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDeleteVariableAnnotation(name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for processing and incorporating new content into an Automated Reasoning policy.
    public struct AutomatedReasoningPolicyIngestContentAnnotation: Swift.Sendable {
        /// The new content to be analyzed and incorporated into the policy, such as additional documents or rule descriptions.
        /// This member is required.
        public var content: Swift.String?

        public init(
            content: Swift.String? = nil
        ) {
            self.content = content
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyIngestContentAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyIngestContentAnnotation(content: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for updating the policy based on feedback about how specific rules performed during testing or real-world usage.
    public struct AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation: Swift.Sendable {
        /// The feedback information about rule performance, including suggestions for improvements or corrections.
        /// This member is required.
        public var feedback: Swift.String?
        /// The list of rule identifiers that the feedback applies to.
        public var ruleIds: [Swift.String]?

        public init(
            feedback: Swift.String? = nil,
            ruleIds: [Swift.String]? = nil
        ) {
            self.feedback = feedback
            self.ruleIds = ruleIds
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation(ruleIds: \(Swift.String(describing: ruleIds)), feedback: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for updating the policy based on feedback about how it performed on specific test scenarios.
    public struct AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation: Swift.Sendable {
        /// The feedback information about scenario performance, including any issues or improvements identified.
        public var feedback: Swift.String?
        /// The list of rule identifiers that were involved in the scenario being evaluated.
        public var ruleIds: [Swift.String]?
        /// The logical expression that defines the test scenario that generated this feedback.
        /// This member is required.
        public var scenarioExpression: Swift.String?

        public init(
            feedback: Swift.String? = nil,
            ruleIds: [Swift.String]? = nil,
            scenarioExpression: Swift.String? = nil
        ) {
            self.feedback = feedback
            self.ruleIds = ruleIds
            self.scenarioExpression = scenarioExpression
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation(ruleIds: \(Swift.String(describing: ruleIds)), feedback: \"CONTENT_REDACTED\", scenarioExpression: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for modifying an existing rule in an Automated Reasoning policy.
    public struct AutomatedReasoningPolicyUpdateRuleAnnotation: Swift.Sendable {
        /// The new formal logical expression for the rule, replacing the previous expression.
        /// This member is required.
        public var expression: Swift.String?
        /// The unique identifier of the rule to update.
        /// This member is required.
        public var ruleId: Swift.String?

        public init(
            expression: Swift.String? = nil,
            ruleId: Swift.String? = nil
        ) {
            self.expression = expression
            self.ruleId = ruleId
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyUpdateRuleAnnotation(ruleId: \(Swift.String(describing: ruleId)), expression: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Represents a single value that can be added to an existing custom type in the policy.
    public struct AutomatedReasoningPolicyAddTypeValue: Swift.Sendable {
        /// A description of what this new type value represents and when it should be used.
        public var description: Swift.String?
        /// The identifier or name of the new value to add to the type.
        /// This member is required.
        public var value: Swift.String?

        public init(
            description: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.description = description
            self.value = value
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddTypeValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyAddTypeValue(value: \(Swift.String(describing: value)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Represents a value to be removed from an existing custom type in the policy.
    public struct AutomatedReasoningPolicyDeleteTypeValue: Swift.Sendable {
        /// The identifier or name of the value to remove from the type.
        /// This member is required.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        ) {
            self.value = value
        }
    }
}

extension BedrockClientTypes {

    /// Represents a modification to a value within an existing custom type.
    public struct AutomatedReasoningPolicyUpdateTypeValue: Swift.Sendable {
        /// The new description for the type value, replacing the previous description.
        public var description: Swift.String?
        /// The new identifier or name for the type value, if you want to rename it.
        public var newValue: Swift.String?
        /// The current identifier or name of the type value to update.
        /// This member is required.
        public var value: Swift.String?

        public init(
            description: Swift.String? = nil,
            newValue: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.description = description
            self.newValue = newValue
            self.value = value
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyUpdateTypeValue(newValue: \(Swift.String(describing: newValue)), value: \(Swift.String(describing: value)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for managing values within custom types, including adding, updating, or removing specific type values.
    public enum AutomatedReasoningPolicyTypeValueAnnotation: Swift.Sendable {
        /// An operation to add a new value to an existing custom type.
        case addtypevalue(BedrockClientTypes.AutomatedReasoningPolicyAddTypeValue)
        /// An operation to modify an existing value within a custom type.
        case updatetypevalue(BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeValue)
        /// An operation to remove a value from an existing custom type.
        case deletetypevalue(BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeValue)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// An annotation for modifying an existing custom type in an Automated Reasoning policy.
    public struct AutomatedReasoningPolicyUpdateTypeAnnotation: Swift.Sendable {
        /// The new description for the custom type, replacing the previous description.
        public var description: Swift.String?
        /// The current name of the custom type to update.
        /// This member is required.
        public var name: Swift.String?
        /// The new name for the custom type, if you want to rename it. If not provided, the name remains unchanged.
        public var newName: Swift.String?
        /// The updated list of values for the custom type, which can include additions, modifications, or removals.
        /// This member is required.
        public var values: [BedrockClientTypes.AutomatedReasoningPolicyTypeValueAnnotation]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            newName: Swift.String? = nil,
            values: [BedrockClientTypes.AutomatedReasoningPolicyTypeValueAnnotation]? = nil
        ) {
            self.description = description
            self.name = name
            self.newName = newName
            self.values = values
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyUpdateTypeAnnotation(values: \(Swift.String(describing: values)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", newName: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// An annotation for modifying an existing variable in an Automated Reasoning policy.
    public struct AutomatedReasoningPolicyUpdateVariableAnnotation: Swift.Sendable {
        /// The new description for the variable, replacing the previous description.
        public var description: Swift.String?
        /// The current name of the variable to update.
        /// This member is required.
        public var name: Swift.String?
        /// The new name for the variable, if you want to rename it. If not provided, the name remains unchanged.
        public var newName: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            newName: Swift.String? = nil
        ) {
            self.description = description
            self.name = name
            self.newName = newName
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableAnnotation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyUpdateVariableAnnotation(description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", newName: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains the various operations that can be performed on an Automated Reasoning policy, including adding, updating, and deleting rules, variables, and types.
    public enum AutomatedReasoningPolicyAnnotation: Swift.Sendable {
        /// An operation to add a new custom type to the policy, defining a set of possible values for policy variables.
        case addtype(BedrockClientTypes.AutomatedReasoningPolicyAddTypeAnnotation)
        /// An operation to modify an existing custom type in the policy, such as changing its name, description, or allowed values.
        case updatetype(BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeAnnotation)
        /// An operation to remove a custom type from the policy. The type must not be referenced by any variables or rules.
        case deletetype(BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeAnnotation)
        /// An operation to add a new variable to the policy, which can be used in rule expressions to represent dynamic values.
        case addvariable(BedrockClientTypes.AutomatedReasoningPolicyAddVariableAnnotation)
        /// An operation to modify an existing variable in the policy, such as changing its name, type, or description.
        case updatevariable(BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableAnnotation)
        /// An operation to remove a variable from the policy. The variable must not be referenced by any rules.
        case deletevariable(BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableAnnotation)
        /// An operation to add a new logical rule to the policy using formal mathematical expressions.
        case addrule(BedrockClientTypes.AutomatedReasoningPolicyAddRuleAnnotation)
        /// An operation to modify an existing rule in the policy, such as changing its logical expression or conditions.
        case updaterule(BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleAnnotation)
        /// An operation to remove a rule from the policy.
        case deleterule(BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleAnnotation)
        /// An operation to add a new rule by converting natural language descriptions into formal logical expressions.
        case addrulefromnaturallanguage(BedrockClientTypes.AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation)
        /// An operation to update the policy based on feedback about how specific rules performed during testing or validation.
        case updatefromrulesfeedback(BedrockClientTypes.AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation)
        /// An operation to update the policy based on feedback about how it performed on specific test scenarios.
        case updatefromscenariofeedback(BedrockClientTypes.AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation)
        /// An operation to process and incorporate new content into the policy, extracting additional rules and concepts.
        case ingestcontent(BedrockClientTypes.AutomatedReasoningPolicyIngestContentAnnotation)
        case sdkUnknown(Swift.String)
    }
}

public struct GetAutomatedReasoningPolicyAnnotationsOutput: Swift.Sendable {
    /// A hash value representing the current state of the annotations. This is used for optimistic concurrency control when updating annotations.
    /// This member is required.
    public var annotationSetHash: Swift.String?
    /// The current set of annotations containing rules, variables, and types extracted from the source documents. These can be modified before finalizing the policy.
    /// This member is required.
    public var annotations: [BedrockClientTypes.AutomatedReasoningPolicyAnnotation]?
    /// The unique identifier of the build workflow.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The name of the Automated Reasoning policy.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The timestamp when the annotations were last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        annotationSetHash: Swift.String? = nil,
        annotations: [BedrockClientTypes.AutomatedReasoningPolicyAnnotation]? = nil,
        buildWorkflowId: Swift.String? = nil,
        name: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.annotationSetHash = annotationSetHash
        self.annotations = annotations
        self.buildWorkflowId = buildWorkflowId
        self.name = name
        self.policyArn = policyArn
        self.updatedAt = updatedAt
    }
}

extension GetAutomatedReasoningPolicyAnnotationsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAutomatedReasoningPolicyAnnotationsOutput(annotationSetHash: \(Swift.String(describing: annotationSetHash)), annotations: \(Swift.String(describing: annotations)), buildWorkflowId: \(Swift.String(describing: buildWorkflowId)), policyArn: \(Swift.String(describing: policyArn)), updatedAt: \(Swift.String(describing: updatedAt)), name: \"CONTENT_REDACTED\")"}
}

public struct GetAutomatedReasoningPolicyBuildWorkflowInput: Swift.Sendable {
    /// The unique identifier of the build workflow to retrieve.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy whose build workflow you want to retrieve.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        buildWorkflowId: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.policyArn = policyArn
    }
}

extension BedrockClientTypes {

    public enum AutomatedReasoningPolicyBuildWorkflowType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case importPolicy
        case ingestContent
        case refinePolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningPolicyBuildWorkflowType] {
            return [
                .importPolicy,
                .ingestContent,
                .refinePolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .importPolicy: return "IMPORT_POLICY"
            case .ingestContent: return "INGEST_CONTENT"
            case .refinePolicy: return "REFINE_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum AutomatedReasoningPolicyBuildDocumentContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pdf
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningPolicyBuildDocumentContentType] {
            return [
                .pdf,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pdf: return "pdf"
            case .text: return "txt"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum AutomatedReasoningPolicyBuildWorkflowStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case building
        case cancelled
        case cancelRequested
        case completed
        case failed
        case preprocessing
        case scheduled
        case testing
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningPolicyBuildWorkflowStatus] {
            return [
                .building,
                .cancelled,
                .cancelRequested,
                .completed,
                .failed,
                .preprocessing,
                .scheduled,
                .testing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .building: return "BUILDING"
            case .cancelled: return "CANCELLED"
            case .cancelRequested: return "CANCEL_REQUESTED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .preprocessing: return "PREPROCESSING"
            case .scheduled: return "SCHEDULED"
            case .testing: return "TESTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAutomatedReasoningPolicyBuildWorkflowOutput: Swift.Sendable {
    /// The unique identifier of the build workflow.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The type of build workflow being executed (e.g., DOCUMENT_INGESTION, POLICY_REPAIR).
    /// This member is required.
    public var buildWorkflowType: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowType?
    /// The timestamp when the build workflow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The content type of the source document (e.g., text/plain, application/pdf).
    public var documentContentType: BedrockClientTypes.AutomatedReasoningPolicyBuildDocumentContentType?
    /// A detailed description of the document's content and how it should be used in the policy generation process.
    public var documentDescription: Swift.String?
    /// The name of the source document used in the build workflow.
    public var documentName: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The current status of the build workflow (e.g., RUNNING, COMPLETED, FAILED, CANCELLED).
    /// This member is required.
    public var status: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowStatus?
    /// The timestamp when the build workflow was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        buildWorkflowId: Swift.String? = nil,
        buildWorkflowType: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowType? = nil,
        createdAt: Foundation.Date? = nil,
        documentContentType: BedrockClientTypes.AutomatedReasoningPolicyBuildDocumentContentType? = nil,
        documentDescription: Swift.String? = nil,
        documentName: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        status: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.buildWorkflowType = buildWorkflowType
        self.createdAt = createdAt
        self.documentContentType = documentContentType
        self.documentDescription = documentDescription
        self.documentName = documentName
        self.policyArn = policyArn
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension GetAutomatedReasoningPolicyBuildWorkflowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAutomatedReasoningPolicyBuildWorkflowOutput(buildWorkflowId: \(Swift.String(describing: buildWorkflowId)), buildWorkflowType: \(Swift.String(describing: buildWorkflowType)), createdAt: \(Swift.String(describing: createdAt)), documentContentType: \(Swift.String(describing: documentContentType)), policyArn: \(Swift.String(describing: policyArn)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), documentDescription: \"CONTENT_REDACTED\", documentName: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum AutomatedReasoningPolicyBuildResultAssetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case buildLog
        case generatedTestCases
        case policyDefinition
        case policyScenarios
        case qualityReport
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningPolicyBuildResultAssetType] {
            return [
                .buildLog,
                .generatedTestCases,
                .policyDefinition,
                .policyScenarios,
                .qualityReport
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .buildLog: return "BUILD_LOG"
            case .generatedTestCases: return "GENERATED_TEST_CASES"
            case .policyDefinition: return "POLICY_DEFINITION"
            case .policyScenarios: return "POLICY_SCENARIOS"
            case .qualityReport: return "QUALITY_REPORT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAutomatedReasoningPolicyBuildWorkflowResultAssetsInput: Swift.Sendable {
    /// The type of asset to retrieve (e.g., BUILD_LOG, QUALITY_REPORT, POLICY_DEFINITION).
    /// This member is required.
    public var assetType: BedrockClientTypes.AutomatedReasoningPolicyBuildResultAssetType?
    /// The unique identifier of the build workflow whose result assets you want to retrieve.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy whose build workflow assets you want to retrieve.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        assetType: BedrockClientTypes.AutomatedReasoningPolicyBuildResultAssetType? = nil,
        buildWorkflowId: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.assetType = assetType
        self.buildWorkflowId = buildWorkflowId
        self.policyArn = policyArn
    }
}

extension BedrockClientTypes {

    /// A mutation operation that adds a new rule to the policy definition during the build process.
    public struct AutomatedReasoningPolicyAddRuleMutation: Swift.Sendable {
        /// The rule definition that specifies the formal logical expression and metadata for the new rule being added to the policy.
        /// This member is required.
        public var rule: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule?

        public init(
            rule: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule? = nil
        ) {
            self.rule = rule
        }
    }
}

extension BedrockClientTypes {

    /// A mutation operation that adds a new custom type to the policy definition during the build process.
    public struct AutomatedReasoningPolicyAddTypeMutation: Swift.Sendable {
        /// The type definition that specifies the name, description, and possible values for the new custom type being added to the policy.
        /// This member is required.
        public var type: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType?

        public init(
            type: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType? = nil
        ) {
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// A mutation operation that adds a new variable to the policy definition during the build process.
    public struct AutomatedReasoningPolicyAddVariableMutation: Swift.Sendable {
        /// The variable definition that specifies the name, type, and description for the new variable being added to the policy.
        /// This member is required.
        public var variable: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable?

        public init(
            variable: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable? = nil
        ) {
            self.variable = variable
        }
    }
}

extension BedrockClientTypes {

    /// A mutation operation that removes a rule from the policy definition during the build process.
    public struct AutomatedReasoningPolicyDeleteRuleMutation: Swift.Sendable {
        /// The unique identifier of the rule to delete.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        ) {
            self.id = id
        }
    }
}

extension BedrockClientTypes {

    /// A mutation operation that removes a custom type from the policy definition during the build process.
    public struct AutomatedReasoningPolicyDeleteTypeMutation: Swift.Sendable {
        /// The name of the custom type to delete.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeMutation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDeleteTypeMutation(name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// A mutation operation that removes a variable from the policy definition during the build process.
    public struct AutomatedReasoningPolicyDeleteVariableMutation: Swift.Sendable {
        /// The name of the variable to delete.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableMutation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDeleteVariableMutation(name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// A mutation operation that modifies an existing rule in the policy definition during the build process.
    public struct AutomatedReasoningPolicyUpdateRuleMutation: Swift.Sendable {
        /// The updated rule definition containing the modified formal logical expression and any changed metadata for the existing rule.
        /// This member is required.
        public var rule: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule?

        public init(
            rule: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule? = nil
        ) {
            self.rule = rule
        }
    }
}

extension BedrockClientTypes {

    /// A mutation operation that modifies an existing custom type in the policy definition during the build process.
    public struct AutomatedReasoningPolicyUpdateTypeMutation: Swift.Sendable {
        /// The updated type definition containing the modified name, description, or values for the existing custom type.
        /// This member is required.
        public var type: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType?

        public init(
            type: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType? = nil
        ) {
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// A mutation operation that modifies an existing variable in the policy definition during the build process.
    public struct AutomatedReasoningPolicyUpdateVariableMutation: Swift.Sendable {
        /// The updated variable definition containing the modified name, type, or description for the existing variable.
        /// This member is required.
        public var variable: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable?

        public init(
            variable: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable? = nil
        ) {
            self.variable = variable
        }
    }
}

extension BedrockClientTypes {

    /// A container for various mutation operations that can be applied to an Automated Reasoning policy, including adding, updating, and deleting policy elements.
    public enum AutomatedReasoningPolicyMutation: Swift.Sendable {
        /// A mutation to add a new custom type to the policy.
        case addtype(BedrockClientTypes.AutomatedReasoningPolicyAddTypeMutation)
        /// A mutation to modify an existing custom type in the policy.
        case updatetype(BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeMutation)
        /// A mutation to remove a custom type from the policy.
        case deletetype(BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeMutation)
        /// A mutation to add a new variable to the policy.
        case addvariable(BedrockClientTypes.AutomatedReasoningPolicyAddVariableMutation)
        /// A mutation to modify an existing variable in the policy.
        case updatevariable(BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableMutation)
        /// A mutation to remove a variable from the policy.
        case deletevariable(BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableMutation)
        /// A mutation to add a new rule to the policy.
        case addrule(BedrockClientTypes.AutomatedReasoningPolicyAddRuleMutation)
        /// A mutation to modify an existing rule in the policy.
        case updaterule(BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleMutation)
        /// A mutation to remove a rule from the policy.
        case deleterule(BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleMutation)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Represents the planning phase of policy build workflow, where the system analyzes source content and determines what operations to perform.
    public struct AutomatedReasoningPolicyPlanning: Swift.Sendable {

        public init() { }
    }
}

extension BedrockClientTypes {

    /// Provides context about what type of operation was being performed during a build step.
    public enum AutomatedReasoningPolicyBuildStepContext: Swift.Sendable {
        /// Indicates that this build step was part of the planning phase, where the system determines what operations to perform.
        case planning(BedrockClientTypes.AutomatedReasoningPolicyPlanning)
        /// Indicates that this build step involved modifying the policy structure, such as adding or updating rules, variables, or types.
        case mutation(BedrockClientTypes.AutomatedReasoningPolicyMutation)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    public enum AutomatedReasoningPolicyBuildMessageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case info
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningPolicyBuildMessageType] {
            return [
                .error,
                .info,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Represents a message generated during a build step, providing information about what happened or any issues encountered.
    public struct AutomatedReasoningPolicyBuildStepMessage: Swift.Sendable {
        /// The content of the message, describing what occurred during the build step.
        /// This member is required.
        public var message: Swift.String?
        /// The type of message (e.g., INFO, WARNING, ERROR) indicating its severity and purpose.
        /// This member is required.
        public var messageType: BedrockClientTypes.AutomatedReasoningPolicyBuildMessageType?

        public init(
            message: Swift.String? = nil,
            messageType: BedrockClientTypes.AutomatedReasoningPolicyBuildMessageType? = nil
        ) {
            self.message = message
            self.messageType = messageType
        }
    }
}

extension BedrockClientTypes {

    /// Represents a single element in an Automated Reasoning policy definition, such as a rule, variable, or type definition.
    public enum AutomatedReasoningPolicyDefinitionElement: Swift.Sendable {
        /// A variable element within the policy definition that represents a concept used in logical expressions and rules.
        case policydefinitionvariable(BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable)
        /// A custom type element within the policy definition that defines a set of possible values for variables.
        case policydefinitiontype(BedrockClientTypes.AutomatedReasoningPolicyDefinitionType)
        /// A rule element within the policy definition that contains a formal logical expression used for validation.
        case policydefinitionrule(BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Represents a single step in the policy build process, containing context about what was being processed and any messages or results.
    public struct AutomatedReasoningPolicyBuildStep: Swift.Sendable {
        /// Contextual information about what was being processed during this build step, such as the type of operation or the source material being analyzed.
        /// This member is required.
        public var context: BedrockClientTypes.AutomatedReasoningPolicyBuildStepContext?
        /// A list of messages generated during this build step, including informational messages, warnings, and error details.
        /// This member is required.
        public var messages: [BedrockClientTypes.AutomatedReasoningPolicyBuildStepMessage]?
        /// Reference to the previous element or step in the build process, helping to trace the sequence of operations.
        public var priorElement: BedrockClientTypes.AutomatedReasoningPolicyDefinitionElement?

        public init(
            context: BedrockClientTypes.AutomatedReasoningPolicyBuildStepContext? = nil,
            messages: [BedrockClientTypes.AutomatedReasoningPolicyBuildStepMessage]? = nil,
            priorElement: BedrockClientTypes.AutomatedReasoningPolicyDefinitionElement? = nil
        ) {
            self.context = context
            self.messages = messages
            self.priorElement = priorElement
        }
    }
}

extension BedrockClientTypes {

    public enum AutomatedReasoningPolicyAnnotationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applied
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningPolicyAnnotationStatus] {
            return [
                .applied,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Represents a single entry in the policy build log, containing information about a specific step or event in the build process.
    public struct AutomatedReasoningPolicyBuildLogEntry: Swift.Sendable {
        /// The annotation or operation that was being processed when this log entry was created.
        /// This member is required.
        public var annotation: BedrockClientTypes.AutomatedReasoningPolicyAnnotation?
        /// Detailed information about the specific build steps that were executed, including any sub-operations or transformations.
        /// This member is required.
        public var buildSteps: [BedrockClientTypes.AutomatedReasoningPolicyBuildStep]?
        /// The status of the build step (e.g., SUCCESS, FAILED, IN_PROGRESS).
        /// This member is required.
        public var status: BedrockClientTypes.AutomatedReasoningPolicyAnnotationStatus?

        public init(
            annotation: BedrockClientTypes.AutomatedReasoningPolicyAnnotation? = nil,
            buildSteps: [BedrockClientTypes.AutomatedReasoningPolicyBuildStep]? = nil,
            status: BedrockClientTypes.AutomatedReasoningPolicyAnnotationStatus? = nil
        ) {
            self.annotation = annotation
            self.buildSteps = buildSteps
            self.status = status
        }
    }
}

extension BedrockClientTypes {

    /// Contains detailed logging information about the policy build process, including steps taken, decisions made, and any issues encountered.
    public struct AutomatedReasoningPolicyBuildLog: Swift.Sendable {
        /// A list of log entries documenting each step in the policy build process, including timestamps, status, and detailed messages.
        /// This member is required.
        public var entries: [BedrockClientTypes.AutomatedReasoningPolicyBuildLogEntry]?

        public init(
            entries: [BedrockClientTypes.AutomatedReasoningPolicyBuildLogEntry]? = nil
        ) {
            self.entries = entries
        }
    }
}

extension BedrockClientTypes {

    /// Represents a generated test case, consisting of query content, guard content, and expected results.
    public struct AutomatedReasoningPolicyGeneratedTestCase: Swift.Sendable {
        /// The expected results of the generated test case. Possible values include:
        ///
        /// * VALID - The claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false. In other words, there are no alternative answers that are true that contradict the claims.
        ///
        /// * INVALID - The claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exists different claims that are consistent with the premises and Automated Reasoning policy.
        ///
        /// * SATISFIABLE - The claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.
        ///
        /// * IMPOSSIBLE - Automated Reasoning canâ€™t make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.
        /// This member is required.
        public var expectedAggregatedFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult?
        /// The output content that's validated by the Automated Reasoning policy. This represents the foundation model response that will be checked for accuracy.
        /// This member is required.
        public var guardContent: Swift.String?
        /// The input query or prompt that generated the content. This provides context for the validation.
        /// This member is required.
        public var queryContent: Swift.String?

        public init(
            expectedAggregatedFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult? = nil,
            guardContent: Swift.String? = nil,
            queryContent: Swift.String? = nil
        ) {
            self.expectedAggregatedFindingsResult = expectedAggregatedFindingsResult
            self.guardContent = guardContent
            self.queryContent = queryContent
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCase: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyGeneratedTestCase(expectedAggregatedFindingsResult: \(Swift.String(describing: expectedAggregatedFindingsResult)), guardContent: \"CONTENT_REDACTED\", queryContent: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains a comprehensive test suite generated by the build workflow, providing validation capabilities for automated reasoning policies.
    public struct AutomatedReasoningPolicyGeneratedTestCases: Swift.Sendable {
        /// Represents a collection of generated test cases.
        /// This member is required.
        public var generatedTestCases: [BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCase]?

        public init(
            generatedTestCases: [BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCase]? = nil
        ) {
            self.generatedTestCases = generatedTestCases
        }
    }
}

extension BedrockClientTypes {

    /// Represents a test scenario used to validate an Automated Reasoning policy, including the test conditions and expected outcomes.
    public struct AutomatedReasoningPolicyScenario: Swift.Sendable {
        /// An alternative way to express the same test scenario, used for validation and comparison purposes.
        /// This member is required.
        public var alternateExpression: Swift.String?
        /// The expected outcome when this scenario is evaluated against the policy (e.g., PASS, FAIL, VIOLATION).
        /// This member is required.
        public var expectedResult: BedrockClientTypes.AutomatedReasoningCheckResult?
        /// The logical expression or condition that defines this test scenario.
        /// This member is required.
        public var expression: Swift.String?
        /// The list of rule identifiers that are expected to be triggered or evaluated by this test scenario.
        /// This member is required.
        public var ruleIds: [Swift.String]?

        public init(
            alternateExpression: Swift.String? = nil,
            expectedResult: BedrockClientTypes.AutomatedReasoningCheckResult? = nil,
            expression: Swift.String? = nil,
            ruleIds: [Swift.String]? = nil
        ) {
            self.alternateExpression = alternateExpression
            self.expectedResult = expectedResult
            self.expression = expression
            self.ruleIds = ruleIds
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyScenario: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyScenario(expectedResult: \(Swift.String(describing: expectedResult)), ruleIds: \(Swift.String(describing: ruleIds)), alternateExpression: \"CONTENT_REDACTED\", expression: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains a comprehensive entity encompassing all the scenarios generated by the build workflow, which can be used to validate an Automated Reasoning policy.
    public struct AutomatedReasoningPolicyScenarios: Swift.Sendable {
        /// Represents a collection of generated policy scenarios.
        /// This member is required.
        public var policyScenarios: [BedrockClientTypes.AutomatedReasoningPolicyScenario]?

        public init(
            policyScenarios: [BedrockClientTypes.AutomatedReasoningPolicyScenario]? = nil
        ) {
            self.policyScenarios = policyScenarios
        }
    }
}

extension BedrockClientTypes {

    /// Represents a set of rules that operate on completely separate variables, indicating they address different concerns or domains within the policy.
    public struct AutomatedReasoningPolicyDisjointRuleSet: Swift.Sendable {
        /// The list of rules that form this disjoint set, all operating on the same set of variables.
        /// This member is required.
        public var rules: [Swift.String]?
        /// The set of variables that are used by the rules in this disjoint set.
        /// This member is required.
        public var variables: [Swift.String]?

        public init(
            rules: [Swift.String]? = nil,
            variables: [Swift.String]? = nil
        ) {
            self.rules = rules
            self.variables = variables
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDisjointRuleSet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDisjointRuleSet(rules: \(Swift.String(describing: rules)), variables: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Associates a type name with a specific value name, used for referencing type values in rules and other policy elements.
    public struct AutomatedReasoningPolicyDefinitionTypeValuePair: Swift.Sendable {
        /// The name of the custom type that contains the referenced value.
        /// This member is required.
        public var typeName: Swift.String?
        /// The name of the specific value within the type.
        /// This member is required.
        public var valueName: Swift.String?

        public init(
            typeName: Swift.String? = nil,
            valueName: Swift.String? = nil
        ) {
            self.typeName = typeName
            self.valueName = valueName
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValuePair: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDefinitionTypeValuePair(valueName: \(Swift.String(describing: valueName)), typeName: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Provides a comprehensive analysis of the quality and completeness of an Automated Reasoning policy definition, highlighting potential issues and optimization opportunities.
    public struct AutomatedReasoningPolicyDefinitionQualityReport: Swift.Sendable {
        /// A list of rules that may conflict with each other, potentially leading to inconsistent policy behavior.
        /// This member is required.
        public var conflictingRules: [Swift.String]?
        /// Groups of rules that operate on completely separate sets of variables, indicating the policy may be addressing multiple unrelated concerns.
        /// This member is required.
        public var disjointRuleSets: [BedrockClientTypes.AutomatedReasoningPolicyDisjointRuleSet]?
        /// The total number of rules defined in the policy.
        /// This member is required.
        public var ruleCount: Swift.Int?
        /// The total number of custom types defined in the policy.
        /// This member is required.
        public var typeCount: Swift.Int?
        /// A list of type values that are defined but never used in any rules, indicating potential cleanup opportunities.
        /// This member is required.
        public var unusedTypeValues: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValuePair]?
        /// A list of custom types that are defined but not referenced by any variables or rules, suggesting they may be unnecessary.
        /// This member is required.
        public var unusedTypes: [Swift.String]?
        /// A list of variables that are defined but not referenced by any rules, suggesting they may be unnecessary.
        /// This member is required.
        public var unusedVariables: [Swift.String]?
        /// The total number of variables defined in the policy.
        /// This member is required.
        public var variableCount: Swift.Int?

        public init(
            conflictingRules: [Swift.String]? = nil,
            disjointRuleSets: [BedrockClientTypes.AutomatedReasoningPolicyDisjointRuleSet]? = nil,
            ruleCount: Swift.Int? = nil,
            typeCount: Swift.Int? = nil,
            unusedTypeValues: [BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValuePair]? = nil,
            unusedTypes: [Swift.String]? = nil,
            unusedVariables: [Swift.String]? = nil,
            variableCount: Swift.Int? = nil
        ) {
            self.conflictingRules = conflictingRules
            self.disjointRuleSets = disjointRuleSets
            self.ruleCount = ruleCount
            self.typeCount = typeCount
            self.unusedTypeValues = unusedTypeValues
            self.unusedTypes = unusedTypes
            self.unusedVariables = unusedVariables
            self.variableCount = variableCount
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionQualityReport: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyDefinitionQualityReport(conflictingRules: \(Swift.String(describing: conflictingRules)), disjointRuleSets: \(Swift.String(describing: disjointRuleSets)), ruleCount: \(Swift.String(describing: ruleCount)), typeCount: \(Swift.String(describing: typeCount)), unusedTypeValues: \(Swift.String(describing: unusedTypeValues)), variableCount: \(Swift.String(describing: variableCount)), unusedTypes: \"CONTENT_REDACTED\", unusedVariables: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains the various assets generated during a policy build workflow, including logs, quality reports, test cases, and the final policy definition.
    public enum AutomatedReasoningPolicyBuildResultAssets: Swift.Sendable {
        /// The complete policy definition generated by the build workflow, containing all rules, variables, and custom types extracted from the source documents.
        case policydefinition(BedrockClientTypes.AutomatedReasoningPolicyDefinition)
        /// A comprehensive report analyzing the quality of the generated policy, including metrics about rule coverage, potential conflicts, and unused elements.
        case qualityreport(BedrockClientTypes.AutomatedReasoningPolicyDefinitionQualityReport)
        /// The complete build log containing detailed information about each step in the policy generation process.
        case buildlog(BedrockClientTypes.AutomatedReasoningPolicyBuildLog)
        /// A comprehensive test suite generated by the build workflow, providing validation capabilities for automated reasoning policies.
        case generatedtestcases(BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCases)
        /// An entity encompassing all the policy scenarios generated by the build workflow, which can be used to validate an Automated Reasoning policy.
        case policyscenarios(BedrockClientTypes.AutomatedReasoningPolicyScenarios)
        case sdkUnknown(Swift.String)
    }
}

public struct GetAutomatedReasoningPolicyBuildWorkflowResultAssetsOutput: Swift.Sendable {
    /// The requested build workflow asset. This is a union type that returns only one of the available asset types (logs, reports, or generated artifacts) based on the specific asset type requested in the API call.
    public var buildWorkflowAssets: BedrockClientTypes.AutomatedReasoningPolicyBuildResultAssets?
    /// The unique identifier of the build workflow.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        buildWorkflowAssets: BedrockClientTypes.AutomatedReasoningPolicyBuildResultAssets? = nil,
        buildWorkflowId: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.buildWorkflowAssets = buildWorkflowAssets
        self.buildWorkflowId = buildWorkflowId
        self.policyArn = policyArn
    }
}

public struct GetAutomatedReasoningPolicyNextScenarioInput: Swift.Sendable {
    /// The unique identifier of the build workflow associated with the test scenarios.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy for which you want to get the next test scenario.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        buildWorkflowId: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.policyArn = policyArn
    }
}

public struct GetAutomatedReasoningPolicyNextScenarioOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The next test scenario to validate, including the test expression and expected results.
    public var scenario: BedrockClientTypes.AutomatedReasoningPolicyScenario?

    public init(
        policyArn: Swift.String? = nil,
        scenario: BedrockClientTypes.AutomatedReasoningPolicyScenario? = nil
    ) {
        self.policyArn = policyArn
        self.scenario = scenario
    }
}

public struct GetAutomatedReasoningPolicyTestCaseInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy that contains the test.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The unique identifier of the test to retrieve.
    /// This member is required.
    public var testCaseId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        testCaseId: Swift.String? = nil
    ) {
        self.policyArn = policyArn
        self.testCaseId = testCaseId
    }
}

extension BedrockClientTypes {

    /// Represents a test for validating an Automated Reasoning policy. tests contain sample inputs and expected outcomes to verify policy behavior.
    public struct AutomatedReasoningPolicyTestCase: Swift.Sendable {
        /// The minimum confidence level for logic validation. Content meeting this threshold is considered high-confidence and can be validated.
        public var confidenceThreshold: Swift.Double?
        /// The timestamp when the test was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The expected result of the Automated Reasoning check for this test.
        public var expectedAggregatedFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult?
        /// The output content to be validated by the policy, typically representing a foundation model response.
        /// This member is required.
        public var guardContent: Swift.String?
        /// The input query or prompt that generated the content. This provides context for the validation.
        public var queryContent: Swift.String?
        /// The unique identifier of the test.
        /// This member is required.
        public var testCaseId: Swift.String?
        /// The timestamp when the test was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            confidenceThreshold: Swift.Double? = nil,
            createdAt: Foundation.Date? = nil,
            expectedAggregatedFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult? = nil,
            guardContent: Swift.String? = nil,
            queryContent: Swift.String? = nil,
            testCaseId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.expectedAggregatedFindingsResult = expectedAggregatedFindingsResult
            self.guardContent = guardContent
            self.queryContent = queryContent
            self.testCaseId = testCaseId
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyTestCase: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyTestCase(confidenceThreshold: \(Swift.String(describing: confidenceThreshold)), createdAt: \(Swift.String(describing: createdAt)), expectedAggregatedFindingsResult: \(Swift.String(describing: expectedAggregatedFindingsResult)), testCaseId: \(Swift.String(describing: testCaseId)), updatedAt: \(Swift.String(describing: updatedAt)), guardContent: \"CONTENT_REDACTED\", queryContent: \"CONTENT_REDACTED\")"}
}

public struct GetAutomatedReasoningPolicyTestCaseOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the policy that contains the test.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The test details including the content, query, expected result, and metadata.
    /// This member is required.
    public var testCase: BedrockClientTypes.AutomatedReasoningPolicyTestCase?

    public init(
        policyArn: Swift.String? = nil,
        testCase: BedrockClientTypes.AutomatedReasoningPolicyTestCase? = nil
    ) {
        self.policyArn = policyArn
        self.testCase = testCase
    }
}

public struct GetAutomatedReasoningPolicyTestResultInput: Swift.Sendable {
    /// The build workflow identifier. The build workflow must display a COMPLETED status to get results.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The unique identifier of the test for which to retrieve results.
    /// This member is required.
    public var testCaseId: Swift.String?

    public init(
        buildWorkflowId: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        testCaseId: Swift.String? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.policyArn = policyArn
        self.testCaseId = testCaseId
    }
}

extension BedrockClientTypes {

    /// References a specific automated reasoning policy rule that was applied during evaluation.
    public struct AutomatedReasoningCheckRule: Swift.Sendable {
        /// The unique identifier of the automated reasoning rule.
        public var id: Swift.String?
        /// The ARN of the automated reasoning policy version that contains this rule.
        public var policyVersionArn: Swift.String?

        public init(
            id: Swift.String? = nil,
            policyVersionArn: Swift.String? = nil
        ) {
            self.id = id
            self.policyVersionArn = policyVersionArn
        }
    }
}

extension BedrockClientTypes {

    /// Represents a logical statement that can be expressed both in formal logic notation and natural language, providing dual representations for better understanding and validation.
    public struct AutomatedReasoningLogicStatement: Swift.Sendable {
        /// The formal logic representation of the statement using mathematical notation and logical operators.
        /// This member is required.
        public var logic: Swift.String?
        /// The natural language representation of the logical statement, providing a human-readable interpretation of the formal logic.
        public var naturalLanguage: Swift.String?

        public init(
            logic: Swift.String? = nil,
            naturalLanguage: Swift.String? = nil
        ) {
            self.logic = logic
            self.naturalLanguage = naturalLanguage
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningLogicStatement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningLogicStatement(logic: \"CONTENT_REDACTED\", naturalLanguage: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum AutomatedReasoningCheckLogicWarningType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alwaysFalse
        case alwaysTrue
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningCheckLogicWarningType] {
            return [
                .alwaysFalse,
                .alwaysTrue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alwaysFalse: return "ALWAYS_FALSE"
            case .alwaysTrue: return "ALWAYS_TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Identifies logical issues in the translated statements that exist independent of any policy rules, such as statements that are always true or always false.
    public struct AutomatedReasoningCheckLogicWarning: Swift.Sendable {
        /// The logical statements that are validated while assuming the policy and premises.
        public var claims: [BedrockClientTypes.AutomatedReasoningLogicStatement]?
        /// The logical statements that serve as premises under which the claims are validated.
        public var premises: [BedrockClientTypes.AutomatedReasoningLogicStatement]?
        /// The category of the detected logical issue, such as statements that are always true or always false.
        public var type: BedrockClientTypes.AutomatedReasoningCheckLogicWarningType?

        public init(
            claims: [BedrockClientTypes.AutomatedReasoningLogicStatement]? = nil,
            premises: [BedrockClientTypes.AutomatedReasoningLogicStatement]? = nil,
            type: BedrockClientTypes.AutomatedReasoningCheckLogicWarningType? = nil
        ) {
            self.claims = claims
            self.premises = premises
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// References a portion of the original input text that corresponds to logical elements.
    public struct AutomatedReasoningCheckInputTextReference: Swift.Sendable {
        /// The specific text from the original input that this reference points to.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        ) {
            self.text = text
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckInputTextReference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningCheckInputTextReference(text: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains the logical translation of natural language input into formal logical statements, including premises, claims, and confidence scores.
    public struct AutomatedReasoningCheckTranslation: Swift.Sendable {
        /// The logical statements that are being validated against the premises and policy rules.
        /// This member is required.
        public var claims: [BedrockClientTypes.AutomatedReasoningLogicStatement]?
        /// A confidence score between 0 and 1 indicating how certain the system is about the logical translation.
        /// This member is required.
        public var confidence: Swift.Double?
        /// The logical statements that serve as the foundation or assumptions for the claims.
        public var premises: [BedrockClientTypes.AutomatedReasoningLogicStatement]?
        /// References to portions of the original input text that correspond to the claims but could not be fully translated.
        public var untranslatedClaims: [BedrockClientTypes.AutomatedReasoningCheckInputTextReference]?
        /// References to portions of the original input text that correspond to the premises but could not be fully translated.
        public var untranslatedPremises: [BedrockClientTypes.AutomatedReasoningCheckInputTextReference]?

        public init(
            claims: [BedrockClientTypes.AutomatedReasoningLogicStatement]? = nil,
            confidence: Swift.Double? = nil,
            premises: [BedrockClientTypes.AutomatedReasoningLogicStatement]? = nil,
            untranslatedClaims: [BedrockClientTypes.AutomatedReasoningCheckInputTextReference]? = nil,
            untranslatedPremises: [BedrockClientTypes.AutomatedReasoningCheckInputTextReference]? = nil
        ) {
            self.claims = claims
            self.confidence = confidence
            self.premises = premises
            self.untranslatedClaims = untranslatedClaims
            self.untranslatedPremises = untranslatedPremises
        }
    }
}

extension BedrockClientTypes {

    /// Indicates that no valid claims can be made due to logical contradictions in the premises or rules.
    public struct AutomatedReasoningCheckImpossibleFinding: Swift.Sendable {
        /// The automated reasoning policy rules that contradict the claims and/or premises in the input.
        public var contradictingRules: [BedrockClientTypes.AutomatedReasoningCheckRule]?
        /// Indication of a logic issue with the translation without needing to consider the automated reasoning policy rules.
        public var logicWarning: BedrockClientTypes.AutomatedReasoningCheckLogicWarning?
        /// The logical translation of the input that this finding evaluates.
        public var translation: BedrockClientTypes.AutomatedReasoningCheckTranslation?

        public init(
            contradictingRules: [BedrockClientTypes.AutomatedReasoningCheckRule]? = nil,
            logicWarning: BedrockClientTypes.AutomatedReasoningCheckLogicWarning? = nil,
            translation: BedrockClientTypes.AutomatedReasoningCheckTranslation? = nil
        ) {
            self.contradictingRules = contradictingRules
            self.logicWarning = logicWarning
            self.translation = translation
        }
    }
}

extension BedrockClientTypes {

    /// Indicates that the claims are logically false and contradictory to the established rules or premises.
    public struct AutomatedReasoningCheckInvalidFinding: Swift.Sendable {
        /// The automated reasoning policy rules that contradict the claims in the input.
        public var contradictingRules: [BedrockClientTypes.AutomatedReasoningCheckRule]?
        /// Indication of a logic issue with the translation without needing to consider the automated reasoning policy rules.
        public var logicWarning: BedrockClientTypes.AutomatedReasoningCheckLogicWarning?
        /// The logical translation of the input that this finding invalidates.
        public var translation: BedrockClientTypes.AutomatedReasoningCheckTranslation?

        public init(
            contradictingRules: [BedrockClientTypes.AutomatedReasoningCheckRule]? = nil,
            logicWarning: BedrockClientTypes.AutomatedReasoningCheckLogicWarning? = nil,
            translation: BedrockClientTypes.AutomatedReasoningCheckTranslation? = nil
        ) {
            self.contradictingRules = contradictingRules
            self.logicWarning = logicWarning
            self.translation = translation
        }
    }
}

extension BedrockClientTypes {

    /// Indicates that no relevant logical information could be extracted from the input for validation.
    public struct AutomatedReasoningCheckNoTranslationsFinding: Swift.Sendable {

        public init() { }
    }
}

extension BedrockClientTypes {

    /// Represents a logical scenario where claims can be evaluated as true or false, containing specific logical assignments.
    public struct AutomatedReasoningCheckScenario: Swift.Sendable {
        /// List of logical assignments and statements that define this scenario.
        public var statements: [BedrockClientTypes.AutomatedReasoningLogicStatement]?

        public init(
            statements: [BedrockClientTypes.AutomatedReasoningLogicStatement]? = nil
        ) {
            self.statements = statements
        }
    }
}

extension BedrockClientTypes {

    /// Indicates that the claims could be either true or false depending on additional assumptions not provided in the input.
    public struct AutomatedReasoningCheckSatisfiableFinding: Swift.Sendable {
        /// An example scenario demonstrating how the claims could be logically false.
        public var claimsFalseScenario: BedrockClientTypes.AutomatedReasoningCheckScenario?
        /// An example scenario demonstrating how the claims could be logically true.
        public var claimsTrueScenario: BedrockClientTypes.AutomatedReasoningCheckScenario?
        /// Indication of a logic issue with the translation without needing to consider the automated reasoning policy rules.
        public var logicWarning: BedrockClientTypes.AutomatedReasoningCheckLogicWarning?
        /// The logical translation of the input that this finding evaluates.
        public var translation: BedrockClientTypes.AutomatedReasoningCheckTranslation?

        public init(
            claimsFalseScenario: BedrockClientTypes.AutomatedReasoningCheckScenario? = nil,
            claimsTrueScenario: BedrockClientTypes.AutomatedReasoningCheckScenario? = nil,
            logicWarning: BedrockClientTypes.AutomatedReasoningCheckLogicWarning? = nil,
            translation: BedrockClientTypes.AutomatedReasoningCheckTranslation? = nil
        ) {
            self.claimsFalseScenario = claimsFalseScenario
            self.claimsTrueScenario = claimsTrueScenario
            self.logicWarning = logicWarning
            self.translation = translation
        }
    }
}

extension BedrockClientTypes {

    /// Indicates that the input exceeds the processing capacity due to the volume or complexity of the logical information.
    public struct AutomatedReasoningCheckTooComplexFinding: Swift.Sendable {

        public init() { }
    }
}

extension BedrockClientTypes {

    /// Represents one possible logical interpretation of ambiguous input content.
    public struct AutomatedReasoningCheckTranslationOption: Swift.Sendable {
        /// Different logical interpretations that were detected during translation of the input.
        public var translations: [BedrockClientTypes.AutomatedReasoningCheckTranslation]?

        public init(
            translations: [BedrockClientTypes.AutomatedReasoningCheckTranslation]? = nil
        ) {
            self.translations = translations
        }
    }
}

extension BedrockClientTypes {

    /// Indicates that the input has multiple valid logical interpretations, requiring additional context or clarification.
    public struct AutomatedReasoningCheckTranslationAmbiguousFinding: Swift.Sendable {
        /// Scenarios showing how the different translation options differ in meaning.
        public var differenceScenarios: [BedrockClientTypes.AutomatedReasoningCheckScenario]?
        /// Different logical interpretations that were detected during translation of the input.
        public var options: [BedrockClientTypes.AutomatedReasoningCheckTranslationOption]?

        public init(
            differenceScenarios: [BedrockClientTypes.AutomatedReasoningCheckScenario]? = nil,
            options: [BedrockClientTypes.AutomatedReasoningCheckTranslationOption]? = nil
        ) {
            self.differenceScenarios = differenceScenarios
            self.options = options
        }
    }
}

extension BedrockClientTypes {

    /// Indicates that the claims are definitively true and logically implied by the premises, with no possible alternative interpretations.
    public struct AutomatedReasoningCheckValidFinding: Swift.Sendable {
        /// An example scenario demonstrating how the claims are logically true.
        public var claimsTrueScenario: BedrockClientTypes.AutomatedReasoningCheckScenario?
        /// Indication of a logic issue with the translation without needing to consider the automated reasoning policy rules.
        public var logicWarning: BedrockClientTypes.AutomatedReasoningCheckLogicWarning?
        /// The automated reasoning policy rules that support why this result is considered valid.
        public var supportingRules: [BedrockClientTypes.AutomatedReasoningCheckRule]?
        /// The logical translation of the input that this finding validates.
        public var translation: BedrockClientTypes.AutomatedReasoningCheckTranslation?

        public init(
            claimsTrueScenario: BedrockClientTypes.AutomatedReasoningCheckScenario? = nil,
            logicWarning: BedrockClientTypes.AutomatedReasoningCheckLogicWarning? = nil,
            supportingRules: [BedrockClientTypes.AutomatedReasoningCheckRule]? = nil,
            translation: BedrockClientTypes.AutomatedReasoningCheckTranslation? = nil
        ) {
            self.claimsTrueScenario = claimsTrueScenario
            self.logicWarning = logicWarning
            self.supportingRules = supportingRules
            self.translation = translation
        }
    }
}

extension BedrockClientTypes {

    /// Represents the result of an Automated Reasoning validation check, indicating whether the content is logically valid, invalid, or falls into other categories based on the policy rules.
    public enum AutomatedReasoningCheckFinding: Swift.Sendable {
        /// Indicates that the claims are true. The claims are implied by the premises and the Automated Reasoning policy. Given the Automated Reasoning policy and premises, it is not possible for these claims to be false.
        case valid(BedrockClientTypes.AutomatedReasoningCheckValidFinding)
        /// Indicates that the claims are false. The claims are not implied by the premises and Automated Reasoning policy. Furthermore, there exist different claims that are consistent with the premises and Automated Reasoning policy.
        case invalid(BedrockClientTypes.AutomatedReasoningCheckInvalidFinding)
        /// Indicates that the claims can be true or false. It depends on what assumptions are made for the claim to be implied from the premises and Automated Reasoning policy rules. In this situation, different assumptions can make input claims false and alternative claims true.
        case satisfiable(BedrockClientTypes.AutomatedReasoningCheckSatisfiableFinding)
        /// Indicates that Automated Reasoning cannot make a statement about the claims. This can happen if the premises are logically incorrect, or if there is a conflict within the Automated Reasoning policy itself.
        case impossible(BedrockClientTypes.AutomatedReasoningCheckImpossibleFinding)
        /// Indicates that an ambiguity was detected in the translation, making it unsound to continue with validity checking. Additional context or follow-up questions might be needed to get translation to succeed.
        case translationambiguous(BedrockClientTypes.AutomatedReasoningCheckTranslationAmbiguousFinding)
        /// Indicates that the input contains too much information for Automated Reasoning to process within its latency limits.
        case toocomplex(BedrockClientTypes.AutomatedReasoningCheckTooComplexFinding)
        /// Identifies that some or all of the input prompt wasn't translated into logic. This can happen if the input isn't relevant to the Automated Reasoning policy, or if the policy doesn't have variables to model relevant input.
        case notranslations(BedrockClientTypes.AutomatedReasoningCheckNoTranslationsFinding)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    public enum AutomatedReasoningPolicyTestRunResult: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case passed
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningPolicyTestRunResult] {
            return [
                .failed,
                .passed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .passed: return "PASSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum AutomatedReasoningPolicyTestRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case notStarted
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomatedReasoningPolicyTestRunStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .notStarted,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Contains the results of testing an Automated Reasoning policy against various scenarios and validation checks.
    public struct AutomatedReasoningPolicyTestResult: Swift.Sendable {
        /// A summary of all test findings, aggregated to provide an overall assessment of policy quality and correctness.
        public var aggregatedTestFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult?
        /// The Amazon Resource Name (ARN) of the Automated Reasoning policy that was tested.
        /// This member is required.
        public var policyArn: Swift.String?
        /// The test case that was executed, including the input content, expected results, and configuration parameters used during validation.
        /// This member is required.
        public var testCase: BedrockClientTypes.AutomatedReasoningPolicyTestCase?
        /// Detailed findings from the test run, including any issues, violations, or unexpected behaviors discovered.
        public var testFindings: [BedrockClientTypes.AutomatedReasoningCheckFinding]?
        /// The overall result of the test run, indicating whether the policy passed or failed validation.
        public var testRunResult: BedrockClientTypes.AutomatedReasoningPolicyTestRunResult?
        /// The overall status of the test run (e.g., COMPLETED, FAILED, IN_PROGRESS).
        /// This member is required.
        public var testRunStatus: BedrockClientTypes.AutomatedReasoningPolicyTestRunStatus?
        /// The timestamp when the test results were last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            aggregatedTestFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult? = nil,
            policyArn: Swift.String? = nil,
            testCase: BedrockClientTypes.AutomatedReasoningPolicyTestCase? = nil,
            testFindings: [BedrockClientTypes.AutomatedReasoningCheckFinding]? = nil,
            testRunResult: BedrockClientTypes.AutomatedReasoningPolicyTestRunResult? = nil,
            testRunStatus: BedrockClientTypes.AutomatedReasoningPolicyTestRunStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.aggregatedTestFindingsResult = aggregatedTestFindingsResult
            self.policyArn = policyArn
            self.testCase = testCase
            self.testFindings = testFindings
            self.testRunResult = testRunResult
            self.testRunStatus = testRunStatus
            self.updatedAt = updatedAt
        }
    }
}

public struct GetAutomatedReasoningPolicyTestResultOutput: Swift.Sendable {
    /// The test result containing validation findings, execution status, and detailed analysis.
    /// This member is required.
    public var testResult: BedrockClientTypes.AutomatedReasoningPolicyTestResult?

    public init(
        testResult: BedrockClientTypes.AutomatedReasoningPolicyTestResult? = nil
    ) {
        self.testResult = testResult
    }
}

public struct ListAutomatedReasoningPoliciesInput: Swift.Sendable {
    /// The maximum number of policies to return in a single call.
    public var maxResults: Swift.Int?
    /// The pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Optional filter to list only the policy versions with the specified Amazon Resource Name (ARN). If not provided, the DRAFT versions for all policies are listed.
    public var policyArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyArn = policyArn
    }
}

extension BedrockClientTypes {

    /// Contains summary information about an Automated Reasoning policy, including metadata and timestamps.
    public struct AutomatedReasoningPolicySummary: Swift.Sendable {
        /// The timestamp when the policy was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the policy.
        public var description: Swift.String?
        /// The name of the policy.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the policy.
        /// This member is required.
        public var policyArn: Swift.String?
        /// The unique identifier of the policy.
        /// This member is required.
        public var policyId: Swift.String?
        /// The timestamp when the policy was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The version of the policy.
        /// This member is required.
        public var version: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            policyArn: Swift.String? = nil,
            policyId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.policyArn = policyArn
            self.policyId = policyId
            self.updatedAt = updatedAt
            self.version = version
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicySummary(createdAt: \(Swift.String(describing: createdAt)), policyArn: \(Swift.String(describing: policyArn)), policyId: \(Swift.String(describing: policyId)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListAutomatedReasoningPoliciesOutput: Swift.Sendable {
    /// A list of Automated Reasoning policy summaries.
    /// This member is required.
    public var automatedReasoningPolicySummaries: [BedrockClientTypes.AutomatedReasoningPolicySummary]?
    /// The pagination token to use in a subsequent request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        automatedReasoningPolicySummaries: [BedrockClientTypes.AutomatedReasoningPolicySummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.automatedReasoningPolicySummaries = automatedReasoningPolicySummaries
        self.nextToken = nextToken
    }
}

public struct ListAutomatedReasoningPolicyBuildWorkflowsInput: Swift.Sendable {
    /// The maximum number of build workflows to return in a single response. Valid range is 1-100.
    public var maxResults: Swift.Int?
    /// A pagination token from a previous request to continue listing build workflows from where the previous request left off.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy whose build workflows you want to list.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyArn = policyArn
    }
}

extension BedrockClientTypes {

    /// Provides a summary of a policy build workflow, including its current status, timing information, and key identifiers.
    public struct AutomatedReasoningPolicyBuildWorkflowSummary: Swift.Sendable {
        /// The unique identifier of the build workflow.
        /// This member is required.
        public var buildWorkflowId: Swift.String?
        /// The type of build workflow (e.g., DOCUMENT_INGESTION, POLICY_REPAIR).
        /// This member is required.
        public var buildWorkflowType: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowType?
        /// The timestamp when the build workflow was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the Automated Reasoning policy associated with this build workflow.
        /// This member is required.
        public var policyArn: Swift.String?
        /// The current status of the build workflow (e.g., RUNNING, COMPLETED, FAILED, CANCELLED).
        /// This member is required.
        public var status: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowStatus?
        /// The timestamp when the build workflow was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            buildWorkflowId: Swift.String? = nil,
            buildWorkflowType: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowType? = nil,
            createdAt: Foundation.Date? = nil,
            policyArn: Swift.String? = nil,
            status: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.buildWorkflowId = buildWorkflowId
            self.buildWorkflowType = buildWorkflowType
            self.createdAt = createdAt
            self.policyArn = policyArn
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListAutomatedReasoningPolicyBuildWorkflowsOutput: Swift.Sendable {
    /// A list of build workflow summaries, each containing key information about a build workflow including its status and timestamps.
    /// This member is required.
    public var automatedReasoningPolicyBuildWorkflowSummaries: [BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSummary]?
    /// A pagination token to use in subsequent requests to retrieve additional build workflows.
    public var nextToken: Swift.String?

    public init(
        automatedReasoningPolicyBuildWorkflowSummaries: [BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.automatedReasoningPolicyBuildWorkflowSummaries = automatedReasoningPolicyBuildWorkflowSummaries
        self.nextToken = nextToken
    }
}

public struct ListAutomatedReasoningPolicyTestCasesInput: Swift.Sendable {
    /// The maximum number of tests to return in a single call.
    public var maxResults: Swift.Int?
    /// The pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy for which to list tests.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyArn = policyArn
    }
}

public struct ListAutomatedReasoningPolicyTestCasesOutput: Swift.Sendable {
    /// The pagination token to use in a subsequent request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// A list of tests for the specified policy.
    /// This member is required.
    public var testCases: [BedrockClientTypes.AutomatedReasoningPolicyTestCase]?

    public init(
        nextToken: Swift.String? = nil,
        testCases: [BedrockClientTypes.AutomatedReasoningPolicyTestCase]? = nil
    ) {
        self.nextToken = nextToken
        self.testCases = testCases
    }
}

public struct ListAutomatedReasoningPolicyTestResultsInput: Swift.Sendable {
    /// The unique identifier of the build workflow whose test results you want to list.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The maximum number of test results to return in a single response. Valid range is 1-100.
    public var maxResults: Swift.Int?
    /// A pagination token from a previous request to continue listing test results from where the previous request left off.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy whose test results you want to list.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        buildWorkflowId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyArn = policyArn
    }
}

public struct ListAutomatedReasoningPolicyTestResultsOutput: Swift.Sendable {
    /// A pagination token to use in subsequent requests to retrieve additional test results.
    public var nextToken: Swift.String?
    /// A list of test results, each containing information about how the policy performed on specific test scenarios.
    /// This member is required.
    public var testResults: [BedrockClientTypes.AutomatedReasoningPolicyTestResult]?

    public init(
        nextToken: Swift.String? = nil,
        testResults: [BedrockClientTypes.AutomatedReasoningPolicyTestResult]? = nil
    ) {
        self.nextToken = nextToken
        self.testResults = testResults
    }
}

extension BedrockClientTypes {

    /// Represents a source document used in the policy build workflow, containing the content and metadata needed for policy generation.
    public struct AutomatedReasoningPolicyBuildWorkflowDocument: Swift.Sendable {
        /// The actual content of the source document that will be analyzed to extract policy rules and concepts.
        /// This member is required.
        public var document: Foundation.Data?
        /// The MIME type of the document content (e.g., text/plain, application/pdf, text/markdown).
        /// This member is required.
        public var documentContentType: BedrockClientTypes.AutomatedReasoningPolicyBuildDocumentContentType?
        /// A detailed description of the document's content and how it should be used in the policy generation process.
        public var documentDescription: Swift.String?
        /// A descriptive name for the document that helps identify its purpose and content.
        /// This member is required.
        public var documentName: Swift.String?

        public init(
            document: Foundation.Data? = nil,
            documentContentType: BedrockClientTypes.AutomatedReasoningPolicyBuildDocumentContentType? = nil,
            documentDescription: Swift.String? = nil,
            documentName: Swift.String? = nil
        ) {
            self.document = document
            self.documentContentType = documentContentType
            self.documentDescription = documentDescription
            self.documentName = documentName
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowDocument: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutomatedReasoningPolicyBuildWorkflowDocument(documentContentType: \(Swift.String(describing: documentContentType)), document: \"CONTENT_REDACTED\", documentDescription: \"CONTENT_REDACTED\", documentName: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains content and instructions for repairing or improving an existing Automated Reasoning policy.
    public struct AutomatedReasoningPolicyBuildWorkflowRepairContent: Swift.Sendable {
        /// Specific annotations or modifications to apply during the policy repair process, such as rule corrections or variable updates.
        /// This member is required.
        public var annotations: [BedrockClientTypes.AutomatedReasoningPolicyAnnotation]?

        public init(
            annotations: [BedrockClientTypes.AutomatedReasoningPolicyAnnotation]? = nil
        ) {
            self.annotations = annotations
        }
    }
}

extension BedrockClientTypes {

    /// Defines the content and configuration for different types of policy build workflows.
    public enum AutomatedReasoningPolicyWorkflowTypeContent: Swift.Sendable {
        /// The list of documents to be processed in a document ingestion workflow.
        case documents([BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowDocument])
        /// The assets and instructions needed for a policy repair workflow, including repair annotations and guidance.
        case policyrepairassets(BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowRepairContent)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Defines the source content for a policy build workflow, which can include documents, repair instructions, or other input materials.
    public struct AutomatedReasoningPolicyBuildWorkflowSource: Swift.Sendable {
        /// An existing policy definition that serves as the starting point for the build workflow, typically used in policy repair or update scenarios.
        public var policyDefinition: BedrockClientTypes.AutomatedReasoningPolicyDefinition?
        /// The actual content to be processed in the build workflow, such as documents to analyze or repair instructions to apply.
        public var workflowContent: BedrockClientTypes.AutomatedReasoningPolicyWorkflowTypeContent?

        public init(
            policyDefinition: BedrockClientTypes.AutomatedReasoningPolicyDefinition? = nil,
            workflowContent: BedrockClientTypes.AutomatedReasoningPolicyWorkflowTypeContent? = nil
        ) {
            self.policyDefinition = policyDefinition
            self.workflowContent = workflowContent
        }
    }
}

public struct StartAutomatedReasoningPolicyBuildWorkflowInput: Swift.Sendable {
    /// The type of build workflow to start (e.g., DOCUMENT_INGESTION for processing new documents, POLICY_REPAIR for fixing existing policies).
    /// This member is required.
    public var buildWorkflowType: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowType?
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request but doesn't return an error.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy for which to start the build workflow.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The source content for the build workflow, such as documents to analyze or repair instructions for existing policies.
    /// This member is required.
    public var sourceContent: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSource?

    public init(
        buildWorkflowType: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowType? = nil,
        clientRequestToken: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        sourceContent: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSource? = nil
    ) {
        self.buildWorkflowType = buildWorkflowType
        self.clientRequestToken = clientRequestToken
        self.policyArn = policyArn
        self.sourceContent = sourceContent
    }
}

public struct StartAutomatedReasoningPolicyBuildWorkflowOutput: Swift.Sendable {
    /// The unique identifier of the newly started build workflow. Use this ID to track the workflow's progress and retrieve its results.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        buildWorkflowId: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.policyArn = policyArn
    }
}

public struct StartAutomatedReasoningPolicyTestWorkflowInput: Swift.Sendable {
    /// The build workflow identifier. The build workflow must show a COMPLETED status before running tests.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request but doesn't return an error.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy to test.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The list of test identifiers to run. If not provided, all tests for the policy are run.
    public var testCaseIds: [Swift.String]?

    public init(
        buildWorkflowId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        testCaseIds: [Swift.String]? = nil
    ) {
        self.buildWorkflowId = buildWorkflowId
        self.clientRequestToken = clientRequestToken
        self.policyArn = policyArn
        self.testCaseIds = testCaseIds
    }
}

public struct StartAutomatedReasoningPolicyTestWorkflowOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the policy for which the test workflow was started.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        policyArn: Swift.String? = nil
    ) {
        self.policyArn = policyArn
    }
}

public struct UpdateAutomatedReasoningPolicyInput: Swift.Sendable {
    /// The updated description for the Automated Reasoning policy.
    public var description: Swift.String?
    /// The updated name for the Automated Reasoning policy.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy to update. This must be the ARN of a draft policy.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The updated policy definition containing the formal logic rules, variables, and types.
    /// This member is required.
    public var policyDefinition: BedrockClientTypes.AutomatedReasoningPolicyDefinition?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        policyDefinition: BedrockClientTypes.AutomatedReasoningPolicyDefinition? = nil
    ) {
        self.description = description
        self.name = name
        self.policyArn = policyArn
        self.policyDefinition = policyDefinition
    }
}

extension UpdateAutomatedReasoningPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAutomatedReasoningPolicyInput(policyArn: \(Swift.String(describing: policyArn)), policyDefinition: \(Swift.String(describing: policyDefinition)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateAutomatedReasoningPolicyOutput: Swift.Sendable {
    /// The hash of the updated policy definition.
    /// This member is required.
    public var definitionHash: Swift.String?
    /// The updated name of the policy.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the updated policy.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The timestamp when the policy was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        definitionHash: Swift.String? = nil,
        name: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.definitionHash = definitionHash
        self.name = name
        self.policyArn = policyArn
        self.updatedAt = updatedAt
    }
}

extension UpdateAutomatedReasoningPolicyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAutomatedReasoningPolicyOutput(definitionHash: \(Swift.String(describing: definitionHash)), policyArn: \(Swift.String(describing: policyArn)), updatedAt: \(Swift.String(describing: updatedAt)), name: \"CONTENT_REDACTED\")"}
}

public struct UpdateAutomatedReasoningPolicyAnnotationsInput: Swift.Sendable {
    /// The updated annotations containing modified rules, variables, and types for the policy.
    /// This member is required.
    public var annotations: [BedrockClientTypes.AutomatedReasoningPolicyAnnotation]?
    /// The unique identifier of the build workflow whose annotations you want to update.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The hash value of the annotation set that you're updating. This is used for optimistic concurrency control to prevent conflicting updates.
    /// This member is required.
    public var lastUpdatedAnnotationSetHash: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy whose annotations you want to update.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        annotations: [BedrockClientTypes.AutomatedReasoningPolicyAnnotation]? = nil,
        buildWorkflowId: Swift.String? = nil,
        lastUpdatedAnnotationSetHash: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.annotations = annotations
        self.buildWorkflowId = buildWorkflowId
        self.lastUpdatedAnnotationSetHash = lastUpdatedAnnotationSetHash
        self.policyArn = policyArn
    }
}

public struct UpdateAutomatedReasoningPolicyAnnotationsOutput: Swift.Sendable {
    /// The new hash value representing the updated state of the annotations.
    /// This member is required.
    public var annotationSetHash: Swift.String?
    /// The unique identifier of the build workflow.
    /// This member is required.
    public var buildWorkflowId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The timestamp when the annotations were updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        annotationSetHash: Swift.String? = nil,
        buildWorkflowId: Swift.String? = nil,
        policyArn: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.annotationSetHash = annotationSetHash
        self.buildWorkflowId = buildWorkflowId
        self.policyArn = policyArn
        self.updatedAt = updatedAt
    }
}

public struct UpdateAutomatedReasoningPolicyTestCaseInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error.
    public var clientRequestToken: Swift.String?
    /// The updated minimum confidence level for logic validation. If null is provided, the threshold will be removed.
    public var confidenceThreshold: Swift.Double?
    /// The updated expected result of the Automated Reasoning check.
    /// This member is required.
    public var expectedAggregatedFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult?
    /// The updated content to be validated by the Automated Reasoning policy.
    /// This member is required.
    public var guardContent: Swift.String?
    /// The timestamp when the test was last updated. This is used as a concurrency token to prevent conflicting modifications.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the Automated Reasoning policy that contains the test.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The updated input query or prompt that generated the content.
    public var queryContent: Swift.String?
    /// The unique identifier of the test to update.
    /// This member is required.
    public var testCaseId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        confidenceThreshold: Swift.Double? = nil,
        expectedAggregatedFindingsResult: BedrockClientTypes.AutomatedReasoningCheckResult? = nil,
        guardContent: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        policyArn: Swift.String? = nil,
        queryContent: Swift.String? = nil,
        testCaseId: Swift.String? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.confidenceThreshold = confidenceThreshold
        self.expectedAggregatedFindingsResult = expectedAggregatedFindingsResult
        self.guardContent = guardContent
        self.lastUpdatedAt = lastUpdatedAt
        self.policyArn = policyArn
        self.queryContent = queryContent
        self.testCaseId = testCaseId
    }
}

extension UpdateAutomatedReasoningPolicyTestCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAutomatedReasoningPolicyTestCaseInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), confidenceThreshold: \(Swift.String(describing: confidenceThreshold)), expectedAggregatedFindingsResult: \(Swift.String(describing: expectedAggregatedFindingsResult)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), policyArn: \(Swift.String(describing: policyArn)), testCaseId: \(Swift.String(describing: testCaseId)), guardContent: \"CONTENT_REDACTED\", queryContent: \"CONTENT_REDACTED\")"}
}

public struct UpdateAutomatedReasoningPolicyTestCaseOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the policy that contains the updated test.
    /// This member is required.
    public var policyArn: Swift.String?
    /// The unique identifier of the updated test.
    /// This member is required.
    public var testCaseId: Swift.String?

    public init(
        policyArn: Swift.String? = nil,
        testCaseId: Swift.String? = nil
    ) {
        self.policyArn = policyArn
        self.testCaseId = testCaseId
    }
}

extension BedrockClientTypes {

    /// The configuration of a virtual private cloud (VPC). For more information, see [Protect your data using Amazon Virtual Private Cloud and Amazon Web Services PrivateLink](https://docs.aws.amazon.com/bedrock/latest/userguide/usingVPC.html).
    public struct VpcConfig: Swift.Sendable {
        /// An array of IDs for each security group in the VPC to use.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// An array of IDs for each subnet in the VPC to use.
        /// This member is required.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        ) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }
}

extension BedrockClientTypes {

    /// Specifies the configuration for a Amazon SageMaker endpoint.
    public struct SageMakerEndpoint: Swift.Sendable {
        /// The ARN of the IAM role that Amazon SageMaker can assume to access model artifacts and docker image for deployment on Amazon EC2 compute instances or for batch transform jobs.
        /// This member is required.
        public var executionRole: Swift.String?
        /// The number of Amazon EC2 compute instances to deploy for initial endpoint creation.
        /// This member is required.
        public var initialInstanceCount: Swift.Int?
        /// The Amazon EC2 compute instance type to deploy for hosting the model.
        /// This member is required.
        public var instanceType: Swift.String?
        /// The Amazon Web Services KMS key that Amazon SageMaker uses to encrypt data on the storage volume attached to the Amazon EC2 compute instance that hosts the endpoint.
        public var kmsEncryptionKey: Swift.String?
        /// The VPC configuration for the endpoint.
        public var vpc: BedrockClientTypes.VpcConfig?

        public init(
            executionRole: Swift.String? = nil,
            initialInstanceCount: Swift.Int? = nil,
            instanceType: Swift.String? = nil,
            kmsEncryptionKey: Swift.String? = nil,
            vpc: BedrockClientTypes.VpcConfig? = nil
        ) {
            self.executionRole = executionRole
            self.initialInstanceCount = initialInstanceCount
            self.instanceType = instanceType
            self.kmsEncryptionKey = kmsEncryptionKey
            self.vpc = vpc
        }
    }
}

extension BedrockClientTypes {

    /// Specifies the configuration for the endpoint.
    public enum EndpointConfig: Swift.Sendable {
        /// The configuration specific to Amazon SageMaker for the endpoint.
        case sagemaker(BedrockClientTypes.SageMakerEndpoint)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateMarketplaceModelEndpointInput: Swift.Sendable {
    /// Indicates whether you accept the end-user license agreement (EULA) for the model. Set to true to accept the EULA.
    public var acceptEula: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token is listed as not required because Amazon Web Services SDKs automatically generate it for you and set this parameter. If you're not using the Amazon Web Services SDK or the CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The configuration for the endpoint, including the number and type of instances to use.
    /// This member is required.
    public var endpointConfig: BedrockClientTypes.EndpointConfig?
    /// The name of the endpoint. This name must be unique within your Amazon Web Services account and region.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The ARN of the model from Amazon Bedrock Marketplace that you want to deploy to the endpoint.
    /// This member is required.
    public var modelSourceIdentifier: Swift.String?
    /// An array of key-value pairs to apply to the underlying Amazon SageMaker endpoint. You can use these tags to organize and identify your Amazon Web Services resources.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        acceptEula: Swift.Bool? = false,
        clientRequestToken: Swift.String? = nil,
        endpointConfig: BedrockClientTypes.EndpointConfig? = nil,
        endpointName: Swift.String? = nil,
        modelSourceIdentifier: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.acceptEula = acceptEula
        self.clientRequestToken = clientRequestToken
        self.endpointConfig = endpointConfig
        self.endpointName = endpointName
        self.modelSourceIdentifier = modelSourceIdentifier
        self.tags = tags
    }
}

extension BedrockClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case incompatibleEndpoint
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .incompatibleEndpoint,
                .registered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .incompatibleEndpoint: return "INCOMPATIBLE_ENDPOINT"
            case .registered: return "REGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Contains details about an endpoint for a model from Amazon Bedrock Marketplace.
    public struct MarketplaceModelEndpoint: Swift.Sendable {
        /// The timestamp when the endpoint was registered.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the endpoint.
        /// This member is required.
        public var endpointArn: Swift.String?
        /// The configuration of the endpoint, including the number and type of instances used.
        /// This member is required.
        public var endpointConfig: BedrockClientTypes.EndpointConfig?
        /// The current status of the endpoint (e.g., Creating, InService, Updating, Failed).
        /// This member is required.
        public var endpointStatus: Swift.String?
        /// Additional information about the endpoint status, if available.
        public var endpointStatusMessage: Swift.String?
        /// The ARN of the model from Amazon Bedrock Marketplace that is deployed on this endpoint.
        /// This member is required.
        public var modelSourceIdentifier: Swift.String?
        /// The overall status of the endpoint in Amazon Bedrock Marketplace (e.g., ACTIVE, INACTIVE).
        public var status: BedrockClientTypes.Status?
        /// Additional information about the overall status, if available.
        public var statusMessage: Swift.String?
        /// The timestamp when the endpoint was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            endpointArn: Swift.String? = nil,
            endpointConfig: BedrockClientTypes.EndpointConfig? = nil,
            endpointStatus: Swift.String? = nil,
            endpointStatusMessage: Swift.String? = nil,
            modelSourceIdentifier: Swift.String? = nil,
            status: BedrockClientTypes.Status? = nil,
            statusMessage: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.createdAt = createdAt
            self.endpointArn = endpointArn
            self.endpointConfig = endpointConfig
            self.endpointStatus = endpointStatus
            self.endpointStatusMessage = endpointStatusMessage
            self.modelSourceIdentifier = modelSourceIdentifier
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }
    }
}

public struct CreateMarketplaceModelEndpointOutput: Swift.Sendable {
    /// Details about the created endpoint.
    /// This member is required.
    public var marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint?

    public init(
        marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint? = nil
    ) {
        self.marketplaceModelEndpoint = marketplaceModelEndpoint
    }
}

public struct DeleteMarketplaceModelEndpointInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint you want to delete.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    ) {
        self.endpointArn = endpointArn
    }
}

public struct DeleteMarketplaceModelEndpointOutput: Swift.Sendable {

    public init() { }
}

/// Returned if the service cannot complete the request.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DeregisterMarketplaceModelEndpointInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint you want to deregister.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    ) {
        self.endpointArn = endpointArn
    }
}

public struct DeregisterMarketplaceModelEndpointOutput: Swift.Sendable {

    public init() { }
}

public struct GetMarketplaceModelEndpointInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the endpoint you want to get information about.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    ) {
        self.endpointArn = endpointArn
    }
}

public struct GetMarketplaceModelEndpointOutput: Swift.Sendable {
    /// Details about the requested endpoint.
    public var marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint?

    public init(
        marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint? = nil
    ) {
        self.marketplaceModelEndpoint = marketplaceModelEndpoint
    }
}

public struct ListMarketplaceModelEndpointsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. If more results are available, the operation returns a NextToken value.
    public var maxResults: Swift.Int?
    /// If specified, only endpoints for the given model source identifier are returned.
    public var modelSourceEquals: Swift.String?
    /// The token for the next set of results. You receive this token from a previous ListMarketplaceModelEndpoints call.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelSourceEquals: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.modelSourceEquals = modelSourceEquals
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {

    /// Provides a summary of an endpoint for a model from Amazon Bedrock Marketplace.
    public struct MarketplaceModelEndpointSummary: Swift.Sendable {
        /// The timestamp when the endpoint was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the endpoint.
        /// This member is required.
        public var endpointArn: Swift.String?
        /// The ARN of the model from Amazon Bedrock Marketplace that is deployed on this endpoint.
        /// This member is required.
        public var modelSourceIdentifier: Swift.String?
        /// The overall status of the endpoint in Amazon Bedrock Marketplace.
        public var status: BedrockClientTypes.Status?
        /// Additional information about the overall status, if available.
        public var statusMessage: Swift.String?
        /// The timestamp when the endpoint was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            endpointArn: Swift.String? = nil,
            modelSourceIdentifier: Swift.String? = nil,
            status: BedrockClientTypes.Status? = nil,
            statusMessage: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.createdAt = createdAt
            self.endpointArn = endpointArn
            self.modelSourceIdentifier = modelSourceIdentifier
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }
    }
}

public struct ListMarketplaceModelEndpointsOutput: Swift.Sendable {
    /// An array of endpoint summaries.
    public var marketplaceModelEndpoints: [BedrockClientTypes.MarketplaceModelEndpointSummary]?
    /// The token for the next set of results. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        marketplaceModelEndpoints: [BedrockClientTypes.MarketplaceModelEndpointSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.marketplaceModelEndpoints = marketplaceModelEndpoints
        self.nextToken = nextToken
    }
}

public struct RegisterMarketplaceModelEndpointInput: Swift.Sendable {
    /// The ARN of the Amazon SageMaker endpoint you want to register with Amazon Bedrock Marketplace.
    /// This member is required.
    public var endpointIdentifier: Swift.String?
    /// The ARN of the model from Amazon Bedrock Marketplace that is deployed on the endpoint.
    /// This member is required.
    public var modelSourceIdentifier: Swift.String?

    public init(
        endpointIdentifier: Swift.String? = nil,
        modelSourceIdentifier: Swift.String? = nil
    ) {
        self.endpointIdentifier = endpointIdentifier
        self.modelSourceIdentifier = modelSourceIdentifier
    }
}

public struct RegisterMarketplaceModelEndpointOutput: Swift.Sendable {
    /// Details about the registered endpoint.
    /// This member is required.
    public var marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint?

    public init(
        marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint? = nil
    ) {
        self.marketplaceModelEndpoint = marketplaceModelEndpoint
    }
}

public struct UpdateMarketplaceModelEndpointInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This token is listed as not required because Amazon Web Services SDKs automatically generate it for you and set this parameter. If you're not using the Amazon Web Services SDK or the CLI, you must provide this token or the action will fail.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the endpoint you want to update.
    /// This member is required.
    public var endpointArn: Swift.String?
    /// The new configuration for the endpoint, including the number and type of instances to use.
    /// This member is required.
    public var endpointConfig: BedrockClientTypes.EndpointConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        endpointArn: Swift.String? = nil,
        endpointConfig: BedrockClientTypes.EndpointConfig? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.endpointArn = endpointArn
        self.endpointConfig = endpointConfig
    }
}

public struct UpdateMarketplaceModelEndpointOutput: Swift.Sendable {
    /// Details about the updated endpoint.
    /// This member is required.
    public var marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint?

    public init(
        marketplaceModelEndpoint: BedrockClientTypes.MarketplaceModelEndpoint? = nil
    ) {
        self.marketplaceModelEndpoint = marketplaceModelEndpoint
    }
}

public struct CreateCustomModelDeploymentInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the operation completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-idempotency.html).
    public var clientRequestToken: Swift.String?
    /// A description for the custom model deployment to help you identify its purpose.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the custom model to deploy for on-demand inference. The custom model must be in the Active state.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The name for the custom model deployment. The name must be unique within your Amazon Web Services account and Region.
    /// This member is required.
    public var modelDeploymentName: Swift.String?
    /// Tags to assign to the custom model deployment. You can use tags to organize and track your Amazon Web Services resources for cost allocation and management purposes.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        modelArn: Swift.String? = nil,
        modelDeploymentName: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.modelArn = modelArn
        self.modelDeploymentName = modelDeploymentName
        self.tags = tags
    }
}

public struct CreateCustomModelDeploymentOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the custom model deployment. Use this ARN as the modelId parameter when invoking the model with the InvokeModel or Converse operations.
    /// This member is required.
    public var customModelDeploymentArn: Swift.String?

    public init(
        customModelDeploymentArn: Swift.String? = nil
    ) {
        self.customModelDeploymentArn = customModelDeploymentArn
    }
}

public struct DeleteCustomModelDeploymentInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or name of the custom model deployment to delete.
    /// This member is required.
    public var customModelDeploymentIdentifier: Swift.String?

    public init(
        customModelDeploymentIdentifier: Swift.String? = nil
    ) {
        self.customModelDeploymentIdentifier = customModelDeploymentIdentifier
    }
}

public struct DeleteCustomModelDeploymentOutput: Swift.Sendable {

    public init() { }
}

public struct GetCustomModelDeploymentInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or name of the custom model deployment to retrieve information about.
    /// This member is required.
    public var customModelDeploymentIdentifier: Swift.String?

    public init(
        customModelDeploymentIdentifier: Swift.String? = nil
    ) {
        self.customModelDeploymentIdentifier = customModelDeploymentIdentifier
    }
}

extension BedrockClientTypes {

    public enum CustomModelDeploymentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomModelDeploymentStatus] {
            return [
                .active,
                .creating,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creating: return "Creating"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum CustomModelDeploymentUpdateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case updateCompleted
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomModelDeploymentUpdateStatus] {
            return [
                .updateCompleted,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .updateCompleted: return "UpdateCompleted"
            case .updateFailed: return "UpdateFailed"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Details about an update to a custom model deployment, including the new custom model resource ARN and current update status.
    public struct CustomModelDeploymentUpdateDetails: Swift.Sendable {
        /// ARN of the new custom model being deployed as part of the update.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Current status of the deployment update.
        /// This member is required.
        public var updateStatus: BedrockClientTypes.CustomModelDeploymentUpdateStatus?

        public init(
            modelArn: Swift.String? = nil,
            updateStatus: BedrockClientTypes.CustomModelDeploymentUpdateStatus? = nil
        ) {
            self.modelArn = modelArn
            self.updateStatus = updateStatus
        }
    }
}

public struct GetCustomModelDeploymentOutput: Swift.Sendable {
    /// The date and time when the custom model deployment was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the custom model deployment.
    /// This member is required.
    public var customModelDeploymentArn: Swift.String?
    /// The description of the custom model deployment.
    public var description: Swift.String?
    /// If the deployment status is FAILED, this field contains a message describing the failure reason.
    public var failureMessage: Swift.String?
    /// The date and time when the custom model deployment was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the custom model associated with this deployment.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The name of the custom model deployment.
    /// This member is required.
    public var modelDeploymentName: Swift.String?
    /// The status of the custom model deployment. Possible values are:
    ///
    /// * CREATING - The deployment is being set up and prepared for inference.
    ///
    /// * ACTIVE - The deployment is ready and available for inference requests.
    ///
    /// * FAILED - The deployment failed to be created or became unavailable.
    /// This member is required.
    public var status: BedrockClientTypes.CustomModelDeploymentStatus?
    /// Details about any pending or completed updates to the custom model deployment, including the new model ARN and update status.
    public var updateDetails: BedrockClientTypes.CustomModelDeploymentUpdateDetails?

    public init(
        createdAt: Foundation.Date? = nil,
        customModelDeploymentArn: Swift.String? = nil,
        description: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        modelArn: Swift.String? = nil,
        modelDeploymentName: Swift.String? = nil,
        status: BedrockClientTypes.CustomModelDeploymentStatus? = nil,
        updateDetails: BedrockClientTypes.CustomModelDeploymentUpdateDetails? = nil
    ) {
        self.createdAt = createdAt
        self.customModelDeploymentArn = customModelDeploymentArn
        self.description = description
        self.failureMessage = failureMessage
        self.lastUpdatedAt = lastUpdatedAt
        self.modelArn = modelArn
        self.modelDeploymentName = modelDeploymentName
        self.status = status
        self.updateDetails = updateDetails
    }
}

extension BedrockClientTypes {

    public enum SortModelsBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortModelsBy] {
            return [
                .creationTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListCustomModelDeploymentsInput: Swift.Sendable {
    /// Filters deployments created after the specified date and time.
    public var createdAfter: Foundation.Date?
    /// Filters deployments created before the specified date and time.
    public var createdBefore: Foundation.Date?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// Filters deployments by the Amazon Resource Name (ARN) of the associated custom model.
    public var modelArnEquals: Swift.String?
    /// Filters deployments whose names contain the specified string.
    public var nameContains: Swift.String?
    /// The token for the next set of results. Use this token to retrieve additional results when the response is truncated.
    public var nextToken: Swift.String?
    /// The field to sort the results by. The only supported value is CreationTime.
    public var sortBy: BedrockClientTypes.SortModelsBy?
    /// The sort order for the results. Valid values are Ascending and Descending. Default is Descending.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Filters deployments by status. Valid values are CREATING, ACTIVE, and FAILED.
    public var statusEquals: BedrockClientTypes.CustomModelDeploymentStatus?

    public init(
        createdAfter: Foundation.Date? = nil,
        createdBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        modelArnEquals: Swift.String? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortModelsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.CustomModelDeploymentStatus? = nil
    ) {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.modelArnEquals = modelArnEquals
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {

    /// Contains summary information about a custom model deployment, including its ARN, name, status, and associated custom model.
    public struct CustomModelDeploymentSummary: Swift.Sendable {
        /// The date and time when the custom model deployment was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the custom model deployment.
        /// This member is required.
        public var customModelDeploymentArn: Swift.String?
        /// The name of the custom model deployment.
        /// This member is required.
        public var customModelDeploymentName: Swift.String?
        /// If the deployment status is FAILED, this field contains a message describing the failure reason.
        public var failureMessage: Swift.String?
        /// The date and time when the custom model deployment was last modified.
        public var lastUpdatedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the custom model associated with this deployment.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The status of the custom model deployment. Possible values are CREATING, ACTIVE, and FAILED.
        /// This member is required.
        public var status: BedrockClientTypes.CustomModelDeploymentStatus?

        public init(
            createdAt: Foundation.Date? = nil,
            customModelDeploymentArn: Swift.String? = nil,
            customModelDeploymentName: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            modelArn: Swift.String? = nil,
            status: BedrockClientTypes.CustomModelDeploymentStatus? = nil
        ) {
            self.createdAt = createdAt
            self.customModelDeploymentArn = customModelDeploymentArn
            self.customModelDeploymentName = customModelDeploymentName
            self.failureMessage = failureMessage
            self.lastUpdatedAt = lastUpdatedAt
            self.modelArn = modelArn
            self.status = status
        }
    }
}

public struct ListCustomModelDeploymentsOutput: Swift.Sendable {
    /// A list of custom model deployment summaries.
    public var modelDeploymentSummaries: [BedrockClientTypes.CustomModelDeploymentSummary]?
    /// The token for the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        modelDeploymentSummaries: [BedrockClientTypes.CustomModelDeploymentSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.modelDeploymentSummaries = modelDeploymentSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateCustomModelDeploymentInput: Swift.Sendable {
    /// Identifier of the custom model deployment to update with the new custom model.
    /// This member is required.
    public var customModelDeploymentIdentifier: Swift.String?
    /// ARN of the new custom model to deploy. This replaces the currently deployed model.
    /// This member is required.
    public var modelArn: Swift.String?

    public init(
        customModelDeploymentIdentifier: Swift.String? = nil,
        modelArn: Swift.String? = nil
    ) {
        self.customModelDeploymentIdentifier = customModelDeploymentIdentifier
        self.modelArn = modelArn
    }
}

public struct UpdateCustomModelDeploymentOutput: Swift.Sendable {
    /// ARN of the custom model deployment being updated.
    /// This member is required.
    public var customModelDeploymentArn: Swift.String?

    public init(
        customModelDeploymentArn: Swift.String? = nil
    ) {
        self.customModelDeploymentArn = customModelDeploymentArn
    }
}

extension BedrockClientTypes {

    /// The Amazon S3 data source of the model to import.
    public struct S3DataSource: Swift.Sendable {
        /// The URI of the Amazon S3 data source.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        ) {
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// The data source of the model to import.
    public enum ModelDataSource: Swift.Sendable {
        /// The Amazon S3 data source of the model to import.
        case s3datasource(BedrockClientTypes.S3DataSource)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateCustomModelInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the customer managed KMS key to encrypt the custom model. If you don't provide a KMS key, Amazon Bedrock uses an Amazon Web Services-managed KMS key to encrypt the model. If you provide a customer managed KMS key, your Amazon Bedrock service role must have permissions to use it. For more information see [Encryption of imported models](https://docs.aws.amazon.com/bedrock/latest/userguide/encryption-import-model.html).
    public var modelKmsKeyArn: Swift.String?
    /// A unique name for the custom model.
    /// This member is required.
    public var modelName: Swift.String?
    /// The data source for the model. The Amazon S3 URI in the model source must be for the Amazon-managed Amazon S3 bucket containing your model artifacts.
    /// This member is required.
    public var modelSourceConfig: BedrockClientTypes.ModelDataSource?
    /// A list of key-value pairs to associate with the custom model resource. You can use these tags to organize and identify your resources. For more information, see [Tagging resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var modelTags: [BedrockClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock assumes to perform tasks on your behalf. This role must have permissions to access the Amazon S3 bucket containing your model artifacts and the KMS key (if specified). For more information, see [Setting up an IAM service role for importing models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-import-iam-role.html) in the Amazon Bedrock User Guide.
    public var roleArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        modelKmsKeyArn: Swift.String? = nil,
        modelName: Swift.String? = nil,
        modelSourceConfig: BedrockClientTypes.ModelDataSource? = nil,
        modelTags: [BedrockClientTypes.Tag]? = nil,
        roleArn: Swift.String? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.modelKmsKeyArn = modelKmsKeyArn
        self.modelName = modelName
        self.modelSourceConfig = modelSourceConfig
        self.modelTags = modelTags
        self.roleArn = roleArn
    }
}

public struct CreateCustomModelOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new custom model.
    /// This member is required.
    public var modelArn: Swift.String?

    public init(
        modelArn: Swift.String? = nil
    ) {
        self.modelArn = modelArn
    }
}

public struct DeleteCustomModelInput: Swift.Sendable {
    /// Name of the model to delete.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    ) {
        self.modelIdentifier = modelIdentifier
    }
}

public struct DeleteCustomModelOutput: Swift.Sendable {

    public init() { }
}

public struct GetCustomModelInput: Swift.Sendable {
    /// Name or Amazon Resource Name (ARN) of the custom model.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    ) {
        self.modelIdentifier = modelIdentifier
    }
}

extension BedrockClientTypes {

    /// Details about a teacher model used for model customization.
    public struct TeacherModelConfig: Swift.Sendable {
        /// The maximum number of tokens requested when the customization job invokes the teacher model.
        public var maxResponseLengthForInference: Swift.Int?
        /// The identifier of the teacher model.
        /// This member is required.
        public var teacherModelIdentifier: Swift.String?

        public init(
            maxResponseLengthForInference: Swift.Int? = nil,
            teacherModelIdentifier: Swift.String? = nil
        ) {
            self.maxResponseLengthForInference = maxResponseLengthForInference
            self.teacherModelIdentifier = teacherModelIdentifier
        }
    }
}

extension BedrockClientTypes {

    /// Settings for distilling a foundation model into a smaller and more efficient model.
    public struct DistillationConfig: Swift.Sendable {
        /// The teacher model configuration.
        /// This member is required.
        public var teacherModelConfig: BedrockClientTypes.TeacherModelConfig?

        public init(
            teacherModelConfig: BedrockClientTypes.TeacherModelConfig? = nil
        ) {
            self.teacherModelConfig = teacherModelConfig
        }
    }
}

extension BedrockClientTypes {

    /// Configuration for using an AWS Lambda function to grade model responses during reinforcement fine-tuning training.
    public struct LambdaGraderConfig: Swift.Sendable {
        /// ARN of the AWS Lambda function that will evaluate model responses and return reward scores for RFT training.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        ) {
            self.lambdaArn = lambdaArn
        }
    }
}

extension BedrockClientTypes {

    /// Configuration for the grader used in reinforcement fine-tuning to evaluate model responses and provide reward signals.
    public enum GraderConfig: Swift.Sendable {
        /// Configuration for using an AWS Lambda function as the grader for evaluating model responses and provide reward signals in reinforcement fine-tuning.
        case lambdagrader(BedrockClientTypes.LambdaGraderConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    public enum ReasoningEffort: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [ReasoningEffort] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .medium: return "medium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Hyperparameters for controlling the reinforcement fine-tuning training process, including learning settings and evaluation intervals.
    public struct RFTHyperParameters: Swift.Sendable {
        /// Number of training samples processed in each batch during reinforcement fine-tuning (RFT) training. Larger batches may improve training stability.
        public var batchSize: Swift.Int?
        /// Number of training epochs to run during reinforcement fine-tuning. Higher values may improve performance but increase training time.
        public var epochCount: Swift.Int?
        /// Interval between evaluation runs during RFT training, measured in training steps. More frequent evaluation provides better monitoring.
        public var evalInterval: Swift.Int?
        /// Maximum number of tokens the model can generate in response to each prompt during RFT training.
        public var inferenceMaxTokens: Swift.Int?
        /// Learning rate for the reinforcement fine-tuning. Controls how quickly the model adapts to reward signals.
        public var learningRate: Swift.Float?
        /// Maximum length of input prompts during RFT training, measured in tokens. Longer prompts allow more context but increase memory usage and training-time.
        public var maxPromptLength: Swift.Int?
        /// Level of reasoning effort applied during RFT training. Higher values may improve response quality but increase training time.
        public var reasoningEffort: BedrockClientTypes.ReasoningEffort?
        /// Number of response samples generated per prompt during RFT training. More samples provide better reward signal estimation.
        public var trainingSamplePerPrompt: Swift.Int?

        public init(
            batchSize: Swift.Int? = nil,
            epochCount: Swift.Int? = nil,
            evalInterval: Swift.Int? = nil,
            inferenceMaxTokens: Swift.Int? = nil,
            learningRate: Swift.Float? = nil,
            maxPromptLength: Swift.Int? = nil,
            reasoningEffort: BedrockClientTypes.ReasoningEffort? = nil,
            trainingSamplePerPrompt: Swift.Int? = nil
        ) {
            self.batchSize = batchSize
            self.epochCount = epochCount
            self.evalInterval = evalInterval
            self.inferenceMaxTokens = inferenceMaxTokens
            self.learningRate = learningRate
            self.maxPromptLength = maxPromptLength
            self.reasoningEffort = reasoningEffort
            self.trainingSamplePerPrompt = trainingSamplePerPrompt
        }
    }
}

extension BedrockClientTypes {

    /// Configuration settings for reinforcement fine-tuning (RFT), including grader configuration and training hyperparameters.
    public struct RFTConfig: Swift.Sendable {
        /// Configuration for the grader that evaluates model responses and provides reward signals during RFT training.
        public var graderConfig: BedrockClientTypes.GraderConfig?
        /// Hyperparameters that control the reinforcement fine-tuning training process, including learning rate, batch size, and epoch count.
        public var hyperParameters: BedrockClientTypes.RFTHyperParameters?

        public init(
            graderConfig: BedrockClientTypes.GraderConfig? = nil,
            hyperParameters: BedrockClientTypes.RFTHyperParameters? = nil
        ) {
            self.graderConfig = graderConfig
            self.hyperParameters = hyperParameters
        }
    }
}

extension BedrockClientTypes {

    /// A model customization configuration
    public enum CustomizationConfig: Swift.Sendable {
        /// The Distillation configuration for the custom model.
        case distillationconfig(BedrockClientTypes.DistillationConfig)
        /// Configuration settings for reinforcement fine-tuning (RFT) model customization, including grader configuration and hyperparameters.
        case rftconfig(BedrockClientTypes.RFTConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    public enum CustomizationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuedPreTraining
        case distillation
        case fineTuning
        case imported
        case reinforcementFineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomizationType] {
            return [
                .continuedPreTraining,
                .distillation,
                .fineTuning,
                .imported,
                .reinforcementFineTuning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .distillation: return "DISTILLATION"
            case .fineTuning: return "FINE_TUNING"
            case .imported: return "IMPORTED"
            case .reinforcementFineTuning: return "REINFORCEMENT_FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum ModelStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelStatus] {
            return [
                .active,
                .creating,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creating: return "Creating"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// S3 Location of the output data.
    public struct OutputDataConfig: Swift.Sendable {
        /// The S3 URI where the output data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        ) {
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// A storage location for invocation logs.
    public enum InvocationLogSource: Swift.Sendable {
        /// The URI of an invocation log in a bucket.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// A mapping of a metadata key to a value that it should or should not equal.
    public struct RequestMetadataBaseFilters: Swift.Sendable {
        /// Include results where the key equals the value.
        public var equals: [Swift.String: Swift.String]?
        /// Include results where the key does not equal the value.
        public var notEquals: [Swift.String: Swift.String]?

        public init(
            equals: [Swift.String: Swift.String]? = nil,
            notEquals: [Swift.String: Swift.String]? = nil
        ) {
            self.equals = equals
            self.notEquals = notEquals
        }
    }
}

extension BedrockClientTypes.RequestMetadataBaseFilters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestMetadataBaseFilters(equals: \"CONTENT_REDACTED\", notEquals: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Rules for filtering invocation logs. A filter can be a mapping of a metadata key to a value that it should or should not equal (a base filter), or a list of base filters that are all applied with AND or OR logical operators
    public enum RequestMetadataFilters: Swift.Sendable {
        /// Include results where the key equals the value.
        case equals([Swift.String: Swift.String])
        /// Include results where the key does not equal the value.
        case notequals([Swift.String: Swift.String])
        /// Include results where all of the based filters match.
        case andall([BedrockClientTypes.RequestMetadataBaseFilters])
        /// Include results where any of the base filters match.
        case orall([BedrockClientTypes.RequestMetadataBaseFilters])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Settings for using invocation logs to customize a model.
    public struct InvocationLogsConfig: Swift.Sendable {
        /// The source of the invocation logs.
        /// This member is required.
        public var invocationLogSource: BedrockClientTypes.InvocationLogSource?
        /// Rules for filtering invocation logs based on request metadata.
        public var requestMetadataFilters: BedrockClientTypes.RequestMetadataFilters?
        /// Whether to use the model's response for training, or just the prompt. The default value is False.
        public var usePromptResponse: Swift.Bool

        public init(
            invocationLogSource: BedrockClientTypes.InvocationLogSource? = nil,
            requestMetadataFilters: BedrockClientTypes.RequestMetadataFilters? = nil,
            usePromptResponse: Swift.Bool = false
        ) {
            self.invocationLogSource = invocationLogSource
            self.requestMetadataFilters = requestMetadataFilters
            self.usePromptResponse = usePromptResponse
        }
    }
}

extension BedrockClientTypes {

    /// S3 Location of the training data.
    public struct TrainingDataConfig: Swift.Sendable {
        /// Settings for using invocation logs to customize a model.
        public var invocationLogsConfig: BedrockClientTypes.InvocationLogsConfig?
        /// The S3 URI where the training data is stored.
        public var s3Uri: Swift.String?

        public init(
            invocationLogsConfig: BedrockClientTypes.InvocationLogsConfig? = nil,
            s3Uri: Swift.String? = nil
        ) {
            self.invocationLogsConfig = invocationLogsConfig
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// Metrics associated with the custom job.
    public struct TrainingMetrics: Swift.Sendable {
        /// Loss metric associated with the custom job.
        public var trainingLoss: Swift.Float?

        public init(
            trainingLoss: Swift.Float? = nil
        ) {
            self.trainingLoss = trainingLoss
        }
    }
}

extension BedrockClientTypes {

    /// Information about a validator.
    public struct Validator: Swift.Sendable {
        /// The S3 URI where the validation data is stored.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        ) {
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// Array of up to 10 validators.
    public struct ValidationDataConfig: Swift.Sendable {
        /// Information about the validators.
        /// This member is required.
        public var validators: [BedrockClientTypes.Validator]?

        public init(
            validators: [BedrockClientTypes.Validator]? = nil
        ) {
            self.validators = validators
        }
    }
}

extension BedrockClientTypes {

    /// The metric for the validator.
    public struct ValidatorMetric: Swift.Sendable {
        /// The validation loss associated with this validator.
        public var validationLoss: Swift.Float?

        public init(
            validationLoss: Swift.Float? = nil
        ) {
            self.validationLoss = validationLoss
        }
    }
}

public struct GetCustomModelOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the base model.
    public var baseModelArn: Swift.String?
    /// Creation time of the model.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The customization configuration for the custom model.
    public var customizationConfig: BedrockClientTypes.CustomizationConfig?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// A failure message for any issues that occurred when creating the custom model. This is included for only a failed CreateCustomModel operation.
    public var failureMessage: Swift.String?
    /// Hyperparameter values associated with this model. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    public var hyperParameters: [Swift.String: Swift.String]?
    /// Job Amazon Resource Name (ARN) associated with this model. For models that you create with the [CreateCustomModel](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_CreateCustomModel.html) API operation, this is NULL.
    public var jobArn: Swift.String?
    /// Job name associated with this model.
    public var jobName: Swift.String?
    /// Amazon Resource Name (ARN) associated with this model.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var modelKmsKeyArn: Swift.String?
    /// Model name associated with this model.
    /// This member is required.
    public var modelName: Swift.String?
    /// The current status of the custom model. Possible values include:
    ///
    /// * Creating - The model is being created and validated.
    ///
    /// * Active - The model has been successfully created and is ready for use.
    ///
    /// * Failed - The model creation process failed. Check the failureMessage field for details.
    public var modelStatus: BedrockClientTypes.ModelStatus?
    /// Output data configuration associated with this custom model.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// Contains information about the training dataset.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Contains training metrics from the job creation.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Contains information about the validation dataset.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The validation metrics from the job creation.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?

    public init(
        baseModelArn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        customizationConfig: BedrockClientTypes.CustomizationConfig? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        failureMessage: Swift.String? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelArn: Swift.String? = nil,
        modelKmsKeyArn: Swift.String? = nil,
        modelName: Swift.String? = nil,
        modelStatus: BedrockClientTypes.ModelStatus? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil
    ) {
        self.baseModelArn = baseModelArn
        self.creationTime = creationTime
        self.customizationConfig = customizationConfig
        self.customizationType = customizationType
        self.failureMessage = failureMessage
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.modelArn = modelArn
        self.modelKmsKeyArn = modelKmsKeyArn
        self.modelName = modelName
        self.modelStatus = modelStatus
        self.outputDataConfig = outputDataConfig
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
    }
}

public struct ListCustomModelsInput: Swift.Sendable {
    /// Return custom models only if the base model Amazon Resource Name (ARN) matches this parameter.
    public var baseModelArnEquals: Swift.String?
    /// Return custom models created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return custom models created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// Return custom models only if the foundation model Amazon Resource Name (ARN) matches this parameter.
    public var foundationModelArnEquals: Swift.String?
    /// Return custom models depending on if the current account owns them (true) or if they were shared with the current account (false).
    public var isOwned: Swift.Bool?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// The status of them model to filter results by. Possible values include:
    ///
    /// * Creating - Include only models that are currently being created and validated.
    ///
    /// * Active - Include only models that have been successfully created and are ready for use.
    ///
    /// * Failed - Include only models where the creation process failed.
    ///
    ///
    /// If you don't specify a status, the API returns models in all states.
    public var modelStatus: BedrockClientTypes.ModelStatus?
    /// Return custom models only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of models.
    public var sortBy: BedrockClientTypes.SortModelsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?

    public init(
        baseModelArnEquals: Swift.String? = nil,
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        foundationModelArnEquals: Swift.String? = nil,
        isOwned: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        modelStatus: BedrockClientTypes.ModelStatus? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortModelsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil
    ) {
        self.baseModelArnEquals = baseModelArnEquals
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.foundationModelArnEquals = foundationModelArnEquals
        self.isOwned = isOwned
        self.maxResults = maxResults
        self.modelStatus = modelStatus
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension BedrockClientTypes {

    /// Summary information for a custom model.
    public struct CustomModelSummary: Swift.Sendable {
        /// The base model Amazon Resource Name (ARN).
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// The base model name.
        /// This member is required.
        public var baseModelName: Swift.String?
        /// Creation time of the model.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// The Amazon Resource Name (ARN) of the custom model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The name of the custom model.
        /// This member is required.
        public var modelName: Swift.String?
        /// The current status of the custom model. Possible values include:
        ///
        /// * Creating - The model is being created and validated.
        ///
        /// * Active - The model has been successfully created and is ready for use.
        ///
        /// * Failed - The model creation process failed.
        public var modelStatus: BedrockClientTypes.ModelStatus?
        /// The unique identifier of the account that owns the model.
        public var ownerAccountId: Swift.String?

        public init(
            baseModelArn: Swift.String? = nil,
            baseModelName: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            modelArn: Swift.String? = nil,
            modelName: Swift.String? = nil,
            modelStatus: BedrockClientTypes.ModelStatus? = nil,
            ownerAccountId: Swift.String? = nil
        ) {
            self.baseModelArn = baseModelArn
            self.baseModelName = baseModelName
            self.creationTime = creationTime
            self.customizationType = customizationType
            self.modelArn = modelArn
            self.modelName = modelName
            self.modelStatus = modelStatus
            self.ownerAccountId = ownerAccountId
        }
    }
}

public struct ListCustomModelsOutput: Swift.Sendable {
    /// Model summaries.
    public var modelSummaries: [BedrockClientTypes.CustomModelSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelSummaries: [BedrockClientTypes.CustomModelSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.modelSummaries = modelSummaries
        self.nextToken = nextToken
    }
}

public struct DeleteEnforcedGuardrailConfigurationInput: Swift.Sendable {
    /// Unique ID for the account enforced configuration.
    /// This member is required.
    public var configId: Swift.String?

    public init(
        configId: Swift.String? = nil
    ) {
        self.configId = configId
    }
}

public struct DeleteEnforcedGuardrailConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct ListEnforcedGuardrailsConfigurationInput: Swift.Sendable {
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    ) {
        self.nextToken = nextToken
    }
}

public struct ListEnforcedGuardrailsConfigurationOutput: Swift.Sendable {
    /// Array of AccountEnforcedGuardrailOutputConfiguration objects.
    /// This member is required.
    public var guardrailsConfig: [BedrockClientTypes.AccountEnforcedGuardrailOutputConfiguration]?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        guardrailsConfig: [BedrockClientTypes.AccountEnforcedGuardrailOutputConfiguration]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.guardrailsConfig = guardrailsConfig
        self.nextToken = nextToken
    }
}

public struct PutEnforcedGuardrailConfigurationInput: Swift.Sendable {
    /// Unique ID for the account enforced configuration.
    public var configId: Swift.String?
    /// Account-level enforced guardrail input configuration.
    /// This member is required.
    public var guardrailInferenceConfig: BedrockClientTypes.AccountEnforcedGuardrailInferenceInputConfiguration?

    public init(
        configId: Swift.String? = nil,
        guardrailInferenceConfig: BedrockClientTypes.AccountEnforcedGuardrailInferenceInputConfiguration? = nil
    ) {
        self.configId = configId
        self.guardrailInferenceConfig = guardrailInferenceConfig
    }
}

public struct PutEnforcedGuardrailConfigurationOutput: Swift.Sendable {
    /// Unique ID for the account enforced configuration.
    public var configId: Swift.String?
    /// Timestamp.
    public var updatedAt: Foundation.Date?
    /// The ARN of the role used to update the configuration.
    public var updatedBy: Swift.String?

    public init(
        configId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    ) {
        self.configId = configId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct BatchDeleteEvaluationJobInput: Swift.Sendable {
    /// A list of one or more evaluation job Amazon Resource Names (ARNs) you want to delete.
    /// This member is required.
    public var jobIdentifiers: [Swift.String]?

    public init(
        jobIdentifiers: [Swift.String]? = nil
    ) {
        self.jobIdentifiers = jobIdentifiers
    }
}

extension BatchDeleteEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteEvaluationJobInput(jobIdentifiers: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// A JSON array that provides the status of the evaluation jobs being deleted.
    public struct BatchDeleteEvaluationJobError: Swift.Sendable {
        /// A HTTP status code of the evaluation job being deleted.
        /// This member is required.
        public var code: Swift.String?
        /// The ARN of the evaluation job being deleted.
        /// This member is required.
        public var jobIdentifier: Swift.String?
        /// A status message about the evaluation job deletion.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            jobIdentifier: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.jobIdentifier = jobIdentifier
            self.message = message
        }
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteEvaluationJobError(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)), jobIdentifier: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum EvaluationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case deleting
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationJobStatus] {
            return [
                .completed,
                .deleting,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// An evaluation job for deletion, and itâ€™s current status.
    public struct BatchDeleteEvaluationJobItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the evaluation job for deletion.
        /// This member is required.
        public var jobIdentifier: Swift.String?
        /// The status of the evaluation job for deletion.
        /// This member is required.
        public var jobStatus: BedrockClientTypes.EvaluationJobStatus?

        public init(
            jobIdentifier: Swift.String? = nil,
            jobStatus: BedrockClientTypes.EvaluationJobStatus? = nil
        ) {
            self.jobIdentifier = jobIdentifier
            self.jobStatus = jobStatus
        }
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteEvaluationJobItem(jobStatus: \(Swift.String(describing: jobStatus)), jobIdentifier: \"CONTENT_REDACTED\")"}
}

public struct BatchDeleteEvaluationJobOutput: Swift.Sendable {
    /// A JSON object containing the HTTP status codes and the ARNs of evaluation jobs that failed to be deleted.
    /// This member is required.
    public var errors: [BedrockClientTypes.BatchDeleteEvaluationJobError]?
    /// The list of evaluation jobs for deletion.
    /// This member is required.
    public var evaluationJobs: [BedrockClientTypes.BatchDeleteEvaluationJobItem]?

    public init(
        errors: [BedrockClientTypes.BatchDeleteEvaluationJobError]? = nil,
        evaluationJobs: [BedrockClientTypes.BatchDeleteEvaluationJobItem]? = nil
    ) {
        self.errors = errors
        self.evaluationJobs = evaluationJobs
    }
}

extension BedrockClientTypes {

    public enum ApplicationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case modelEvaluation
        case ragEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationType] {
            return [
                .modelEvaluation,
                .ragEvaluation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .modelEvaluation: return "ModelEvaluation"
            case .ragEvaluation: return "RagEvaluation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Defines the value for one rating in a custom metric rating scale.
    public enum RatingScaleItemValue: Swift.Sendable {
        /// A string representing the value for a rating in a custom metric rating scale.
        case stringvalue(Swift.String)
        /// A floating point number representing the value for a rating in a custom metric rating scale.
        case floatvalue(Swift.Float)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Defines the value and corresponding definition for one rating in a custom metric rating scale.
    public struct RatingScaleItem: Swift.Sendable {
        /// Defines the definition for one rating in a custom metric rating scale.
        /// This member is required.
        public var definition: Swift.String?
        /// Defines the value for one rating in a custom metric rating scale.
        /// This member is required.
        public var value: BedrockClientTypes.RatingScaleItemValue?

        public init(
            definition: Swift.String? = nil,
            value: BedrockClientTypes.RatingScaleItemValue? = nil
        ) {
            self.definition = definition
            self.value = value
        }
    }
}

extension BedrockClientTypes {

    /// The definition of a custom metric for use in an Amazon Bedrock evaluation job. A custom metric definition includes a metric name, prompt (instructions) and optionally, a rating scale. Your prompt must include a task description and input variables. The required input variables are different for model-as-a-judge and RAG evaluations. For more information about how to define a custom metric in Amazon Bedrock, see [Create a prompt for a custom metrics (LLM-as-a-judge model evaluations)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-custom-metrics-prompt-formats.html) and [Create a prompt for a custom metrics (RAG evaluations)](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-evaluation-custom-metrics-prompt-formats.html).
    public struct CustomMetricDefinition: Swift.Sendable {
        /// The prompt for a custom metric that instructs the evaluator model how to rate the model or RAG source under evaluation.
        /// This member is required.
        public var instructions: Swift.String?
        /// The name for a custom metric. Names must be unique in your Amazon Web Services region.
        /// This member is required.
        public var name: Swift.String?
        /// Defines the rating scale to be used for a custom metric. We recommend that you always define a ratings scale when creating a custom metric. If you don't define a scale, Amazon Bedrock won't be able to visually display the results of the evaluation in the console or calculate average values of numerical scores. For more information on specifying a rating scale, see [Specifying an output schema (rating scale)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-custom-metrics-prompt-formats.html#model-evaluation-custom-metrics-prompt-formats-schema).
        public var ratingScale: [BedrockClientTypes.RatingScaleItem]?

        public init(
            instructions: Swift.String? = nil,
            name: Swift.String? = nil,
            ratingScale: [BedrockClientTypes.RatingScaleItem]? = nil
        ) {
            self.instructions = instructions
            self.name = name
            self.ratingScale = ratingScale
        }
    }
}

extension BedrockClientTypes.CustomMetricDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockClientTypes {

    /// An array item definining a single custom metric for use in an Amazon Bedrock evaluation job.
    public enum AutomatedEvaluationCustomMetricSource: Swift.Sendable {
        /// The definition of a custom metric for use in an Amazon Bedrock evaluation job.
        case custommetricdefinition(BedrockClientTypes.CustomMetricDefinition)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Defines the model you want to evaluate custom metrics in an Amazon Bedrock evaluation job.
    public struct CustomMetricBedrockEvaluatorModel: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the evaluator model for custom metrics. For a list of supported evaluator models, see [Evaluate model performance using another LLM as a judge](https://docs.aws.amazon.com/bedrock/latest/userguide/evaluation-judge.html) and [Evaluate the performance of RAG sources using Amazon Bedrock evaluations](https://docs.aws.amazon.com/bedrock/latest/userguide/evaluation-kb.html).
        /// This member is required.
        public var modelIdentifier: Swift.String?

        public init(
            modelIdentifier: Swift.String? = nil
        ) {
            self.modelIdentifier = modelIdentifier
        }
    }
}

extension BedrockClientTypes {

    /// Configuration of the evaluator model you want to use to evaluate custom metrics in an Amazon Bedrock evaluation job.
    public struct CustomMetricEvaluatorModelConfig: Swift.Sendable {
        /// Defines the model you want to evaluate custom metrics in an Amazon Bedrock evaluation job.
        /// This member is required.
        public var bedrockEvaluatorModels: [BedrockClientTypes.CustomMetricBedrockEvaluatorModel]?

        public init(
            bedrockEvaluatorModels: [BedrockClientTypes.CustomMetricBedrockEvaluatorModel]? = nil
        ) {
            self.bedrockEvaluatorModels = bedrockEvaluatorModels
        }
    }
}

extension BedrockClientTypes {

    /// Defines the configuration of custom metrics to be used in an evaluation job. To learn more about using custom metrics in Amazon Bedrock evaluation jobs, see [Create a prompt for a custom metrics (LLM-as-a-judge model evaluations)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-custom-metrics-prompt-formats.html) and [Create a prompt for a custom metrics (RAG evaluations)](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-evaluation-custom-metrics-prompt-formats.html).
    public struct AutomatedEvaluationCustomMetricConfig: Swift.Sendable {
        /// Defines a list of custom metrics to be used in an Amazon Bedrock evaluation job.
        /// This member is required.
        public var customMetrics: [BedrockClientTypes.AutomatedEvaluationCustomMetricSource]?
        /// Configuration of the evaluator model you want to use to evaluate custom metrics in an Amazon Bedrock evaluation job.
        /// This member is required.
        public var evaluatorModelConfig: BedrockClientTypes.CustomMetricEvaluatorModelConfig?

        public init(
            customMetrics: [BedrockClientTypes.AutomatedEvaluationCustomMetricSource]? = nil,
            evaluatorModelConfig: BedrockClientTypes.CustomMetricEvaluatorModelConfig? = nil
        ) {
            self.customMetrics = customMetrics
            self.evaluatorModelConfig = evaluatorModelConfig
        }
    }
}

extension BedrockClientTypes {

    /// The location in Amazon S3 where your prompt dataset is stored.
    public enum EvaluationDatasetLocation: Swift.Sendable {
        /// The S3 URI of the S3 bucket specified in the job.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Used to specify the name of a built-in prompt dataset and optionally, the Amazon S3 bucket where a custom prompt dataset is saved.
    public struct EvaluationDataset: Swift.Sendable {
        /// For custom prompt datasets, you must specify the location in Amazon S3 where the prompt dataset is saved.
        public var datasetLocation: BedrockClientTypes.EvaluationDatasetLocation?
        /// Used to specify supported built-in prompt datasets. Valid values are Builtin.Bold, Builtin.BoolQ, Builtin.NaturalQuestions, Builtin.Gigaword, Builtin.RealToxicityPrompts, Builtin.TriviaQA, Builtin.T-Rex, Builtin.WomensEcommerceClothingReviews and Builtin.Wikitext2.
        /// This member is required.
        public var name: Swift.String?

        public init(
            datasetLocation: BedrockClientTypes.EvaluationDatasetLocation? = nil,
            name: Swift.String? = nil
        ) {
            self.datasetLocation = datasetLocation
            self.name = name
        }
    }
}

extension BedrockClientTypes.EvaluationDataset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationDataset(datasetLocation: \(Swift.String(describing: datasetLocation)), name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum EvaluationTaskType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case classification
        case custom
        case generation
        case questionAndAnswer
        case summarization
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationTaskType] {
            return [
                .classification,
                .custom,
                .generation,
                .questionAndAnswer,
                .summarization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .classification: return "Classification"
            case .custom: return "Custom"
            case .generation: return "Generation"
            case .questionAndAnswer: return "QuestionAndAnswer"
            case .summarization: return "Summarization"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Defines the prompt datasets, built-in metric names and custom metric names, and the task type.
    public struct EvaluationDatasetMetricConfig: Swift.Sendable {
        /// Specifies the prompt dataset.
        /// This member is required.
        public var dataset: BedrockClientTypes.EvaluationDataset?
        /// The names of the metrics you want to use for your evaluation job. For knowledge base evaluation jobs that evaluate retrieval only, valid values are "Builtin.ContextRelevance", "Builtin.ContextCoverage". For knowledge base evaluation jobs that evaluate retrieval with response generation, valid values are "Builtin.Correctness", "Builtin.Completeness", "Builtin.Helpfulness", "Builtin.LogicalCoherence", "Builtin.Faithfulness", "Builtin.Harmfulness", "Builtin.Stereotyping", "Builtin.Refusal". For automated model evaluation jobs, valid values are "Builtin.Accuracy", "Builtin.Robustness", and "Builtin.Toxicity". In model evaluation jobs that use a LLM as judge you can specify "Builtin.Correctness", "Builtin.Completeness", "Builtin.Faithfulness", "Builtin.Helpfulness", "Builtin.Coherence", "Builtin.Relevance", "Builtin.FollowingInstructions", "Builtin.ProfessionalStyleAndTone", You can also specify the following responsible AI related metrics only for model evaluation job that use a LLM as judge "Builtin.Harmfulness", "Builtin.Stereotyping", and "Builtin.Refusal". For human-based model evaluation jobs, the list of strings must match the name parameter specified in HumanEvaluationCustomMetric.
        /// This member is required.
        public var metricNames: [Swift.String]?
        /// The the type of task you want to evaluate for your evaluation job. This applies only to model evaluation jobs and is ignored for knowledge base evaluation jobs.
        /// This member is required.
        public var taskType: BedrockClientTypes.EvaluationTaskType?

        public init(
            dataset: BedrockClientTypes.EvaluationDataset? = nil,
            metricNames: [Swift.String]? = nil,
            taskType: BedrockClientTypes.EvaluationTaskType? = nil
        ) {
            self.dataset = dataset
            self.metricNames = metricNames
            self.taskType = taskType
        }
    }
}

extension BedrockClientTypes.EvaluationDatasetMetricConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationDatasetMetricConfig(dataset: \(Swift.String(describing: dataset)), taskType: \(Swift.String(describing: taskType)), metricNames: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// The evaluator model used in knowledge base evaluation job or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
    public struct BedrockEvaluatorModel: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the evaluator model used used in knowledge base evaluation job or in model evaluation job that use a model as judge.
        /// This member is required.
        public var modelIdentifier: Swift.String?

        public init(
            modelIdentifier: Swift.String? = nil
        ) {
            self.modelIdentifier = modelIdentifier
        }
    }
}

extension BedrockClientTypes {

    /// Specifies the model configuration for the evaluator model. EvaluatorModelConfig is required for evaluation jobs that use a knowledge base or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
    public enum EvaluatorModelConfig: Swift.Sendable {
        /// The evaluator model used in knowledge base evaluation job or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
        case bedrockevaluatormodels([BedrockClientTypes.BedrockEvaluatorModel])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// The configuration details of an automated evaluation job. The EvaluationDatasetMetricConfig object is used to specify the prompt datasets, task type, and metric names.
    public struct AutomatedEvaluationConfig: Swift.Sendable {
        /// Defines the configuration of custom metrics to be used in an evaluation job.
        public var customMetricConfig: BedrockClientTypes.AutomatedEvaluationCustomMetricConfig?
        /// Configuration details of the prompt datasets and metrics you want to use for your evaluation job.
        /// This member is required.
        public var datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]?
        /// Contains the evaluator model configuration details. EvaluatorModelConfig is required for evaluation jobs that use a knowledge base or in model evaluation job that use a model as judge. This model computes all evaluation related metrics.
        public var evaluatorModelConfig: BedrockClientTypes.EvaluatorModelConfig?

        public init(
            customMetricConfig: BedrockClientTypes.AutomatedEvaluationCustomMetricConfig? = nil,
            datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]? = nil,
            evaluatorModelConfig: BedrockClientTypes.EvaluatorModelConfig? = nil
        ) {
            self.customMetricConfig = customMetricConfig
            self.datasetMetricConfigs = datasetMetricConfigs
            self.evaluatorModelConfig = evaluatorModelConfig
        }
    }
}

extension BedrockClientTypes {

    /// In a model evaluation job that uses human workers you must define the name of the metric, and how you want that metric rated ratingMethod, and an optional description of the metric.
    public struct HumanEvaluationCustomMetric: Swift.Sendable {
        /// An optional description of the metric. Use this parameter to provide more details about the metric.
        public var description: Swift.String?
        /// The name of the metric. Your human evaluators will see this name in the evaluation UI.
        /// This member is required.
        public var name: Swift.String?
        /// Choose how you want your human workers to evaluation your model. Valid values for rating methods are ThumbsUpDown, IndividualLikertScale,ComparisonLikertScale, ComparisonChoice, and ComparisonRank
        /// This member is required.
        public var ratingMethod: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ratingMethod: Swift.String? = nil
        ) {
            self.description = description
            self.name = name
            self.ratingMethod = ratingMethod
        }
    }
}

extension BedrockClientTypes.HumanEvaluationCustomMetric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanEvaluationCustomMetric(ratingMethod: \(Swift.String(describing: ratingMethod)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains SageMakerFlowDefinition object. The object is used to specify the prompt dataset, task type, rating method and metric names.
    public struct HumanWorkflowConfig: Swift.Sendable {
        /// The Amazon Resource Number (ARN) for the flow definition
        /// This member is required.
        public var flowDefinitionArn: Swift.String?
        /// Instructions for the flow definition
        public var instructions: Swift.String?

        public init(
            flowDefinitionArn: Swift.String? = nil,
            instructions: Swift.String? = nil
        ) {
            self.flowDefinitionArn = flowDefinitionArn
            self.instructions = instructions
        }
    }
}

extension BedrockClientTypes.HumanWorkflowConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HumanWorkflowConfig(flowDefinitionArn: \(Swift.String(describing: flowDefinitionArn)), instructions: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Specifies the custom metrics, how tasks will be rated, the flow definition ARN, and your custom prompt datasets. Model evaluation jobs use human workers only support the use of custom prompt datasets. To learn more about custom prompt datasets and the required format, see [Custom prompt datasets](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-prompt-datasets-custom.html). When you create custom metrics in HumanEvaluationCustomMetric you must specify the metric's name. The list of names specified in the HumanEvaluationCustomMetric array, must match the metricNames array of strings specified in EvaluationDatasetMetricConfig. For example, if in the HumanEvaluationCustomMetric array your specified the names "accuracy", "toxicity", "readability" as custom metrics then the metricNames array would need to look like the following ["accuracy", "toxicity", "readability"] in EvaluationDatasetMetricConfig.
    public struct HumanEvaluationConfig: Swift.Sendable {
        /// A HumanEvaluationCustomMetric object. It contains the names the metrics, how the metrics are to be evaluated, an optional description.
        public var customMetrics: [BedrockClientTypes.HumanEvaluationCustomMetric]?
        /// Use to specify the metrics, task, and prompt dataset to be used in your model evaluation job.
        /// This member is required.
        public var datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]?
        /// The parameters of the human workflow.
        public var humanWorkflowConfig: BedrockClientTypes.HumanWorkflowConfig?

        public init(
            customMetrics: [BedrockClientTypes.HumanEvaluationCustomMetric]? = nil,
            datasetMetricConfigs: [BedrockClientTypes.EvaluationDatasetMetricConfig]? = nil,
            humanWorkflowConfig: BedrockClientTypes.HumanWorkflowConfig? = nil
        ) {
            self.customMetrics = customMetrics
            self.datasetMetricConfigs = datasetMetricConfigs
            self.humanWorkflowConfig = humanWorkflowConfig
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details of either an automated or human-based evaluation job.
    public enum EvaluationConfig: Swift.Sendable {
        /// Contains the configuration details of an automated evaluation job that computes metrics.
        case automated(BedrockClientTypes.AutomatedEvaluationConfig)
        /// Contains the configuration details of an evaluation job that uses human workers.
        case human(BedrockClientTypes.HumanEvaluationConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    public enum PerformanceConfigLatency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case optimized
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [PerformanceConfigLatency] {
            return [
                .optimized,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .optimized: return "optimized"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Contains performance settings for a model.
    public struct PerformanceConfiguration: Swift.Sendable {
        /// Specifies whether to use the latency-optimized or standard version of a model or inference profile.
        public var latency: BedrockClientTypes.PerformanceConfigLatency?

        public init(
            latency: BedrockClientTypes.PerformanceConfigLatency? = nil
        ) {
            self.latency = latency
        }
    }
}

extension BedrockClientTypes {

    /// Contains the ARN of the Amazon Bedrock model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) specified in your evaluation job. Each Amazon Bedrock model supports different inferenceParams. To learn more about supported inference parameters for Amazon Bedrock models, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). The inferenceParams are specified using JSON. To successfully insert JSON as string make sure that all quotations are properly escaped. For example, "temperature":"0.25" key value pair would need to be formatted as \"temperature\":\"0.25\" to successfully accepted in the request.
    public struct EvaluationBedrockModel: Swift.Sendable {
        /// Each Amazon Bedrock support different inference parameters that change how the model behaves during inference.
        public var inferenceParams: Swift.String?
        /// The ARN of the Amazon Bedrock model or inference profile specified.
        /// This member is required.
        public var modelIdentifier: Swift.String?
        /// Specifies performance settings for the model or inference profile.
        public var performanceConfig: BedrockClientTypes.PerformanceConfiguration?

        public init(
            inferenceParams: Swift.String? = "{}",
            modelIdentifier: Swift.String? = nil,
            performanceConfig: BedrockClientTypes.PerformanceConfiguration? = nil
        ) {
            self.inferenceParams = inferenceParams
            self.modelIdentifier = modelIdentifier
            self.performanceConfig = performanceConfig
        }
    }
}

extension BedrockClientTypes.EvaluationBedrockModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluationBedrockModel(modelIdentifier: \(Swift.String(describing: modelIdentifier)), performanceConfig: \(Swift.String(describing: performanceConfig)), inferenceParams: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// A summary of a model used for a model evaluation job where you provide your own inference response data.
    public struct EvaluationPrecomputedInferenceSource: Swift.Sendable {
        /// A label that identifies a model used in a model evaluation job where you provide your own inference response data.
        /// This member is required.
        public var inferenceSourceIdentifier: Swift.String?

        public init(
            inferenceSourceIdentifier: Swift.String? = nil
        ) {
            self.inferenceSourceIdentifier = inferenceSourceIdentifier
        }
    }
}

extension BedrockClientTypes {

    /// Defines the models used in the model evaluation job.
    public enum EvaluationModelConfig: Swift.Sendable {
        /// Defines the Amazon Bedrock model or inference profile and inference parameters you want used.
        case bedrockmodel(BedrockClientTypes.EvaluationBedrockModel)
        /// Defines the model used to generate inference response data for a model evaluation job where you provide your own inference response data.
        case precomputedinferencesource(BedrockClientTypes.EvaluationPrecomputedInferenceSource)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// The configuration details for the guardrail.
    public struct GuardrailConfiguration: Swift.Sendable {
        /// The unique identifier for the guardrail.
        /// This member is required.
        public var guardrailId: Swift.String?
        /// The version of the guardrail.
        /// This member is required.
        public var guardrailVersion: Swift.String?

        public init(
            guardrailId: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil
        ) {
            self.guardrailId = guardrailId
            self.guardrailVersion = guardrailVersion
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for text generation using a language model via the RetrieveAndGenerate function.
    public struct TextInferenceConfig: Swift.Sendable {
        /// The maximum number of tokens to generate in the output text. Do not use the minimum of 0 or the maximum of 65536. The limit values described here are arbitrary values, for actual values consult the limits defined by your specific model.
        public var maxTokens: Swift.Int?
        /// A list of sequences of characters that, if generated, will cause the model to stop generating further tokens. Do not use a minimum length of 1 or a maximum length of 1000. The limit values described here are arbitrary values, for actual values consult the limits defined by your specific model.
        public var stopSequences: [Swift.String]?
        /// Controls the random-ness of text generated by the language model, influencing how much the model sticks to the most predictable next words versus exploring more surprising options. A lower temperature value (e.g. 0.2 or 0.3) makes model outputs more deterministic or predictable, while a higher temperature (e.g. 0.8 or 0.9) makes the outputs more creative or unpredictable.
        public var temperature: Swift.Float?
        /// A probability distribution threshold which controls what the model considers for the set of possible next tokens. The model will only consider the top p% of the probability distribution when generating the next token.
        public var topp: Swift.Float?

        public init(
            maxTokens: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topp: Swift.Float? = nil
        ) {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topp = topp
        }
    }
}

extension BedrockClientTypes {

    /// Contains configuration details of the inference for knowledge base retrieval and response generation.
    public struct KbInferenceConfig: Swift.Sendable {
        /// Contains configuration details for text generation using a language model via the RetrieveAndGenerate function.
        public var textInferenceConfig: BedrockClientTypes.TextInferenceConfig?

        public init(
            textInferenceConfig: BedrockClientTypes.TextInferenceConfig? = nil
        ) {
            self.textInferenceConfig = textInferenceConfig
        }
    }
}

extension BedrockClientTypes {

    /// The template for the prompt that's sent to the model for response generation.
    public struct PromptTemplate: Swift.Sendable {
        /// The template for the prompt that's sent to the model for response generation. You can include prompt placeholders, which become replaced before the prompt is sent to the model to provide instructions and context to the model. In addition, you can include XML tags to delineate meaningful sections of the prompt template. For more information, see [Knowledge base prompt template](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html) and [Use XML tags with Anthropic Claude models](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags).
        public var textPromptTemplate: Swift.String?

        public init(
            textPromptTemplate: Swift.String? = nil
        ) {
            self.textPromptTemplate = textPromptTemplate
        }
    }
}

extension BedrockClientTypes.PromptTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromptTemplate(textPromptTemplate: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// The response generation configuration of the external source wrapper object.
    public struct ExternalSourcesGenerationConfiguration: Swift.Sendable {
        /// Additional model parameters and their corresponding values not included in the text inference configuration for an external source. Takes in custom model parameters specific to the language model being used.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// Configuration details for the guardrail.
        public var guardrailConfiguration: BedrockClientTypes.GuardrailConfiguration?
        /// Configuration details for inference when using RetrieveAndGenerate to generate responses while using an external source.
        public var kbInferenceConfig: BedrockClientTypes.KbInferenceConfig?
        /// Contains the template for the prompt for the external source wrapper object.
        public var promptTemplate: BedrockClientTypes.PromptTemplate?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            guardrailConfiguration: BedrockClientTypes.GuardrailConfiguration? = nil,
            kbInferenceConfig: BedrockClientTypes.KbInferenceConfig? = nil,
            promptTemplate: BedrockClientTypes.PromptTemplate? = nil
        ) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.kbInferenceConfig = kbInferenceConfig
            self.promptTemplate = promptTemplate
        }
    }
}

extension BedrockClientTypes {

    /// Contains the document contained in the wrapper object, along with its attributes/fields.
    public struct ByteContentDoc: Swift.Sendable {
        /// The MIME type of the document contained in the wrapper object.
        /// This member is required.
        public var contentType: Swift.String?
        /// The byte value of the file to upload, encoded as a Base-64 string.
        /// This member is required.
        public var data: Foundation.Data?
        /// The file name of the document contained in the wrapper object.
        /// This member is required.
        public var identifier: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            data: Foundation.Data? = nil,
            identifier: Swift.String? = nil
        ) {
            self.contentType = contentType
            self.data = data
            self.identifier = identifier
        }
    }
}

extension BedrockClientTypes.ByteContentDoc: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ByteContentDoc(contentType: \(Swift.String(describing: contentType)), data: \"CONTENT_REDACTED\", identifier: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// The unique wrapper object of the document from the S3 location.
    public struct S3ObjectDoc: Swift.Sendable {
        /// The S3 URI location for the wrapper object of the document.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        ) {
            self.uri = uri
        }
    }
}

extension BedrockClientTypes {

    public enum ExternalSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byteContent
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalSourceType] {
            return [
                .byteContent,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byteContent: return "BYTE_CONTENT"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The unique external source of the content contained in the wrapper object.
    public struct ExternalSource: Swift.Sendable {
        /// The identifier, content type, and data of the external source wrapper object.
        public var byteContent: BedrockClientTypes.ByteContentDoc?
        /// The S3 location of the external source wrapper object.
        public var s3Location: BedrockClientTypes.S3ObjectDoc?
        /// The source type of the external source wrapper object.
        /// This member is required.
        public var sourceType: BedrockClientTypes.ExternalSourceType?

        public init(
            byteContent: BedrockClientTypes.ByteContentDoc? = nil,
            s3Location: BedrockClientTypes.S3ObjectDoc? = nil,
            sourceType: BedrockClientTypes.ExternalSourceType? = nil
        ) {
            self.byteContent = byteContent
            self.s3Location = s3Location
            self.sourceType = sourceType
        }
    }
}

extension BedrockClientTypes {

    /// The configuration of the external source wrapper object in the retrieveAndGenerate function.
    public struct ExternalSourcesRetrieveAndGenerateConfiguration: Swift.Sendable {
        /// Contains configurations details for response generation based on retrieved text chunks.
        public var generationConfiguration: BedrockClientTypes.ExternalSourcesGenerationConfiguration?
        /// The Amazon Resource Name (ARN) of the foundation model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) used to generate responses.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The document for the external source wrapper object in the retrieveAndGenerate function.
        /// This member is required.
        public var sources: [BedrockClientTypes.ExternalSource]?

        public init(
            generationConfiguration: BedrockClientTypes.ExternalSourcesGenerationConfiguration? = nil,
            modelArn: Swift.String? = nil,
            sources: [BedrockClientTypes.ExternalSource]? = nil
        ) {
            self.generationConfiguration = generationConfiguration
            self.modelArn = modelArn
            self.sources = sources
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for response generation based on retrieved text chunks.
    public struct GenerationConfiguration: Swift.Sendable {
        /// Additional model parameters and corresponding values not included in the textInferenceConfig structure for a knowledge base. This allows you to provide custom model parameters specific to the language model being used.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// Contains configuration details for the guardrail.
        public var guardrailConfiguration: BedrockClientTypes.GuardrailConfiguration?
        /// Contains configuration details for inference for knowledge base retrieval and response generation.
        public var kbInferenceConfig: BedrockClientTypes.KbInferenceConfig?
        /// Contains the template for the prompt that's sent to the model for response generation.
        public var promptTemplate: BedrockClientTypes.PromptTemplate?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            guardrailConfiguration: BedrockClientTypes.GuardrailConfiguration? = nil,
            kbInferenceConfig: BedrockClientTypes.KbInferenceConfig? = nil,
            promptTemplate: BedrockClientTypes.PromptTemplate? = nil
        ) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.guardrailConfiguration = guardrailConfiguration
            self.kbInferenceConfig = kbInferenceConfig
            self.promptTemplate = promptTemplate
        }
    }
}

extension BedrockClientTypes {

    public enum QueryTransformationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case queryDecomposition
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryTransformationType] {
            return [
                .queryDecomposition
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .queryDecomposition: return "QUERY_DECOMPOSITION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for transforming the prompt.
    public struct QueryTransformationConfiguration: Swift.Sendable {
        /// The type of transformation to apply to the prompt.
        /// This member is required.
        public var type: BedrockClientTypes.QueryTransformationType?

        public init(
            type: BedrockClientTypes.QueryTransformationType? = nil
        ) {
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for the model to process the prompt prior to retrieval and response generation.
    public struct OrchestrationConfiguration: Swift.Sendable {
        /// Contains configuration details for transforming the prompt.
        /// This member is required.
        public var queryTransformationConfiguration: BedrockClientTypes.QueryTransformationConfiguration?

        public init(
            queryTransformationConfiguration: BedrockClientTypes.QueryTransformationConfiguration? = nil
        ) {
            self.queryTransformationConfiguration = queryTransformationConfiguration
        }
    }
}

extension BedrockClientTypes {

    /// Specifies the name of the metadata attribute/field to apply filters. You must match the name of the attribute/field in your data source/document metadata.
    public struct FilterAttribute: Swift.Sendable {
        /// The name of metadata attribute/field, which must match the name in your data source/document metadata.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the metadata attribute/field.
        /// This member is required.
        public var value: Smithy.Document?

        public init(
            key: Swift.String? = nil,
            value: Smithy.Document? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension BedrockClientTypes {

    public enum AttributeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case number
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeType] {
            return [
                .boolean,
                .number,
                .string,
                .stringList
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .number: return "NUMBER"
            case .string: return "STRING"
            case .stringList: return "STRING_LIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Defines the schema for a metadata attribute used in Knowledge Base vector searches. Metadata attributes provide additional context for documents and can be used for filtering and reranking search results.
    public struct MetadataAttributeSchema: Swift.Sendable {
        /// An optional description of the metadata attribute that provides additional context about its purpose and usage.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier for the metadata attribute. This key is used to reference the attribute in filter expressions and reranking configurations.
        /// This member is required.
        public var key: Swift.String?
        /// The data type of the metadata attribute. The type determines how the attribute can be used in filter expressions and reranking.
        /// This member is required.
        public var type: BedrockClientTypes.AttributeType?

        public init(
            description: Swift.String? = nil,
            key: Swift.String? = nil,
            type: BedrockClientTypes.AttributeType? = nil
        ) {
            self.description = description
            self.key = key
            self.type = type
        }
    }
}

extension BedrockClientTypes.MetadataAttributeSchema: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockClientTypes {

    /// Configuration for implicit filtering in Knowledge Base vector searches. Implicit filtering allows you to automatically filter search results based on metadata attributes without requiring explicit filter expressions in each query.
    public struct ImplicitFilterConfiguration: Swift.Sendable {
        /// A list of metadata attribute schemas that define the structure and properties of metadata fields used for implicit filtering. Each attribute defines a key, type, and optional description.
        /// This member is required.
        public var metadataAttributes: [BedrockClientTypes.MetadataAttributeSchema]?
        /// The Amazon Resource Name (ARN) of the foundation model used for implicit filtering. This model processes the query to extract relevant filtering criteria.
        /// This member is required.
        public var modelArn: Swift.String?

        public init(
            metadataAttributes: [BedrockClientTypes.MetadataAttributeSchema]? = nil,
            modelArn: Swift.String? = nil
        ) {
            self.metadataAttributes = metadataAttributes
            self.modelArn = modelArn
        }
    }
}

extension BedrockClientTypes.ImplicitFilterConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImplicitFilterConfiguration(modelArn: \(Swift.String(describing: modelArn)), metadataAttributes: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum SearchType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hybrid
        case semantic
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchType] {
            return [
                .hybrid,
                .semantic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hybrid: return "HYBRID"
            case .semantic: return "SEMANTIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum RerankingMetadataSelectionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case selective
        case sdkUnknown(Swift.String)

        public static var allCases: [RerankingMetadataSelectionMode] {
            return [
                .all,
                .selective
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .selective: return "SELECTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Specifies a field to be used during the reranking process in a Knowledge Base vector search. This structure identifies metadata fields that should be considered when reordering search results to improve relevance.
    public struct FieldForReranking: Swift.Sendable {
        /// The name of the metadata field to be used during the reranking process.
        /// This member is required.
        public var fieldName: Swift.String?

        public init(
            fieldName: Swift.String? = nil
        ) {
            self.fieldName = fieldName
        }
    }
}

extension BedrockClientTypes {

    /// Configuration for selectively including or excluding metadata fields during the reranking process. This allows you to control which metadata attributes are considered when reordering search results.
    public enum RerankingMetadataSelectiveModeConfiguration: Swift.Sendable {
        /// A list of metadata field names to explicitly include in the reranking process. Only these fields will be considered when reordering search results. This parameter cannot be used together with fieldsToExclude.
        case fieldstoinclude([BedrockClientTypes.FieldForReranking])
        /// A list of metadata field names to explicitly exclude from the reranking process. All metadata fields except these will be considered when reordering search results. This parameter cannot be used together with fieldsToInclude.
        case fieldstoexclude([BedrockClientTypes.FieldForReranking])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Configuration for how metadata should be used during the reranking process in Knowledge Base vector searches. This determines which metadata fields are included or excluded when reordering search results.
    public struct MetadataConfigurationForReranking: Swift.Sendable {
        /// The mode for selecting which metadata fields to include in the reranking process. Valid values are ALL (use all available metadata fields) or SELECTIVE (use only specified fields).
        /// This member is required.
        public var selectionMode: BedrockClientTypes.RerankingMetadataSelectionMode?
        /// Configuration for selective mode, which allows you to explicitly include or exclude specific metadata fields during reranking. This is only used when selectionMode is set to SELECTIVE.
        public var selectiveModeConfiguration: BedrockClientTypes.RerankingMetadataSelectiveModeConfiguration?

        public init(
            selectionMode: BedrockClientTypes.RerankingMetadataSelectionMode? = nil,
            selectiveModeConfiguration: BedrockClientTypes.RerankingMetadataSelectiveModeConfiguration? = nil
        ) {
            self.selectionMode = selectionMode
            self.selectiveModeConfiguration = selectiveModeConfiguration
        }
    }
}

extension BedrockClientTypes {

    /// Configuration for the Amazon Bedrock foundation model used for reranking vector search results. This specifies which model to use and any additional parameters required by the model.
    public struct VectorSearchBedrockRerankingModelConfiguration: Swift.Sendable {
        /// A list of additional fields to include in the model request during reranking. These fields provide extra context or configuration options specific to the selected foundation model.
        public var additionalModelRequestFields: [Swift.String: Smithy.Document]?
        /// The Amazon Resource Name (ARN) of the foundation model to use for reranking. This model processes the query and search results to determine a more relevant ordering.
        /// This member is required.
        public var modelArn: Swift.String?

        public init(
            additionalModelRequestFields: [Swift.String: Smithy.Document]? = nil,
            modelArn: Swift.String? = nil
        ) {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.modelArn = modelArn
        }
    }
}

extension BedrockClientTypes {

    /// Configuration for using Amazon Bedrock foundation models to rerank Knowledge Base vector search results. This enables more sophisticated relevance ranking using large language models.
    public struct VectorSearchBedrockRerankingConfiguration: Swift.Sendable {
        /// Configuration for how document metadata should be used during the reranking process. This determines which metadata fields are included when reordering search results.
        public var metadataConfiguration: BedrockClientTypes.MetadataConfigurationForReranking?
        /// Configuration for the Amazon Bedrock foundation model used for reranking. This includes the model ARN and any additional request fields required by the model.
        /// This member is required.
        public var modelConfiguration: BedrockClientTypes.VectorSearchBedrockRerankingModelConfiguration?
        /// The maximum number of results to rerank. This limits how many of the initial vector search results will be processed by the reranking model. A smaller number improves performance but may exclude potentially relevant results.
        public var numberOfRerankedResults: Swift.Int?

        public init(
            metadataConfiguration: BedrockClientTypes.MetadataConfigurationForReranking? = nil,
            modelConfiguration: BedrockClientTypes.VectorSearchBedrockRerankingModelConfiguration? = nil,
            numberOfRerankedResults: Swift.Int? = nil
        ) {
            self.metadataConfiguration = metadataConfiguration
            self.modelConfiguration = modelConfiguration
            self.numberOfRerankedResults = numberOfRerankedResults
        }
    }
}

extension BedrockClientTypes {

    public enum VectorSearchRerankingConfigurationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bedrockRerankingModel
        case sdkUnknown(Swift.String)

        public static var allCases: [VectorSearchRerankingConfigurationType] {
            return [
                .bedrockRerankingModel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bedrockRerankingModel: return "BEDROCK_RERANKING_MODEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Configuration for reranking vector search results to improve relevance. Reranking applies additional relevance models to reorder the initial vector search results based on more sophisticated criteria.
    public struct VectorSearchRerankingConfiguration: Swift.Sendable {
        /// Configuration for using Amazon Bedrock foundation models to rerank search results. This is required when the reranking type is set to BEDROCK.
        public var bedrockRerankingConfiguration: BedrockClientTypes.VectorSearchBedrockRerankingConfiguration?
        /// The type of reranking to apply to vector search results. Currently, the only supported value is BEDROCK, which uses Amazon Bedrock foundation models for reranking.
        /// This member is required.
        public var type: BedrockClientTypes.VectorSearchRerankingConfigurationType?

        public init(
            bedrockRerankingConfiguration: BedrockClientTypes.VectorSearchBedrockRerankingConfiguration? = nil,
            type: BedrockClientTypes.VectorSearchRerankingConfigurationType? = nil
        ) {
            self.bedrockRerankingConfiguration = bedrockRerankingConfiguration
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    public enum RetrieveAndGenerateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case externalSources
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [RetrieveAndGenerateType] {
            return [
                .externalSources,
                .knowledgeBase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .externalSources: return "EXTERNAL_SOURCES"
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// A summary of a RAG source used for a retrieve-and-generate Knowledge Base evaluation job where you provide your own inference response data.
    public struct EvaluationPrecomputedRetrieveAndGenerateSourceConfig: Swift.Sendable {
        /// A label that identifies the RAG source used for a retrieve-and-generate Knowledge Base evaluation job where you provide your own inference response data.
        /// This member is required.
        public var ragSourceIdentifier: Swift.String?

        public init(
            ragSourceIdentifier: Swift.String? = nil
        ) {
            self.ragSourceIdentifier = ragSourceIdentifier
        }
    }
}

extension BedrockClientTypes {

    /// A summary of a RAG source used for a retrieve-only Knowledge Base evaluation job where you provide your own inference response data.
    public struct EvaluationPrecomputedRetrieveSourceConfig: Swift.Sendable {
        /// A label that identifies the RAG source used for a retrieve-only Knowledge Base evaluation job where you provide your own inference response data.
        /// This member is required.
        public var ragSourceIdentifier: Swift.String?

        public init(
            ragSourceIdentifier: Swift.String? = nil
        ) {
            self.ragSourceIdentifier = ragSourceIdentifier
        }
    }
}

extension BedrockClientTypes {

    /// A summary of a RAG source used for a Knowledge Base evaluation job where you provide your own inference response data.
    public enum EvaluationPrecomputedRagSourceConfig: Swift.Sendable {
        /// A summary of a RAG source used for a retrieve-only Knowledge Base evaluation job where you provide your own inference response data.
        case retrievesourceconfig(BedrockClientTypes.EvaluationPrecomputedRetrieveSourceConfig)
        /// A summary of a RAG source used for a retrieve-and-generate Knowledge Base evaluation job where you provide your own inference response data.
        case retrieveandgeneratesourceconfig(BedrockClientTypes.EvaluationPrecomputedRetrieveAndGenerateSourceConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// The Amazon S3 location where the results of your evaluation job are saved.
    public struct EvaluationOutputDataConfig: Swift.Sendable {
        /// The Amazon S3 URI where the results of the evaluation job are saved.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        ) {
            self.s3Uri = s3Uri
        }
    }
}

public struct CreateEvaluationJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the evaluation job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    ) {
        self.jobArn = jobArn
    }
}

public struct GetEvaluationJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the evaluation job you want get information on.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    ) {
        self.jobIdentifier = jobIdentifier
    }
}

extension GetEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvaluationJobInput(jobIdentifier: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum EvaluationJobType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automated
        case human
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationJobType] {
            return [
                .automated,
                .human
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automated: return "Automated"
            case .human: return "Human"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum SortJobsBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortJobsBy] {
            return [
                .creationTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListEvaluationJobsInput: Swift.Sendable {
    /// A filter to only list evaluation jobs that are either model evaluations or knowledge base evaluations.
    public var applicationTypeEquals: BedrockClientTypes.ApplicationType?
    /// A filter to only list evaluation jobs created after a specified time.
    public var creationTimeAfter: Foundation.Date?
    /// A filter to only list evaluation jobs created before a specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A filter to only list evaluation jobs that contain a specified string in the job name.
    public var nameContains: Swift.String?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?
    /// Specifies a creation time to sort the list of evaluation jobs by when they were created.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the list of evaluation jobs by either ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// A filter to only list evaluation jobs that are of a certain status.
    public var statusEquals: BedrockClientTypes.EvaluationJobStatus?

    public init(
        applicationTypeEquals: BedrockClientTypes.ApplicationType? = nil,
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.EvaluationJobStatus? = nil
    ) {
        self.applicationTypeEquals = applicationTypeEquals
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {

    /// A summary of the models used in an Amazon Bedrock model evaluation job. These resources can be models in Amazon Bedrock or models outside of Amazon Bedrock that you use to generate your own inference response data.
    public struct EvaluationModelConfigSummary: Swift.Sendable {
        /// The Amazon Resource Names (ARNs) of the models used for the evaluation job.
        public var bedrockModelIdentifiers: [Swift.String]?
        /// A label that identifies the models used for a model evaluation job where you provide your own inference response data.
        public var precomputedInferenceSourceIdentifiers: [Swift.String]?

        public init(
            bedrockModelIdentifiers: [Swift.String]? = nil,
            precomputedInferenceSourceIdentifiers: [Swift.String]? = nil
        ) {
            self.bedrockModelIdentifiers = bedrockModelIdentifiers
            self.precomputedInferenceSourceIdentifiers = precomputedInferenceSourceIdentifiers
        }
    }
}

extension BedrockClientTypes {

    /// A summary of the RAG resources used in an Amazon Bedrock Knowledge Base evaluation job. These resources can be Knowledge Bases in Amazon Bedrock or RAG sources outside of Amazon Bedrock that you use to generate your own inference response data.
    public struct EvaluationRagConfigSummary: Swift.Sendable {
        /// The Amazon Resource Names (ARNs) of the Knowledge Base resources used for a Knowledge Base evaluation job where Amazon Bedrock invokes the Knowledge Base for you.
        public var bedrockKnowledgeBaseIdentifiers: [Swift.String]?
        /// A label that identifies the RAG sources used for a Knowledge Base evaluation job where you provide your own inference response data.
        public var precomputedRagSourceIdentifiers: [Swift.String]?

        public init(
            bedrockKnowledgeBaseIdentifiers: [Swift.String]? = nil,
            precomputedRagSourceIdentifiers: [Swift.String]? = nil
        ) {
            self.bedrockKnowledgeBaseIdentifiers = bedrockKnowledgeBaseIdentifiers
            self.precomputedRagSourceIdentifiers = precomputedRagSourceIdentifiers
        }
    }
}

extension BedrockClientTypes {

    /// Identifies the models, Knowledge Bases, or other RAG sources evaluated in a model or Knowledge Base evaluation job.
    public struct EvaluationInferenceConfigSummary: Swift.Sendable {
        /// A summary of the models used in an Amazon Bedrock model evaluation job. These resources can be models in Amazon Bedrock or models outside of Amazon Bedrock that you use to generate your own inference response data.
        public var modelConfigSummary: BedrockClientTypes.EvaluationModelConfigSummary?
        /// A summary of the RAG resources used in an Amazon Bedrock Knowledge Base evaluation job. These resources can be Knowledge Bases in Amazon Bedrock or RAG sources outside of Amazon Bedrock that you use to generate your own inference response data.
        public var ragConfigSummary: BedrockClientTypes.EvaluationRagConfigSummary?

        public init(
            modelConfigSummary: BedrockClientTypes.EvaluationModelConfigSummary? = nil,
            ragConfigSummary: BedrockClientTypes.EvaluationRagConfigSummary? = nil
        ) {
            self.modelConfigSummary = modelConfigSummary
            self.ragConfigSummary = ragConfigSummary
        }
    }
}

extension BedrockClientTypes {

    /// Summary information of an evaluation job.
    public struct EvaluationSummary: Swift.Sendable {
        /// Specifies whether the evaluation job is for evaluating a model or evaluating a knowledge base (retrieval and response generation).
        public var applicationType: BedrockClientTypes.ApplicationType?
        /// The time the evaluation job was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Names (ARNs) of the models used to compute custom metrics in an Amazon Bedrock evaluation job.
        public var customMetricsEvaluatorModelIdentifiers: [Swift.String]?
        /// The type of task for model evaluation.
        /// This member is required.
        public var evaluationTaskTypes: [BedrockClientTypes.EvaluationTaskType]?
        /// The Amazon Resource Names (ARNs) of the models used to compute the metrics for a knowledge base evaluation job.
        public var evaluatorModelIdentifiers: [Swift.String]?
        /// Identifies the models, Knowledge Bases, or other RAG sources evaluated in a model or Knowledge Base evaluation job.
        public var inferenceConfigSummary: BedrockClientTypes.EvaluationInferenceConfigSummary?
        /// The Amazon Resource Name (ARN) of the evaluation job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name for the evaluation job.
        /// This member is required.
        public var jobName: Swift.String?
        /// Specifies whether the evaluation job is automated or human-based.
        /// This member is required.
        public var jobType: BedrockClientTypes.EvaluationJobType?
        /// The Amazon Resource Names (ARNs) of the model(s) used for the evaluation job.
        @available(*, deprecated, message: "Inference identifiers should be retrieved from the inferenceConfigSummary API deprecated since 2025-03-07")
        public var modelIdentifiers: [Swift.String]?
        /// The Amazon Resource Names (ARNs) of the knowledge base resources used for a knowledge base evaluation job.
        @available(*, deprecated, message: "Inference identifiers should be retrieved from the inferenceConfigSummary API deprecated since 2025-03-07")
        public var ragIdentifiers: [Swift.String]?
        /// The current status of the evaluation job.
        /// This member is required.
        public var status: BedrockClientTypes.EvaluationJobStatus?

        public init(
            applicationType: BedrockClientTypes.ApplicationType? = nil,
            creationTime: Foundation.Date? = nil,
            customMetricsEvaluatorModelIdentifiers: [Swift.String]? = nil,
            evaluationTaskTypes: [BedrockClientTypes.EvaluationTaskType]? = nil,
            evaluatorModelIdentifiers: [Swift.String]? = nil,
            inferenceConfigSummary: BedrockClientTypes.EvaluationInferenceConfigSummary? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobType: BedrockClientTypes.EvaluationJobType? = nil,
            modelIdentifiers: [Swift.String]? = [],
            ragIdentifiers: [Swift.String]? = nil,
            status: BedrockClientTypes.EvaluationJobStatus? = nil
        ) {
            self.applicationType = applicationType
            self.creationTime = creationTime
            self.customMetricsEvaluatorModelIdentifiers = customMetricsEvaluatorModelIdentifiers
            self.evaluationTaskTypes = evaluationTaskTypes
            self.evaluatorModelIdentifiers = evaluatorModelIdentifiers
            self.inferenceConfigSummary = inferenceConfigSummary
            self.jobArn = jobArn
            self.jobName = jobName
            self.jobType = jobType
            self.modelIdentifiers = modelIdentifiers
            self.ragIdentifiers = ragIdentifiers
            self.status = status
        }
    }
}

public struct ListEvaluationJobsOutput: Swift.Sendable {
    /// A list of summaries of the evaluation jobs.
    public var jobSummaries: [BedrockClientTypes.EvaluationSummary]?
    /// Continuation token from the previous response, for Amazon Bedrock to list the next set of results.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [BedrockClientTypes.EvaluationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

public struct StopEvaluationJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the evaluation job you want to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    ) {
        self.jobIdentifier = jobIdentifier
    }
}

extension StopEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopEvaluationJobInput(jobIdentifier: \"CONTENT_REDACTED\")"}
}

public struct StopEvaluationJobOutput: Swift.Sendable {

    public init() { }
}

extension BedrockClientTypes {

    /// Configuration settings for integrating Automated Reasoning policies with Amazon Bedrock Guardrails.
    public struct GuardrailAutomatedReasoningPolicyConfig: Swift.Sendable {
        /// The confidence threshold for triggering guardrail actions based on Automated Reasoning policy violations.
        public var confidenceThreshold: Swift.Double?
        /// The list of Automated Reasoning policy ARNs to include in the guardrail configuration.
        /// This member is required.
        public var policies: [Swift.String]?

        public init(
            confidenceThreshold: Swift.Double? = nil,
            policies: [Swift.String]? = nil
        ) {
            self.confidenceThreshold = confidenceThreshold
            self.policies = policies
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailContentFilterAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case block
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterAction] {
            return [
                .block,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .block: return "BLOCK"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailModality: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case image
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailModality] {
            return [
                .image,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .image: return "IMAGE"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailFilterStrength: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailFilterStrength] {
            return [
                .high,
                .low,
                .medium,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailContentFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hate
        case insults
        case misconduct
        case promptAttack
        case sexual
        case violence
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterType] {
            return [
                .hate,
                .insults,
                .misconduct,
                .promptAttack,
                .sexual,
                .violence
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hate: return "HATE"
            case .insults: return "INSULTS"
            case .misconduct: return "MISCONDUCT"
            case .promptAttack: return "PROMPT_ATTACK"
            case .sexual: return "SEXUAL"
            case .violence: return "VIOLENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Contains filter strengths for harmful content. Guardrails support the following content filters to detect and filter harmful user inputs and FM-generated outputs.
    ///
    /// * Hate â€“ Describes language or a statement that discriminates, criticizes, insults, denounces, or dehumanizes a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
    ///
    /// * Insults â€“ Describes language or a statement that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
    ///
    /// * Sexual â€“ Describes language or a statement that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
    ///
    /// * Violence â€“ Describes language or a statement that includes glorification of or threats to inflict physical pain, hurt, or injury toward a person, group or thing.
    ///
    ///
    /// Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as Hate with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as Hate with HIGH confidence, Insults with LOW confidence, Sexual with NONE confidence, and Violence with MEDIUM confidence. For more information, see [Guardrails content filters](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-filters.html).
    public struct GuardrailContentFilterConfig: Swift.Sendable {
        /// Specifies the action to take when harmful content is detected. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailContentFilterAction?
        /// Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// The input modalities selected for the guardrail content filter configuration.
        public var inputModalities: [BedrockClientTypes.GuardrailModality]?
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var inputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// Specifies the action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailContentFilterAction?
        /// Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// The output modalities selected for the guardrail content filter configuration.
        public var outputModalities: [BedrockClientTypes.GuardrailModality]?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var outputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The harmful category that the content filter is applied to.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContentFilterType?

        public init(
            inputAction: BedrockClientTypes.GuardrailContentFilterAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            inputModalities: [BedrockClientTypes.GuardrailModality]? = nil,
            inputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            outputAction: BedrockClientTypes.GuardrailContentFilterAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            outputModalities: [BedrockClientTypes.GuardrailModality]? = nil,
            outputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            type: BedrockClientTypes.GuardrailContentFilterType? = nil
        ) {
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.inputModalities = inputModalities
            self.inputStrength = inputStrength
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.outputModalities = outputModalities
            self.outputStrength = outputStrength
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailContentFilterConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContentFilterConfig(inputEnabled: \(Swift.String(describing: inputEnabled)), inputStrength: \(Swift.String(describing: inputStrength)), outputEnabled: \(Swift.String(describing: outputEnabled)), outputStrength: \(Swift.String(describing: outputStrength)), type: \(Swift.String(describing: type)), inputAction: \"CONTENT_REDACTED\", inputModalities: \"CONTENT_REDACTED\", outputAction: \"CONTENT_REDACTED\", outputModalities: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum GuardrailContentFiltersTierName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case classic
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFiltersTierName] {
            return [
                .classic,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .classic: return "CLASSIC"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The tier that your guardrail uses for content filters. Consider using a tier that balances performance, accuracy, and compatibility with your existing generative AI workflows.
    public struct GuardrailContentFiltersTierConfig: Swift.Sendable {
        /// The tier that your guardrail uses for content filters. Valid values include:
        ///
        /// * CLASSIC tier â€“ Provides established guardrails functionality supporting English, French, and Spanish languages.
        ///
        /// * STANDARD tier â€“ Provides a more robust solution than the CLASSIC tier and has more comprehensive language support. This tier requires that your guardrail use [cross-Region inference](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
        /// This member is required.
        public var tierName: BedrockClientTypes.GuardrailContentFiltersTierName?

        public init(
            tierName: BedrockClientTypes.GuardrailContentFiltersTierName? = nil
        ) {
            self.tierName = tierName
        }
    }
}

extension BedrockClientTypes.GuardrailContentFiltersTierConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContentFiltersTierConfig(tierName: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about how to handle harmful content.
    public struct GuardrailContentPolicyConfig: Swift.Sendable {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        /// This member is required.
        public var filtersConfig: [BedrockClientTypes.GuardrailContentFilterConfig]?
        /// The tier that your guardrail uses for content filters.
        public var tierConfig: BedrockClientTypes.GuardrailContentFiltersTierConfig?

        public init(
            filtersConfig: [BedrockClientTypes.GuardrailContentFilterConfig]? = nil,
            tierConfig: BedrockClientTypes.GuardrailContentFiltersTierConfig? = nil
        ) {
            self.filtersConfig = filtersConfig
            self.tierConfig = tierConfig
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailContextualGroundingAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case block
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContextualGroundingAction] {
            return [
                .block,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .block: return "BLOCK"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailContextualGroundingFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case grounding
        case relevance
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContextualGroundingFilterType] {
            return [
                .grounding,
                .relevance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grounding: return "GROUNDING"
            case .relevance: return "RELEVANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The filter configuration details for the guardrails contextual grounding filter.
    public struct GuardrailContextualGroundingFilterConfig: Swift.Sendable {
        /// Specifies the action to take when content fails the contextual grounding evaluation. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var action: BedrockClientTypes.GuardrailContextualGroundingAction?
        /// Specifies whether to enable contextual grounding evaluation. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var enabled: Swift.Bool?
        /// The threshold details for the guardrails contextual grounding filter.
        /// This member is required.
        public var threshold: Swift.Double?
        /// The filter details for the guardrails contextual grounding filter.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContextualGroundingFilterType?

        public init(
            action: BedrockClientTypes.GuardrailContextualGroundingAction? = nil,
            enabled: Swift.Bool? = nil,
            threshold: Swift.Double? = nil,
            type: BedrockClientTypes.GuardrailContextualGroundingFilterType? = nil
        ) {
            self.action = action
            self.enabled = enabled
            self.threshold = threshold
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingFilterConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContextualGroundingFilterConfig(enabled: \(Swift.String(describing: enabled)), threshold: \(Swift.String(describing: threshold)), type: \(Swift.String(describing: type)), action: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// The policy configuration details for the guardrails contextual grounding policy.
    public struct GuardrailContextualGroundingPolicyConfig: Swift.Sendable {
        /// The filter configuration details for the guardrails contextual grounding policy.
        /// This member is required.
        public var filtersConfig: [BedrockClientTypes.GuardrailContextualGroundingFilterConfig]?

        public init(
            filtersConfig: [BedrockClientTypes.GuardrailContextualGroundingFilterConfig]? = nil
        ) {
            self.filtersConfig = filtersConfig
        }
    }
}

extension BedrockClientTypes {

    /// The system-defined guardrail profile that you're using with your guardrail. Guardrail profiles define the destination Amazon Web Services Regions where guardrail inference requests can be automatically routed. Using guardrail profiles helps maintain guardrail performance and reliability when demand increases. For more information, see the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
    public struct GuardrailCrossRegionConfig: Swift.Sendable {
        /// The ID or Amazon Resource Name (ARN) of the guardrail profile that your guardrail is using. Guardrail profile availability depends on your current Amazon Web Services Region. For more information, see the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region-support.html).
        /// This member is required.
        public var guardrailProfileIdentifier: Swift.String?

        public init(
            guardrailProfileIdentifier: Swift.String? = nil
        ) {
            self.guardrailProfileIdentifier = guardrailProfileIdentifier
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailSensitiveInformationAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymize
        case block
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailSensitiveInformationAction] {
            return [
                .anonymize,
                .block,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymize: return "ANONYMIZE"
            case .block: return "BLOCK"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailPiiEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case age
        case awsAccessKey
        case awsSecretKey
        case caHealthNumber
        case caSocialInsuranceNumber
        case creditDebitCardCvv
        case creditDebitCardExpiry
        case creditDebitCardNumber
        case driverId
        case email
        case internationalBankAccountNumber
        case ipAddress
        case licensePlate
        case macAddress
        case name
        case password
        case phone
        case pin
        case swiftCode
        case ukNationalHealthServiceNumber
        case ukNationalInsuranceNumber
        case ukUniqueTaxpayerReferenceNumber
        case url
        case username
        case usBankAccountNumber
        case usBankRoutingNumber
        case usIndividualTaxIdentificationNumber
        case usPassportNumber
        case usSocialSecurityNumber
        case vehicleIdentificationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailPiiEntityType] {
            return [
                .address,
                .age,
                .awsAccessKey,
                .awsSecretKey,
                .caHealthNumber,
                .caSocialInsuranceNumber,
                .creditDebitCardCvv,
                .creditDebitCardExpiry,
                .creditDebitCardNumber,
                .driverId,
                .email,
                .internationalBankAccountNumber,
                .ipAddress,
                .licensePlate,
                .macAddress,
                .name,
                .password,
                .phone,
                .pin,
                .swiftCode,
                .ukNationalHealthServiceNumber,
                .ukNationalInsuranceNumber,
                .ukUniqueTaxpayerReferenceNumber,
                .url,
                .username,
                .usBankAccountNumber,
                .usBankRoutingNumber,
                .usIndividualTaxIdentificationNumber,
                .usPassportNumber,
                .usSocialSecurityNumber,
                .vehicleIdentificationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .awsAccessKey: return "AWS_ACCESS_KEY"
            case .awsSecretKey: return "AWS_SECRET_KEY"
            case .caHealthNumber: return "CA_HEALTH_NUMBER"
            case .caSocialInsuranceNumber: return "CA_SOCIAL_INSURANCE_NUMBER"
            case .creditDebitCardCvv: return "CREDIT_DEBIT_CARD_CVV"
            case .creditDebitCardExpiry: return "CREDIT_DEBIT_CARD_EXPIRY"
            case .creditDebitCardNumber: return "CREDIT_DEBIT_CARD_NUMBER"
            case .driverId: return "DRIVER_ID"
            case .email: return "EMAIL"
            case .internationalBankAccountNumber: return "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
            case .ipAddress: return "IP_ADDRESS"
            case .licensePlate: return "LICENSE_PLATE"
            case .macAddress: return "MAC_ADDRESS"
            case .name: return "NAME"
            case .password: return "PASSWORD"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .swiftCode: return "SWIFT_CODE"
            case .ukNationalHealthServiceNumber: return "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
            case .ukNationalInsuranceNumber: return "UK_NATIONAL_INSURANCE_NUMBER"
            case .ukUniqueTaxpayerReferenceNumber: return "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
            case .url: return "URL"
            case .username: return "USERNAME"
            case .usBankAccountNumber: return "US_BANK_ACCOUNT_NUMBER"
            case .usBankRoutingNumber: return "US_BANK_ROUTING_NUMBER"
            case .usIndividualTaxIdentificationNumber: return "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            case .usPassportNumber: return "US_PASSPORT_NUMBER"
            case .usSocialSecurityNumber: return "US_SOCIAL_SECURITY_NUMBER"
            case .vehicleIdentificationNumber: return "VEHICLE_IDENTIFICATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The PII entity to configure for the guardrail.
    public struct GuardrailPiiEntityConfig: Swift.Sendable {
        /// Configure guardrail action when the PII entity is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Specifies the action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * ANONYMIZE â€“ Mask the content and replace it with identifier tags.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// Specifies the action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * ANONYMIZE â€“ Mask the content and replace it with identifier tags.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// Configure guardrail type when the PII entity is detected. The following PIIs are used to block or mask sensitive information:
        ///
        /// * General
        ///
        /// * ADDRESS A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
        ///
        /// * AGE An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guardrails recognizes "40 years" as an age.
        ///
        /// * NAME An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
        ///
        /// * EMAIL An email address, such as marymajor@email.com.
        ///
        /// * PHONE A phone number. This entity type also includes fax and pager numbers.
        ///
        /// * USERNAME A user name that identifies an account, such as a login name, screen name, nick name, or handle.
        ///
        /// * PASSWORD An alphanumeric string that is used as a password, such as "*very20special#pass*".
        ///
        /// * DRIVER_ID The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
        ///
        /// * LICENSE_PLATE A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
        ///
        /// * VEHICLE_IDENTIFICATION_NUMBER A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the ISO 3779 specification. Each country has specific codes and formats for VINs.
        ///
        ///
        ///
        ///
        /// * Finance
        ///
        /// * CREDIT_DEBIT_CARD_CVV A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
        ///
        /// * CREDIT_DEBIT_CARD_EXPIRY The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as month/year or MM/YY. Guardrails recognizes expiration dates such as 01/21, 01/2021, and Jan 2021.
        ///
        /// * CREDIT_DEBIT_CARD_NUMBER The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
        ///
        /// * PIN A four-digit personal identification number (PIN) with which you can access your bank account.
        ///
        /// * INTERNATIONAL_BANK_ACCOUNT_NUMBER An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://www.iban.com/structure).
        ///
        /// * SWIFT_CODE A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers. SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
        ///
        ///
        ///
        ///
        /// * IT
        ///
        /// * IP_ADDRESS An IPv4 address, such as 198.51.100.0.
        ///
        /// * MAC_ADDRESS A media access control (MAC) address is a unique identifier assigned to a network interface controller (NIC).
        ///
        /// * URL A web address, such as www.example.com.
        ///
        /// * AWS_ACCESS_KEY A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.
        ///
        /// * AWS_SECRET_KEY A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic Amazon Web Services requests cryptographically.
        ///
        ///
        ///
        ///
        /// * USA specific
        ///
        /// * US_BANK_ACCOUNT_NUMBER A US bank account number, which is typically 10 to 12 digits long.
        ///
        /// * US_BANK_ROUTING_NUMBER A US bank account routing number. These are typically nine digits long,
        ///
        /// * US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
        ///
        /// * US_PASSPORT_NUMBER A US passport number. Passport numbers range from six to nine alphanumeric characters.
        ///
        /// * US_SOCIAL_SECURITY_NUMBER A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
        ///
        ///
        ///
        ///
        /// * Canada specific
        ///
        /// * CA_HEALTH_NUMBER A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
        ///
        /// * CA_SOCIAL_INSURANCE_NUMBER A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits. The SIN is formatted as three groups of three digits, such as 123-456-789. A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://www.wikipedia.org/wiki/Luhn_algorithm).
        ///
        ///
        ///
        ///
        /// * UK Specific
        ///
        /// * UK_NATIONAL_HEALTH_SERVICE_NUMBER A UK National Health Service Number is a 10-17 digit number, such as 485 777 3456. The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
        ///
        /// * UK_NATIONAL_INSURANCE_NUMBER A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system. The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
        ///
        /// * UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
        ///
        ///
        ///
        ///
        /// * Custom
        ///
        /// * Regex filter - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            inputAction: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            outputAction: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            type: BedrockClientTypes.GuardrailPiiEntityType? = nil
        ) {
            self.action = action
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The regular expression to configure for the guardrail.
    public struct GuardrailRegexConfig: Swift.Sendable {
        /// The guardrail action to configure when matching regular expression is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The description of the regular expression to configure for the guardrail.
        public var description: Swift.String?
        /// Specifies the action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// The name of the regular expression to configure for the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// The regular expression pattern to configure for the guardrail.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            description: Swift.String? = nil,
            inputAction: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            outputAction: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            pattern: Swift.String? = nil
        ) {
            self.action = action
            self.description = description
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.name = name
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.pattern = pattern
        }
    }
}

extension BedrockClientTypes {

    /// Contains details about PII entities and regular expressions to configure for the guardrail.
    public struct GuardrailSensitiveInformationPolicyConfig: Swift.Sendable {
        /// A list of PII entities to configure to the guardrail.
        public var piiEntitiesConfig: [BedrockClientTypes.GuardrailPiiEntityConfig]?
        /// A list of regular expressions to configure to the guardrail.
        public var regexesConfig: [BedrockClientTypes.GuardrailRegexConfig]?

        public init(
            piiEntitiesConfig: [BedrockClientTypes.GuardrailPiiEntityConfig]? = nil,
            regexesConfig: [BedrockClientTypes.GuardrailRegexConfig]? = nil
        ) {
            self.piiEntitiesConfig = piiEntitiesConfig
            self.regexesConfig = regexesConfig
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailTopicsTierName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case classic
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicsTierName] {
            return [
                .classic,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .classic: return "CLASSIC"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The tier that your guardrail uses for denied topic filters. Consider using a tier that balances performance, accuracy, and compatibility with your existing generative AI workflows.
    public struct GuardrailTopicsTierConfig: Swift.Sendable {
        /// The tier that your guardrail uses for denied topic filters. Valid values include:
        ///
        /// * CLASSIC tier â€“ Provides established guardrails functionality supporting English, French, and Spanish languages.
        ///
        /// * STANDARD tier â€“ Provides a more robust solution than the CLASSIC tier and has more comprehensive language support. This tier requires that your guardrail use [cross-Region inference](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
        /// This member is required.
        public var tierName: BedrockClientTypes.GuardrailTopicsTierName?

        public init(
            tierName: BedrockClientTypes.GuardrailTopicsTierName? = nil
        ) {
            self.tierName = tierName
        }
    }
}

extension BedrockClientTypes.GuardrailTopicsTierConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopicsTierConfig(tierName: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum GuardrailTopicAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case block
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicAction] {
            return [
                .block,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .block: return "BLOCK"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailTopicType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicType] {
            return [
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Details about topics for the guardrail to identify and deny.
    public struct GuardrailTopicConfig: Swift.Sendable {
        /// A definition of the topic to deny.
        /// This member is required.
        public var definition: Swift.String?
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public var examples: [Swift.String]?
        /// Specifies the action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailTopicAction?
        /// Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// The name of the topic to deny.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailTopicAction?
        /// Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// Specifies to deny the topic.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailTopicType?

        public init(
            definition: Swift.String? = nil,
            examples: [Swift.String]? = nil,
            inputAction: BedrockClientTypes.GuardrailTopicAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            outputAction: BedrockClientTypes.GuardrailTopicAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            type: BedrockClientTypes.GuardrailTopicType? = nil
        ) {
            self.definition = definition
            self.examples = examples
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.name = name
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailTopicConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopicConfig(inputEnabled: \(Swift.String(describing: inputEnabled)), outputEnabled: \(Swift.String(describing: outputEnabled)), type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", examples: \"CONTENT_REDACTED\", inputAction: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", outputAction: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about topics that the guardrail should identify and deny.
    public struct GuardrailTopicPolicyConfig: Swift.Sendable {
        /// The tier that your guardrail uses for denied topic filters.
        public var tierConfig: BedrockClientTypes.GuardrailTopicsTierConfig?
        /// A list of policies related to topics that the guardrail should deny.
        /// This member is required.
        public var topicsConfig: [BedrockClientTypes.GuardrailTopicConfig]?

        public init(
            tierConfig: BedrockClientTypes.GuardrailTopicsTierConfig? = nil,
            topicsConfig: [BedrockClientTypes.GuardrailTopicConfig]? = nil
        ) {
            self.tierConfig = tierConfig
            self.topicsConfig = topicsConfig
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailWordAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case block
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailWordAction] {
            return [
                .block,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .block: return "BLOCK"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailManagedWordsType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profanity
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailManagedWordsType] {
            return [
                .profanity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profanity: return "PROFANITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The managed word list to configure for the guardrail.
    public struct GuardrailManagedWordsConfig: Swift.Sendable {
        /// Specifies the action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailWordAction?
        /// Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// Specifies the action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailWordAction?
        /// Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// The managed word type to configure for the guardrail.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailManagedWordsType?

        public init(
            inputAction: BedrockClientTypes.GuardrailWordAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            outputAction: BedrockClientTypes.GuardrailWordAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            type: BedrockClientTypes.GuardrailManagedWordsType? = nil
        ) {
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailManagedWordsConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailManagedWordsConfig(inputEnabled: \(Swift.String(describing: inputEnabled)), outputEnabled: \(Swift.String(describing: outputEnabled)), type: \(Swift.String(describing: type)), inputAction: \"CONTENT_REDACTED\", outputAction: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// A word to configure for the guardrail.
    public struct GuardrailWordConfig: Swift.Sendable {
        /// Specifies the action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailWordAction?
        /// Specifies whether to enable guardrail evaluation on the intput. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// Specifies the action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailWordAction?
        /// Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// Text of the word configured for the guardrail to block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            inputAction: BedrockClientTypes.GuardrailWordAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            outputAction: BedrockClientTypes.GuardrailWordAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            text: Swift.String? = nil
        ) {
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.text = text
        }
    }
}

extension BedrockClientTypes.GuardrailWordConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailWordConfig(inputEnabled: \(Swift.String(describing: inputEnabled)), outputEnabled: \(Swift.String(describing: outputEnabled)), text: \(Swift.String(describing: text)), inputAction: \"CONTENT_REDACTED\", outputAction: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about the word policy to configured for the guardrail.
    public struct GuardrailWordPolicyConfig: Swift.Sendable {
        /// A list of managed words to configure for the guardrail.
        public var managedWordListsConfig: [BedrockClientTypes.GuardrailManagedWordsConfig]?
        /// A list of words to configure for the guardrail.
        public var wordsConfig: [BedrockClientTypes.GuardrailWordConfig]?

        public init(
            managedWordListsConfig: [BedrockClientTypes.GuardrailManagedWordsConfig]? = nil,
            wordsConfig: [BedrockClientTypes.GuardrailWordConfig]? = nil
        ) {
            self.managedWordListsConfig = managedWordListsConfig
            self.wordsConfig = wordsConfig
        }
    }
}

public struct CreateGuardrailInput: Swift.Sendable {
    /// Optional configuration for integrating Automated Reasoning policies with the new guardrail.
    public var automatedReasoningPolicyConfig: BedrockClientTypes.GuardrailAutomatedReasoningPolicyConfig?
    /// The message to return when the guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// The content filter policies to configure for the guardrail.
    public var contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig?
    /// The contextual grounding policy configuration used to create a guardrail.
    public var contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig?
    /// The system-defined guardrail profile that you're using with your guardrail. Guardrail profiles define the destination Amazon Web Services Regions where guardrail inference requests can be automatically routed. For more information, see the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
    public var crossRegionConfig: BedrockClientTypes.GuardrailCrossRegionConfig?
    /// A description of the guardrail.
    public var description: Swift.String?
    /// The ARN of the KMS key that you use to encrypt the guardrail.
    public var kmsKeyId: Swift.String?
    /// The name to give the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy to configure for the guardrail.
    public var sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?
    /// The tags that you want to attach to the guardrail.
    public var tags: [BedrockClientTypes.Tag]?
    /// The topic policies to configure for the guardrail.
    public var topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig?
    /// The word policy you configure for the guardrail.
    public var wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig?

    public init(
        automatedReasoningPolicyConfig: BedrockClientTypes.GuardrailAutomatedReasoningPolicyConfig? = nil,
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig? = nil,
        contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig? = nil,
        crossRegionConfig: BedrockClientTypes.GuardrailCrossRegionConfig? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig? = nil,
        tags: [BedrockClientTypes.Tag]? = nil,
        topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig? = nil,
        wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig? = nil
    ) {
        self.automatedReasoningPolicyConfig = automatedReasoningPolicyConfig
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.clientRequestToken = clientRequestToken
        self.contentPolicyConfig = contentPolicyConfig
        self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
        self.crossRegionConfig = crossRegionConfig
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.tags = tags
        self.topicPolicyConfig = topicPolicyConfig
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension CreateGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGuardrailInput(automatedReasoningPolicyConfig: \(Swift.String(describing: automatedReasoningPolicyConfig)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), contextualGroundingPolicyConfig: \(Swift.String(describing: contextualGroundingPolicyConfig)), crossRegionConfig: \(Swift.String(describing: crossRegionConfig)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), tags: \(Swift.String(describing: tags)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateGuardrailOutput: Swift.Sendable {
    /// The time at which the guardrail was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ARN of the guardrail.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail that was created.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The version of the guardrail that was created. This value will always be DRAFT.
    /// This member is required.
    public var version: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        version: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.version = version
    }
}

public struct CreateGuardrailVersionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than once. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// A description of the guardrail version.
    public var description: Swift.String?
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.guardrailIdentifier = guardrailIdentifier
    }
}

extension CreateGuardrailVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGuardrailVersionInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateGuardrailVersionOutput: Swift.Sendable {
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The number of the version of the guardrail.
    /// This member is required.
    public var version: Swift.String?

    public init(
        guardrailId: Swift.String? = nil,
        version: Swift.String? = nil
    ) {
        self.guardrailId = guardrailId
        self.version = version
    }
}

public struct DeleteGuardrailInput: Swift.Sendable {
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The version of the guardrail.
    public var guardrailVersion: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil
    ) {
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
    }
}

public struct DeleteGuardrailOutput: Swift.Sendable {

    public init() { }
}

public struct GetGuardrailInput: Swift.Sendable {
    /// The unique identifier of the guardrail for which to get details. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The version of the guardrail for which to get details. If you don't specify a version, the response returns details for the DRAFT version.
    public var guardrailVersion: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil
    ) {
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
    }
}

extension BedrockClientTypes {

    /// Represents the configuration of Automated Reasoning policies within a Amazon Bedrock Guardrail, including the policies to apply and confidence thresholds.
    public struct GuardrailAutomatedReasoningPolicy: Swift.Sendable {
        /// The minimum confidence level required for Automated Reasoning policy violations to trigger guardrail actions. Values range from 0.0 to 1.0.
        public var confidenceThreshold: Swift.Double?
        /// The list of Automated Reasoning policy ARNs that should be applied as part of this guardrail configuration.
        /// This member is required.
        public var policies: [Swift.String]?

        public init(
            confidenceThreshold: Swift.Double? = nil,
            policies: [Swift.String]? = nil
        ) {
            self.confidenceThreshold = confidenceThreshold
            self.policies = policies
        }
    }
}

extension BedrockClientTypes {

    /// Contains filter strengths for harmful content. Guardrails support the following content filters to detect and filter harmful user inputs and FM-generated outputs.
    ///
    /// * Hate â€“ Describes language or a statement that discriminates, criticizes, insults, denounces, or dehumanizes a person or group on the basis of an identity (such as race, ethnicity, gender, religion, sexual orientation, ability, and national origin).
    ///
    /// * Insults â€“ Describes language or a statement that includes demeaning, humiliating, mocking, insulting, or belittling language. This type of language is also labeled as bullying.
    ///
    /// * Sexual â€“ Describes language or a statement that indicates sexual interest, activity, or arousal using direct or indirect references to body parts, physical traits, or sex.
    ///
    /// * Violence â€“ Describes language or a statement that includes glorification of or threats to inflict physical pain, hurt, or injury toward a person, group or thing.
    ///
    ///
    /// Content filtering depends on the confidence classification of user inputs and FM responses across each of the four harmful categories. All input and output statements are classified into one of four confidence levels (NONE, LOW, MEDIUM, HIGH) for each harmful category. For example, if a statement is classified as Hate with HIGH confidence, the likelihood of the statement representing hateful content is high. A single statement can be classified across multiple categories with varying confidence levels. For example, a single statement can be classified as Hate with HIGH confidence, Insults with LOW confidence, Sexual with NONE confidence, and Violence with MEDIUM confidence. For more information, see [Guardrails content filters](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-filters.html). This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailContentFilter: Swift.Sendable {
        /// The action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailContentFilterAction?
        /// Indicates whether guardrail evaluation is enabled on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// The input modalities selected for the guardrail content filter.
        public var inputModalities: [BedrockClientTypes.GuardrailModality]?
        /// The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var inputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailContentFilterAction?
        /// Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// The output modalities selected for the guardrail content filter.
        public var outputModalities: [BedrockClientTypes.GuardrailModality]?
        /// The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        /// This member is required.
        public var outputStrength: BedrockClientTypes.GuardrailFilterStrength?
        /// The harmful category that the content filter is applied to.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContentFilterType?

        public init(
            inputAction: BedrockClientTypes.GuardrailContentFilterAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            inputModalities: [BedrockClientTypes.GuardrailModality]? = nil,
            inputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            outputAction: BedrockClientTypes.GuardrailContentFilterAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            outputModalities: [BedrockClientTypes.GuardrailModality]? = nil,
            outputStrength: BedrockClientTypes.GuardrailFilterStrength? = nil,
            type: BedrockClientTypes.GuardrailContentFilterType? = nil
        ) {
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.inputModalities = inputModalities
            self.inputStrength = inputStrength
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.outputModalities = outputModalities
            self.outputStrength = outputStrength
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailContentFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContentFilter(inputEnabled: \(Swift.String(describing: inputEnabled)), inputStrength: \(Swift.String(describing: inputStrength)), outputEnabled: \(Swift.String(describing: outputEnabled)), outputStrength: \(Swift.String(describing: outputStrength)), type: \(Swift.String(describing: type)), inputAction: \"CONTENT_REDACTED\", inputModalities: \"CONTENT_REDACTED\", outputAction: \"CONTENT_REDACTED\", outputModalities: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// The tier that your guardrail uses for content filters.
    public struct GuardrailContentFiltersTier: Swift.Sendable {
        /// The tier that your guardrail uses for content filters. Valid values include:
        ///
        /// * CLASSIC tier â€“ Provides established guardrails functionality supporting English, French, and Spanish languages.
        ///
        /// * STANDARD tier â€“ Provides a more robust solution than the CLASSIC tier and has more comprehensive language support. This tier requires that your guardrail use [cross-Region inference](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
        /// This member is required.
        public var tierName: BedrockClientTypes.GuardrailContentFiltersTierName?

        public init(
            tierName: BedrockClientTypes.GuardrailContentFiltersTierName? = nil
        ) {
            self.tierName = tierName
        }
    }
}

extension BedrockClientTypes.GuardrailContentFiltersTier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContentFiltersTier(tierName: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about how to handle harmful content. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailContentPolicy: Swift.Sendable {
        /// Contains the type of the content filter and how strongly it should apply to prompts and model responses.
        public var filters: [BedrockClientTypes.GuardrailContentFilter]?
        /// The tier that your guardrail uses for content filters.
        public var tier: BedrockClientTypes.GuardrailContentFiltersTier?

        public init(
            filters: [BedrockClientTypes.GuardrailContentFilter]? = nil,
            tier: BedrockClientTypes.GuardrailContentFiltersTier? = nil
        ) {
            self.filters = filters
            self.tier = tier
        }
    }
}

extension BedrockClientTypes {

    /// The details for the guardrails contextual grounding filter.
    public struct GuardrailContextualGroundingFilter: Swift.Sendable {
        /// The action to take when content fails the contextual grounding evaluation. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var action: BedrockClientTypes.GuardrailContextualGroundingAction?
        /// Indicates whether contextual grounding is enabled for evaluation. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var enabled: Swift.Bool?
        /// The threshold details for the guardrails contextual grounding filter.
        /// This member is required.
        public var threshold: Swift.Double?
        /// The filter type details for the guardrails contextual grounding filter.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailContextualGroundingFilterType?

        public init(
            action: BedrockClientTypes.GuardrailContextualGroundingAction? = nil,
            enabled: Swift.Bool? = nil,
            threshold: Swift.Double? = nil,
            type: BedrockClientTypes.GuardrailContextualGroundingFilterType? = nil
        ) {
            self.action = action
            self.enabled = enabled
            self.threshold = threshold
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailContextualGroundingFilter(enabled: \(Swift.String(describing: enabled)), threshold: \(Swift.String(describing: threshold)), type: \(Swift.String(describing: type)), action: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// The details for the guardrails contextual grounding policy.
    public struct GuardrailContextualGroundingPolicy: Swift.Sendable {
        /// The filter details for the guardrails contextual grounding policy.
        /// This member is required.
        public var filters: [BedrockClientTypes.GuardrailContextualGroundingFilter]?

        public init(
            filters: [BedrockClientTypes.GuardrailContextualGroundingFilter]? = nil
        ) {
            self.filters = filters
        }
    }
}

extension BedrockClientTypes {

    /// Contains details about the system-defined guardrail profile that you're using with your guardrail for cross-Region inference. For more information, see the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
    public struct GuardrailCrossRegionDetails: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the guardrail profile that you're using with your guardrail.
        public var guardrailProfileArn: Swift.String?
        /// The ID of the guardrail profile that your guardrail is using. Profile availability depends on your current Amazon Web Services Region. For more information, see the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region-support.html).
        public var guardrailProfileId: Swift.String?

        public init(
            guardrailProfileArn: Swift.String? = nil,
            guardrailProfileId: Swift.String? = nil
        ) {
            self.guardrailProfileArn = guardrailProfileArn
            self.guardrailProfileId = guardrailProfileId
        }
    }
}

extension BedrockClientTypes {

    /// The PII entity configured for the guardrail.
    public struct GuardrailPiiEntity: Swift.Sendable {
        /// The configured guardrail action when PII entity is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * ANONYMIZE â€“ Mask the content and replace it with identifier tags.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Indicates whether guardrail evaluation is enabled on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// The action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * ANONYMIZE â€“ Mask the content and replace it with identifier tags.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// The type of PII entity. For example, Social Security Number.
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            inputAction: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            outputAction: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            type: BedrockClientTypes.GuardrailPiiEntityType? = nil
        ) {
            self.action = action
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The regular expression configured for the guardrail.
    public struct GuardrailRegex: Swift.Sendable {
        /// The action taken when a match to the regular expression is detected.
        /// This member is required.
        public var action: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// The description of the regular expression for the guardrail.
        public var description: Swift.String?
        /// The action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Indicates whether guardrail evaluation is enabled on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// The name of the regular expression for the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailSensitiveInformationAction?
        /// Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// The pattern of the regular expression configured for the guardrail.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            action: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            description: Swift.String? = nil,
            inputAction: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            outputAction: BedrockClientTypes.GuardrailSensitiveInformationAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            pattern: Swift.String? = nil
        ) {
            self.action = action
            self.description = description
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.name = name
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.pattern = pattern
        }
    }
}

extension BedrockClientTypes {

    /// Contains details about PII entities and regular expressions configured for the guardrail.
    public struct GuardrailSensitiveInformationPolicy: Swift.Sendable {
        /// The list of PII entities configured for the guardrail.
        public var piiEntities: [BedrockClientTypes.GuardrailPiiEntity]?
        /// The list of regular expressions configured for the guardrail.
        public var regexes: [BedrockClientTypes.GuardrailRegex]?

        public init(
            piiEntities: [BedrockClientTypes.GuardrailPiiEntity]? = nil,
            regexes: [BedrockClientTypes.GuardrailRegex]? = nil
        ) {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }
    }
}

extension BedrockClientTypes {

    public enum GuardrailStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case ready
        case updating
        case versioning
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .ready,
                .updating,
                .versioning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .ready: return "READY"
            case .updating: return "UPDATING"
            case .versioning: return "VERSIONING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// The tier that your guardrail uses for denied topic filters.
    public struct GuardrailTopicsTier: Swift.Sendable {
        /// The tier that your guardrail uses for denied topic filters. Valid values include:
        ///
        /// * CLASSIC tier â€“ Provides established guardrails functionality supporting English, French, and Spanish languages.
        ///
        /// * STANDARD tier â€“ Provides a more robust solution than the CLASSIC tier and has more comprehensive language support. This tier requires that your guardrail use [cross-Region inference](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
        /// This member is required.
        public var tierName: BedrockClientTypes.GuardrailTopicsTierName?

        public init(
            tierName: BedrockClientTypes.GuardrailTopicsTierName? = nil
        ) {
            self.tierName = tierName
        }
    }
}

extension BedrockClientTypes.GuardrailTopicsTier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopicsTier(tierName: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Details about topics for the guardrail to identify and deny. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailTopic: Swift.Sendable {
        /// A definition of the topic to deny.
        /// This member is required.
        public var definition: Swift.String?
        /// A list of prompts, each of which is an example of a prompt that can be categorized as belonging to the topic.
        public var examples: [Swift.String]?
        /// The action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailTopicAction?
        /// Indicates whether guardrail evaluation is enabled on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// The name of the topic to deny.
        /// This member is required.
        public var name: Swift.String?
        /// The action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailTopicAction?
        /// Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// Specifies to deny the topic.
        public var type: BedrockClientTypes.GuardrailTopicType?

        public init(
            definition: Swift.String? = nil,
            examples: [Swift.String]? = nil,
            inputAction: BedrockClientTypes.GuardrailTopicAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            outputAction: BedrockClientTypes.GuardrailTopicAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            type: BedrockClientTypes.GuardrailTopicType? = nil
        ) {
            self.definition = definition
            self.examples = examples
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.name = name
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailTopic: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailTopic(inputEnabled: \(Swift.String(describing: inputEnabled)), outputEnabled: \(Swift.String(describing: outputEnabled)), type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", examples: \"CONTENT_REDACTED\", inputAction: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", outputAction: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about topics that the guardrail should identify and deny. This data type is used in the following API operations:
    ///
    /// * [GetGuardrail response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GetGuardrail.html#API_GetGuardrail_ResponseSyntax)
    public struct GuardrailTopicPolicy: Swift.Sendable {
        /// The tier that your guardrail uses for denied topic filters.
        public var tier: BedrockClientTypes.GuardrailTopicsTier?
        /// A list of policies related to topics that the guardrail should deny.
        /// This member is required.
        public var topics: [BedrockClientTypes.GuardrailTopic]?

        public init(
            tier: BedrockClientTypes.GuardrailTopicsTier? = nil,
            topics: [BedrockClientTypes.GuardrailTopic]? = nil
        ) {
            self.tier = tier
            self.topics = topics
        }
    }
}

extension BedrockClientTypes {

    /// The managed word list that was configured for the guardrail. (This is a list of words that are pre-defined and managed by guardrails only.)
    public struct GuardrailManagedWords: Swift.Sendable {
        /// The action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailWordAction?
        /// Indicates whether guardrail evaluation is enabled on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// The action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailWordAction?
        /// Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// ManagedWords$type The managed word type that was configured for the guardrail. (For now, we only offer profanity word list)
        /// This member is required.
        public var type: BedrockClientTypes.GuardrailManagedWordsType?

        public init(
            inputAction: BedrockClientTypes.GuardrailWordAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            outputAction: BedrockClientTypes.GuardrailWordAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            type: BedrockClientTypes.GuardrailManagedWordsType? = nil
        ) {
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.type = type
        }
    }
}

extension BedrockClientTypes.GuardrailManagedWords: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailManagedWords(inputEnabled: \(Swift.String(describing: inputEnabled)), outputEnabled: \(Swift.String(describing: outputEnabled)), type: \(Swift.String(describing: type)), inputAction: \"CONTENT_REDACTED\", outputAction: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// A word configured for the guardrail.
    public struct GuardrailWord: Swift.Sendable {
        /// The action to take when harmful content is detected in the input. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var inputAction: BedrockClientTypes.GuardrailWordAction?
        /// Indicates whether guardrail evaluation is enabled on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var inputEnabled: Swift.Bool?
        /// The action to take when harmful content is detected in the output. Supported values include:
        ///
        /// * BLOCK â€“ Block the content and replace it with blocked messaging.
        ///
        /// * NONE â€“ Take no action but return detection information in the trace response.
        public var outputAction: BedrockClientTypes.GuardrailWordAction?
        /// Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        public var outputEnabled: Swift.Bool?
        /// Text of the word configured for the guardrail to block.
        /// This member is required.
        public var text: Swift.String?

        public init(
            inputAction: BedrockClientTypes.GuardrailWordAction? = nil,
            inputEnabled: Swift.Bool? = nil,
            outputAction: BedrockClientTypes.GuardrailWordAction? = nil,
            outputEnabled: Swift.Bool? = nil,
            text: Swift.String? = nil
        ) {
            self.inputAction = inputAction
            self.inputEnabled = inputEnabled
            self.outputAction = outputAction
            self.outputEnabled = outputEnabled
            self.text = text
        }
    }
}

extension BedrockClientTypes.GuardrailWord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailWord(inputEnabled: \(Swift.String(describing: inputEnabled)), outputEnabled: \(Swift.String(describing: outputEnabled)), text: \(Swift.String(describing: text)), inputAction: \"CONTENT_REDACTED\", outputAction: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains details about the word policy configured for the guardrail.
    public struct GuardrailWordPolicy: Swift.Sendable {
        /// A list of managed words configured for the guardrail.
        public var managedWordLists: [BedrockClientTypes.GuardrailManagedWords]?
        /// A list of words configured for the guardrail.
        public var words: [BedrockClientTypes.GuardrailWord]?

        public init(
            managedWordLists: [BedrockClientTypes.GuardrailManagedWords]? = nil,
            words: [BedrockClientTypes.GuardrailWord]? = nil
        ) {
            self.managedWordLists = managedWordLists
            self.words = words
        }
    }
}

public struct GetGuardrailOutput: Swift.Sendable {
    /// The current Automated Reasoning policy configuration for the guardrail, if any is configured.
    public var automatedReasoningPolicy: BedrockClientTypes.GuardrailAutomatedReasoningPolicy?
    /// The message that the guardrail returns when it blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message that the guardrail returns when it blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// The content policy that was configured for the guardrail.
    public var contentPolicy: BedrockClientTypes.GuardrailContentPolicy?
    /// The contextual grounding policy used in the guardrail.
    public var contextualGroundingPolicy: BedrockClientTypes.GuardrailContextualGroundingPolicy?
    /// The date and time at which the guardrail was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Details about the system-defined guardrail profile that you're using with your guardrail, including the guardrail profile ID and Amazon Resource Name (ARN).
    public var crossRegionDetails: BedrockClientTypes.GuardrailCrossRegionDetails?
    /// The description of the guardrail.
    public var description: Swift.String?
    /// Appears if the status of the guardrail is FAILED. A list of recommendations to carry out before retrying the request.
    public var failureRecommendations: [Swift.String]?
    /// The ARN of the guardrail.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail.
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The ARN of the KMS key that encrypts the guardrail.
    public var kmsKeyArn: Swift.String?
    /// The name of the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy that was configured for the guardrail.
    public var sensitiveInformationPolicy: BedrockClientTypes.GuardrailSensitiveInformationPolicy?
    /// The status of the guardrail.
    /// This member is required.
    public var status: BedrockClientTypes.GuardrailStatus?
    /// Appears if the status is FAILED. A list of reasons for why the guardrail failed to be created, updated, versioned, or deleted.
    public var statusReasons: [Swift.String]?
    /// The topic policy that was configured for the guardrail.
    public var topicPolicy: BedrockClientTypes.GuardrailTopicPolicy?
    /// The date and time at which the guardrail was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version of the guardrail.
    /// This member is required.
    public var version: Swift.String?
    /// The word policy that was configured for the guardrail.
    public var wordPolicy: BedrockClientTypes.GuardrailWordPolicy?

    public init(
        automatedReasoningPolicy: BedrockClientTypes.GuardrailAutomatedReasoningPolicy? = nil,
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        contentPolicy: BedrockClientTypes.GuardrailContentPolicy? = nil,
        contextualGroundingPolicy: BedrockClientTypes.GuardrailContextualGroundingPolicy? = nil,
        createdAt: Foundation.Date? = nil,
        crossRegionDetails: BedrockClientTypes.GuardrailCrossRegionDetails? = nil,
        description: Swift.String? = nil,
        failureRecommendations: [Swift.String]? = nil,
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicy: BedrockClientTypes.GuardrailSensitiveInformationPolicy? = nil,
        status: BedrockClientTypes.GuardrailStatus? = nil,
        statusReasons: [Swift.String]? = nil,
        topicPolicy: BedrockClientTypes.GuardrailTopicPolicy? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil,
        wordPolicy: BedrockClientTypes.GuardrailWordPolicy? = nil
    ) {
        self.automatedReasoningPolicy = automatedReasoningPolicy
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.contentPolicy = contentPolicy
        self.contextualGroundingPolicy = contextualGroundingPolicy
        self.createdAt = createdAt
        self.crossRegionDetails = crossRegionDetails
        self.description = description
        self.failureRecommendations = failureRecommendations
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.sensitiveInformationPolicy = sensitiveInformationPolicy
        self.status = status
        self.statusReasons = statusReasons
        self.topicPolicy = topicPolicy
        self.updatedAt = updatedAt
        self.version = version
        self.wordPolicy = wordPolicy
    }
}

extension GetGuardrailOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetGuardrailOutput(automatedReasoningPolicy: \(Swift.String(describing: automatedReasoningPolicy)), contentPolicy: \(Swift.String(describing: contentPolicy)), contextualGroundingPolicy: \(Swift.String(describing: contextualGroundingPolicy)), createdAt: \(Swift.String(describing: createdAt)), crossRegionDetails: \(Swift.String(describing: crossRegionDetails)), guardrailArn: \(Swift.String(describing: guardrailArn)), guardrailId: \(Swift.String(describing: guardrailId)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), sensitiveInformationPolicy: \(Swift.String(describing: sensitiveInformationPolicy)), status: \(Swift.String(describing: status)), topicPolicy: \(Swift.String(describing: topicPolicy)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), wordPolicy: \(Swift.String(describing: wordPolicy)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", failureRecommendations: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", statusReasons: \"CONTENT_REDACTED\")"}
}

public struct ListGuardrailsInput: Swift.Sendable {
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    public var guardrailIdentifier: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
    public var nextToken: Swift.String?

    public init(
        guardrailIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.guardrailIdentifier = guardrailIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {

    /// Contains details about a guardrail. This data type is used in the following API operations:
    ///
    /// * [ListGuardrails response body](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListGuardrails.html#API_ListGuardrails_ResponseSyntax)
    public struct GuardrailSummary: Swift.Sendable {
        /// The ARN of the guardrail.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time at which the guardrail was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Details about the system-defined guardrail profile that you're using with your guardrail, including the guardrail profile ID and Amazon Resource Name (ARN).
        public var crossRegionDetails: BedrockClientTypes.GuardrailCrossRegionDetails?
        /// A description of the guardrail.
        public var description: Swift.String?
        /// The unique identifier of the guardrail.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the guardrail.
        /// This member is required.
        public var status: BedrockClientTypes.GuardrailStatus?
        /// The date and time at which the guardrail was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The version of the guardrail.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            crossRegionDetails: BedrockClientTypes.GuardrailCrossRegionDetails? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockClientTypes.GuardrailStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.crossRegionDetails = crossRegionDetails
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }
    }
}

extension BedrockClientTypes.GuardrailSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GuardrailSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), crossRegionDetails: \(Swift.String(describing: crossRegionDetails)), id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListGuardrailsOutput: Swift.Sendable {
    /// A list of objects, each of which contains details about a guardrail.
    /// This member is required.
    public var guardrails: [BedrockClientTypes.GuardrailSummary]?
    /// If there are more results than were returned in the response, the response returns a nextToken that you can send in another ListGuardrails request to see the next batch of results.
    public var nextToken: Swift.String?

    public init(
        guardrails: [BedrockClientTypes.GuardrailSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.guardrails = guardrails
        self.nextToken = nextToken
    }
}

public struct UpdateGuardrailInput: Swift.Sendable {
    /// Updated configuration for Automated Reasoning policies associated with the guardrail.
    public var automatedReasoningPolicyConfig: BedrockClientTypes.GuardrailAutomatedReasoningPolicyConfig?
    /// The message to return when the guardrail blocks a prompt.
    /// This member is required.
    public var blockedInputMessaging: Swift.String?
    /// The message to return when the guardrail blocks a model response.
    /// This member is required.
    public var blockedOutputsMessaging: Swift.String?
    /// The content policy to configure for the guardrail.
    public var contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig?
    /// The contextual grounding policy configuration used to update a guardrail.
    public var contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig?
    /// The system-defined guardrail profile that you're using with your guardrail. Guardrail profiles define the destination Amazon Web Services Regions where guardrail inference requests can be automatically routed. For more information, see the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
    public var crossRegionConfig: BedrockClientTypes.GuardrailCrossRegionConfig?
    /// A description of the guardrail.
    public var description: Swift.String?
    /// The unique identifier of the guardrail. This can be an ID or the ARN.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The ARN of the KMS key with which to encrypt the guardrail.
    public var kmsKeyId: Swift.String?
    /// A name for the guardrail.
    /// This member is required.
    public var name: Swift.String?
    /// The sensitive information policy to configure for the guardrail.
    public var sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?
    /// The topic policy to configure for the guardrail.
    public var topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig?
    /// The word policy to configure for the guardrail.
    public var wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig?

    public init(
        automatedReasoningPolicyConfig: BedrockClientTypes.GuardrailAutomatedReasoningPolicyConfig? = nil,
        blockedInputMessaging: Swift.String? = nil,
        blockedOutputsMessaging: Swift.String? = nil,
        contentPolicyConfig: BedrockClientTypes.GuardrailContentPolicyConfig? = nil,
        contextualGroundingPolicyConfig: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig? = nil,
        crossRegionConfig: BedrockClientTypes.GuardrailCrossRegionConfig? = nil,
        description: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        sensitiveInformationPolicyConfig: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig? = nil,
        topicPolicyConfig: BedrockClientTypes.GuardrailTopicPolicyConfig? = nil,
        wordPolicyConfig: BedrockClientTypes.GuardrailWordPolicyConfig? = nil
    ) {
        self.automatedReasoningPolicyConfig = automatedReasoningPolicyConfig
        self.blockedInputMessaging = blockedInputMessaging
        self.blockedOutputsMessaging = blockedOutputsMessaging
        self.contentPolicyConfig = contentPolicyConfig
        self.contextualGroundingPolicyConfig = contextualGroundingPolicyConfig
        self.crossRegionConfig = crossRegionConfig
        self.description = description
        self.guardrailIdentifier = guardrailIdentifier
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig
        self.topicPolicyConfig = topicPolicyConfig
        self.wordPolicyConfig = wordPolicyConfig
    }
}

extension UpdateGuardrailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGuardrailInput(automatedReasoningPolicyConfig: \(Swift.String(describing: automatedReasoningPolicyConfig)), contentPolicyConfig: \(Swift.String(describing: contentPolicyConfig)), contextualGroundingPolicyConfig: \(Swift.String(describing: contextualGroundingPolicyConfig)), crossRegionConfig: \(Swift.String(describing: crossRegionConfig)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), sensitiveInformationPolicyConfig: \(Swift.String(describing: sensitiveInformationPolicyConfig)), topicPolicyConfig: \(Swift.String(describing: topicPolicyConfig)), wordPolicyConfig: \(Swift.String(describing: wordPolicyConfig)), blockedInputMessaging: \"CONTENT_REDACTED\", blockedOutputsMessaging: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateGuardrailOutput: Swift.Sendable {
    /// The ARN of the guardrail.
    /// This member is required.
    public var guardrailArn: Swift.String?
    /// The unique identifier of the guardrail
    /// This member is required.
    public var guardrailId: Swift.String?
    /// The date and time at which the guardrail was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version of the guardrail.
    /// This member is required.
    public var version: Swift.String?

    public init(
        guardrailArn: Swift.String? = nil,
        guardrailId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil
    ) {
        self.guardrailArn = guardrailArn
        self.guardrailId = guardrailId
        self.updatedAt = updatedAt
        self.version = version
    }
}

extension BedrockClientTypes {

    /// Contains information about the model or system-defined inference profile that is the source for an inference profile..
    public enum InferenceProfileModelSource: Swift.Sendable {
        /// The ARN of the model or system-defined inference profile that is the source for the inference profile.
        case copyfrom(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateInferenceProfileInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// A description for the inference profile.
    public var description: Swift.String?
    /// A name for the inference profile.
    /// This member is required.
    public var inferenceProfileName: Swift.String?
    /// The foundation model or system-defined inference profile that the inference profile will track metrics and costs for.
    /// This member is required.
    public var modelSource: BedrockClientTypes.InferenceProfileModelSource?
    /// An array of objects, each of which contains a tag and its value. For more information, see [Tagging resources](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        inferenceProfileName: Swift.String? = nil,
        modelSource: BedrockClientTypes.InferenceProfileModelSource? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.inferenceProfileName = inferenceProfileName
        self.modelSource = modelSource
        self.tags = tags
    }
}

extension CreateInferenceProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInferenceProfileInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), inferenceProfileName: \(Swift.String(describing: inferenceProfileName)), modelSource: \(Swift.String(describing: modelSource)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    public enum InferenceProfileStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceProfileStatus] {
            return [
                .active
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateInferenceProfileOutput: Swift.Sendable {
    /// The ARN of the inference profile that you created.
    /// This member is required.
    public var inferenceProfileArn: Swift.String?
    /// The status of the inference profile. ACTIVE means that the inference profile is ready to be used.
    public var status: BedrockClientTypes.InferenceProfileStatus?

    public init(
        inferenceProfileArn: Swift.String? = nil,
        status: BedrockClientTypes.InferenceProfileStatus? = nil
    ) {
        self.inferenceProfileArn = inferenceProfileArn
        self.status = status
    }
}

public struct DeleteInferenceProfileInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or ID of the application inference profile to delete.
    /// This member is required.
    public var inferenceProfileIdentifier: Swift.String?

    public init(
        inferenceProfileIdentifier: Swift.String? = nil
    ) {
        self.inferenceProfileIdentifier = inferenceProfileIdentifier
    }
}

public struct DeleteInferenceProfileOutput: Swift.Sendable {

    public init() { }
}

public struct GetInferenceProfileInput: Swift.Sendable {
    /// The ID or Amazon Resource Name (ARN) of the inference profile.
    /// This member is required.
    public var inferenceProfileIdentifier: Swift.String?

    public init(
        inferenceProfileIdentifier: Swift.String? = nil
    ) {
        self.inferenceProfileIdentifier = inferenceProfileIdentifier
    }
}

extension BedrockClientTypes {

    /// Contains information about a model.
    public struct InferenceProfileModel: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the model.
        public var modelArn: Swift.String?

        public init(
            modelArn: Swift.String? = nil
        ) {
            self.modelArn = modelArn
        }
    }
}

extension BedrockClientTypes {

    public enum InferenceProfileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case systemDefined
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceProfileType] {
            return [
                .application,
                .systemDefined
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .systemDefined: return "SYSTEM_DEFINED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetInferenceProfileOutput: Swift.Sendable {
    /// The time at which the inference profile was created.
    public var createdAt: Foundation.Date?
    /// The description of the inference profile.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the inference profile.
    /// This member is required.
    public var inferenceProfileArn: Swift.String?
    /// The unique identifier of the inference profile.
    /// This member is required.
    public var inferenceProfileId: Swift.String?
    /// The name of the inference profile.
    /// This member is required.
    public var inferenceProfileName: Swift.String?
    /// A list of information about each model in the inference profile.
    /// This member is required.
    public var models: [BedrockClientTypes.InferenceProfileModel]?
    /// The status of the inference profile. ACTIVE means that the inference profile is ready to be used.
    /// This member is required.
    public var status: BedrockClientTypes.InferenceProfileStatus?
    /// The type of the inference profile. The following types are possible:
    ///
    /// * SYSTEM_DEFINED â€“ The inference profile is defined by Amazon Bedrock. You can route inference requests across regions with these inference profiles.
    ///
    /// * APPLICATION â€“ The inference profile was created by a user. This type of inference profile can track metrics and costs when invoking the model in it. The inference profile may route requests to one or multiple regions.
    /// This member is required.
    public var type: BedrockClientTypes.InferenceProfileType?
    /// The time at which the inference profile was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        inferenceProfileArn: Swift.String? = nil,
        inferenceProfileId: Swift.String? = nil,
        inferenceProfileName: Swift.String? = nil,
        models: [BedrockClientTypes.InferenceProfileModel]? = nil,
        status: BedrockClientTypes.InferenceProfileStatus? = nil,
        type: BedrockClientTypes.InferenceProfileType? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.inferenceProfileArn = inferenceProfileArn
        self.inferenceProfileId = inferenceProfileId
        self.inferenceProfileName = inferenceProfileName
        self.models = models
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension GetInferenceProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInferenceProfileOutput(createdAt: \(Swift.String(describing: createdAt)), inferenceProfileArn: \(Swift.String(describing: inferenceProfileArn)), inferenceProfileId: \(Swift.String(describing: inferenceProfileId)), inferenceProfileName: \(Swift.String(describing: inferenceProfileName)), models: \(Swift.String(describing: models)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct ListInferenceProfilesInput: Swift.Sendable {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// Filters for inference profiles that match the type you specify.
    ///
    /// * SYSTEM_DEFINED â€“ The inference profile is defined by Amazon Bedrock. You can route inference requests across regions with these inference profiles.
    ///
    /// * APPLICATION â€“ The inference profile was created by a user. This type of inference profile can track metrics and costs when invoking the model in it. The inference profile may route requests to one or multiple regions.
    public var typeEquals: BedrockClientTypes.InferenceProfileType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        typeEquals: BedrockClientTypes.InferenceProfileType? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeEquals = typeEquals
    }
}

extension BedrockClientTypes {

    /// Contains information about an inference profile.
    public struct InferenceProfileSummary: Swift.Sendable {
        /// The time at which the inference profile was created.
        public var createdAt: Foundation.Date?
        /// The description of the inference profile.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the inference profile.
        /// This member is required.
        public var inferenceProfileArn: Swift.String?
        /// The unique identifier of the inference profile.
        /// This member is required.
        public var inferenceProfileId: Swift.String?
        /// The name of the inference profile.
        /// This member is required.
        public var inferenceProfileName: Swift.String?
        /// A list of information about each model in the inference profile.
        /// This member is required.
        public var models: [BedrockClientTypes.InferenceProfileModel]?
        /// The status of the inference profile. ACTIVE means that the inference profile is ready to be used.
        /// This member is required.
        public var status: BedrockClientTypes.InferenceProfileStatus?
        /// The type of the inference profile. The following types are possible:
        ///
        /// * SYSTEM_DEFINED â€“ The inference profile is defined by Amazon Bedrock. You can route inference requests across regions with these inference profiles.
        ///
        /// * APPLICATION â€“ The inference profile was created by a user. This type of inference profile can track metrics and costs when invoking the model in it. The inference profile may route requests to one or multiple regions.
        /// This member is required.
        public var type: BedrockClientTypes.InferenceProfileType?
        /// The time at which the inference profile was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            inferenceProfileArn: Swift.String? = nil,
            inferenceProfileId: Swift.String? = nil,
            inferenceProfileName: Swift.String? = nil,
            models: [BedrockClientTypes.InferenceProfileModel]? = nil,
            status: BedrockClientTypes.InferenceProfileStatus? = nil,
            type: BedrockClientTypes.InferenceProfileType? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.createdAt = createdAt
            self.description = description
            self.inferenceProfileArn = inferenceProfileArn
            self.inferenceProfileId = inferenceProfileId
            self.inferenceProfileName = inferenceProfileName
            self.models = models
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockClientTypes.InferenceProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InferenceProfileSummary(createdAt: \(Swift.String(describing: createdAt)), inferenceProfileArn: \(Swift.String(describing: inferenceProfileArn)), inferenceProfileId: \(Swift.String(describing: inferenceProfileId)), inferenceProfileName: \(Swift.String(describing: inferenceProfileName)), models: \(Swift.String(describing: models)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct ListInferenceProfilesOutput: Swift.Sendable {
    /// A list of information about each inference profile that you can use.
    public var inferenceProfileSummaries: [BedrockClientTypes.InferenceProfileSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        inferenceProfileSummaries: [BedrockClientTypes.InferenceProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.inferenceProfileSummaries = inferenceProfileSummaries
        self.nextToken = nextToken
    }
}

public struct DeleteModelInvocationLoggingConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct DeleteModelInvocationLoggingConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct GetModelInvocationLoggingConfigurationInput: Swift.Sendable {

    public init() { }
}

extension BedrockClientTypes {

    /// S3 configuration for storing log data.
    public struct S3Config: Swift.Sendable {
        /// S3 bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// S3 prefix.
        public var keyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            keyPrefix: Swift.String? = nil
        ) {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
        }
    }
}

extension BedrockClientTypes {

    /// CloudWatch logging configuration.
    public struct CloudWatchConfig: Swift.Sendable {
        /// S3 configuration for delivering a large amount of data.
        public var largeDataDeliveryS3Config: BedrockClientTypes.S3Config?
        /// The log group name.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The role Amazon Resource Name (ARN).
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            largeDataDeliveryS3Config: BedrockClientTypes.S3Config? = nil,
            logGroupName: Swift.String? = nil,
            roleArn: Swift.String? = nil
        ) {
            self.largeDataDeliveryS3Config = largeDataDeliveryS3Config
            self.logGroupName = logGroupName
            self.roleArn = roleArn
        }
    }
}

extension BedrockClientTypes {

    /// Configuration fields for invocation logging.
    public struct LoggingConfig: Swift.Sendable {
        /// Set to include audio data in the log delivery.
        public var audioDataDeliveryEnabled: Swift.Bool?
        /// CloudWatch logging configuration.
        public var cloudWatchConfig: BedrockClientTypes.CloudWatchConfig?
        /// Set to include embeddings data in the log delivery.
        public var embeddingDataDeliveryEnabled: Swift.Bool?
        /// Set to include image data in the log delivery.
        public var imageDataDeliveryEnabled: Swift.Bool?
        /// S3 configuration for storing log data.
        public var s3Config: BedrockClientTypes.S3Config?
        /// Set to include text data in the log delivery.
        public var textDataDeliveryEnabled: Swift.Bool?
        /// Set to include video data in the log delivery.
        public var videoDataDeliveryEnabled: Swift.Bool?

        public init(
            audioDataDeliveryEnabled: Swift.Bool? = nil,
            cloudWatchConfig: BedrockClientTypes.CloudWatchConfig? = nil,
            embeddingDataDeliveryEnabled: Swift.Bool? = nil,
            imageDataDeliveryEnabled: Swift.Bool? = nil,
            s3Config: BedrockClientTypes.S3Config? = nil,
            textDataDeliveryEnabled: Swift.Bool? = nil,
            videoDataDeliveryEnabled: Swift.Bool? = nil
        ) {
            self.audioDataDeliveryEnabled = audioDataDeliveryEnabled
            self.cloudWatchConfig = cloudWatchConfig
            self.embeddingDataDeliveryEnabled = embeddingDataDeliveryEnabled
            self.imageDataDeliveryEnabled = imageDataDeliveryEnabled
            self.s3Config = s3Config
            self.textDataDeliveryEnabled = textDataDeliveryEnabled
            self.videoDataDeliveryEnabled = videoDataDeliveryEnabled
        }
    }
}

public struct GetModelInvocationLoggingConfigurationOutput: Swift.Sendable {
    /// The current configuration values.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    ) {
        self.loggingConfig = loggingConfig
    }
}

public struct PutModelInvocationLoggingConfigurationInput: Swift.Sendable {
    /// The logging configuration values to set.
    /// This member is required.
    public var loggingConfig: BedrockClientTypes.LoggingConfig?

    public init(
        loggingConfig: BedrockClientTypes.LoggingConfig? = nil
    ) {
        self.loggingConfig = loggingConfig
    }
}

public struct PutModelInvocationLoggingConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct CreateModelCopyJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The ARN of the KMS key that you use to encrypt the model copy.
    public var modelKmsKeyId: Swift.String?
    /// The Amazon Resource Name (ARN) of the model to be copied.
    /// This member is required.
    public var sourceModelArn: Swift.String?
    /// A name for the copied model.
    /// This member is required.
    public var targetModelName: Swift.String?
    /// Tags to associate with the target model. For more information, see [Tag resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var targetModelTags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        modelKmsKeyId: Swift.String? = nil,
        sourceModelArn: Swift.String? = nil,
        targetModelName: Swift.String? = nil,
        targetModelTags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.modelKmsKeyId = modelKmsKeyId
        self.sourceModelArn = sourceModelArn
        self.targetModelName = targetModelName
        self.targetModelTags = targetModelTags
    }
}

public struct CreateModelCopyJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model copy job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    ) {
        self.jobArn = jobArn
    }
}

public struct GetModelCopyJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model copy job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    ) {
        self.jobArn = jobArn
    }
}

extension BedrockClientTypes {

    public enum ModelCopyJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCopyJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelCopyJobOutput: Swift.Sendable {
    /// The time at which the model copy job was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// An error message for why the model copy job failed.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the model copy job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The unique identifier of the account that the model being copied originated from.
    /// This member is required.
    public var sourceAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the original model being copied.
    /// This member is required.
    public var sourceModelArn: Swift.String?
    /// The name of the original model being copied.
    public var sourceModelName: Swift.String?
    /// The status of the model copy job.
    /// This member is required.
    public var status: BedrockClientTypes.ModelCopyJobStatus?
    /// The Amazon Resource Name (ARN) of the copied model.
    /// This member is required.
    public var targetModelArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key encrypting the copied model.
    public var targetModelKmsKeyArn: Swift.String?
    /// The name of the copied model.
    public var targetModelName: Swift.String?
    /// The tags associated with the copied model.
    public var targetModelTags: [BedrockClientTypes.Tag]?

    public init(
        creationTime: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        sourceAccountId: Swift.String? = nil,
        sourceModelArn: Swift.String? = nil,
        sourceModelName: Swift.String? = nil,
        status: BedrockClientTypes.ModelCopyJobStatus? = nil,
        targetModelArn: Swift.String? = nil,
        targetModelKmsKeyArn: Swift.String? = nil,
        targetModelName: Swift.String? = nil,
        targetModelTags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.creationTime = creationTime
        self.failureMessage = failureMessage
        self.jobArn = jobArn
        self.sourceAccountId = sourceAccountId
        self.sourceModelArn = sourceModelArn
        self.sourceModelName = sourceModelName
        self.status = status
        self.targetModelArn = targetModelArn
        self.targetModelKmsKeyArn = targetModelKmsKeyArn
        self.targetModelName = targetModelName
        self.targetModelTags = targetModelTags
    }
}

public struct ListModelCopyJobsInput: Swift.Sendable {
    /// Filters for model copy jobs created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Filters for model copy jobs created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of model copy jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the results in ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Filters for model copy jobs in which the account that the source model belongs to is equal to the value that you specify.
    public var sourceAccountEquals: Swift.String?
    /// Filters for model copy jobs in which the Amazon Resource Name (ARN) of the source model to is equal to the value that you specify.
    public var sourceModelArnEquals: Swift.String?
    /// Filters for model copy jobs whose status matches the value that you specify.
    public var statusEquals: BedrockClientTypes.ModelCopyJobStatus?
    /// Filters for model copy jobs in which the name of the copied model contains the string that you specify.
    public var targetModelNameContains: Swift.String?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        sourceAccountEquals: Swift.String? = nil,
        sourceModelArnEquals: Swift.String? = nil,
        statusEquals: BedrockClientTypes.ModelCopyJobStatus? = nil,
        targetModelNameContains: Swift.String? = nil
    ) {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.sourceAccountEquals = sourceAccountEquals
        self.sourceModelArnEquals = sourceModelArnEquals
        self.statusEquals = statusEquals
        self.targetModelNameContains = targetModelNameContains
    }
}

extension BedrockClientTypes {

    /// Contains details about each model copy job. This data type is used in the following API operations:
    ///
    /// * [ListModelCopyJobs response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListModelCopyJobs.html#API_ListModelCopyJobs_ResponseSyntax)
    public struct ModelCopyJobSummary: Swift.Sendable {
        /// The time that the model copy job was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// If a model fails to be copied, a message describing why the job failed is included here.
        public var failureMessage: Swift.String?
        /// The Amazon Resoource Name (ARN) of the model copy job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The unique identifier of the account that the model being copied originated from.
        /// This member is required.
        public var sourceAccountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the original model being copied.
        /// This member is required.
        public var sourceModelArn: Swift.String?
        /// The name of the original model being copied.
        public var sourceModelName: Swift.String?
        /// The status of the model copy job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelCopyJobStatus?
        /// The Amazon Resource Name (ARN) of the copied model.
        /// This member is required.
        public var targetModelArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the copied model.
        public var targetModelKmsKeyArn: Swift.String?
        /// The name of the copied model.
        public var targetModelName: Swift.String?
        /// Tags associated with the copied model.
        public var targetModelTags: [BedrockClientTypes.Tag]?

        public init(
            creationTime: Foundation.Date? = nil,
            failureMessage: Swift.String? = nil,
            jobArn: Swift.String? = nil,
            sourceAccountId: Swift.String? = nil,
            sourceModelArn: Swift.String? = nil,
            sourceModelName: Swift.String? = nil,
            status: BedrockClientTypes.ModelCopyJobStatus? = nil,
            targetModelArn: Swift.String? = nil,
            targetModelKmsKeyArn: Swift.String? = nil,
            targetModelName: Swift.String? = nil,
            targetModelTags: [BedrockClientTypes.Tag]? = nil
        ) {
            self.creationTime = creationTime
            self.failureMessage = failureMessage
            self.jobArn = jobArn
            self.sourceAccountId = sourceAccountId
            self.sourceModelArn = sourceModelArn
            self.sourceModelName = sourceModelName
            self.status = status
            self.targetModelArn = targetModelArn
            self.targetModelKmsKeyArn = targetModelKmsKeyArn
            self.targetModelName = targetModelName
            self.targetModelTags = targetModelTags
        }
    }
}

public struct ListModelCopyJobsOutput: Swift.Sendable {
    /// A list of information about each model copy job.
    public var modelCopyJobSummaries: [BedrockClientTypes.ModelCopyJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelCopyJobSummaries: [BedrockClientTypes.ModelCopyJobSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.modelCopyJobSummaries = modelCopyJobSummaries
        self.nextToken = nextToken
    }
}

public struct CreateModelImportJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The imported model is encrypted at rest using this key.
    public var importedModelKmsKeyId: Swift.String?
    /// The name of the imported model.
    /// This member is required.
    public var importedModelName: Swift.String?
    /// Tags to attach to the imported model.
    public var importedModelTags: [BedrockClientTypes.Tag]?
    /// The name of the import job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to this import job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// The data source for the imported model.
    /// This member is required.
    public var modelDataSource: BedrockClientTypes.ModelDataSource?
    /// The Amazon Resource Name (ARN) of the model import job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// VPC configuration parameters for the private Virtual Private Cloud (VPC) that contains the resources you are using for the import job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        importedModelKmsKeyId: Swift.String? = nil,
        importedModelName: Swift.String? = nil,
        importedModelTags: [BedrockClientTypes.Tag]? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        modelDataSource: BedrockClientTypes.ModelDataSource? = nil,
        roleArn: Swift.String? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.importedModelKmsKeyId = importedModelKmsKeyId
        self.importedModelName = importedModelName
        self.importedModelTags = importedModelTags
        self.jobName = jobName
        self.jobTags = jobTags
        self.modelDataSource = modelDataSource
        self.roleArn = roleArn
        self.vpcConfig = vpcConfig
    }
}

public struct CreateModelImportJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the model import job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    ) {
        self.jobArn = jobArn
    }
}

public struct DeleteImportedModelInput: Swift.Sendable {
    /// Name of the imported model to delete.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    ) {
        self.modelIdentifier = modelIdentifier
    }
}

public struct DeleteImportedModelOutput: Swift.Sendable {

    public init() { }
}

public struct GetImportedModelInput: Swift.Sendable {
    /// Name or Amazon Resource Name (ARN) of the imported model.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    ) {
        self.modelIdentifier = modelIdentifier
    }
}

extension BedrockClientTypes {

    /// A CustomModelUnit (CMU) is an abstract view of the hardware utilization that Amazon Bedrock needs to host a single copy of your custom model. A model copy represents a single instance of your imported model that is ready to serve inference requests. Amazon Bedrock determines the number of custom model units that a model copy needs when you import the custom model. You can use CustomModelUnits to estimate the cost of running your custom model. For more information, see Calculate the cost of running a custom model in the Amazon Bedrock user guide.
    public struct CustomModelUnits: Swift.Sendable {
        /// The number of custom model units used to host a model copy.
        public var customModelUnitsPerModelCopy: Swift.Int?
        /// The version of the custom model unit. Use to determine the billing rate for the custom model unit.
        public var customModelUnitsVersion: Swift.String?

        public init(
            customModelUnitsPerModelCopy: Swift.Int? = nil,
            customModelUnitsVersion: Swift.String? = nil
        ) {
            self.customModelUnitsPerModelCopy = customModelUnitsPerModelCopy
            self.customModelUnitsVersion = customModelUnitsVersion
        }
    }
}

public struct GetImportedModelOutput: Swift.Sendable {
    /// Creation time of the imported model.
    public var creationTime: Foundation.Date?
    /// Information about the hardware utilization for a single copy of the model.
    public var customModelUnits: BedrockClientTypes.CustomModelUnits?
    /// Specifies if the imported model supports converse.
    public var instructSupported: Swift.Bool?
    /// Job Amazon Resource Name (ARN) associated with the imported model.
    public var jobArn: Swift.String?
    /// Job name associated with the imported model.
    public var jobName: Swift.String?
    /// The architecture of the imported model.
    public var modelArchitecture: Swift.String?
    /// The Amazon Resource Name (ARN) associated with this imported model.
    public var modelArn: Swift.String?
    /// The data source for this imported model.
    public var modelDataSource: BedrockClientTypes.ModelDataSource?
    /// The imported model is encrypted at rest using this key.
    public var modelKmsKeyArn: Swift.String?
    /// The name of the imported model.
    public var modelName: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        customModelUnits: BedrockClientTypes.CustomModelUnits? = nil,
        instructSupported: Swift.Bool? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        modelArchitecture: Swift.String? = nil,
        modelArn: Swift.String? = nil,
        modelDataSource: BedrockClientTypes.ModelDataSource? = nil,
        modelKmsKeyArn: Swift.String? = nil,
        modelName: Swift.String? = nil
    ) {
        self.creationTime = creationTime
        self.customModelUnits = customModelUnits
        self.instructSupported = instructSupported
        self.jobArn = jobArn
        self.jobName = jobName
        self.modelArchitecture = modelArchitecture
        self.modelArn = modelArn
        self.modelDataSource = modelDataSource
        self.modelKmsKeyArn = modelKmsKeyArn
        self.modelName = modelName
    }
}

public struct GetModelImportJobInput: Swift.Sendable {
    /// The identifier of the import job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    ) {
        self.jobIdentifier = jobIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelImportJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelImportJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelImportJobOutput: Swift.Sendable {
    /// The time the resource was created.
    public var creationTime: Foundation.Date?
    /// Time that the resource transitioned to terminal state.
    public var endTime: Foundation.Date?
    /// Information about why the import job failed.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the imported model.
    public var importedModelArn: Swift.String?
    /// The imported model is encrypted at rest using this key.
    public var importedModelKmsKeyArn: Swift.String?
    /// The name of the imported model.
    public var importedModelName: Swift.String?
    /// The Amazon Resource Name (ARN) of the import job.
    public var jobArn: Swift.String?
    /// The name of the import job.
    public var jobName: Swift.String?
    /// Time the resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// The data source for the imported model.
    public var modelDataSource: BedrockClientTypes.ModelDataSource?
    /// The Amazon Resource Name (ARN) of the IAM role associated with this job.
    public var roleArn: Swift.String?
    /// The status of the job. A successful job transitions from in-progress to completed when the imported model is ready to use. If the job failed, the failure message contains information about why the job failed.
    public var status: BedrockClientTypes.ModelImportJobStatus?
    /// The Virtual Private Cloud (VPC) configuration of the import model job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        creationTime: Foundation.Date? = nil,
        endTime: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        importedModelArn: Swift.String? = nil,
        importedModelKmsKeyArn: Swift.String? = nil,
        importedModelName: Swift.String? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        modelDataSource: BedrockClientTypes.ModelDataSource? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelImportJobStatus? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    ) {
        self.creationTime = creationTime
        self.endTime = endTime
        self.failureMessage = failureMessage
        self.importedModelArn = importedModelArn
        self.importedModelKmsKeyArn = importedModelKmsKeyArn
        self.importedModelName = importedModelName
        self.jobArn = jobArn
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.modelDataSource = modelDataSource
        self.roleArn = roleArn
        self.status = status
        self.vpcConfig = vpcConfig
    }
}

public struct ListImportedModelsInput: Swift.Sendable {
    /// Return imported models that were created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return imported models that created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return imported models only if the model name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of imported models.
    public var sortBy: BedrockClientTypes.SortModelsBy?
    /// Specifies whetehr to sort the results in ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortModelsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil
    ) {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension BedrockClientTypes {

    /// Information about the imported model.
    public struct ImportedModelSummary: Swift.Sendable {
        /// Creation time of the imported model.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Specifies if the imported model supports converse.
        public var instructSupported: Swift.Bool?
        /// The architecture of the imported model.
        public var modelArchitecture: Swift.String?
        /// The Amazon Resource Name (ARN) of the imported model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Name of the imported model.
        /// This member is required.
        public var modelName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            instructSupported: Swift.Bool? = nil,
            modelArchitecture: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            modelName: Swift.String? = nil
        ) {
            self.creationTime = creationTime
            self.instructSupported = instructSupported
            self.modelArchitecture = modelArchitecture
            self.modelArn = modelArn
            self.modelName = modelName
        }
    }
}

public struct ListImportedModelsOutput: Swift.Sendable {
    /// Model summaries.
    public var modelSummaries: [BedrockClientTypes.ImportedModelSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelSummaries: [BedrockClientTypes.ImportedModelSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.modelSummaries = modelSummaries
        self.nextToken = nextToken
    }
}

public struct ListModelImportJobsInput: Swift.Sendable {
    /// Return import jobs that were created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return import jobs that were created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return imported jobs only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of imported jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the results in ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Return imported jobs with the specified status.
    public var statusEquals: BedrockClientTypes.ModelImportJobStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ModelImportJobStatus? = nil
    ) {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {

    /// Information about the import job.
    public struct ModelImportJobSummary: Swift.Sendable {
        /// The time import job was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The time when import job ended.
        public var endTime: Foundation.Date?
        /// The Amazon resource Name (ARN) of the imported model.
        public var importedModelArn: Swift.String?
        /// The name of the imported model.
        public var importedModelName: Swift.String?
        /// The Amazon Resource Name (ARN) of the import job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The name of the import job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The time when the import job was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// The status of the imported job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelImportJobStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            endTime: Foundation.Date? = nil,
            importedModelArn: Swift.String? = nil,
            importedModelName: Swift.String? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: BedrockClientTypes.ModelImportJobStatus? = nil
        ) {
            self.creationTime = creationTime
            self.endTime = endTime
            self.importedModelArn = importedModelArn
            self.importedModelName = importedModelName
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }
}

public struct ListModelImportJobsOutput: Swift.Sendable {
    /// Import job summaries.
    public var modelImportJobSummaries: [BedrockClientTypes.ModelImportJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelImportJobSummaries: [BedrockClientTypes.ModelImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.modelImportJobSummaries = modelImportJobSummaries
        self.nextToken = nextToken
    }
}

extension BedrockClientTypes {

    public enum S3InputFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jsonl
        case sdkUnknown(Swift.String)

        public static var allCases: [S3InputFormat] {
            return [
                .jsonl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jsonl: return "JSONL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Contains the configuration of the S3 location of the input data.
    public struct ModelInvocationJobS3InputDataConfig: Swift.Sendable {
        /// The ID of the Amazon Web Services account that owns the S3 bucket containing the input data.
        public var s3BucketOwner: Swift.String?
        /// The format of the input data.
        public var s3InputFormat: BedrockClientTypes.S3InputFormat?
        /// The S3 location of the input data.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3BucketOwner: Swift.String? = nil,
            s3InputFormat: BedrockClientTypes.S3InputFormat? = nil,
            s3Uri: Swift.String? = nil
        ) {
            self.s3BucketOwner = s3BucketOwner
            self.s3InputFormat = s3InputFormat
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// Details about the location of the input to the batch inference job.
    public enum ModelInvocationJobInputDataConfig: Swift.Sendable {
        /// Contains the configuration of the S3 location of the input data.
        case s3inputdataconfig(BedrockClientTypes.ModelInvocationJobS3InputDataConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Contains the configuration of the S3 location of the output data.
    public struct ModelInvocationJobS3OutputDataConfig: Swift.Sendable {
        /// The ID of the Amazon Web Services account that owns the S3 bucket containing the output data.
        public var s3BucketOwner: Swift.String?
        /// The unique identifier of the key that encrypts the S3 location of the output data.
        public var s3EncryptionKeyId: Swift.String?
        /// The S3 location of the output data.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3BucketOwner: Swift.String? = nil,
            s3EncryptionKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        ) {
            self.s3BucketOwner = s3BucketOwner
            self.s3EncryptionKeyId = s3EncryptionKeyId
            self.s3Uri = s3Uri
        }
    }
}

extension BedrockClientTypes {

    /// Contains the configuration of the S3 location of the output data.
    public enum ModelInvocationJobOutputDataConfig: Swift.Sendable {
        /// Contains the configuration of the S3 location of the output data.
        case s3outputdataconfig(BedrockClientTypes.ModelInvocationJobS3OutputDataConfig)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateModelInvocationJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// Details about the location of the input to the batch inference job.
    /// This member is required.
    public var inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig?
    /// A name to give the batch inference job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The unique identifier of the foundation model to use for the batch inference job.
    /// This member is required.
    public var modelId: Swift.String?
    /// Details about the location of the output of the batch inference job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at [Create a service role for batch inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
    /// This member is required.
    public var roleArn: Swift.String?
    /// Any tags to associate with the batch inference job. For more information, see [Tagging Amazon Bedrock resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html).
    public var tags: [BedrockClientTypes.Tag]?
    /// The number of hours after which to force the batch inference job to time out.
    public var timeoutDurationInHours: Swift.Int?
    /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see [Protect batch inference jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-vpc).
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig? = nil,
        jobName: Swift.String? = nil,
        modelId: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil,
        timeoutDurationInHours: Swift.Int? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.modelId = modelId
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.tags = tags
        self.timeoutDurationInHours = timeoutDurationInHours
        self.vpcConfig = vpcConfig
    }
}

public struct CreateModelInvocationJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the batch inference job.
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    ) {
        self.jobArn = jobArn
    }
}

public struct GetModelInvocationJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the batch inference job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    ) {
        self.jobIdentifier = jobIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelInvocationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case expired
        case failed
        case inProgress
        case partiallyCompleted
        case scheduled
        case stopped
        case stopping
        case submitted
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelInvocationJobStatus] {
            return [
                .completed,
                .expired,
                .failed,
                .inProgress,
                .partiallyCompleted,
                .scheduled,
                .stopped,
                .stopping,
                .submitted,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .expired: return "Expired"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .partiallyCompleted: return "PartiallyCompleted"
            case .scheduled: return "Scheduled"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case .submitted: return "Submitted"
            case .validating: return "Validating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetModelInvocationJobOutput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The time at which the batch inference job ended.
    public var endTime: Foundation.Date?
    /// Details about the location of the input to the batch inference job.
    /// This member is required.
    public var inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig?
    /// The Amazon Resource Name (ARN) of the batch inference job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The time at which the batch inference job times or timed out.
    public var jobExpirationTime: Foundation.Date?
    /// The name of the batch inference job.
    public var jobName: Swift.String?
    /// The time at which the batch inference job was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// If the batch inference job failed, this field contains a message describing why the job failed.
    public var message: Swift.String?
    /// The unique identifier of the foundation model used for model inference.
    /// This member is required.
    public var modelId: Swift.String?
    /// Details about the location of the output of the batch inference job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at [Create a service role for batch inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the batch inference job. The following statuses are possible:
    ///
    /// * Submitted â€“ This job has been submitted to a queue for validation.
    ///
    /// * Validating â€“ This job is being validated for the requirements described in [Format and upload your batch inference data](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-data.html). The criteria include the following:
    ///
    /// * Your IAM service role has access to the Amazon S3 buckets containing your files.
    ///
    /// * Your files are .jsonl files and each individual record is a JSON object in the correct format. Note that validation doesn't check if the modelInput value matches the request body for the model.
    ///
    /// * Your files fulfill the requirements for file size and number of records. For more information, see [Quotas for Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html).
    ///
    ///
    ///
    ///
    /// * Scheduled â€“ This job has been validated and is now in a queue. The job will automatically start when it reaches its turn.
    ///
    /// * Expired â€“ This job timed out because it was scheduled but didn't begin before the set timeout duration. Submit a new job request.
    ///
    /// * InProgress â€“ This job has begun. You can start viewing the results in the output S3 location.
    ///
    /// * Completed â€“ This job has successfully completed. View the output files in the output S3 location.
    ///
    /// * PartiallyCompleted â€“ This job has partially completed. Not all of your records could be processed in time. View the output files in the output S3 location.
    ///
    /// * Failed â€“ This job has failed. Check the failure message for any further details. For further assistance, reach out to the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home/).
    ///
    /// * Stopped â€“ This job was stopped by a user.
    ///
    /// * Stopping â€“ This job is being stopped by a user.
    public var status: BedrockClientTypes.ModelInvocationJobStatus?
    /// The time at which the batch inference job was submitted.
    /// This member is required.
    public var submitTime: Foundation.Date?
    /// The number of hours after which batch inference job was set to time out.
    public var timeoutDurationInHours: Swift.Int?
    /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see [Protect batch inference jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-vpc).
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig? = nil,
        jobArn: Swift.String? = nil,
        jobExpirationTime: Foundation.Date? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        modelId: Swift.String? = nil,
        outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelInvocationJobStatus? = nil,
        submitTime: Foundation.Date? = nil,
        timeoutDurationInHours: Swift.Int? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobArn = jobArn
        self.jobExpirationTime = jobExpirationTime
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.message = message
        self.modelId = modelId
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.status = status
        self.submitTime = submitTime
        self.timeoutDurationInHours = timeoutDurationInHours
        self.vpcConfig = vpcConfig
    }
}

extension GetModelInvocationJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetModelInvocationJobOutput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), endTime: \(Swift.String(describing: endTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobArn: \(Swift.String(describing: jobArn)), jobExpirationTime: \(Swift.String(describing: jobExpirationTime)), jobName: \(Swift.String(describing: jobName)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modelId: \(Swift.String(describing: modelId)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), submitTime: \(Swift.String(describing: submitTime)), timeoutDurationInHours: \(Swift.String(describing: timeoutDurationInHours)), vpcConfig: \(Swift.String(describing: vpcConfig)), message: \"CONTENT_REDACTED\")"}
}

public struct ListModelInvocationJobsInput: Swift.Sendable {
    /// The maximum number of results to return. If there are more results than the number that you specify, a nextToken value is returned. Use the nextToken in a request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Specify a string to filter for batch inference jobs whose names contain the string.
    public var nameContains: Swift.String?
    /// If there were more results than the value you specified in the maxResults field in a previous ListModelInvocationJobs request, the response would have returned a nextToken value. To see the next batch of results, send the nextToken value in another request.
    public var nextToken: Swift.String?
    /// An attribute by which to sort the results.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// Specifies whether to sort the results by ascending or descending order.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Specify a status to filter for batch inference jobs whose statuses match the string you specify. The following statuses are possible:
    ///
    /// * Submitted â€“ This job has been submitted to a queue for validation.
    ///
    /// * Validating â€“ This job is being validated for the requirements described in [Format and upload your batch inference data](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-data.html). The criteria include the following:
    ///
    /// * Your IAM service role has access to the Amazon S3 buckets containing your files.
    ///
    /// * Your files are .jsonl files and each individual record is a JSON object in the correct format. Note that validation doesn't check if the modelInput value matches the request body for the model.
    ///
    /// * Your files fulfill the requirements for file size and number of records. For more information, see [Quotas for Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html).
    ///
    ///
    ///
    ///
    /// * Scheduled â€“ This job has been validated and is now in a queue. The job will automatically start when it reaches its turn.
    ///
    /// * Expired â€“ This job timed out because it was scheduled but didn't begin before the set timeout duration. Submit a new job request.
    ///
    /// * InProgress â€“ This job has begun. You can start viewing the results in the output S3 location.
    ///
    /// * Completed â€“ This job has successfully completed. View the output files in the output S3 location.
    ///
    /// * PartiallyCompleted â€“ This job has partially completed. Not all of your records could be processed in time. View the output files in the output S3 location.
    ///
    /// * Failed â€“ This job has failed. Check the failure message for any further details. For further assistance, reach out to the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home/).
    ///
    /// * Stopped â€“ This job was stopped by a user.
    ///
    /// * Stopping â€“ This job is being stopped by a user.
    public var statusEquals: BedrockClientTypes.ModelInvocationJobStatus?
    /// Specify a time to filter for batch inference jobs that were submitted after the time you specify.
    public var submitTimeAfter: Foundation.Date?
    /// Specify a time to filter for batch inference jobs that were submitted before the time you specify.
    public var submitTimeBefore: Foundation.Date?

    public init(
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ModelInvocationJobStatus? = nil,
        submitTimeAfter: Foundation.Date? = nil,
        submitTimeBefore: Foundation.Date? = nil
    ) {
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
        self.submitTimeAfter = submitTimeAfter
        self.submitTimeBefore = submitTimeBefore
    }
}

extension BedrockClientTypes {

    /// A summary of a batch inference job.
    public struct ModelInvocationJobSummary: Swift.Sendable {
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientRequestToken: Swift.String?
        /// The time at which the batch inference job ended.
        public var endTime: Foundation.Date?
        /// Details about the location of the input to the batch inference job.
        /// This member is required.
        public var inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig?
        /// The Amazon Resource Name (ARN) of the batch inference job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// The time at which the batch inference job times or timed out.
        public var jobExpirationTime: Foundation.Date?
        /// The name of the batch inference job.
        /// This member is required.
        public var jobName: Swift.String?
        /// The time at which the batch inference job was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// If the batch inference job failed, this field contains a message describing why the job failed.
        public var message: Swift.String?
        /// The unique identifier of the foundation model used for model inference.
        /// This member is required.
        public var modelId: Swift.String?
        /// Details about the location of the output of the batch inference job.
        /// This member is required.
        public var outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig?
        /// The Amazon Resource Name (ARN) of the service role with permissions to carry out and manage batch inference. You can use the console to create a default service role or follow the steps at [Create a service role for batch inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the batch inference job. The following statuses are possible:
        ///
        /// * Submitted â€“ This job has been submitted to a queue for validation.
        ///
        /// * Validating â€“ This job is being validated for the requirements described in [Format and upload your batch inference data](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-data.html). The criteria include the following:
        ///
        /// * Your IAM service role has access to the Amazon S3 buckets containing your files.
        ///
        /// * Your files are .jsonl files and each individual record is a JSON object in the correct format. Note that validation doesn't check if the modelInput value matches the request body for the model.
        ///
        /// * Your files fulfill the requirements for file size and number of records. For more information, see [Quotas for Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html).
        ///
        ///
        ///
        ///
        /// * Scheduled â€“ This job has been validated and is now in a queue. The job will automatically start when it reaches its turn.
        ///
        /// * Expired â€“ This job timed out because it was scheduled but didn't begin before the set timeout duration. Submit a new job request.
        ///
        /// * InProgress â€“ This job has begun. You can start viewing the results in the output S3 location.
        ///
        /// * Completed â€“ This job has successfully completed. View the output files in the output S3 location.
        ///
        /// * PartiallyCompleted â€“ This job has partially completed. Not all of your records could be processed in time. View the output files in the output S3 location.
        ///
        /// * Failed â€“ This job has failed. Check the failure message for any further details. For further assistance, reach out to the [Amazon Web Services Support Center](https://console.aws.amazon.com/support/home/).
        ///
        /// * Stopped â€“ This job was stopped by a user.
        ///
        /// * Stopping â€“ This job is being stopped by a user.
        public var status: BedrockClientTypes.ModelInvocationJobStatus?
        /// The time at which the batch inference job was submitted.
        /// This member is required.
        public var submitTime: Foundation.Date?
        /// The number of hours after which the batch inference job was set to time out.
        public var timeoutDurationInHours: Swift.Int?
        /// The configuration of the Virtual Private Cloud (VPC) for the data in the batch inference job. For more information, see [Protect batch inference jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-vpc).
        public var vpcConfig: BedrockClientTypes.VpcConfig?

        public init(
            clientRequestToken: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            inputDataConfig: BedrockClientTypes.ModelInvocationJobInputDataConfig? = nil,
            jobArn: Swift.String? = nil,
            jobExpirationTime: Foundation.Date? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            modelId: Swift.String? = nil,
            outputDataConfig: BedrockClientTypes.ModelInvocationJobOutputDataConfig? = nil,
            roleArn: Swift.String? = nil,
            status: BedrockClientTypes.ModelInvocationJobStatus? = nil,
            submitTime: Foundation.Date? = nil,
            timeoutDurationInHours: Swift.Int? = nil,
            vpcConfig: BedrockClientTypes.VpcConfig? = nil
        ) {
            self.clientRequestToken = clientRequestToken
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobArn = jobArn
            self.jobExpirationTime = jobExpirationTime
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.message = message
            self.modelId = modelId
            self.outputDataConfig = outputDataConfig
            self.roleArn = roleArn
            self.status = status
            self.submitTime = submitTime
            self.timeoutDurationInHours = timeoutDurationInHours
            self.vpcConfig = vpcConfig
        }
    }
}

extension BedrockClientTypes.ModelInvocationJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModelInvocationJobSummary(clientRequestToken: \(Swift.String(describing: clientRequestToken)), endTime: \(Swift.String(describing: endTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobArn: \(Swift.String(describing: jobArn)), jobExpirationTime: \(Swift.String(describing: jobExpirationTime)), jobName: \(Swift.String(describing: jobName)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), modelId: \(Swift.String(describing: modelId)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), submitTime: \(Swift.String(describing: submitTime)), timeoutDurationInHours: \(Swift.String(describing: timeoutDurationInHours)), vpcConfig: \(Swift.String(describing: vpcConfig)), message: \"CONTENT_REDACTED\")"}
}

public struct ListModelInvocationJobsOutput: Swift.Sendable {
    /// A list of items, each of which contains a summary about a batch inference job.
    public var invocationJobSummaries: [BedrockClientTypes.ModelInvocationJobSummary]?
    /// If there are more results than can fit in the response, a nextToken is returned. Use the nextToken in a request to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        invocationJobSummaries: [BedrockClientTypes.ModelInvocationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.invocationJobSummaries = invocationJobSummaries
        self.nextToken = nextToken
    }
}

public struct StopModelInvocationJobInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the batch inference job to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    ) {
        self.jobIdentifier = jobIdentifier
    }
}

public struct StopModelInvocationJobOutput: Swift.Sendable {

    public init() { }
}

public struct GetFoundationModelInput: Swift.Sendable {
    /// The model identifier.
    /// This member is required.
    public var modelIdentifier: Swift.String?

    public init(
        modelIdentifier: Swift.String? = nil
    ) {
        self.modelIdentifier = modelIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelCustomization: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuedPreTraining
        case distillation
        case fineTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomization] {
            return [
                .continuedPreTraining,
                .distillation,
                .fineTuning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuedPreTraining: return "CONTINUED_PRE_TRAINING"
            case .distillation: return "DISTILLATION"
            case .fineTuning: return "FINE_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum InferenceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case onDemand
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [InferenceType] {
            return [
                .onDemand,
                .provisioned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .onDemand: return "ON_DEMAND"
            case .provisioned: return "PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum ModelModality: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case embedding
        case image
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelModality] {
            return [
                .embedding,
                .image,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .embedding: return "EMBEDDING"
            case .image: return "IMAGE"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum FoundationModelLifecycleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case legacy
        case sdkUnknown(Swift.String)

        public static var allCases: [FoundationModelLifecycleStatus] {
            return [
                .active,
                .legacy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .legacy: return "LEGACY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// Details about whether a model version is available or deprecated.
    public struct FoundationModelLifecycle: Swift.Sendable {
        /// Specifies whether a model version is available (ACTIVE) or deprecated (LEGACY.
        /// This member is required.
        public var status: BedrockClientTypes.FoundationModelLifecycleStatus?

        public init(
            status: BedrockClientTypes.FoundationModelLifecycleStatus? = nil
        ) {
            self.status = status
        }
    }
}

extension BedrockClientTypes {

    /// Information about a foundation model.
    public struct FoundationModelDetails: Swift.Sendable {
        /// The customization that the model supports.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The model Amazon Resource Name (ARN).
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model identifier.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The model name.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// The model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        ) {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }
}

public struct GetFoundationModelOutput: Swift.Sendable {
    /// Information about the foundation model.
    public var modelDetails: BedrockClientTypes.FoundationModelDetails?

    public init(
        modelDetails: BedrockClientTypes.FoundationModelDetails? = nil
    ) {
        self.modelDetails = modelDetails
    }
}

public struct ListFoundationModelsInput: Swift.Sendable {
    /// Return models that support the customization type that you specify. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var byCustomizationType: BedrockClientTypes.ModelCustomization?
    /// Return models that support the inference type that you specify. For more information, see [Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    public var byInferenceType: BedrockClientTypes.InferenceType?
    /// Return models that support the output modality that you specify.
    public var byOutputModality: BedrockClientTypes.ModelModality?
    /// Return models belonging to the model provider that you specify.
    public var byProvider: Swift.String?

    public init(
        byCustomizationType: BedrockClientTypes.ModelCustomization? = nil,
        byInferenceType: BedrockClientTypes.InferenceType? = nil,
        byOutputModality: BedrockClientTypes.ModelModality? = nil,
        byProvider: Swift.String? = nil
    ) {
        self.byCustomizationType = byCustomizationType
        self.byInferenceType = byInferenceType
        self.byOutputModality = byOutputModality
        self.byProvider = byProvider
    }
}

extension BedrockClientTypes {

    /// Summary information for a foundation model.
    public struct FoundationModelSummary: Swift.Sendable {
        /// Whether the model supports fine-tuning or continual pre-training.
        public var customizationsSupported: [BedrockClientTypes.ModelCustomization]?
        /// The inference types that the model supports.
        public var inferenceTypesSupported: [BedrockClientTypes.InferenceType]?
        /// The input modalities that the model supports.
        public var inputModalities: [BedrockClientTypes.ModelModality]?
        /// The Amazon Resource Name (ARN) of the foundation model.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The model ID of the foundation model.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains details about whether a model version is available or deprecated.
        public var modelLifecycle: BedrockClientTypes.FoundationModelLifecycle?
        /// The name of the model.
        public var modelName: Swift.String?
        /// The output modalities that the model supports.
        public var outputModalities: [BedrockClientTypes.ModelModality]?
        /// The model's provider name.
        public var providerName: Swift.String?
        /// Indicates whether the model supports streaming.
        public var responseStreamingSupported: Swift.Bool?

        public init(
            customizationsSupported: [BedrockClientTypes.ModelCustomization]? = nil,
            inferenceTypesSupported: [BedrockClientTypes.InferenceType]? = nil,
            inputModalities: [BedrockClientTypes.ModelModality]? = nil,
            modelArn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelLifecycle: BedrockClientTypes.FoundationModelLifecycle? = nil,
            modelName: Swift.String? = nil,
            outputModalities: [BedrockClientTypes.ModelModality]? = nil,
            providerName: Swift.String? = nil,
            responseStreamingSupported: Swift.Bool? = nil
        ) {
            self.customizationsSupported = customizationsSupported
            self.inferenceTypesSupported = inferenceTypesSupported
            self.inputModalities = inputModalities
            self.modelArn = modelArn
            self.modelId = modelId
            self.modelLifecycle = modelLifecycle
            self.modelName = modelName
            self.outputModalities = outputModalities
            self.providerName = providerName
            self.responseStreamingSupported = responseStreamingSupported
        }
    }
}

public struct ListFoundationModelsOutput: Swift.Sendable {
    /// A list of Amazon Bedrock foundation models.
    public var modelSummaries: [BedrockClientTypes.FoundationModelSummary]?

    public init(
        modelSummaries: [BedrockClientTypes.FoundationModelSummary]? = nil
    ) {
        self.modelSummaries = modelSummaries
    }
}

extension BedrockClientTypes {

    /// The target model for a prompt router.
    public struct PromptRouterTargetModel: Swift.Sendable {
        /// The target model's ARN.
        /// This member is required.
        public var modelArn: Swift.String?

        public init(
            modelArn: Swift.String? = nil
        ) {
            self.modelArn = modelArn
        }
    }
}

extension BedrockClientTypes {

    /// Routing criteria for a prompt router.
    public struct RoutingCriteria: Swift.Sendable {
        /// The criteria's response quality difference.
        /// This member is required.
        public var responseQualityDifference: Swift.Double?

        public init(
            responseQualityDifference: Swift.Double? = nil
        ) {
            self.responseQualityDifference = responseQualityDifference
        }
    }
}

public struct CreatePromptRouterInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure idempotency of your requests. If not specified, the Amazon Web Services SDK automatically generates one for you.
    public var clientRequestToken: Swift.String?
    /// An optional description of the prompt router to help identify its purpose.
    public var description: Swift.String?
    /// The default model to use when the routing criteria is not met.
    /// This member is required.
    public var fallbackModel: BedrockClientTypes.PromptRouterTargetModel?
    /// A list of foundation models that the prompt router can route requests to. At least one model must be specified.
    /// This member is required.
    public var models: [BedrockClientTypes.PromptRouterTargetModel]?
    /// The name of the prompt router. The name must be unique within your Amazon Web Services account in the current region.
    /// This member is required.
    public var promptRouterName: Swift.String?
    /// The criteria, which is the response quality difference, used to determine how incoming requests are routed to different models.
    /// This member is required.
    public var routingCriteria: BedrockClientTypes.RoutingCriteria?
    /// An array of key-value pairs to apply to this resource as tags. You can use tags to categorize and manage your Amazon Web Services resources.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        fallbackModel: BedrockClientTypes.PromptRouterTargetModel? = nil,
        models: [BedrockClientTypes.PromptRouterTargetModel]? = nil,
        promptRouterName: Swift.String? = nil,
        routingCriteria: BedrockClientTypes.RoutingCriteria? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.fallbackModel = fallbackModel
        self.models = models
        self.promptRouterName = promptRouterName
        self.routingCriteria = routingCriteria
        self.tags = tags
    }
}

extension CreatePromptRouterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePromptRouterInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), fallbackModel: \(Swift.String(describing: fallbackModel)), models: \(Swift.String(describing: models)), promptRouterName: \(Swift.String(describing: promptRouterName)), routingCriteria: \(Swift.String(describing: routingCriteria)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

public struct CreatePromptRouterOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the prompt router.
    public var promptRouterArn: Swift.String?

    public init(
        promptRouterArn: Swift.String? = nil
    ) {
        self.promptRouterArn = promptRouterArn
    }
}

public struct DeletePromptRouterInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the prompt router to delete.
    /// This member is required.
    public var promptRouterArn: Swift.String?

    public init(
        promptRouterArn: Swift.String? = nil
    ) {
        self.promptRouterArn = promptRouterArn
    }
}

public struct DeletePromptRouterOutput: Swift.Sendable {

    public init() { }
}

public struct GetPromptRouterInput: Swift.Sendable {
    /// The prompt router's ARN
    /// This member is required.
    public var promptRouterArn: Swift.String?

    public init(
        promptRouterArn: Swift.String? = nil
    ) {
        self.promptRouterArn = promptRouterArn
    }
}

extension BedrockClientTypes {

    public enum PromptRouterStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptRouterStatus] {
            return [
                .available
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum PromptRouterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptRouterType] {
            return [
                .custom,
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "custom"
            case .default: return "default"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetPromptRouterOutput: Swift.Sendable {
    /// When the router was created.
    public var createdAt: Foundation.Date?
    /// The router's description.
    public var description: Swift.String?
    /// The router's fallback model.
    /// This member is required.
    public var fallbackModel: BedrockClientTypes.PromptRouterTargetModel?
    /// The router's models.
    /// This member is required.
    public var models: [BedrockClientTypes.PromptRouterTargetModel]?
    /// The prompt router's ARN
    /// This member is required.
    public var promptRouterArn: Swift.String?
    /// The router's name.
    /// This member is required.
    public var promptRouterName: Swift.String?
    /// The router's routing criteria.
    /// This member is required.
    public var routingCriteria: BedrockClientTypes.RoutingCriteria?
    /// The router's status.
    /// This member is required.
    public var status: BedrockClientTypes.PromptRouterStatus?
    /// The router's type.
    /// This member is required.
    public var type: BedrockClientTypes.PromptRouterType?
    /// When the router was updated.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        fallbackModel: BedrockClientTypes.PromptRouterTargetModel? = nil,
        models: [BedrockClientTypes.PromptRouterTargetModel]? = nil,
        promptRouterArn: Swift.String? = nil,
        promptRouterName: Swift.String? = nil,
        routingCriteria: BedrockClientTypes.RoutingCriteria? = nil,
        status: BedrockClientTypes.PromptRouterStatus? = nil,
        type: BedrockClientTypes.PromptRouterType? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.description = description
        self.fallbackModel = fallbackModel
        self.models = models
        self.promptRouterArn = promptRouterArn
        self.promptRouterName = promptRouterName
        self.routingCriteria = routingCriteria
        self.status = status
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension GetPromptRouterOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPromptRouterOutput(createdAt: \(Swift.String(describing: createdAt)), fallbackModel: \(Swift.String(describing: fallbackModel)), models: \(Swift.String(describing: models)), promptRouterArn: \(Swift.String(describing: promptRouterArn)), promptRouterName: \(Swift.String(describing: promptRouterName)), routingCriteria: \(Swift.String(describing: routingCriteria)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct ListPromptRoutersInput: Swift.Sendable {
    /// The maximum number of prompt routers to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The type of the prompt routers, such as whether it's default or custom.
    public var type: BedrockClientTypes.PromptRouterType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: BedrockClientTypes.PromptRouterType? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension BedrockClientTypes {

    /// Details about a prompt router.
    public struct PromptRouterSummary: Swift.Sendable {
        /// When the router was created.
        public var createdAt: Foundation.Date?
        /// The router's description.
        public var description: Swift.String?
        /// The router's fallback model.
        /// This member is required.
        public var fallbackModel: BedrockClientTypes.PromptRouterTargetModel?
        /// The router's models.
        /// This member is required.
        public var models: [BedrockClientTypes.PromptRouterTargetModel]?
        /// The router's ARN.
        /// This member is required.
        public var promptRouterArn: Swift.String?
        /// The router's name.
        /// This member is required.
        public var promptRouterName: Swift.String?
        /// The router's routing criteria.
        /// This member is required.
        public var routingCriteria: BedrockClientTypes.RoutingCriteria?
        /// The router's status.
        /// This member is required.
        public var status: BedrockClientTypes.PromptRouterStatus?
        /// The summary's type.
        /// This member is required.
        public var type: BedrockClientTypes.PromptRouterType?
        /// When the router was updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            fallbackModel: BedrockClientTypes.PromptRouterTargetModel? = nil,
            models: [BedrockClientTypes.PromptRouterTargetModel]? = nil,
            promptRouterArn: Swift.String? = nil,
            promptRouterName: Swift.String? = nil,
            routingCriteria: BedrockClientTypes.RoutingCriteria? = nil,
            status: BedrockClientTypes.PromptRouterStatus? = nil,
            type: BedrockClientTypes.PromptRouterType? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.createdAt = createdAt
            self.description = description
            self.fallbackModel = fallbackModel
            self.models = models
            self.promptRouterArn = promptRouterArn
            self.promptRouterName = promptRouterName
            self.routingCriteria = routingCriteria
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockClientTypes.PromptRouterSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromptRouterSummary(createdAt: \(Swift.String(describing: createdAt)), fallbackModel: \(Swift.String(describing: fallbackModel)), models: \(Swift.String(describing: models)), promptRouterArn: \(Swift.String(describing: promptRouterArn)), promptRouterName: \(Swift.String(describing: promptRouterName)), routingCriteria: \(Swift.String(describing: routingCriteria)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\")"}
}

public struct ListPromptRoutersOutput: Swift.Sendable {
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// A list of prompt router summaries.
    public var promptRouterSummaries: [BedrockClientTypes.PromptRouterSummary]?

    public init(
        nextToken: Swift.String? = nil,
        promptRouterSummaries: [BedrockClientTypes.PromptRouterSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.promptRouterSummaries = promptRouterSummaries
    }
}

extension BedrockClientTypes {

    public enum CommitmentDuration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneMonth
        case sixMonths
        case sdkUnknown(Swift.String)

        public static var allCases: [CommitmentDuration] {
            return [
                .oneMonth,
                .sixMonths
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneMonth: return "OneMonth"
            case .sixMonths: return "SixMonths"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProvisionedModelThroughputInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon S3 User Guide.
    public var clientRequestToken: Swift.String?
    /// The commitment duration requested for the Provisioned Throughput. Billing occurs hourly and is discounted for longer commitment terms. To request a no-commit Provisioned Throughput, omit this field. Custom models support all levels of commitment. To see which base models support no commitment, see [Supported regions and models for Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/pt-supported.html) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html)
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// The Amazon Resource Name (ARN) or name of the model to associate with this Provisioned Throughput. For a list of models for which you can purchase Provisioned Throughput, see [Amazon Bedrock model IDs for purchasing Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#prov-throughput-models) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html).
    /// This member is required.
    public var modelId: Swift.String?
    /// Number of model units to allocate. A model unit delivers a specific throughput level for the specified model. The throughput level of a model unit specifies the total number of input and output tokens that it can process and generate within a span of one minute. By default, your account has no model units for purchasing Provisioned Throughputs with commitment. You must first visit the [Amazon Web Services support center](https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase) to request MUs. For model unit quotas, see [Provisioned Throughput quotas](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html#prov-thru-quotas) in the [Amazon Bedrock User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-service.html). For more information about what an MU specifies, contact your Amazon Web Services account manager.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// The name for this Provisioned Throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// Tags to associate with this Provisioned Throughput.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        modelId: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelName: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.clientRequestToken = clientRequestToken
        self.commitmentDuration = commitmentDuration
        self.modelId = modelId
        self.modelUnits = modelUnits
        self.provisionedModelName = provisionedModelName
        self.tags = tags
    }
}

public struct CreateProvisionedModelThroughputOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for this Provisioned Throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?

    public init(
        provisionedModelArn: Swift.String? = nil
    ) {
        self.provisionedModelArn = provisionedModelArn
    }
}

public struct DeleteProvisionedModelThroughputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    ) {
        self.provisionedModelId = provisionedModelId
    }
}

public struct DeleteProvisionedModelThroughputOutput: Swift.Sendable {

    public init() { }
}

public struct GetProvisionedModelThroughputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        provisionedModelId: Swift.String? = nil
    ) {
        self.provisionedModelId = provisionedModelId
    }
}

extension BedrockClientTypes {

    public enum ProvisionedModelStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case failed
        case inService
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedModelStatus] {
            return [
                .creating,
                .failed,
                .inService,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "Creating"
            case .failed: return "Failed"
            case .inService: return "InService"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetProvisionedModelThroughputOutput: Swift.Sendable {
    /// Commitment duration of the Provisioned Throughput.
    public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
    /// The timestamp for when the commitment term for the Provisioned Throughput expires.
    public var commitmentExpirationTime: Foundation.Date?
    /// The timestamp of the creation time for this Provisioned Throughput.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
    /// This member is required.
    public var desiredModelArn: Swift.String?
    /// The number of model units that was requested for this Provisioned Throughput.
    /// This member is required.
    public var desiredModelUnits: Swift.Int?
    /// A failure message for any issues that occurred during creation, updating, or deletion of the Provisioned Throughput.
    public var failureMessage: Swift.String?
    /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
    /// This member is required.
    public var foundationModelArn: Swift.String?
    /// The timestamp of the last time that this Provisioned Throughput was modified.
    /// This member is required.
    public var lastModifiedTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the model associated with this Provisioned Throughput.
    /// This member is required.
    public var modelArn: Swift.String?
    /// The number of model units allocated to this Provisioned Throughput.
    /// This member is required.
    public var modelUnits: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelArn: Swift.String?
    /// The name of the Provisioned Throughput.
    /// This member is required.
    public var provisionedModelName: Swift.String?
    /// The status of the Provisioned Throughput.
    /// This member is required.
    public var status: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
        commitmentExpirationTime: Foundation.Date? = nil,
        creationTime: Foundation.Date? = nil,
        desiredModelArn: Swift.String? = nil,
        desiredModelUnits: Swift.Int? = nil,
        failureMessage: Swift.String? = nil,
        foundationModelArn: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        modelArn: Swift.String? = nil,
        modelUnits: Swift.Int? = nil,
        provisionedModelArn: Swift.String? = nil,
        provisionedModelName: Swift.String? = nil,
        status: BedrockClientTypes.ProvisionedModelStatus? = nil
    ) {
        self.commitmentDuration = commitmentDuration
        self.commitmentExpirationTime = commitmentExpirationTime
        self.creationTime = creationTime
        self.desiredModelArn = desiredModelArn
        self.desiredModelUnits = desiredModelUnits
        self.failureMessage = failureMessage
        self.foundationModelArn = foundationModelArn
        self.lastModifiedTime = lastModifiedTime
        self.modelArn = modelArn
        self.modelUnits = modelUnits
        self.provisionedModelArn = provisionedModelArn
        self.provisionedModelName = provisionedModelName
        self.status = status
    }
}

extension BedrockClientTypes {

    public enum SortByProvisionedModels: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationTime
        case sdkUnknown(Swift.String)

        public static var allCases: [SortByProvisionedModels] {
            return [
                .creationTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationTime: return "CreationTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListProvisionedModelThroughputsInput: Swift.Sendable {
    /// A filter that returns Provisioned Throughputs created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// A filter that returns Provisioned Throughputs created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// THe maximum number of results to return in the response. If there are more results than the number you specified, the response returns a nextToken value. To see the next batch of results, send the nextToken value in another list request.
    public var maxResults: Swift.Int?
    /// A filter that returns Provisioned Throughputs whose model Amazon Resource Name (ARN) is equal to the value that you specify.
    public var modelArnEquals: Swift.String?
    /// A filter that returns Provisioned Throughputs if their name contains the expression that you specify.
    public var nameContains: Swift.String?
    /// If there are more results than the number you specified in the maxResults field, the response returns a nextToken value. To see the next batch of results, specify the nextToken value in this field.
    public var nextToken: Swift.String?
    /// The field by which to sort the returned list of Provisioned Throughputs.
    public var sortBy: BedrockClientTypes.SortByProvisionedModels?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// A filter that returns Provisioned Throughputs if their statuses matches the value that you specify.
    public var statusEquals: BedrockClientTypes.ProvisionedModelStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        modelArnEquals: Swift.String? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortByProvisionedModels? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.ProvisionedModelStatus? = nil
    ) {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.modelArnEquals = modelArnEquals
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {

    /// A summary of information about a Provisioned Throughput. This data type is used in the following API operations:
    ///
    /// * [ListProvisionedThroughputs response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListProvisionedModelThroughputs.html#API_ListProvisionedModelThroughputs_ResponseSyntax)
    public struct ProvisionedModelSummary: Swift.Sendable {
        /// The duration for which the Provisioned Throughput was committed.
        public var commitmentDuration: BedrockClientTypes.CommitmentDuration?
        /// The timestamp for when the commitment term of the Provisioned Throughput expires.
        public var commitmentExpirationTime: Foundation.Date?
        /// The time that the Provisioned Throughput was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the model requested to be associated to this Provisioned Throughput. This value differs from the modelArn if updating hasn't completed.
        /// This member is required.
        public var desiredModelArn: Swift.String?
        /// The number of model units that was requested to be allocated to the Provisioned Throughput.
        /// This member is required.
        public var desiredModelUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the base model for which the Provisioned Throughput was created, or of the base model that the custom model for which the Provisioned Throughput was created was customized.
        /// This member is required.
        public var foundationModelArn: Swift.String?
        /// The time that the Provisioned Throughput was last modified.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the model associated with the Provisioned Throughput.
        /// This member is required.
        public var modelArn: Swift.String?
        /// The number of model units allocated to the Provisioned Throughput.
        /// This member is required.
        public var modelUnits: Swift.Int?
        /// The Amazon Resource Name (ARN) of the Provisioned Throughput.
        /// This member is required.
        public var provisionedModelArn: Swift.String?
        /// The name of the Provisioned Throughput.
        /// This member is required.
        public var provisionedModelName: Swift.String?
        /// The status of the Provisioned Throughput.
        /// This member is required.
        public var status: BedrockClientTypes.ProvisionedModelStatus?

        public init(
            commitmentDuration: BedrockClientTypes.CommitmentDuration? = nil,
            commitmentExpirationTime: Foundation.Date? = nil,
            creationTime: Foundation.Date? = nil,
            desiredModelArn: Swift.String? = nil,
            desiredModelUnits: Swift.Int? = nil,
            foundationModelArn: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            modelArn: Swift.String? = nil,
            modelUnits: Swift.Int? = nil,
            provisionedModelArn: Swift.String? = nil,
            provisionedModelName: Swift.String? = nil,
            status: BedrockClientTypes.ProvisionedModelStatus? = nil
        ) {
            self.commitmentDuration = commitmentDuration
            self.commitmentExpirationTime = commitmentExpirationTime
            self.creationTime = creationTime
            self.desiredModelArn = desiredModelArn
            self.desiredModelUnits = desiredModelUnits
            self.foundationModelArn = foundationModelArn
            self.lastModifiedTime = lastModifiedTime
            self.modelArn = modelArn
            self.modelUnits = modelUnits
            self.provisionedModelArn = provisionedModelArn
            self.provisionedModelName = provisionedModelName
            self.status = status
        }
    }
}

public struct ListProvisionedModelThroughputsOutput: Swift.Sendable {
    /// If there are more results than the number you specified in the maxResults field, this value is returned. To see the next batch of results, include this value in the nextToken field in another list request.
    public var nextToken: Swift.String?
    /// A list of summaries, one for each Provisioned Throughput in the response.
    public var provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]?

    public init(
        nextToken: Swift.String? = nil,
        provisionedModelSummaries: [BedrockClientTypes.ProvisionedModelSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.provisionedModelSummaries = provisionedModelSummaries
    }
}

public struct UpdateProvisionedModelThroughputInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new model to associate with this Provisioned Throughput. You can't specify this field if this Provisioned Throughput is associated with a base model. If this Provisioned Throughput is associated with a custom model, you can specify one of the following options:
    ///
    /// * The base model from which the custom model was customized.
    ///
    /// * Another custom model that was customized from the same base model as the custom model.
    public var desiredModelId: Swift.String?
    /// The new name for this Provisioned Throughput.
    public var desiredProvisionedModelName: Swift.String?
    /// The Amazon Resource Name (ARN) or name of the Provisioned Throughput to update.
    /// This member is required.
    public var provisionedModelId: Swift.String?

    public init(
        desiredModelId: Swift.String? = nil,
        desiredProvisionedModelName: Swift.String? = nil,
        provisionedModelId: Swift.String? = nil
    ) {
        self.desiredModelId = desiredModelId
        self.desiredProvisionedModelName = desiredProvisionedModelName
        self.provisionedModelId = provisionedModelId
    }
}

public struct UpdateProvisionedModelThroughputOutput: Swift.Sendable {

    public init() { }
}

public struct CreateFoundationModelAgreementInput: Swift.Sendable {
    /// Model Id of the model for the access request.
    /// This member is required.
    public var modelId: Swift.String?
    /// An offer token encapsulates the information for an offer.
    /// This member is required.
    public var offerToken: Swift.String?

    public init(
        modelId: Swift.String? = nil,
        offerToken: Swift.String? = nil
    ) {
        self.modelId = modelId
        self.offerToken = offerToken
    }
}

public struct CreateFoundationModelAgreementOutput: Swift.Sendable {
    /// Model Id of the model for the access request.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        modelId: Swift.String? = nil
    ) {
        self.modelId = modelId
    }
}

public struct DeleteFoundationModelAgreementInput: Swift.Sendable {
    /// Model Id of the model access to delete.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        modelId: Swift.String? = nil
    ) {
        self.modelId = modelId
    }
}

public struct DeleteFoundationModelAgreementOutput: Swift.Sendable {

    public init() { }
}

public struct GetFoundationModelAvailabilityInput: Swift.Sendable {
    /// The model Id of the foundation model.
    /// This member is required.
    public var modelId: Swift.String?

    public init(
        modelId: Swift.String? = nil
    ) {
        self.modelId = modelId
    }
}

extension BedrockClientTypes {

    public enum AuthorizationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authorized
        case notAuthorized
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizationStatus] {
            return [
                .authorized,
                .notAuthorized
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authorized: return "AUTHORIZED"
            case .notAuthorized: return "NOT_AUTHORIZED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum EntitlementAvailability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case notAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementAvailability] {
            return [
                .available,
                .notAvailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .notAvailable: return "NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum RegionAvailability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case notAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [RegionAvailability] {
            return [
                .available,
                .notAvailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .notAvailable: return "NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetFoundationModelAvailabilityOutput: Swift.Sendable {
    /// Agreement availability.
    /// This member is required.
    public var agreementAvailability: BedrockClientTypes.AgreementAvailability?
    /// Authorization status.
    /// This member is required.
    public var authorizationStatus: BedrockClientTypes.AuthorizationStatus?
    /// Entitlement availability.
    /// This member is required.
    public var entitlementAvailability: BedrockClientTypes.EntitlementAvailability?
    /// The model Id of the foundation model.
    /// This member is required.
    public var modelId: Swift.String?
    /// Region availability.
    /// This member is required.
    public var regionAvailability: BedrockClientTypes.RegionAvailability?

    public init(
        agreementAvailability: BedrockClientTypes.AgreementAvailability? = nil,
        authorizationStatus: BedrockClientTypes.AuthorizationStatus? = nil,
        entitlementAvailability: BedrockClientTypes.EntitlementAvailability? = nil,
        modelId: Swift.String? = nil,
        regionAvailability: BedrockClientTypes.RegionAvailability? = nil
    ) {
        self.agreementAvailability = agreementAvailability
        self.authorizationStatus = authorizationStatus
        self.entitlementAvailability = entitlementAvailability
        self.modelId = modelId
        self.regionAvailability = regionAvailability
    }
}

extension BedrockClientTypes {

    public enum OfferType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferType] {
            return [
                .all,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListFoundationModelAgreementOffersInput: Swift.Sendable {
    /// Model Id of the foundation model.
    /// This member is required.
    public var modelId: Swift.String?
    /// Type of offer associated with the model.
    public var offerType: BedrockClientTypes.OfferType?

    public init(
        modelId: Swift.String? = nil,
        offerType: BedrockClientTypes.OfferType? = nil
    ) {
        self.modelId = modelId
        self.offerType = offerType
    }
}

extension BedrockClientTypes {

    /// The legal term of the agreement.
    public struct LegalTerm: Swift.Sendable {
        /// URL to the legal term document.
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        ) {
            self.url = url
        }
    }
}

extension BedrockClientTypes {

    /// Describes a support term.
    public struct SupportTerm: Swift.Sendable {
        /// Describes the refund policy.
        public var refundPolicyDescription: Swift.String?

        public init(
            refundPolicyDescription: Swift.String? = nil
        ) {
            self.refundPolicyDescription = refundPolicyDescription
        }
    }
}

extension BedrockClientTypes {

    /// Dimensional price rate.
    public struct DimensionalPriceRate: Swift.Sendable {
        /// Description of the price rate.
        public var description: Swift.String?
        /// Dimension for the price rate.
        public var dimension: Swift.String?
        /// Single-dimensional rate information.
        public var price: Swift.String?
        /// Unit associated with the price.
        public var unit: Swift.String?

        public init(
            description: Swift.String? = nil,
            dimension: Swift.String? = nil,
            price: Swift.String? = nil,
            unit: Swift.String? = nil
        ) {
            self.description = description
            self.dimension = dimension
            self.price = price
            self.unit = unit
        }
    }
}

extension BedrockClientTypes {

    /// Describes the usage-based pricing term.
    public struct PricingTerm: Swift.Sendable {
        /// Describes a usage price for each dimension.
        /// This member is required.
        public var rateCard: [BedrockClientTypes.DimensionalPriceRate]?

        public init(
            rateCard: [BedrockClientTypes.DimensionalPriceRate]? = nil
        ) {
            self.rateCard = rateCard
        }
    }
}

extension BedrockClientTypes {

    /// Describes the validity terms.
    public struct ValidityTerm: Swift.Sendable {
        /// Describes the agreement duration.
        public var agreementDuration: Swift.String?

        public init(
            agreementDuration: Swift.String? = nil
        ) {
            self.agreementDuration = agreementDuration
        }
    }
}

extension BedrockClientTypes {

    /// Describes the usage terms of an offer.
    public struct TermDetails: Swift.Sendable {
        /// Describes the legal terms.
        /// This member is required.
        public var legalTerm: BedrockClientTypes.LegalTerm?
        /// Describes the support terms.
        /// This member is required.
        public var supportTerm: BedrockClientTypes.SupportTerm?
        /// Describes the usage-based pricing term.
        /// This member is required.
        public var usageBasedPricingTerm: BedrockClientTypes.PricingTerm?
        /// Describes the validity terms.
        public var validityTerm: BedrockClientTypes.ValidityTerm?

        public init(
            legalTerm: BedrockClientTypes.LegalTerm? = nil,
            supportTerm: BedrockClientTypes.SupportTerm? = nil,
            usageBasedPricingTerm: BedrockClientTypes.PricingTerm? = nil,
            validityTerm: BedrockClientTypes.ValidityTerm? = nil
        ) {
            self.legalTerm = legalTerm
            self.supportTerm = supportTerm
            self.usageBasedPricingTerm = usageBasedPricingTerm
            self.validityTerm = validityTerm
        }
    }
}

extension BedrockClientTypes {

    /// An offer dictates usage terms for the model.
    public struct Offer: Swift.Sendable {
        /// Offer Id for a model offer.
        public var offerId: Swift.String?
        /// Offer token.
        /// This member is required.
        public var offerToken: Swift.String?
        /// Details about the terms of the offer.
        /// This member is required.
        public var termDetails: BedrockClientTypes.TermDetails?

        public init(
            offerId: Swift.String? = nil,
            offerToken: Swift.String? = nil,
            termDetails: BedrockClientTypes.TermDetails? = nil
        ) {
            self.offerId = offerId
            self.offerToken = offerToken
            self.termDetails = termDetails
        }
    }
}

public struct ListFoundationModelAgreementOffersOutput: Swift.Sendable {
    /// Model Id of the foundation model.
    /// This member is required.
    public var modelId: Swift.String?
    /// List of the offers associated with the specified model.
    /// This member is required.
    public var offers: [BedrockClientTypes.Offer]?

    public init(
        modelId: Swift.String? = nil,
        offers: [BedrockClientTypes.Offer]? = nil
    ) {
        self.modelId = modelId
        self.offers = offers
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    ) {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// An array of the tags associated with this resource.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        tags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tags to associate with the resource.
    /// This member is required.
    public var tags: [BedrockClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BedrockClientTypes.Tag]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to untag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Tag keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct CreateModelCustomizationJobInput: Swift.Sendable {
    /// Name of the base model.
    /// This member is required.
    public var baseModelIdentifier: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var customModelKmsKeyId: Swift.String?
    /// A name for the resulting custom model.
    /// This member is required.
    public var customModelName: Swift.String?
    /// Tags to attach to the resulting custom model.
    public var customModelTags: [BedrockClientTypes.Tag]?
    /// The customization configuration for the model customization job.
    public var customizationConfig: BedrockClientTypes.CustomizationConfig?
    /// The customization type.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Parameters related to tuning the model. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    public var hyperParameters: [Swift.String: Swift.String]?
    /// A name for the fine-tuning job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to the job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// S3 location for the output data.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can assume to perform tasks on your behalf. For example, during model training, Amazon Bedrock needs your permission to read input data from an S3 bucket, write model artifacts to an S3 bucket. To pass this role to Amazon Bedrock, the caller of this API must have the iam:PassRole permission.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Information about the validation dataset.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The configuration of the Virtual Private Cloud (VPC) that contains the resources that you're using for this job. For more information, see [Protect your model customization jobs using a VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/vpc-model-customization.html).
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelIdentifier: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        customModelKmsKeyId: Swift.String? = nil,
        customModelName: Swift.String? = nil,
        customModelTags: [BedrockClientTypes.Tag]? = nil,
        customizationConfig: BedrockClientTypes.CustomizationConfig? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    ) {
        self.baseModelIdentifier = baseModelIdentifier
        self.clientRequestToken = clientRequestToken
        self.customModelKmsKeyId = customModelKmsKeyId
        self.customModelName = customModelName
        self.customModelTags = customModelTags
        self.customizationConfig = customizationConfig
        self.customizationType = customizationType
        self.hyperParameters = hyperParameters
        self.jobName = jobName
        self.jobTags = jobTags
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.trainingDataConfig = trainingDataConfig
        self.validationDataConfig = validationDataConfig
        self.vpcConfig = vpcConfig
    }
}

public struct CreateModelCustomizationJobOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the fine tuning job
    /// This member is required.
    public var jobArn: Swift.String?

    public init(
        jobArn: Swift.String? = nil
    ) {
        self.jobArn = jobArn
    }
}

public struct GetModelCustomizationJobInput: Swift.Sendable {
    /// Identifier for the customization job.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    ) {
        self.jobIdentifier = jobIdentifier
    }
}

extension BedrockClientTypes {

    public enum ModelCustomizationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelCustomizationJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    public enum JobStatusDetails: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case notStarted
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatusDetails] {
            return [
                .completed,
                .failed,
                .inProgress,
                .notStarted,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .notStarted: return "NotStarted"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockClientTypes {

    /// For a Distillation job, the status details for the data processing sub-task of the job.
    public struct DataProcessingDetails: Swift.Sendable {
        /// The start time of the data processing sub-task of the job.
        public var creationTime: Foundation.Date?
        /// The latest update to the data processing sub-task of the job.
        public var lastModifiedTime: Foundation.Date?
        /// The status of the data processing sub-task of the job.
        public var status: BedrockClientTypes.JobStatusDetails?

        public init(
            creationTime: Foundation.Date? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: BedrockClientTypes.JobStatusDetails? = nil
        ) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }
}

extension BedrockClientTypes {

    /// For a Distillation job, the status details for the training sub-task of the job.
    public struct TrainingDetails: Swift.Sendable {
        /// The start time of the training sub-task of the job.
        public var creationTime: Foundation.Date?
        /// The latest update to the training sub-task of the job.
        public var lastModifiedTime: Foundation.Date?
        /// The status of the training sub-task of the job.
        public var status: BedrockClientTypes.JobStatusDetails?

        public init(
            creationTime: Foundation.Date? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: BedrockClientTypes.JobStatusDetails? = nil
        ) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }
}

extension BedrockClientTypes {

    /// For a Distillation job, the status details for the validation sub-task of the job.
    public struct ValidationDetails: Swift.Sendable {
        /// The start time of the validation sub-task of the job.
        public var creationTime: Foundation.Date?
        /// The latest update to the validation sub-task of the job.
        public var lastModifiedTime: Foundation.Date?
        /// The status of the validation sub-task of the job.
        public var status: BedrockClientTypes.JobStatusDetails?

        public init(
            creationTime: Foundation.Date? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: BedrockClientTypes.JobStatusDetails? = nil
        ) {
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
            self.status = status
        }
    }
}

extension BedrockClientTypes {

    /// For a Distillation job, the status details for sub-tasks of the job. Possible statuses for each sub-task include the following:
    ///
    /// * NotStarted
    ///
    /// * InProgress
    ///
    /// * Completed
    ///
    /// * Stopping
    ///
    /// * Stopped
    ///
    /// * Failed
    public struct StatusDetails: Swift.Sendable {
        /// The status details for the data processing sub-task of the job.
        public var dataProcessingDetails: BedrockClientTypes.DataProcessingDetails?
        /// The status details for the training sub-task of the job.
        public var trainingDetails: BedrockClientTypes.TrainingDetails?
        /// The status details for the validation sub-task of the job.
        public var validationDetails: BedrockClientTypes.ValidationDetails?

        public init(
            dataProcessingDetails: BedrockClientTypes.DataProcessingDetails? = nil,
            trainingDetails: BedrockClientTypes.TrainingDetails? = nil,
            validationDetails: BedrockClientTypes.ValidationDetails? = nil
        ) {
            self.dataProcessingDetails = dataProcessingDetails
            self.trainingDetails = trainingDetails
            self.validationDetails = validationDetails
        }
    }
}

public struct GetModelCustomizationJobOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the base model.
    /// This member is required.
    public var baseModelArn: Swift.String?
    /// The token that you specified in the CreateCustomizationJob request.
    public var clientRequestToken: Swift.String?
    /// Time that the resource was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The customization configuration for the model customization job.
    public var customizationConfig: BedrockClientTypes.CustomizationConfig?
    /// The type of model customization.
    public var customizationType: BedrockClientTypes.CustomizationType?
    /// Time that the resource transitioned to terminal state.
    public var endTime: Foundation.Date?
    /// Information about why the job failed.
    public var failureMessage: Swift.String?
    /// The hyperparameter values for the job. For details on the format for different models, see [Custom model hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
    public var hyperParameters: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the customization job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The name of the customization job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Time that the resource was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// Output data configuration
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.OutputDataConfig?
    /// The Amazon Resource Name (ARN) of the output model.
    public var outputModelArn: Swift.String?
    /// The custom model is encrypted at rest using this key.
    public var outputModelKmsKeyArn: Swift.String?
    /// The name of the output model.
    /// This member is required.
    public var outputModelName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The status of the job. A successful job transitions from in-progress to completed when the output model is ready to use. If the job failed, the failure message contains information about why the job failed.
    public var status: BedrockClientTypes.ModelCustomizationJobStatus?
    /// For a Distillation job, the details about the statuses of the sub-tasks of the customization job.
    public var statusDetails: BedrockClientTypes.StatusDetails?
    /// Contains information about the training dataset.
    /// This member is required.
    public var trainingDataConfig: BedrockClientTypes.TrainingDataConfig?
    /// Contains training metrics from the job creation.
    public var trainingMetrics: BedrockClientTypes.TrainingMetrics?
    /// Contains information about the validation dataset.
    /// This member is required.
    public var validationDataConfig: BedrockClientTypes.ValidationDataConfig?
    /// The loss metric for each validator that you provided in the createjob request.
    public var validationMetrics: [BedrockClientTypes.ValidatorMetric]?
    /// VPC configuration for the custom model job.
    public var vpcConfig: BedrockClientTypes.VpcConfig?

    public init(
        baseModelArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        customizationConfig: BedrockClientTypes.CustomizationConfig? = nil,
        customizationType: BedrockClientTypes.CustomizationType? = nil,
        endTime: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        hyperParameters: [Swift.String: Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        outputDataConfig: BedrockClientTypes.OutputDataConfig? = nil,
        outputModelArn: Swift.String? = nil,
        outputModelKmsKeyArn: Swift.String? = nil,
        outputModelName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.ModelCustomizationJobStatus? = nil,
        statusDetails: BedrockClientTypes.StatusDetails? = nil,
        trainingDataConfig: BedrockClientTypes.TrainingDataConfig? = nil,
        trainingMetrics: BedrockClientTypes.TrainingMetrics? = nil,
        validationDataConfig: BedrockClientTypes.ValidationDataConfig? = nil,
        validationMetrics: [BedrockClientTypes.ValidatorMetric]? = nil,
        vpcConfig: BedrockClientTypes.VpcConfig? = nil
    ) {
        self.baseModelArn = baseModelArn
        self.clientRequestToken = clientRequestToken
        self.creationTime = creationTime
        self.customizationConfig = customizationConfig
        self.customizationType = customizationType
        self.endTime = endTime
        self.failureMessage = failureMessage
        self.hyperParameters = hyperParameters
        self.jobArn = jobArn
        self.jobName = jobName
        self.lastModifiedTime = lastModifiedTime
        self.outputDataConfig = outputDataConfig
        self.outputModelArn = outputModelArn
        self.outputModelKmsKeyArn = outputModelKmsKeyArn
        self.outputModelName = outputModelName
        self.roleArn = roleArn
        self.status = status
        self.statusDetails = statusDetails
        self.trainingDataConfig = trainingDataConfig
        self.trainingMetrics = trainingMetrics
        self.validationDataConfig = validationDataConfig
        self.validationMetrics = validationMetrics
        self.vpcConfig = vpcConfig
    }
}

extension BedrockClientTypes {

    public enum FineTuningJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [FineTuningJobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListModelCustomizationJobsInput: Swift.Sendable {
    /// Return customization jobs created after the specified time.
    public var creationTimeAfter: Foundation.Date?
    /// Return customization jobs created before the specified time.
    public var creationTimeBefore: Foundation.Date?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// Return customization jobs only if the job name contains these characters.
    public var nameContains: Swift.String?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The field to sort by in the returned list of jobs.
    public var sortBy: BedrockClientTypes.SortJobsBy?
    /// The sort order of the results.
    public var sortOrder: BedrockClientTypes.SortOrder?
    /// Return customization jobs with the specified status.
    public var statusEquals: BedrockClientTypes.FineTuningJobStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nameContains: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockClientTypes.SortJobsBy? = nil,
        sortOrder: BedrockClientTypes.SortOrder? = nil,
        statusEquals: BedrockClientTypes.FineTuningJobStatus? = nil
    ) {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.maxResults = maxResults
        self.nameContains = nameContains
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
        self.statusEquals = statusEquals
    }
}

extension BedrockClientTypes {

    /// Information about one customization job
    public struct ModelCustomizationJobSummary: Swift.Sendable {
        /// Amazon Resource Name (ARN) of the base model.
        /// This member is required.
        public var baseModelArn: Swift.String?
        /// Creation time of the custom model.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of the custom model.
        public var customModelArn: Swift.String?
        /// Name of the custom model.
        public var customModelName: Swift.String?
        /// Specifies whether to carry out continued pre-training of a model or whether to fine-tune it. For more information, see [Custom models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html).
        public var customizationType: BedrockClientTypes.CustomizationType?
        /// Time that the customization job ended.
        public var endTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of the customization job.
        /// This member is required.
        public var jobArn: Swift.String?
        /// Name of the customization job.
        /// This member is required.
        public var jobName: Swift.String?
        /// Time that the customization job was last modified.
        public var lastModifiedTime: Foundation.Date?
        /// Status of the customization job.
        /// This member is required.
        public var status: BedrockClientTypes.ModelCustomizationJobStatus?
        /// Details about the status of the data processing sub-task of the job.
        public var statusDetails: BedrockClientTypes.StatusDetails?

        public init(
            baseModelArn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            customModelArn: Swift.String? = nil,
            customModelName: Swift.String? = nil,
            customizationType: BedrockClientTypes.CustomizationType? = nil,
            endTime: Foundation.Date? = nil,
            jobArn: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            status: BedrockClientTypes.ModelCustomizationJobStatus? = nil,
            statusDetails: BedrockClientTypes.StatusDetails? = nil
        ) {
            self.baseModelArn = baseModelArn
            self.creationTime = creationTime
            self.customModelArn = customModelArn
            self.customModelName = customModelName
            self.customizationType = customizationType
            self.endTime = endTime
            self.jobArn = jobArn
            self.jobName = jobName
            self.lastModifiedTime = lastModifiedTime
            self.status = status
            self.statusDetails = statusDetails
        }
    }
}

public struct ListModelCustomizationJobsOutput: Swift.Sendable {
    /// Job summaries.
    public var modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        modelCustomizationJobSummaries: [BedrockClientTypes.ModelCustomizationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.modelCustomizationJobSummaries = modelCustomizationJobSummaries
        self.nextToken = nextToken
    }
}

public struct StopModelCustomizationJobInput: Swift.Sendable {
    /// Job identifier of the job to stop.
    /// This member is required.
    public var jobIdentifier: Swift.String?

    public init(
        jobIdentifier: Swift.String? = nil
    ) {
        self.jobIdentifier = jobIdentifier
    }
}

public struct StopModelCustomizationJobOutput: Swift.Sendable {

    public init() { }
}

extension BedrockClientTypes {

    /// Specifies the filters to use on the metadata attributes/fields in the knowledge base data sources before returning results.
    public indirect enum RetrievalFilter: Swift.Sendable {
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value matches the value in this object. The following example would return data sources with an animal attribute whose value is 'cat': "equals": { "key": "animal", "value": "cat" }
        case equals(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources that contain a metadata attribute whose name matches the key and whose value doesn't match the value in this object are returned. The following example would return data sources that don't contain an animal attribute whose value is 'cat': "notEquals": { "key": "animal", "value": "cat" }
        case notequals(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than the value in this object. The following example would return data sources with an year attribute whose value is greater than '1989': "greaterThan": { "key": "year", "value": 1989 }
        case greaterthan(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is greater than or equal to the value in this object. The following example would return data sources with an year attribute whose value is greater than or equal to '1989': "greaterThanOrEquals": { "key": "year", "value": 1989 }
        case greaterthanorequals(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than the value in this object. The following example would return data sources with an year attribute whose value is less than to '1989': "lessThan": { "key": "year", "value": 1989 }
        case lessthan(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is less than or equal to the value in this object. The following example would return data sources with an year attribute whose value is less than or equal to '1989': "lessThanOrEquals": { "key": "year", "value": 1989 }
        case lessthanorequals(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is in the list specified in the value in this object. The following example would return data sources with an animal attribute that is either 'cat' or 'dog': "in": { "key": "animal", "value": ["cat", "dog"] }
        case `in`(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value isn't in the list specified in the value in this object. The following example would return data sources whose animal attribute is neither 'cat' nor 'dog': "notIn": { "key": "animal", "value": ["cat", "dog"] }
        case notin(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value starts with the value in this object. This filter is currently only supported for Amazon OpenSearch Serverless vector stores. The following example would return data sources with an animal attribute starts with 'ca' (for example, 'cat' or 'camel'). "startsWith": { "key": "animal", "value": "ca" }
        case startswith(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is a list that contains the value as one of its members. The following example would return data sources with an animals attribute that is a list containing a cat member (for example, ["dog", "cat"]): "listContains": { "key": "animals", "value": "cat" }
        case listcontains(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if they contain a metadata attribute whose name matches the key and whose value is one of the following: A string that contains the value as a substring. The following example would return data sources with an animal attribute that contains the substring at (for example, 'cat'): "stringContains": { "key": "animal", "value": "at" } A list with a member that contains the value as a substring. The following example would return data sources with an animals attribute that is a list containing a member that contains the substring at (for example, ["dog", "cat"]): "stringContains": { "key": "animals", "value": "at" }
        case stringcontains(BedrockClientTypes.FilterAttribute)
        /// Knowledge base data sources are returned if their metadata attributes fulfill all the filter conditions inside this list.
        case andall([BedrockClientTypes.RetrievalFilter])
        /// Knowledge base data sources are returned if their metadata attributes fulfill at least one of the filter conditions inside this list.
        case orall([BedrockClientTypes.RetrievalFilter])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// The configuration details for returning the results from the knowledge base vector search.
    public struct KnowledgeBaseVectorSearchConfiguration: Swift.Sendable {
        /// Specifies the filters to use on the metadata fields in the knowledge base data sources before returning results.
        public var filter: BedrockClientTypes.RetrievalFilter?
        /// Configuration for implicit filtering in Knowledge Base vector searches. This allows the system to automatically apply filters based on the query context without requiring explicit filter expressions.
        public var implicitFilterConfiguration: BedrockClientTypes.ImplicitFilterConfiguration?
        /// The number of text chunks to retrieve; the number of results to return.
        public var numberOfResults: Swift.Int?
        /// By default, Amazon Bedrock decides a search strategy for you. If you're using an Amazon OpenSearch Serverless vector store that contains a filterable text field, you can specify whether to query the knowledge base with a HYBRID search using both vector embeddings and raw text, or SEMANTIC search using only vector embeddings. For other vector store configurations, only SEMANTIC search is available.
        public var overrideSearchType: BedrockClientTypes.SearchType?
        /// Configuration for reranking search results in Knowledge Base vector searches. Reranking improves search relevance by reordering initial vector search results using more sophisticated relevance models.
        public var rerankingConfiguration: BedrockClientTypes.VectorSearchRerankingConfiguration?

        public init(
            filter: BedrockClientTypes.RetrievalFilter? = nil,
            implicitFilterConfiguration: BedrockClientTypes.ImplicitFilterConfiguration? = nil,
            numberOfResults: Swift.Int? = nil,
            overrideSearchType: BedrockClientTypes.SearchType? = nil,
            rerankingConfiguration: BedrockClientTypes.VectorSearchRerankingConfiguration? = nil
        ) {
            self.filter = filter
            self.implicitFilterConfiguration = implicitFilterConfiguration
            self.numberOfResults = numberOfResults
            self.overrideSearchType = overrideSearchType
            self.rerankingConfiguration = rerankingConfiguration
        }
    }
}

extension BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseVectorSearchConfiguration(implicitFilterConfiguration: \(Swift.String(describing: implicitFilterConfiguration)), numberOfResults: \(Swift.String(describing: numberOfResults)), overrideSearchType: \(Swift.String(describing: overrideSearchType)), rerankingConfiguration: \(Swift.String(describing: rerankingConfiguration)), filter: \"CONTENT_REDACTED\")"}
}

extension BedrockClientTypes {

    /// Contains configuration details for retrieving information from a knowledge base.
    public struct KnowledgeBaseRetrievalConfiguration: Swift.Sendable {
        /// Contains configuration details for returning the results from the vector search.
        /// This member is required.
        public var vectorSearchConfiguration: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration?

        public init(
            vectorSearchConfiguration: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration? = nil
        ) {
            self.vectorSearchConfiguration = vectorSearchConfiguration
        }
    }
}

extension BedrockClientTypes {

    /// Contains configuration details for retrieving information from a knowledge base and generating responses.
    public struct KnowledgeBaseRetrieveAndGenerateConfiguration: Swift.Sendable {
        /// Contains configurations details for response generation based on retrieved text chunks.
        public var generationConfiguration: BedrockClientTypes.GenerationConfiguration?
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The Amazon Resource Name (ARN) of the foundation model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) used to generate responses.
        /// This member is required.
        public var modelArn: Swift.String?
        /// Contains configuration details for the model to process the prompt prior to retrieval and response generation.
        public var orchestrationConfiguration: BedrockClientTypes.OrchestrationConfiguration?
        /// Contains configuration details for retrieving text chunks.
        public var retrievalConfiguration: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration?

        public init(
            generationConfiguration: BedrockClientTypes.GenerationConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            modelArn: Swift.String? = nil,
            orchestrationConfiguration: BedrockClientTypes.OrchestrationConfiguration? = nil,
            retrievalConfiguration: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration? = nil
        ) {
            self.generationConfiguration = generationConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelArn = modelArn
            self.orchestrationConfiguration = orchestrationConfiguration
            self.retrievalConfiguration = retrievalConfiguration
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for retrieving information from a knowledge base.
    public struct RetrieveConfig: Swift.Sendable {
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Contains configuration details for knowledge base retrieval.
        /// This member is required.
        public var knowledgeBaseRetrievalConfiguration: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration?

        public init(
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseRetrievalConfiguration: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration? = nil
        ) {
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseRetrievalConfiguration = knowledgeBaseRetrievalConfiguration
        }
    }
}

extension BedrockClientTypes {

    /// Contains configuration details for a knowledge base retrieval and response generation.
    public struct RetrieveAndGenerateConfiguration: Swift.Sendable {
        /// The configuration for the external source wrapper object in the retrieveAndGenerate function.
        public var externalSourcesConfiguration: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration?
        /// Contains configuration details for the knowledge base retrieval and response generation.
        public var knowledgeBaseConfiguration: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?
        /// The type of resource that contains your data for retrieving information and generating responses. If you choose to use EXTERNAL_SOURCES, then currently only Claude 3 Sonnet models for knowledge bases are supported.
        /// This member is required.
        public var type: BedrockClientTypes.RetrieveAndGenerateType?

        public init(
            externalSourcesConfiguration: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration? = nil,
            knowledgeBaseConfiguration: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration? = nil,
            type: BedrockClientTypes.RetrieveAndGenerateType? = nil
        ) {
            self.externalSourcesConfiguration = externalSourcesConfiguration
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.type = type
        }
    }
}

extension BedrockClientTypes {

    /// The configuration details for retrieving information from a knowledge base and generating responses.
    public indirect enum KnowledgeBaseConfig: Swift.Sendable {
        /// Contains configuration details for retrieving information from a knowledge base.
        case retrieveconfig(BedrockClientTypes.RetrieveConfig)
        /// Contains configuration details for retrieving information from a knowledge base and generating responses.
        case retrieveandgenerateconfig(BedrockClientTypes.RetrieveAndGenerateConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// Contains configuration details for retrieval of information and response generation.
    public indirect enum RAGConfig: Swift.Sendable {
        /// Contains configuration details for knowledge base retrieval and response generation.
        case knowledgebaseconfig(BedrockClientTypes.KnowledgeBaseConfig)
        /// Contains configuration details about the RAG source used to generate inference response data for a Knowledge Base evaluation job.
        case precomputedragsourceconfig(BedrockClientTypes.EvaluationPrecomputedRagSourceConfig)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockClientTypes {

    /// The configuration details of the inference model for an evaluation job. For automated model evaluation jobs, only a single model is supported. For human-based model evaluation jobs, your annotator can compare the responses for up to two different models.
    public indirect enum EvaluationInferenceConfig: Swift.Sendable {
        /// Specifies the inference models.
        case models([BedrockClientTypes.EvaluationModelConfig])
        /// Contains the configuration details of the inference for a knowledge base evaluation job, including either the retrieval only configuration or the retrieval with response generation configuration.
        case ragconfigs([BedrockClientTypes.RAGConfig])
        case sdkUnknown(Swift.String)
    }
}

public struct CreateEvaluationJobInput: Swift.Sendable {
    /// Specifies whether the evaluation job is for evaluating a model or evaluating a knowledge base (retrieval and response generation).
    public var applicationType: BedrockClientTypes.ApplicationType?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientRequestToken: Swift.String?
    /// Specify your customer managed encryption key Amazon Resource Name (ARN) that will be used to encrypt your evaluation job.
    public var customerEncryptionKeyId: Swift.String?
    /// Contains the configuration details of either an automated or human-based evaluation job.
    /// This member is required.
    public var evaluationConfig: BedrockClientTypes.EvaluationConfig?
    /// Contains the configuration details of the inference model for the evaluation job. For model evaluation jobs, automated jobs support a single model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html), and jobs that use human workers support two models or inference profiles.
    /// This member is required.
    public var inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig?
    /// A description of the evaluation job.
    public var jobDescription: Swift.String?
    /// A name for the evaluation job. Names must unique with your Amazon Web Services account, and your account's Amazon Web Services region.
    /// This member is required.
    public var jobName: Swift.String?
    /// Tags to attach to the model evaluation job.
    public var jobTags: [BedrockClientTypes.Tag]?
    /// Contains the configuration details of the Amazon S3 bucket for storing the results of the evaluation job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig?
    /// The Amazon Resource Name (ARN) of an IAM service role that Amazon Bedrock can assume to perform tasks on your behalf. To learn more about the required permissions, see [Required permissions for model evaluations](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-security.html).
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        applicationType: BedrockClientTypes.ApplicationType? = nil,
        clientRequestToken: Swift.String? = nil,
        customerEncryptionKeyId: Swift.String? = nil,
        evaluationConfig: BedrockClientTypes.EvaluationConfig? = nil,
        inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig? = nil,
        jobDescription: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobTags: [BedrockClientTypes.Tag]? = nil,
        outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig? = nil,
        roleArn: Swift.String? = nil
    ) {
        self.applicationType = applicationType
        self.clientRequestToken = clientRequestToken
        self.customerEncryptionKeyId = customerEncryptionKeyId
        self.evaluationConfig = evaluationConfig
        self.inferenceConfig = inferenceConfig
        self.jobDescription = jobDescription
        self.jobName = jobName
        self.jobTags = jobTags
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
    }
}

extension CreateEvaluationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEvaluationJobInput(applicationType: \(Swift.String(describing: applicationType)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), customerEncryptionKeyId: \(Swift.String(describing: customerEncryptionKeyId)), evaluationConfig: \(Swift.String(describing: evaluationConfig)), inferenceConfig: \(Swift.String(describing: inferenceConfig)), jobName: \(Swift.String(describing: jobName)), jobTags: \(Swift.String(describing: jobTags)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), jobDescription: \"CONTENT_REDACTED\")"}
}

public struct GetEvaluationJobOutput: Swift.Sendable {
    /// Specifies whether the evaluation job is for evaluating a model or evaluating a knowledge base (retrieval and response generation).
    public var applicationType: BedrockClientTypes.ApplicationType?
    /// The time the evaluation job was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the customer managed encryption key specified when the evaluation job was created.
    public var customerEncryptionKeyId: Swift.String?
    /// Contains the configuration details of either an automated or human-based evaluation job.
    /// This member is required.
    public var evaluationConfig: BedrockClientTypes.EvaluationConfig?
    /// A list of strings that specify why the evaluation job failed to create.
    public var failureMessages: [Swift.String]?
    /// Contains the configuration details of the inference model used for the evaluation job.
    /// This member is required.
    public var inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig?
    /// The Amazon Resource Name (ARN) of the evaluation job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The description of the evaluation job.
    public var jobDescription: Swift.String?
    /// The name for the evaluation job.
    /// This member is required.
    public var jobName: Swift.String?
    /// Specifies whether the evaluation job is automated or human-based.
    /// This member is required.
    public var jobType: BedrockClientTypes.EvaluationJobType?
    /// The time the evaluation job was last modified.
    public var lastModifiedTime: Foundation.Date?
    /// Contains the configuration details of the Amazon S3 bucket for storing the results of the evaluation job.
    /// This member is required.
    public var outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig?
    /// The Amazon Resource Name (ARN) of the IAM service role used in the evaluation job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The current status of the evaluation job.
    /// This member is required.
    public var status: BedrockClientTypes.EvaluationJobStatus?

    public init(
        applicationType: BedrockClientTypes.ApplicationType? = nil,
        creationTime: Foundation.Date? = nil,
        customerEncryptionKeyId: Swift.String? = nil,
        evaluationConfig: BedrockClientTypes.EvaluationConfig? = nil,
        failureMessages: [Swift.String]? = nil,
        inferenceConfig: BedrockClientTypes.EvaluationInferenceConfig? = nil,
        jobArn: Swift.String? = nil,
        jobDescription: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobType: BedrockClientTypes.EvaluationJobType? = nil,
        lastModifiedTime: Foundation.Date? = nil,
        outputDataConfig: BedrockClientTypes.EvaluationOutputDataConfig? = nil,
        roleArn: Swift.String? = nil,
        status: BedrockClientTypes.EvaluationJobStatus? = nil
    ) {
        self.applicationType = applicationType
        self.creationTime = creationTime
        self.customerEncryptionKeyId = customerEncryptionKeyId
        self.evaluationConfig = evaluationConfig
        self.failureMessages = failureMessages
        self.inferenceConfig = inferenceConfig
        self.jobArn = jobArn
        self.jobDescription = jobDescription
        self.jobName = jobName
        self.jobType = jobType
        self.lastModifiedTime = lastModifiedTime
        self.outputDataConfig = outputDataConfig
        self.roleArn = roleArn
        self.status = status
    }
}

extension GetEvaluationJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEvaluationJobOutput(applicationType: \(Swift.String(describing: applicationType)), creationTime: \(Swift.String(describing: creationTime)), customerEncryptionKeyId: \(Swift.String(describing: customerEncryptionKeyId)), evaluationConfig: \(Swift.String(describing: evaluationConfig)), failureMessages: \(Swift.String(describing: failureMessages)), inferenceConfig: \(Swift.String(describing: inferenceConfig)), jobArn: \(Swift.String(describing: jobArn)), jobName: \(Swift.String(describing: jobName)), jobType: \(Swift.String(describing: jobType)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), jobDescription: \"CONTENT_REDACTED\")"}
}

extension BatchDeleteEvaluationJobInput {

    static func urlPathProvider(_ value: BatchDeleteEvaluationJobInput) -> Swift.String? {
        return "/evaluation-jobs/batch-delete"
    }
}

extension CancelAutomatedReasoningPolicyBuildWorkflowInput {

    static func urlPathProvider(_ value: CancelAutomatedReasoningPolicyBuildWorkflowInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())/cancel"
    }
}

extension CreateAutomatedReasoningPolicyInput {

    static func urlPathProvider(_ value: CreateAutomatedReasoningPolicyInput) -> Swift.String? {
        return "/automated-reasoning-policies"
    }
}

extension CreateAutomatedReasoningPolicyTestCaseInput {

    static func urlPathProvider(_ value: CreateAutomatedReasoningPolicyTestCaseInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/test-cases"
    }
}

extension CreateAutomatedReasoningPolicyVersionInput {

    static func urlPathProvider(_ value: CreateAutomatedReasoningPolicyVersionInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/versions"
    }
}

extension CreateCustomModelInput {

    static func urlPathProvider(_ value: CreateCustomModelInput) -> Swift.String? {
        return "/custom-models/create-custom-model"
    }
}

extension CreateCustomModelDeploymentInput {

    static func urlPathProvider(_ value: CreateCustomModelDeploymentInput) -> Swift.String? {
        return "/model-customization/custom-model-deployments"
    }
}

extension CreateEvaluationJobInput {

    static func urlPathProvider(_ value: CreateEvaluationJobInput) -> Swift.String? {
        return "/evaluation-jobs"
    }
}

extension CreateFoundationModelAgreementInput {

    static func urlPathProvider(_ value: CreateFoundationModelAgreementInput) -> Swift.String? {
        return "/create-foundation-model-agreement"
    }
}

extension CreateGuardrailInput {

    static func urlPathProvider(_ value: CreateGuardrailInput) -> Swift.String? {
        return "/guardrails"
    }
}

extension CreateGuardrailVersionInput {

    static func urlPathProvider(_ value: CreateGuardrailVersionInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension CreateInferenceProfileInput {

    static func urlPathProvider(_ value: CreateInferenceProfileInput) -> Swift.String? {
        return "/inference-profiles"
    }
}

extension CreateMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: CreateMarketplaceModelEndpointInput) -> Swift.String? {
        return "/marketplace-model/endpoints"
    }
}

extension CreateModelCopyJobInput {

    static func urlPathProvider(_ value: CreateModelCopyJobInput) -> Swift.String? {
        return "/model-copy-jobs"
    }
}

extension CreateModelCustomizationJobInput {

    static func urlPathProvider(_ value: CreateModelCustomizationJobInput) -> Swift.String? {
        return "/model-customization-jobs"
    }
}

extension CreateModelImportJobInput {

    static func urlPathProvider(_ value: CreateModelImportJobInput) -> Swift.String? {
        return "/model-import-jobs"
    }
}

extension CreateModelInvocationJobInput {

    static func urlPathProvider(_ value: CreateModelInvocationJobInput) -> Swift.String? {
        return "/model-invocation-job"
    }
}

extension CreatePromptRouterInput {

    static func urlPathProvider(_ value: CreatePromptRouterInput) -> Swift.String? {
        return "/prompt-routers"
    }
}

extension CreateProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: CreateProvisionedModelThroughputInput) -> Swift.String? {
        return "/provisioned-model-throughput"
    }
}

extension DeleteAutomatedReasoningPolicyInput {

    static func urlPathProvider(_ value: DeleteAutomatedReasoningPolicyInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())"
    }
}

extension DeleteAutomatedReasoningPolicyInput {

    static func queryItemProvider(_ value: DeleteAutomatedReasoningPolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let force = value.force {
            let forceQueryItem = Smithy.URIQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
            items.append(forceQueryItem)
        }
        return items
    }
}

extension DeleteAutomatedReasoningPolicyBuildWorkflowInput {

    static func urlPathProvider(_ value: DeleteAutomatedReasoningPolicyBuildWorkflowInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())"
    }
}

extension DeleteAutomatedReasoningPolicyBuildWorkflowInput {

    static func queryItemProvider(_ value: DeleteAutomatedReasoningPolicyBuildWorkflowInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let lastUpdatedAt = value.lastUpdatedAt else {
            let message = "Creating a URL Query Item failed. lastUpdatedAt is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let lastUpdatedAtQueryItem = Smithy.URIQueryItem(name: "updatedAt".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: lastUpdatedAt)).urlPercentEncoding())
        items.append(lastUpdatedAtQueryItem)
        return items
    }
}

extension DeleteAutomatedReasoningPolicyTestCaseInput {

    static func urlPathProvider(_ value: DeleteAutomatedReasoningPolicyTestCaseInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let testCaseId = value.testCaseId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/test-cases/\(testCaseId.urlPercentEncoding())"
    }
}

extension DeleteAutomatedReasoningPolicyTestCaseInput {

    static func queryItemProvider(_ value: DeleteAutomatedReasoningPolicyTestCaseInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let lastUpdatedAt = value.lastUpdatedAt else {
            let message = "Creating a URL Query Item failed. lastUpdatedAt is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let lastUpdatedAtQueryItem = Smithy.URIQueryItem(name: "updatedAt".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: lastUpdatedAt)).urlPercentEncoding())
        items.append(lastUpdatedAtQueryItem)
        return items
    }
}

extension DeleteCustomModelInput {

    static func urlPathProvider(_ value: DeleteCustomModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension DeleteCustomModelDeploymentInput {

    static func urlPathProvider(_ value: DeleteCustomModelDeploymentInput) -> Swift.String? {
        guard let customModelDeploymentIdentifier = value.customModelDeploymentIdentifier else {
            return nil
        }
        return "/model-customization/custom-model-deployments/\(customModelDeploymentIdentifier.urlPercentEncoding())"
    }
}

extension DeleteEnforcedGuardrailConfigurationInput {

    static func urlPathProvider(_ value: DeleteEnforcedGuardrailConfigurationInput) -> Swift.String? {
        guard let configId = value.configId else {
            return nil
        }
        return "/enforcedGuardrailsConfiguration/\(configId.urlPercentEncoding())"
    }
}

extension DeleteFoundationModelAgreementInput {

    static func urlPathProvider(_ value: DeleteFoundationModelAgreementInput) -> Swift.String? {
        return "/delete-foundation-model-agreement"
    }
}

extension DeleteGuardrailInput {

    static func urlPathProvider(_ value: DeleteGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension DeleteGuardrailInput {

    static func queryItemProvider(_ value: DeleteGuardrailInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let guardrailVersion = value.guardrailVersion {
            let guardrailVersionQueryItem = Smithy.URIQueryItem(name: "guardrailVersion".urlPercentEncoding(), value: Swift.String(guardrailVersion).urlPercentEncoding())
            items.append(guardrailVersionQueryItem)
        }
        return items
    }
}

extension DeleteImportedModelInput {

    static func urlPathProvider(_ value: DeleteImportedModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/imported-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension DeleteInferenceProfileInput {

    static func urlPathProvider(_ value: DeleteInferenceProfileInput) -> Swift.String? {
        guard let inferenceProfileIdentifier = value.inferenceProfileIdentifier else {
            return nil
        }
        return "/inference-profiles/\(inferenceProfileIdentifier.urlPercentEncoding())"
    }
}

extension DeleteMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: DeleteMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointArn = value.endpointArn else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointArn.urlPercentEncoding())"
    }
}

extension DeleteModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: DeleteModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension DeletePromptRouterInput {

    static func urlPathProvider(_ value: DeletePromptRouterInput) -> Swift.String? {
        guard let promptRouterArn = value.promptRouterArn else {
            return nil
        }
        return "/prompt-routers/\(promptRouterArn.urlPercentEncoding())"
    }
}

extension DeleteProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: DeleteProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension DeregisterMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: DeregisterMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointArn = value.endpointArn else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointArn.urlPercentEncoding())/registration"
    }
}

extension ExportAutomatedReasoningPolicyVersionInput {

    static func urlPathProvider(_ value: ExportAutomatedReasoningPolicyVersionInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/export"
    }
}

extension GetAutomatedReasoningPolicyInput {

    static func urlPathProvider(_ value: GetAutomatedReasoningPolicyInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())"
    }
}

extension GetAutomatedReasoningPolicyAnnotationsInput {

    static func urlPathProvider(_ value: GetAutomatedReasoningPolicyAnnotationsInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())/annotations"
    }
}

extension GetAutomatedReasoningPolicyBuildWorkflowInput {

    static func urlPathProvider(_ value: GetAutomatedReasoningPolicyBuildWorkflowInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())"
    }
}

extension GetAutomatedReasoningPolicyBuildWorkflowResultAssetsInput {

    static func urlPathProvider(_ value: GetAutomatedReasoningPolicyBuildWorkflowResultAssetsInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())/result-assets"
    }
}

extension GetAutomatedReasoningPolicyBuildWorkflowResultAssetsInput {

    static func queryItemProvider(_ value: GetAutomatedReasoningPolicyBuildWorkflowResultAssetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let assetType = value.assetType else {
            let message = "Creating a URL Query Item failed. assetType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let assetTypeQueryItem = Smithy.URIQueryItem(name: "assetType".urlPercentEncoding(), value: Swift.String(assetType.rawValue).urlPercentEncoding())
        items.append(assetTypeQueryItem)
        return items
    }
}

extension GetAutomatedReasoningPolicyNextScenarioInput {

    static func urlPathProvider(_ value: GetAutomatedReasoningPolicyNextScenarioInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())/scenarios"
    }
}

extension GetAutomatedReasoningPolicyTestCaseInput {

    static func urlPathProvider(_ value: GetAutomatedReasoningPolicyTestCaseInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let testCaseId = value.testCaseId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/test-cases/\(testCaseId.urlPercentEncoding())"
    }
}

extension GetAutomatedReasoningPolicyTestResultInput {

    static func urlPathProvider(_ value: GetAutomatedReasoningPolicyTestResultInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        guard let testCaseId = value.testCaseId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())/test-cases/\(testCaseId.urlPercentEncoding())/test-results"
    }
}

extension GetCustomModelInput {

    static func urlPathProvider(_ value: GetCustomModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/custom-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension GetCustomModelDeploymentInput {

    static func urlPathProvider(_ value: GetCustomModelDeploymentInput) -> Swift.String? {
        guard let customModelDeploymentIdentifier = value.customModelDeploymentIdentifier else {
            return nil
        }
        return "/model-customization/custom-model-deployments/\(customModelDeploymentIdentifier.urlPercentEncoding())"
    }
}

extension GetEvaluationJobInput {

    static func urlPathProvider(_ value: GetEvaluationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/evaluation-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetFoundationModelInput {

    static func urlPathProvider(_ value: GetFoundationModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/foundation-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension GetFoundationModelAvailabilityInput {

    static func urlPathProvider(_ value: GetFoundationModelAvailabilityInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/foundation-model-availability/\(modelId.urlPercentEncoding())"
    }
}

extension GetGuardrailInput {

    static func urlPathProvider(_ value: GetGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension GetGuardrailInput {

    static func queryItemProvider(_ value: GetGuardrailInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let guardrailVersion = value.guardrailVersion {
            let guardrailVersionQueryItem = Smithy.URIQueryItem(name: "guardrailVersion".urlPercentEncoding(), value: Swift.String(guardrailVersion).urlPercentEncoding())
            items.append(guardrailVersionQueryItem)
        }
        return items
    }
}

extension GetImportedModelInput {

    static func urlPathProvider(_ value: GetImportedModelInput) -> Swift.String? {
        guard let modelIdentifier = value.modelIdentifier else {
            return nil
        }
        return "/imported-models/\(modelIdentifier.urlPercentEncoding())"
    }
}

extension GetInferenceProfileInput {

    static func urlPathProvider(_ value: GetInferenceProfileInput) -> Swift.String? {
        guard let inferenceProfileIdentifier = value.inferenceProfileIdentifier else {
            return nil
        }
        return "/inference-profiles/\(inferenceProfileIdentifier.urlPercentEncoding())"
    }
}

extension GetMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: GetMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointArn = value.endpointArn else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointArn.urlPercentEncoding())"
    }
}

extension GetModelCopyJobInput {

    static func urlPathProvider(_ value: GetModelCopyJobInput) -> Swift.String? {
        guard let jobArn = value.jobArn else {
            return nil
        }
        return "/model-copy-jobs/\(jobArn.urlPercentEncoding())"
    }
}

extension GetModelCustomizationJobInput {

    static func urlPathProvider(_ value: GetModelCustomizationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetModelImportJobInput {

    static func urlPathProvider(_ value: GetModelImportJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-import-jobs/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetModelInvocationJobInput {

    static func urlPathProvider(_ value: GetModelInvocationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-invocation-job/\(jobIdentifier.urlPercentEncoding())"
    }
}

extension GetModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: GetModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension GetPromptRouterInput {

    static func urlPathProvider(_ value: GetPromptRouterInput) -> Swift.String? {
        guard let promptRouterArn = value.promptRouterArn else {
            return nil
        }
        return "/prompt-routers/\(promptRouterArn.urlPercentEncoding())"
    }
}

extension GetProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: GetProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension GetUseCaseForModelAccessInput {

    static func urlPathProvider(_ value: GetUseCaseForModelAccessInput) -> Swift.String? {
        return "/use-case-for-model-access"
    }
}

extension ListAutomatedReasoningPoliciesInput {

    static func urlPathProvider(_ value: ListAutomatedReasoningPoliciesInput) -> Swift.String? {
        return "/automated-reasoning-policies"
    }
}

extension ListAutomatedReasoningPoliciesInput {

    static func queryItemProvider(_ value: ListAutomatedReasoningPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let policyArn = value.policyArn {
            let policyArnQueryItem = Smithy.URIQueryItem(name: "policyArn".urlPercentEncoding(), value: Swift.String(policyArn).urlPercentEncoding())
            items.append(policyArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAutomatedReasoningPolicyBuildWorkflowsInput {

    static func urlPathProvider(_ value: ListAutomatedReasoningPolicyBuildWorkflowsInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows"
    }
}

extension ListAutomatedReasoningPolicyBuildWorkflowsInput {

    static func queryItemProvider(_ value: ListAutomatedReasoningPolicyBuildWorkflowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAutomatedReasoningPolicyTestCasesInput {

    static func urlPathProvider(_ value: ListAutomatedReasoningPolicyTestCasesInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/test-cases"
    }
}

extension ListAutomatedReasoningPolicyTestCasesInput {

    static func queryItemProvider(_ value: ListAutomatedReasoningPolicyTestCasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAutomatedReasoningPolicyTestResultsInput {

    static func urlPathProvider(_ value: ListAutomatedReasoningPolicyTestResultsInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())/test-results"
    }
}

extension ListAutomatedReasoningPolicyTestResultsInput {

    static func queryItemProvider(_ value: ListAutomatedReasoningPolicyTestResultsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCustomModelDeploymentsInput {

    static func urlPathProvider(_ value: ListCustomModelDeploymentsInput) -> Swift.String? {
        return "/model-customization/custom-model-deployments"
    }
}

extension ListCustomModelDeploymentsInput {

    static func queryItemProvider(_ value: ListCustomModelDeploymentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let modelArnEquals = value.modelArnEquals {
            let modelArnEqualsQueryItem = Smithy.URIQueryItem(name: "modelArnEquals".urlPercentEncoding(), value: Swift.String(modelArnEquals).urlPercentEncoding())
            items.append(modelArnEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let createdBefore = value.createdBefore {
            let createdBeforeQueryItem = Smithy.URIQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: createdBefore)).urlPercentEncoding())
            items.append(createdBeforeQueryItem)
        }
        if let createdAfter = value.createdAfter {
            let createdAfterQueryItem = Smithy.URIQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: createdAfter)).urlPercentEncoding())
            items.append(createdAfterQueryItem)
        }
        return items
    }
}

extension ListCustomModelsInput {

    static func urlPathProvider(_ value: ListCustomModelsInput) -> Swift.String? {
        return "/custom-models"
    }
}

extension ListCustomModelsInput {

    static func queryItemProvider(_ value: ListCustomModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let modelStatus = value.modelStatus {
            let modelStatusQueryItem = Smithy.URIQueryItem(name: "modelStatus".urlPercentEncoding(), value: Swift.String(modelStatus.rawValue).urlPercentEncoding())
            items.append(modelStatusQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let isOwned = value.isOwned {
            let isOwnedQueryItem = Smithy.URIQueryItem(name: "isOwned".urlPercentEncoding(), value: Swift.String(isOwned).urlPercentEncoding())
            items.append(isOwnedQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let baseModelArnEquals = value.baseModelArnEquals {
            let baseModelArnEqualsQueryItem = Smithy.URIQueryItem(name: "baseModelArnEquals".urlPercentEncoding(), value: Swift.String(baseModelArnEquals).urlPercentEncoding())
            items.append(baseModelArnEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let foundationModelArnEquals = value.foundationModelArnEquals {
            let foundationModelArnEqualsQueryItem = Smithy.URIQueryItem(name: "foundationModelArnEquals".urlPercentEncoding(), value: Swift.String(foundationModelArnEquals).urlPercentEncoding())
            items.append(foundationModelArnEqualsQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListEnforcedGuardrailsConfigurationInput {

    static func urlPathProvider(_ value: ListEnforcedGuardrailsConfigurationInput) -> Swift.String? {
        return "/enforcedGuardrailsConfiguration"
    }
}

extension ListEnforcedGuardrailsConfigurationInput {

    static func queryItemProvider(_ value: ListEnforcedGuardrailsConfigurationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListEvaluationJobsInput {

    static func urlPathProvider(_ value: ListEvaluationJobsInput) -> Swift.String? {
        return "/evaluation-jobs"
    }
}

extension ListEvaluationJobsInput {

    static func queryItemProvider(_ value: ListEvaluationJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let applicationTypeEquals = value.applicationTypeEquals {
            let applicationTypeEqualsQueryItem = Smithy.URIQueryItem(name: "applicationTypeEquals".urlPercentEncoding(), value: Swift.String(applicationTypeEquals.rawValue).urlPercentEncoding())
            items.append(applicationTypeEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListFoundationModelAgreementOffersInput {

    static func urlPathProvider(_ value: ListFoundationModelAgreementOffersInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/list-foundation-model-agreement-offers/\(modelId.urlPercentEncoding())"
    }
}

extension ListFoundationModelAgreementOffersInput {

    static func queryItemProvider(_ value: ListFoundationModelAgreementOffersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let offerType = value.offerType {
            let offerTypeQueryItem = Smithy.URIQueryItem(name: "offerType".urlPercentEncoding(), value: Swift.String(offerType.rawValue).urlPercentEncoding())
            items.append(offerTypeQueryItem)
        }
        return items
    }
}

extension ListFoundationModelsInput {

    static func urlPathProvider(_ value: ListFoundationModelsInput) -> Swift.String? {
        return "/foundation-models"
    }
}

extension ListFoundationModelsInput {

    static func queryItemProvider(_ value: ListFoundationModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let byOutputModality = value.byOutputModality {
            let byOutputModalityQueryItem = Smithy.URIQueryItem(name: "byOutputModality".urlPercentEncoding(), value: Swift.String(byOutputModality.rawValue).urlPercentEncoding())
            items.append(byOutputModalityQueryItem)
        }
        if let byCustomizationType = value.byCustomizationType {
            let byCustomizationTypeQueryItem = Smithy.URIQueryItem(name: "byCustomizationType".urlPercentEncoding(), value: Swift.String(byCustomizationType.rawValue).urlPercentEncoding())
            items.append(byCustomizationTypeQueryItem)
        }
        if let byProvider = value.byProvider {
            let byProviderQueryItem = Smithy.URIQueryItem(name: "byProvider".urlPercentEncoding(), value: Swift.String(byProvider).urlPercentEncoding())
            items.append(byProviderQueryItem)
        }
        if let byInferenceType = value.byInferenceType {
            let byInferenceTypeQueryItem = Smithy.URIQueryItem(name: "byInferenceType".urlPercentEncoding(), value: Swift.String(byInferenceType.rawValue).urlPercentEncoding())
            items.append(byInferenceTypeQueryItem)
        }
        return items
    }
}

extension ListGuardrailsInput {

    static func urlPathProvider(_ value: ListGuardrailsInput) -> Swift.String? {
        return "/guardrails"
    }
}

extension ListGuardrailsInput {

    static func queryItemProvider(_ value: ListGuardrailsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            let guardrailIdentifierQueryItem = Smithy.URIQueryItem(name: "guardrailIdentifier".urlPercentEncoding(), value: Swift.String(guardrailIdentifier).urlPercentEncoding())
            items.append(guardrailIdentifierQueryItem)
        }
        return items
    }
}

extension ListImportedModelsInput {

    static func urlPathProvider(_ value: ListImportedModelsInput) -> Swift.String? {
        return "/imported-models"
    }
}

extension ListImportedModelsInput {

    static func queryItemProvider(_ value: ListImportedModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListInferenceProfilesInput {

    static func urlPathProvider(_ value: ListInferenceProfilesInput) -> Swift.String? {
        return "/inference-profiles"
    }
}

extension ListInferenceProfilesInput {

    static func queryItemProvider(_ value: ListInferenceProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let typeEquals = value.typeEquals {
            let typeEqualsQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(typeEquals.rawValue).urlPercentEncoding())
            items.append(typeEqualsQueryItem)
        }
        return items
    }
}

extension ListMarketplaceModelEndpointsInput {

    static func urlPathProvider(_ value: ListMarketplaceModelEndpointsInput) -> Swift.String? {
        return "/marketplace-model/endpoints"
    }
}

extension ListMarketplaceModelEndpointsInput {

    static func queryItemProvider(_ value: ListMarketplaceModelEndpointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let modelSourceEquals = value.modelSourceEquals {
            let modelSourceEqualsQueryItem = Smithy.URIQueryItem(name: "modelSourceIdentifier".urlPercentEncoding(), value: Swift.String(modelSourceEquals).urlPercentEncoding())
            items.append(modelSourceEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListModelCopyJobsInput {

    static func urlPathProvider(_ value: ListModelCopyJobsInput) -> Swift.String? {
        return "/model-copy-jobs"
    }
}

extension ListModelCopyJobsInput {

    static func queryItemProvider(_ value: ListModelCopyJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let sourceModelArnEquals = value.sourceModelArnEquals {
            let sourceModelArnEqualsQueryItem = Smithy.URIQueryItem(name: "sourceModelArnEquals".urlPercentEncoding(), value: Swift.String(sourceModelArnEquals).urlPercentEncoding())
            items.append(sourceModelArnEqualsQueryItem)
        }
        if let sourceAccountEquals = value.sourceAccountEquals {
            let sourceAccountEqualsQueryItem = Smithy.URIQueryItem(name: "sourceAccountEquals".urlPercentEncoding(), value: Swift.String(sourceAccountEquals).urlPercentEncoding())
            items.append(sourceAccountEqualsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let targetModelNameContains = value.targetModelNameContains {
            let targetModelNameContainsQueryItem = Smithy.URIQueryItem(name: "outputModelNameContains".urlPercentEncoding(), value: Swift.String(targetModelNameContains).urlPercentEncoding())
            items.append(targetModelNameContainsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelCustomizationJobsInput {

    static func urlPathProvider(_ value: ListModelCustomizationJobsInput) -> Swift.String? {
        return "/model-customization-jobs"
    }
}

extension ListModelCustomizationJobsInput {

    static func queryItemProvider(_ value: ListModelCustomizationJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelImportJobsInput {

    static func urlPathProvider(_ value: ListModelImportJobsInput) -> Swift.String? {
        return "/model-import-jobs"
    }
}

extension ListModelImportJobsInput {

    static func queryItemProvider(_ value: ListModelImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListModelInvocationJobsInput {

    static func urlPathProvider(_ value: ListModelInvocationJobsInput) -> Swift.String? {
        return "/model-invocation-jobs"
    }
}

extension ListModelInvocationJobsInput {

    static func queryItemProvider(_ value: ListModelInvocationJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let submitTimeAfter = value.submitTimeAfter {
            let submitTimeAfterQueryItem = Smithy.URIQueryItem(name: "submitTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: submitTimeAfter)).urlPercentEncoding())
            items.append(submitTimeAfterQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let submitTimeBefore = value.submitTimeBefore {
            let submitTimeBeforeQueryItem = Smithy.URIQueryItem(name: "submitTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: submitTimeBefore)).urlPercentEncoding())
            items.append(submitTimeBeforeQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        return items
    }
}

extension ListPromptRoutersInput {

    static func urlPathProvider(_ value: ListPromptRoutersInput) -> Swift.String? {
        return "/prompt-routers"
    }
}

extension ListPromptRoutersInput {

    static func queryItemProvider(_ value: ListPromptRoutersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension ListProvisionedModelThroughputsInput {

    static func urlPathProvider(_ value: ListProvisionedModelThroughputsInput) -> Swift.String? {
        return "/provisioned-model-throughputs"
    }
}

extension ListProvisionedModelThroughputsInput {

    static func queryItemProvider(_ value: ListProvisionedModelThroughputsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameContains = value.nameContains {
            let nameContainsQueryItem = Smithy.URIQueryItem(name: "nameContains".urlPercentEncoding(), value: Swift.String(nameContains).urlPercentEncoding())
            items.append(nameContainsQueryItem)
        }
        if let statusEquals = value.statusEquals {
            let statusEqualsQueryItem = Smithy.URIQueryItem(name: "statusEquals".urlPercentEncoding(), value: Swift.String(statusEquals.rawValue).urlPercentEncoding())
            items.append(statusEqualsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = value.creationTimeAfter {
            let creationTimeAfterQueryItem = Smithy.URIQueryItem(name: "creationTimeAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeAfter)).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        if let modelArnEquals = value.modelArnEquals {
            let modelArnEqualsQueryItem = Smithy.URIQueryItem(name: "modelArnEquals".urlPercentEncoding(), value: Swift.String(modelArnEquals).urlPercentEncoding())
            items.append(modelArnEqualsQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if let creationTimeBefore = value.creationTimeBefore {
            let creationTimeBeforeQueryItem = Smithy.URIQueryItem(name: "creationTimeBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: creationTimeBefore)).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/listTagsForResource"
    }
}

extension PutEnforcedGuardrailConfigurationInput {

    static func urlPathProvider(_ value: PutEnforcedGuardrailConfigurationInput) -> Swift.String? {
        return "/enforcedGuardrailsConfiguration"
    }
}

extension PutModelInvocationLoggingConfigurationInput {

    static func urlPathProvider(_ value: PutModelInvocationLoggingConfigurationInput) -> Swift.String? {
        return "/logging/modelinvocations"
    }
}

extension PutUseCaseForModelAccessInput {

    static func urlPathProvider(_ value: PutUseCaseForModelAccessInput) -> Swift.String? {
        return "/use-case-for-model-access"
    }
}

extension RegisterMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: RegisterMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointIdentifier = value.endpointIdentifier else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointIdentifier.urlPercentEncoding())/registration"
    }
}

extension StartAutomatedReasoningPolicyBuildWorkflowInput {

    static func urlPathProvider(_ value: StartAutomatedReasoningPolicyBuildWorkflowInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowType = value.buildWorkflowType else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowType.rawValue.urlPercentEncoding())/start"
    }
}

extension StartAutomatedReasoningPolicyBuildWorkflowInput {

    static func headerProvider(_ value: StartAutomatedReasoningPolicyBuildWorkflowInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientRequestToken = value.clientRequestToken {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-client-token", value: Swift.String(clientRequestToken)))
        }
        return items
    }
}

extension StartAutomatedReasoningPolicyTestWorkflowInput {

    static func urlPathProvider(_ value: StartAutomatedReasoningPolicyTestWorkflowInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())/test-workflows"
    }
}

extension StopEvaluationJobInput {

    static func urlPathProvider(_ value: StopEvaluationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/evaluation-job/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

extension StopModelCustomizationJobInput {

    static func urlPathProvider(_ value: StopModelCustomizationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-customization-jobs/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

extension StopModelInvocationJobInput {

    static func urlPathProvider(_ value: StopModelInvocationJobInput) -> Swift.String? {
        guard let jobIdentifier = value.jobIdentifier else {
            return nil
        }
        return "/model-invocation-job/\(jobIdentifier.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/untagResource"
    }
}

extension UpdateAutomatedReasoningPolicyInput {

    static func urlPathProvider(_ value: UpdateAutomatedReasoningPolicyInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())"
    }
}

extension UpdateAutomatedReasoningPolicyAnnotationsInput {

    static func urlPathProvider(_ value: UpdateAutomatedReasoningPolicyAnnotationsInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let buildWorkflowId = value.buildWorkflowId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/build-workflows/\(buildWorkflowId.urlPercentEncoding())/annotations"
    }
}

extension UpdateAutomatedReasoningPolicyTestCaseInput {

    static func urlPathProvider(_ value: UpdateAutomatedReasoningPolicyTestCaseInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        guard let testCaseId = value.testCaseId else {
            return nil
        }
        return "/automated-reasoning-policies/\(policyArn.urlPercentEncoding())/test-cases/\(testCaseId.urlPercentEncoding())"
    }
}

extension UpdateCustomModelDeploymentInput {

    static func urlPathProvider(_ value: UpdateCustomModelDeploymentInput) -> Swift.String? {
        guard let customModelDeploymentIdentifier = value.customModelDeploymentIdentifier else {
            return nil
        }
        return "/model-customization/custom-model-deployments/\(customModelDeploymentIdentifier.urlPercentEncoding())"
    }
}

extension UpdateGuardrailInput {

    static func urlPathProvider(_ value: UpdateGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        return "/guardrails/\(guardrailIdentifier.urlPercentEncoding())"
    }
}

extension UpdateMarketplaceModelEndpointInput {

    static func urlPathProvider(_ value: UpdateMarketplaceModelEndpointInput) -> Swift.String? {
        guard let endpointArn = value.endpointArn else {
            return nil
        }
        return "/marketplace-model/endpoints/\(endpointArn.urlPercentEncoding())"
    }
}

extension UpdateProvisionedModelThroughputInput {

    static func urlPathProvider(_ value: UpdateProvisionedModelThroughputInput) -> Swift.String? {
        guard let provisionedModelId = value.provisionedModelId else {
            return nil
        }
        return "/provisioned-model-throughput/\(provisionedModelId.urlPercentEncoding())"
    }
}

extension BatchDeleteEvaluationJobInput {

    static func write(value: BatchDeleteEvaluationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobIdentifiers"].writeList(value.jobIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAutomatedReasoningPolicyInput {

    static func write(value: CreateAutomatedReasoningPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["policyDefinition"].write(value.policyDefinition, with: BedrockClientTypes.AutomatedReasoningPolicyDefinition.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAutomatedReasoningPolicyTestCaseInput {

    static func write(value: CreateAutomatedReasoningPolicyTestCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["confidenceThreshold"].write(value.confidenceThreshold)
        try writer["expectedAggregatedFindingsResult"].write(value.expectedAggregatedFindingsResult)
        try writer["guardContent"].write(value.guardContent)
        try writer["queryContent"].write(value.queryContent)
    }
}

extension CreateAutomatedReasoningPolicyVersionInput {

    static func write(value: CreateAutomatedReasoningPolicyVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["lastUpdatedDefinitionHash"].write(value.lastUpdatedDefinitionHash)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCustomModelInput {

    static func write(value: CreateCustomModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["modelKmsKeyArn"].write(value.modelKmsKeyArn)
        try writer["modelName"].write(value.modelName)
        try writer["modelSourceConfig"].write(value.modelSourceConfig, with: BedrockClientTypes.ModelDataSource.write(value:to:))
        try writer["modelTags"].writeList(value.modelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension CreateCustomModelDeploymentInput {

    static func write(value: CreateCustomModelDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
        try writer["modelArn"].write(value.modelArn)
        try writer["modelDeploymentName"].write(value.modelDeploymentName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEvaluationJobInput {

    static func write(value: CreateEvaluationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationType"].write(value.applicationType)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["customerEncryptionKeyId"].write(value.customerEncryptionKeyId)
        try writer["evaluationConfig"].write(value.evaluationConfig, with: BedrockClientTypes.EvaluationConfig.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockClientTypes.EvaluationInferenceConfig.write(value:to:))
        try writer["jobDescription"].write(value.jobDescription)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.EvaluationOutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }
}

extension CreateFoundationModelAgreementInput {

    static func write(value: CreateFoundationModelAgreementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelId"].write(value.modelId)
        try writer["offerToken"].write(value.offerToken)
    }
}

extension CreateGuardrailInput {

    static func write(value: CreateGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["automatedReasoningPolicyConfig"].write(value.automatedReasoningPolicyConfig, with: BedrockClientTypes.GuardrailAutomatedReasoningPolicyConfig.write(value:to:))
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: BedrockClientTypes.GuardrailContentPolicyConfig.write(value:to:))
        try writer["contextualGroundingPolicyConfig"].write(value.contextualGroundingPolicyConfig, with: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig.write(value:to:))
        try writer["crossRegionConfig"].write(value.crossRegionConfig, with: BedrockClientTypes.GuardrailCrossRegionConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: BedrockClientTypes.GuardrailTopicPolicyConfig.write(value:to:))
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: BedrockClientTypes.GuardrailWordPolicyConfig.write(value:to:))
    }
}

extension CreateGuardrailVersionInput {

    static func write(value: CreateGuardrailVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
    }
}

extension CreateInferenceProfileInput {

    static func write(value: CreateInferenceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
        try writer["inferenceProfileName"].write(value.inferenceProfileName)
        try writer["modelSource"].write(value.modelSource, with: BedrockClientTypes.InferenceProfileModelSource.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMarketplaceModelEndpointInput {

    static func write(value: CreateMarketplaceModelEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acceptEula"].write(value.acceptEula)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["endpointConfig"].write(value.endpointConfig, with: BedrockClientTypes.EndpointConfig.write(value:to:))
        try writer["endpointName"].write(value.endpointName)
        try writer["modelSourceIdentifier"].write(value.modelSourceIdentifier)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateModelCopyJobInput {

    static func write(value: CreateModelCopyJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["modelKmsKeyId"].write(value.modelKmsKeyId)
        try writer["sourceModelArn"].write(value.sourceModelArn)
        try writer["targetModelName"].write(value.targetModelName)
        try writer["targetModelTags"].writeList(value.targetModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateModelCustomizationJobInput {

    static func write(value: CreateModelCustomizationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseModelIdentifier"].write(value.baseModelIdentifier)
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["customModelKmsKeyId"].write(value.customModelKmsKeyId)
        try writer["customModelName"].write(value.customModelName)
        try writer["customModelTags"].writeList(value.customModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["customizationConfig"].write(value.customizationConfig, with: BedrockClientTypes.CustomizationConfig.write(value:to:))
        try writer["customizationType"].write(value.customizationType)
        try writer["hyperParameters"].writeMap(value.hyperParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.OutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["trainingDataConfig"].write(value.trainingDataConfig, with: BedrockClientTypes.TrainingDataConfig.write(value:to:))
        try writer["validationDataConfig"].write(value.validationDataConfig, with: BedrockClientTypes.ValidationDataConfig.write(value:to:))
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateModelImportJobInput {

    static func write(value: CreateModelImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["importedModelKmsKeyId"].write(value.importedModelKmsKeyId)
        try writer["importedModelName"].write(value.importedModelName)
        try writer["importedModelTags"].writeList(value.importedModelTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["jobName"].write(value.jobName)
        try writer["jobTags"].writeList(value.jobTags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modelDataSource"].write(value.modelDataSource, with: BedrockClientTypes.ModelDataSource.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateModelInvocationJobInput {

    static func write(value: CreateModelInvocationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["inputDataConfig"].write(value.inputDataConfig, with: BedrockClientTypes.ModelInvocationJobInputDataConfig.write(value:to:))
        try writer["jobName"].write(value.jobName)
        try writer["modelId"].write(value.modelId)
        try writer["outputDataConfig"].write(value.outputDataConfig, with: BedrockClientTypes.ModelInvocationJobOutputDataConfig.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeoutDurationInHours"].write(value.timeoutDurationInHours)
        try writer["vpcConfig"].write(value.vpcConfig, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreatePromptRouterInput {

    static func write(value: CreatePromptRouterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["description"].write(value.description)
        try writer["fallbackModel"].write(value.fallbackModel, with: BedrockClientTypes.PromptRouterTargetModel.write(value:to:))
        try writer["models"].writeList(value.models, memberWritingClosure: BedrockClientTypes.PromptRouterTargetModel.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["promptRouterName"].write(value.promptRouterName)
        try writer["routingCriteria"].write(value.routingCriteria, with: BedrockClientTypes.RoutingCriteria.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProvisionedModelThroughputInput {

    static func write(value: CreateProvisionedModelThroughputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["commitmentDuration"].write(value.commitmentDuration)
        try writer["modelId"].write(value.modelId)
        try writer["modelUnits"].write(value.modelUnits)
        try writer["provisionedModelName"].write(value.provisionedModelName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteFoundationModelAgreementInput {

    static func write(value: DeleteFoundationModelAgreementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelId"].write(value.modelId)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
    }
}

extension PutEnforcedGuardrailConfigurationInput {

    static func write(value: PutEnforcedGuardrailConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configId"].write(value.configId)
        try writer["guardrailInferenceConfig"].write(value.guardrailInferenceConfig, with: BedrockClientTypes.AccountEnforcedGuardrailInferenceInputConfiguration.write(value:to:))
    }
}

extension PutModelInvocationLoggingConfigurationInput {

    static func write(value: PutModelInvocationLoggingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["loggingConfig"].write(value.loggingConfig, with: BedrockClientTypes.LoggingConfig.write(value:to:))
    }
}

extension PutUseCaseForModelAccessInput {

    static func write(value: PutUseCaseForModelAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["formData"].write(value.formData)
    }
}

extension RegisterMarketplaceModelEndpointInput {

    static func write(value: RegisterMarketplaceModelEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelSourceIdentifier"].write(value.modelSourceIdentifier)
    }
}

extension StartAutomatedReasoningPolicyBuildWorkflowInput {

    static func write(value: StartAutomatedReasoningPolicyBuildWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceContent"].write(value.sourceContent, with: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSource.write(value:to:))
    }
}

extension StartAutomatedReasoningPolicyTestWorkflowInput {

    static func write(value: StartAutomatedReasoningPolicyTestWorkflowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["testCaseIds"].writeList(value.testCaseIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAutomatedReasoningPolicyInput {

    static func write(value: UpdateAutomatedReasoningPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["policyDefinition"].write(value.policyDefinition, with: BedrockClientTypes.AutomatedReasoningPolicyDefinition.write(value:to:))
    }
}

extension UpdateAutomatedReasoningPolicyAnnotationsInput {

    static func write(value: UpdateAutomatedReasoningPolicyAnnotationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["annotations"].writeList(value.annotations, memberWritingClosure: BedrockClientTypes.AutomatedReasoningPolicyAnnotation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lastUpdatedAnnotationSetHash"].write(value.lastUpdatedAnnotationSetHash)
    }
}

extension UpdateAutomatedReasoningPolicyTestCaseInput {

    static func write(value: UpdateAutomatedReasoningPolicyTestCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["confidenceThreshold"].write(value.confidenceThreshold)
        try writer["expectedAggregatedFindingsResult"].write(value.expectedAggregatedFindingsResult)
        try writer["guardContent"].write(value.guardContent)
        try writer["lastUpdatedAt"].writeTimestamp(value.lastUpdatedAt, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["queryContent"].write(value.queryContent)
    }
}

extension UpdateCustomModelDeploymentInput {

    static func write(value: UpdateCustomModelDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelArn"].write(value.modelArn)
    }
}

extension UpdateGuardrailInput {

    static func write(value: UpdateGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["automatedReasoningPolicyConfig"].write(value.automatedReasoningPolicyConfig, with: BedrockClientTypes.GuardrailAutomatedReasoningPolicyConfig.write(value:to:))
        try writer["blockedInputMessaging"].write(value.blockedInputMessaging)
        try writer["blockedOutputsMessaging"].write(value.blockedOutputsMessaging)
        try writer["contentPolicyConfig"].write(value.contentPolicyConfig, with: BedrockClientTypes.GuardrailContentPolicyConfig.write(value:to:))
        try writer["contextualGroundingPolicyConfig"].write(value.contextualGroundingPolicyConfig, with: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig.write(value:to:))
        try writer["crossRegionConfig"].write(value.crossRegionConfig, with: BedrockClientTypes.GuardrailCrossRegionConfig.write(value:to:))
        try writer["description"].write(value.description)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["sensitiveInformationPolicyConfig"].write(value.sensitiveInformationPolicyConfig, with: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig.write(value:to:))
        try writer["topicPolicyConfig"].write(value.topicPolicyConfig, with: BedrockClientTypes.GuardrailTopicPolicyConfig.write(value:to:))
        try writer["wordPolicyConfig"].write(value.wordPolicyConfig, with: BedrockClientTypes.GuardrailWordPolicyConfig.write(value:to:))
    }
}

extension UpdateMarketplaceModelEndpointInput {

    static func write(value: UpdateMarketplaceModelEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["endpointConfig"].write(value.endpointConfig, with: BedrockClientTypes.EndpointConfig.write(value:to:))
    }
}

extension UpdateProvisionedModelThroughputInput {

    static func write(value: UpdateProvisionedModelThroughputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredModelId"].write(value.desiredModelId)
        try writer["desiredProvisionedModelName"].write(value.desiredProvisionedModelName)
    }
}

extension BatchDeleteEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteEvaluationJobOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BedrockClientTypes.BatchDeleteEvaluationJobError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.evaluationJobs = try reader["evaluationJobs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.BatchDeleteEvaluationJobItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CancelAutomatedReasoningPolicyBuildWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelAutomatedReasoningPolicyBuildWorkflowOutput {
        return CancelAutomatedReasoningPolicyBuildWorkflowOutput()
    }
}

extension CreateAutomatedReasoningPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAutomatedReasoningPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAutomatedReasoningPolicyOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.definitionHash = try reader["definitionHash"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAutomatedReasoningPolicyTestCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAutomatedReasoningPolicyTestCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAutomatedReasoningPolicyTestCaseOutput()
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.testCaseId = try reader["testCaseId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAutomatedReasoningPolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAutomatedReasoningPolicyVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAutomatedReasoningPolicyVersionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.definitionHash = try reader["definitionHash"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateCustomModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomModelOutput()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateCustomModelDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomModelDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomModelDeploymentOutput()
        value.customModelDeploymentArn = try reader["customModelDeploymentArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEvaluationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateFoundationModelAgreementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFoundationModelAgreementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFoundationModelAgreementOutput()
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGuardrailOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.guardrailArn = try reader["guardrailArn"].readIfPresent() ?? ""
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateGuardrailVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGuardrailVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGuardrailVersionOutput()
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateInferenceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInferenceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInferenceProfileOutput()
        value.inferenceProfileArn = try reader["inferenceProfileArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMarketplaceModelEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMarketplaceModelEndpointOutput()
        value.marketplaceModelEndpoint = try reader["marketplaceModelEndpoint"].readIfPresent(with: BedrockClientTypes.MarketplaceModelEndpoint.read(from:))
        return value
    }
}

extension CreateModelCopyJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelCopyJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelCopyJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelCustomizationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelCustomizationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelImportJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelInvocationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelInvocationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelInvocationJobOutput()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreatePromptRouterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePromptRouterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePromptRouterOutput()
        value.promptRouterArn = try reader["promptRouterArn"].readIfPresent()
        return value
    }
}

extension CreateProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisionedModelThroughputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisionedModelThroughputOutput()
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAutomatedReasoningPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAutomatedReasoningPolicyOutput {
        return DeleteAutomatedReasoningPolicyOutput()
    }
}

extension DeleteAutomatedReasoningPolicyBuildWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAutomatedReasoningPolicyBuildWorkflowOutput {
        return DeleteAutomatedReasoningPolicyBuildWorkflowOutput()
    }
}

extension DeleteAutomatedReasoningPolicyTestCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAutomatedReasoningPolicyTestCaseOutput {
        return DeleteAutomatedReasoningPolicyTestCaseOutput()
    }
}

extension DeleteCustomModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomModelOutput {
        return DeleteCustomModelOutput()
    }
}

extension DeleteCustomModelDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomModelDeploymentOutput {
        return DeleteCustomModelDeploymentOutput()
    }
}

extension DeleteEnforcedGuardrailConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnforcedGuardrailConfigurationOutput {
        return DeleteEnforcedGuardrailConfigurationOutput()
    }
}

extension DeleteFoundationModelAgreementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFoundationModelAgreementOutput {
        return DeleteFoundationModelAgreementOutput()
    }
}

extension DeleteGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGuardrailOutput {
        return DeleteGuardrailOutput()
    }
}

extension DeleteImportedModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImportedModelOutput {
        return DeleteImportedModelOutput()
    }
}

extension DeleteInferenceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInferenceProfileOutput {
        return DeleteInferenceProfileOutput()
    }
}

extension DeleteMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMarketplaceModelEndpointOutput {
        return DeleteMarketplaceModelEndpointOutput()
    }
}

extension DeleteModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelInvocationLoggingConfigurationOutput {
        return DeleteModelInvocationLoggingConfigurationOutput()
    }
}

extension DeletePromptRouterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePromptRouterOutput {
        return DeletePromptRouterOutput()
    }
}

extension DeleteProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisionedModelThroughputOutput {
        return DeleteProvisionedModelThroughputOutput()
    }
}

extension DeregisterMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterMarketplaceModelEndpointOutput {
        return DeregisterMarketplaceModelEndpointOutput()
    }
}

extension ExportAutomatedReasoningPolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportAutomatedReasoningPolicyVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportAutomatedReasoningPolicyVersionOutput()
        value.policyDefinition = try reader.readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyDefinition.read(from:))
        return value
    }
}

extension GetAutomatedReasoningPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomatedReasoningPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomatedReasoningPolicyOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.definitionHash = try reader["definitionHash"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.policyId = try reader["policyId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension GetAutomatedReasoningPolicyAnnotationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomatedReasoningPolicyAnnotationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomatedReasoningPolicyAnnotationsOutput()
        value.annotationSetHash = try reader["annotationSetHash"].readIfPresent() ?? ""
        value.annotations = try reader["annotations"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyAnnotation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.buildWorkflowId = try reader["buildWorkflowId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetAutomatedReasoningPolicyBuildWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomatedReasoningPolicyBuildWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomatedReasoningPolicyBuildWorkflowOutput()
        value.buildWorkflowId = try reader["buildWorkflowId"].readIfPresent() ?? ""
        value.buildWorkflowType = try reader["buildWorkflowType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.documentContentType = try reader["documentContentType"].readIfPresent()
        value.documentDescription = try reader["documentDescription"].readIfPresent()
        value.documentName = try reader["documentName"].readIfPresent()
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetAutomatedReasoningPolicyBuildWorkflowResultAssetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomatedReasoningPolicyBuildWorkflowResultAssetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomatedReasoningPolicyBuildWorkflowResultAssetsOutput()
        value.buildWorkflowAssets = try reader["buildWorkflowAssets"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyBuildResultAssets.read(from:))
        value.buildWorkflowId = try reader["buildWorkflowId"].readIfPresent() ?? ""
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetAutomatedReasoningPolicyNextScenarioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomatedReasoningPolicyNextScenarioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomatedReasoningPolicyNextScenarioOutput()
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.scenario = try reader["scenario"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyScenario.read(from:))
        return value
    }
}

extension GetAutomatedReasoningPolicyTestCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomatedReasoningPolicyTestCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomatedReasoningPolicyTestCaseOutput()
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.testCase = try reader["testCase"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyTestCase.read(from:))
        return value
    }
}

extension GetAutomatedReasoningPolicyTestResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomatedReasoningPolicyTestResultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomatedReasoningPolicyTestResultOutput()
        value.testResult = try reader["testResult"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyTestResult.read(from:))
        return value
    }
}

extension GetCustomModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomModelOutput()
        value.baseModelArn = try reader["baseModelArn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customizationConfig = try reader["customizationConfig"].readIfPresent(with: BedrockClientTypes.CustomizationConfig.read(from:))
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelKmsKeyArn = try reader["modelKmsKeyArn"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent() ?? ""
        value.modelStatus = try reader["modelStatus"].readIfPresent()
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.OutputDataConfig.read(from:))
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: BedrockClientTypes.TrainingDataConfig.read(from:))
        value.trainingMetrics = try reader["trainingMetrics"].readIfPresent(with: BedrockClientTypes.TrainingMetrics.read(from:))
        value.validationDataConfig = try reader["validationDataConfig"].readIfPresent(with: BedrockClientTypes.ValidationDataConfig.read(from:))
        value.validationMetrics = try reader["validationMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ValidatorMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetCustomModelDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomModelDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomModelDeploymentOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customModelDeploymentArn = try reader["customModelDeploymentArn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelDeploymentName = try reader["modelDeploymentName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updateDetails = try reader["updateDetails"].readIfPresent(with: BedrockClientTypes.CustomModelDeploymentUpdateDetails.read(from:))
        return value
    }
}

extension GetEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEvaluationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEvaluationJobOutput()
        value.applicationType = try reader["applicationType"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyId = try reader["customerEncryptionKeyId"].readIfPresent()
        value.evaluationConfig = try reader["evaluationConfig"].readIfPresent(with: BedrockClientTypes.EvaluationConfig.read(from:))
        value.failureMessages = try reader["failureMessages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceConfig = try reader["inferenceConfig"].readIfPresent(with: BedrockClientTypes.EvaluationInferenceConfig.read(from:))
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobDescription = try reader["jobDescription"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.jobType = try reader["jobType"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.EvaluationOutputDataConfig.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetFoundationModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFoundationModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFoundationModelOutput()
        value.modelDetails = try reader["modelDetails"].readIfPresent(with: BedrockClientTypes.FoundationModelDetails.read(from:))
        return value
    }
}

extension GetFoundationModelAvailabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFoundationModelAvailabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFoundationModelAvailabilityOutput()
        value.agreementAvailability = try reader["agreementAvailability"].readIfPresent(with: BedrockClientTypes.AgreementAvailability.read(from:))
        value.authorizationStatus = try reader["authorizationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.entitlementAvailability = try reader["entitlementAvailability"].readIfPresent() ?? .sdkUnknown("")
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.regionAvailability = try reader["regionAvailability"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGuardrailOutput()
        value.automatedReasoningPolicy = try reader["automatedReasoningPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailAutomatedReasoningPolicy.read(from:))
        value.blockedInputMessaging = try reader["blockedInputMessaging"].readIfPresent() ?? ""
        value.blockedOutputsMessaging = try reader["blockedOutputsMessaging"].readIfPresent() ?? ""
        value.contentPolicy = try reader["contentPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailContentPolicy.read(from:))
        value.contextualGroundingPolicy = try reader["contextualGroundingPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailContextualGroundingPolicy.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.crossRegionDetails = try reader["crossRegionDetails"].readIfPresent(with: BedrockClientTypes.GuardrailCrossRegionDetails.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.failureRecommendations = try reader["failureRecommendations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.guardrailArn = try reader["guardrailArn"].readIfPresent() ?? ""
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sensitiveInformationPolicy = try reader["sensitiveInformationPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailSensitiveInformationPolicy.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReasons = try reader["statusReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.topicPolicy = try reader["topicPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailTopicPolicy.read(from:))
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        value.wordPolicy = try reader["wordPolicy"].readIfPresent(with: BedrockClientTypes.GuardrailWordPolicy.read(from:))
        return value
    }
}

extension GetImportedModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportedModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportedModelOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customModelUnits = try reader["customModelUnits"].readIfPresent(with: BedrockClientTypes.CustomModelUnits.read(from:))
        value.instructSupported = try reader["instructSupported"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.modelArchitecture = try reader["modelArchitecture"].readIfPresent()
        value.modelArn = try reader["modelArn"].readIfPresent()
        value.modelDataSource = try reader["modelDataSource"].readIfPresent(with: BedrockClientTypes.ModelDataSource.read(from:))
        value.modelKmsKeyArn = try reader["modelKmsKeyArn"].readIfPresent()
        value.modelName = try reader["modelName"].readIfPresent()
        return value
    }
}

extension GetInferenceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInferenceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInferenceProfileOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.inferenceProfileArn = try reader["inferenceProfileArn"].readIfPresent() ?? ""
        value.inferenceProfileId = try reader["inferenceProfileId"].readIfPresent() ?? ""
        value.inferenceProfileName = try reader["inferenceProfileName"].readIfPresent() ?? ""
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceProfileModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMarketplaceModelEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMarketplaceModelEndpointOutput()
        value.marketplaceModelEndpoint = try reader["marketplaceModelEndpoint"].readIfPresent(with: BedrockClientTypes.MarketplaceModelEndpoint.read(from:))
        return value
    }
}

extension GetModelCopyJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelCopyJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelCopyJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.sourceAccountId = try reader["sourceAccountId"].readIfPresent() ?? ""
        value.sourceModelArn = try reader["sourceModelArn"].readIfPresent() ?? ""
        value.sourceModelName = try reader["sourceModelName"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.targetModelArn = try reader["targetModelArn"].readIfPresent() ?? ""
        value.targetModelKmsKeyArn = try reader["targetModelKmsKeyArn"].readIfPresent()
        value.targetModelName = try reader["targetModelName"].readIfPresent()
        value.targetModelTags = try reader["targetModelTags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelCustomizationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelCustomizationJobOutput()
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customizationConfig = try reader["customizationConfig"].readIfPresent(with: BedrockClientTypes.CustomizationConfig.read(from:))
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.hyperParameters = try reader["hyperParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.OutputDataConfig.read(from:))
        value.outputModelArn = try reader["outputModelArn"].readIfPresent()
        value.outputModelKmsKeyArn = try reader["outputModelKmsKeyArn"].readIfPresent()
        value.outputModelName = try reader["outputModelName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusDetails = try reader["statusDetails"].readIfPresent(with: BedrockClientTypes.StatusDetails.read(from:))
        value.trainingDataConfig = try reader["trainingDataConfig"].readIfPresent(with: BedrockClientTypes.TrainingDataConfig.read(from:))
        value.trainingMetrics = try reader["trainingMetrics"].readIfPresent(with: BedrockClientTypes.TrainingMetrics.read(from:))
        value.validationDataConfig = try reader["validationDataConfig"].readIfPresent(with: BedrockClientTypes.ValidationDataConfig.read(from:))
        value.validationMetrics = try reader["validationMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ValidatorMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension GetModelImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelImportJobOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.importedModelArn = try reader["importedModelArn"].readIfPresent()
        value.importedModelKmsKeyArn = try reader["importedModelKmsKeyArn"].readIfPresent()
        value.importedModelName = try reader["importedModelName"].readIfPresent()
        value.jobArn = try reader["jobArn"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.modelDataSource = try reader["modelDataSource"].readIfPresent(with: BedrockClientTypes.ModelDataSource.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension GetModelInvocationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelInvocationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelInvocationJobOutput()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.inputDataConfig = try reader["inputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobInputDataConfig.read(from:))
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobExpirationTime = try reader["jobExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.jobName = try reader["jobName"].readIfPresent()
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.message = try reader["message"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobOutputDataConfig.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.submitTime = try reader["submitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timeoutDurationInHours = try reader["timeoutDurationInHours"].readIfPresent()
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension GetModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelInvocationLoggingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelInvocationLoggingConfigurationOutput()
        value.loggingConfig = try reader["loggingConfig"].readIfPresent(with: BedrockClientTypes.LoggingConfig.read(from:))
        return value
    }
}

extension GetPromptRouterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPromptRouterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPromptRouterOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.fallbackModel = try reader["fallbackModel"].readIfPresent(with: BedrockClientTypes.PromptRouterTargetModel.read(from:))
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.PromptRouterTargetModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.promptRouterArn = try reader["promptRouterArn"].readIfPresent() ?? ""
        value.promptRouterName = try reader["promptRouterName"].readIfPresent() ?? ""
        value.routingCriteria = try reader["routingCriteria"].readIfPresent(with: BedrockClientTypes.RoutingCriteria.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProvisionedModelThroughputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProvisionedModelThroughputOutput()
        value.commitmentDuration = try reader["commitmentDuration"].readIfPresent()
        value.commitmentExpirationTime = try reader["commitmentExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.desiredModelArn = try reader["desiredModelArn"].readIfPresent() ?? ""
        value.desiredModelUnits = try reader["desiredModelUnits"].readIfPresent() ?? 0
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.foundationModelArn = try reader["foundationModelArn"].readIfPresent() ?? ""
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelUnits = try reader["modelUnits"].readIfPresent() ?? 0
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent() ?? ""
        value.provisionedModelName = try reader["provisionedModelName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetUseCaseForModelAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUseCaseForModelAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUseCaseForModelAccessOutput()
        value.formData = try reader["formData"].readIfPresent() ?? Foundation.Data(base64Encoded: "")
        return value
    }
}

extension ListAutomatedReasoningPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomatedReasoningPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomatedReasoningPoliciesOutput()
        value.automatedReasoningPolicySummaries = try reader["automatedReasoningPolicySummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAutomatedReasoningPolicyBuildWorkflowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomatedReasoningPolicyBuildWorkflowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomatedReasoningPolicyBuildWorkflowsOutput()
        value.automatedReasoningPolicyBuildWorkflowSummaries = try reader["automatedReasoningPolicyBuildWorkflowSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAutomatedReasoningPolicyTestCasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomatedReasoningPolicyTestCasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomatedReasoningPolicyTestCasesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testCases = try reader["testCases"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyTestCase.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListAutomatedReasoningPolicyTestResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomatedReasoningPolicyTestResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomatedReasoningPolicyTestResultsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testResults = try reader["testResults"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyTestResult.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListCustomModelDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomModelDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomModelDeploymentsOutput()
        value.modelDeploymentSummaries = try reader["modelDeploymentSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.CustomModelDeploymentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCustomModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.CustomModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnforcedGuardrailsConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnforcedGuardrailsConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnforcedGuardrailsConfigurationOutput()
        value.guardrailsConfig = try reader["guardrailsConfig"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AccountEnforcedGuardrailOutputConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEvaluationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEvaluationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEvaluationJobsOutput()
        value.jobSummaries = try reader["jobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFoundationModelAgreementOffersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFoundationModelAgreementOffersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFoundationModelAgreementOffersOutput()
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.offers = try reader["offers"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Offer.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListFoundationModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFoundationModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFoundationModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.FoundationModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListGuardrailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGuardrailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGuardrailsOutput()
        value.guardrails = try reader["guardrails"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImportedModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportedModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportedModelsOutput()
        value.modelSummaries = try reader["modelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ImportedModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListInferenceProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInferenceProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInferenceProfilesOutput()
        value.inferenceProfileSummaries = try reader["inferenceProfileSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMarketplaceModelEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMarketplaceModelEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMarketplaceModelEndpointsOutput()
        value.marketplaceModelEndpoints = try reader["marketplaceModelEndpoints"].readListIfPresent(memberReadingClosure: BedrockClientTypes.MarketplaceModelEndpointSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelCopyJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelCopyJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelCopyJobsOutput()
        value.modelCopyJobSummaries = try reader["modelCopyJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelCopyJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelCustomizationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelCustomizationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelCustomizationJobsOutput()
        value.modelCustomizationJobSummaries = try reader["modelCustomizationJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelCustomizationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelImportJobsOutput()
        value.modelImportJobSummaries = try reader["modelImportJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelImportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelInvocationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelInvocationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelInvocationJobsOutput()
        value.invocationJobSummaries = try reader["invocationJobSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ModelInvocationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPromptRoutersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPromptRoutersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPromptRoutersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.promptRouterSummaries = try reader["promptRouterSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.PromptRouterSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProvisionedModelThroughputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisionedModelThroughputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisionedModelThroughputsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.provisionedModelSummaries = try reader["provisionedModelSummaries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ProvisionedModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutEnforcedGuardrailConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEnforcedGuardrailConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEnforcedGuardrailConfigurationOutput()
        value.configId = try reader["configId"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension PutModelInvocationLoggingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutModelInvocationLoggingConfigurationOutput {
        return PutModelInvocationLoggingConfigurationOutput()
    }
}

extension PutUseCaseForModelAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutUseCaseForModelAccessOutput {
        return PutUseCaseForModelAccessOutput()
    }
}

extension RegisterMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterMarketplaceModelEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterMarketplaceModelEndpointOutput()
        value.marketplaceModelEndpoint = try reader["marketplaceModelEndpoint"].readIfPresent(with: BedrockClientTypes.MarketplaceModelEndpoint.read(from:))
        return value
    }
}

extension StartAutomatedReasoningPolicyBuildWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAutomatedReasoningPolicyBuildWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAutomatedReasoningPolicyBuildWorkflowOutput()
        value.buildWorkflowId = try reader["buildWorkflowId"].readIfPresent() ?? ""
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        return value
    }
}

extension StartAutomatedReasoningPolicyTestWorkflowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAutomatedReasoningPolicyTestWorkflowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAutomatedReasoningPolicyTestWorkflowOutput()
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        return value
    }
}

extension StopEvaluationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopEvaluationJobOutput {
        return StopEvaluationJobOutput()
    }
}

extension StopModelCustomizationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopModelCustomizationJobOutput {
        return StopModelCustomizationJobOutput()
    }
}

extension StopModelInvocationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopModelInvocationJobOutput {
        return StopModelInvocationJobOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAutomatedReasoningPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAutomatedReasoningPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAutomatedReasoningPolicyOutput()
        value.definitionHash = try reader["definitionHash"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateAutomatedReasoningPolicyAnnotationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAutomatedReasoningPolicyAnnotationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAutomatedReasoningPolicyAnnotationsOutput()
        value.annotationSetHash = try reader["annotationSetHash"].readIfPresent() ?? ""
        value.buildWorkflowId = try reader["buildWorkflowId"].readIfPresent() ?? ""
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateAutomatedReasoningPolicyTestCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAutomatedReasoningPolicyTestCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAutomatedReasoningPolicyTestCaseOutput()
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.testCaseId = try reader["testCaseId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateCustomModelDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCustomModelDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCustomModelDeploymentOutput()
        value.customModelDeploymentArn = try reader["customModelDeploymentArn"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGuardrailOutput()
        value.guardrailArn = try reader["guardrailArn"].readIfPresent() ?? ""
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateMarketplaceModelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMarketplaceModelEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMarketplaceModelEndpointOutput()
        value.marketplaceModelEndpoint = try reader["marketplaceModelEndpoint"].readIfPresent(with: BedrockClientTypes.MarketplaceModelEndpoint.read(from:))
        return value
    }
}

extension UpdateProvisionedModelThroughputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProvisionedModelThroughputOutput {
        return UpdateProvisionedModelThroughputOutput()
    }
}

enum BatchDeleteEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelAutomatedReasoningPolicyBuildWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAutomatedReasoningPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAutomatedReasoningPolicyTestCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAutomatedReasoningPolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomModelDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFoundationModelAgreementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGuardrailVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInferenceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelCopyJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelCustomizationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelInvocationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePromptRouterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAutomatedReasoningPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAutomatedReasoningPolicyBuildWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAutomatedReasoningPolicyTestCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomModelDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnforcedGuardrailConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFoundationModelAgreementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImportedModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInferenceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePromptRouterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportAutomatedReasoningPolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomatedReasoningPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomatedReasoningPolicyAnnotationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomatedReasoningPolicyBuildWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomatedReasoningPolicyBuildWorkflowResultAssetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomatedReasoningPolicyNextScenarioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomatedReasoningPolicyTestCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomatedReasoningPolicyTestResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomModelDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFoundationModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFoundationModelAvailabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportedModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInferenceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelCopyJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelCustomizationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelInvocationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPromptRouterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUseCaseForModelAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomatedReasoningPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomatedReasoningPolicyBuildWorkflowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomatedReasoningPolicyTestCasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomatedReasoningPolicyTestResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomModelDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnforcedGuardrailsConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEvaluationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFoundationModelAgreementOffersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFoundationModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGuardrailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportedModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInferenceProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMarketplaceModelEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelCopyJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelCustomizationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelInvocationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPromptRoutersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisionedModelThroughputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEnforcedGuardrailConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutModelInvocationLoggingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutUseCaseForModelAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAutomatedReasoningPolicyBuildWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAutomatedReasoningPolicyTestWorkflowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopEvaluationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopModelCustomizationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopModelInvocationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAutomatedReasoningPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAutomatedReasoningPolicyAnnotationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAutomatedReasoningPolicyTestCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCustomModelDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMarketplaceModelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProvisionedModelThroughputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockClientTypes.AccountEnforcedGuardrailInferenceInputConfiguration {

    static func write(value: BedrockClientTypes.AccountEnforcedGuardrailInferenceInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailIdentifier"].write(value.guardrailIdentifier)
        try writer["guardrailVersion"].write(value.guardrailVersion)
        try writer["inputTags"].write(value.inputTags)
    }
}

extension BedrockClientTypes.AccountEnforcedGuardrailOutputConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AccountEnforcedGuardrailOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AccountEnforcedGuardrailOutputConfiguration()
        value.configId = try reader["configId"].readIfPresent()
        value.guardrailArn = try reader["guardrailArn"].readIfPresent()
        value.guardrailId = try reader["guardrailId"].readIfPresent()
        value.inputTags = try reader["inputTags"].readIfPresent()
        value.guardrailVersion = try reader["guardrailVersion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AgreementAvailability {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AgreementAvailability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AgreementAvailability()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedEvaluationConfig {

    static func write(value: BedrockClientTypes.AutomatedEvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customMetricConfig"].write(value.customMetricConfig, with: BedrockClientTypes.AutomatedEvaluationCustomMetricConfig.write(value:to:))
        try writer["datasetMetricConfigs"].writeList(value.datasetMetricConfigs, memberWritingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["evaluatorModelConfig"].write(value.evaluatorModelConfig, with: BedrockClientTypes.EvaluatorModelConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedEvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedEvaluationConfig()
        value.datasetMetricConfigs = try reader["datasetMetricConfigs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.evaluatorModelConfig = try reader["evaluatorModelConfig"].readIfPresent(with: BedrockClientTypes.EvaluatorModelConfig.read(from:))
        value.customMetricConfig = try reader["customMetricConfig"].readIfPresent(with: BedrockClientTypes.AutomatedEvaluationCustomMetricConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedEvaluationCustomMetricConfig {

    static func write(value: BedrockClientTypes.AutomatedEvaluationCustomMetricConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customMetrics"].writeList(value.customMetrics, memberWritingClosure: BedrockClientTypes.AutomatedEvaluationCustomMetricSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["evaluatorModelConfig"].write(value.evaluatorModelConfig, with: BedrockClientTypes.CustomMetricEvaluatorModelConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedEvaluationCustomMetricConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedEvaluationCustomMetricConfig()
        value.customMetrics = try reader["customMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedEvaluationCustomMetricSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.evaluatorModelConfig = try reader["evaluatorModelConfig"].readIfPresent(with: BedrockClientTypes.CustomMetricEvaluatorModelConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedEvaluationCustomMetricSource {

    static func write(value: BedrockClientTypes.AutomatedEvaluationCustomMetricSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .custommetricdefinition(custommetricdefinition):
                try writer["customMetricDefinition"].write(custommetricdefinition, with: BedrockClientTypes.CustomMetricDefinition.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedEvaluationCustomMetricSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "customMetricDefinition":
                return .custommetricdefinition(try reader["customMetricDefinition"].read(with: BedrockClientTypes.CustomMetricDefinition.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "valid":
                return .valid(try reader["valid"].read(with: BedrockClientTypes.AutomatedReasoningCheckValidFinding.read(from:)))
            case "invalid":
                return .invalid(try reader["invalid"].read(with: BedrockClientTypes.AutomatedReasoningCheckInvalidFinding.read(from:)))
            case "satisfiable":
                return .satisfiable(try reader["satisfiable"].read(with: BedrockClientTypes.AutomatedReasoningCheckSatisfiableFinding.read(from:)))
            case "impossible":
                return .impossible(try reader["impossible"].read(with: BedrockClientTypes.AutomatedReasoningCheckImpossibleFinding.read(from:)))
            case "translationAmbiguous":
                return .translationambiguous(try reader["translationAmbiguous"].read(with: BedrockClientTypes.AutomatedReasoningCheckTranslationAmbiguousFinding.read(from:)))
            case "tooComplex":
                return .toocomplex(try reader["tooComplex"].read(with: BedrockClientTypes.AutomatedReasoningCheckTooComplexFinding.read(from:)))
            case "noTranslations":
                return .notranslations(try reader["noTranslations"].read(with: BedrockClientTypes.AutomatedReasoningCheckNoTranslationsFinding.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckImpossibleFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckImpossibleFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckImpossibleFinding()
        value.translation = try reader["translation"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckTranslation.read(from:))
        value.contradictingRules = try reader["contradictingRules"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningCheckRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.logicWarning = try reader["logicWarning"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckLogicWarning.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckInputTextReference {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckInputTextReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckInputTextReference()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckInvalidFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckInvalidFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckInvalidFinding()
        value.translation = try reader["translation"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckTranslation.read(from:))
        value.contradictingRules = try reader["contradictingRules"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningCheckRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.logicWarning = try reader["logicWarning"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckLogicWarning.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckLogicWarning {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckLogicWarning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckLogicWarning()
        value.type = try reader["type"].readIfPresent()
        value.premises = try reader["premises"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningLogicStatement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.claims = try reader["claims"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningLogicStatement.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckNoTranslationsFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckNoTranslationsFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockClientTypes.AutomatedReasoningCheckNoTranslationsFinding()
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckRule {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckRule()
        value.id = try reader["id"].readIfPresent()
        value.policyVersionArn = try reader["policyVersionArn"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckSatisfiableFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckSatisfiableFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckSatisfiableFinding()
        value.translation = try reader["translation"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckTranslation.read(from:))
        value.claimsTrueScenario = try reader["claimsTrueScenario"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckScenario.read(from:))
        value.claimsFalseScenario = try reader["claimsFalseScenario"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckScenario.read(from:))
        value.logicWarning = try reader["logicWarning"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckLogicWarning.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckScenario {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckScenario {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckScenario()
        value.statements = try reader["statements"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningLogicStatement.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckTooComplexFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckTooComplexFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockClientTypes.AutomatedReasoningCheckTooComplexFinding()
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckTranslation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckTranslation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckTranslation()
        value.premises = try reader["premises"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningLogicStatement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.claims = try reader["claims"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningLogicStatement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.untranslatedPremises = try reader["untranslatedPremises"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningCheckInputTextReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.untranslatedClaims = try reader["untranslatedClaims"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningCheckInputTextReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.confidence = try reader["confidence"].readIfPresent() ?? 0.0
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckTranslationAmbiguousFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckTranslationAmbiguousFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckTranslationAmbiguousFinding()
        value.options = try reader["options"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningCheckTranslationOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.differenceScenarios = try reader["differenceScenarios"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningCheckScenario.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckTranslationOption {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckTranslationOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckTranslationOption()
        value.translations = try reader["translations"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningCheckTranslation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningCheckValidFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningCheckValidFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningCheckValidFinding()
        value.translation = try reader["translation"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckTranslation.read(from:))
        value.claimsTrueScenario = try reader["claimsTrueScenario"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckScenario.read(from:))
        value.supportingRules = try reader["supportingRules"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningCheckRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.logicWarning = try reader["logicWarning"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningCheckLogicWarning.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningLogicStatement {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningLogicStatement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningLogicStatement()
        value.logic = try reader["logic"].readIfPresent() ?? ""
        value.naturalLanguage = try reader["naturalLanguage"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddRuleAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyAddRuleAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expression"].write(value.expression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyAddRuleAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyAddRuleAnnotation()
        value.expression = try reader["expression"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["naturalLanguage"].write(value.naturalLanguage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation()
        value.naturalLanguage = try reader["naturalLanguage"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddRuleMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyAddRuleMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyAddRuleMutation()
        value.rule = try reader["rule"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddTypeAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyAddTypeAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyAddTypeAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyAddTypeAnnotation()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddTypeMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyAddTypeMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyAddTypeMutation()
        value.type = try reader["type"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddTypeValue {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyAddTypeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyAddTypeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyAddTypeValue()
        value.value = try reader["value"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddVariableAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyAddVariableAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyAddVariableAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyAddVariableAnnotation()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAddVariableMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyAddVariableMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyAddVariableMutation()
        value.variable = try reader["variable"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .addrule(addrule):
                try writer["addRule"].write(addrule, with: BedrockClientTypes.AutomatedReasoningPolicyAddRuleAnnotation.write(value:to:))
            case let .addrulefromnaturallanguage(addrulefromnaturallanguage):
                try writer["addRuleFromNaturalLanguage"].write(addrulefromnaturallanguage, with: BedrockClientTypes.AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation.write(value:to:))
            case let .addtype(addtype):
                try writer["addType"].write(addtype, with: BedrockClientTypes.AutomatedReasoningPolicyAddTypeAnnotation.write(value:to:))
            case let .addvariable(addvariable):
                try writer["addVariable"].write(addvariable, with: BedrockClientTypes.AutomatedReasoningPolicyAddVariableAnnotation.write(value:to:))
            case let .deleterule(deleterule):
                try writer["deleteRule"].write(deleterule, with: BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleAnnotation.write(value:to:))
            case let .deletetype(deletetype):
                try writer["deleteType"].write(deletetype, with: BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeAnnotation.write(value:to:))
            case let .deletevariable(deletevariable):
                try writer["deleteVariable"].write(deletevariable, with: BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableAnnotation.write(value:to:))
            case let .ingestcontent(ingestcontent):
                try writer["ingestContent"].write(ingestcontent, with: BedrockClientTypes.AutomatedReasoningPolicyIngestContentAnnotation.write(value:to:))
            case let .updatefromrulesfeedback(updatefromrulesfeedback):
                try writer["updateFromRulesFeedback"].write(updatefromrulesfeedback, with: BedrockClientTypes.AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation.write(value:to:))
            case let .updatefromscenariofeedback(updatefromscenariofeedback):
                try writer["updateFromScenarioFeedback"].write(updatefromscenariofeedback, with: BedrockClientTypes.AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation.write(value:to:))
            case let .updaterule(updaterule):
                try writer["updateRule"].write(updaterule, with: BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleAnnotation.write(value:to:))
            case let .updatetype(updatetype):
                try writer["updateType"].write(updatetype, with: BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeAnnotation.write(value:to:))
            case let .updatevariable(updatevariable):
                try writer["updateVariable"].write(updatevariable, with: BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableAnnotation.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "addType":
                return .addtype(try reader["addType"].read(with: BedrockClientTypes.AutomatedReasoningPolicyAddTypeAnnotation.read(from:)))
            case "updateType":
                return .updatetype(try reader["updateType"].read(with: BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeAnnotation.read(from:)))
            case "deleteType":
                return .deletetype(try reader["deleteType"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeAnnotation.read(from:)))
            case "addVariable":
                return .addvariable(try reader["addVariable"].read(with: BedrockClientTypes.AutomatedReasoningPolicyAddVariableAnnotation.read(from:)))
            case "updateVariable":
                return .updatevariable(try reader["updateVariable"].read(with: BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableAnnotation.read(from:)))
            case "deleteVariable":
                return .deletevariable(try reader["deleteVariable"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableAnnotation.read(from:)))
            case "addRule":
                return .addrule(try reader["addRule"].read(with: BedrockClientTypes.AutomatedReasoningPolicyAddRuleAnnotation.read(from:)))
            case "updateRule":
                return .updaterule(try reader["updateRule"].read(with: BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleAnnotation.read(from:)))
            case "deleteRule":
                return .deleterule(try reader["deleteRule"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleAnnotation.read(from:)))
            case "addRuleFromNaturalLanguage":
                return .addrulefromnaturallanguage(try reader["addRuleFromNaturalLanguage"].read(with: BedrockClientTypes.AutomatedReasoningPolicyAddRuleFromNaturalLanguageAnnotation.read(from:)))
            case "updateFromRulesFeedback":
                return .updatefromrulesfeedback(try reader["updateFromRulesFeedback"].read(with: BedrockClientTypes.AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation.read(from:)))
            case "updateFromScenarioFeedback":
                return .updatefromscenariofeedback(try reader["updateFromScenarioFeedback"].read(with: BedrockClientTypes.AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation.read(from:)))
            case "ingestContent":
                return .ingestcontent(try reader["ingestContent"].read(with: BedrockClientTypes.AutomatedReasoningPolicyIngestContentAnnotation.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildLog {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyBuildLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyBuildLog()
        value.entries = try reader["entries"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyBuildLogEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildLogEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyBuildLogEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyBuildLogEntry()
        value.annotation = try reader["annotation"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyAnnotation.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.buildSteps = try reader["buildSteps"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyBuildStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildResultAssets {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyBuildResultAssets {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "policyDefinition":
                return .policydefinition(try reader["policyDefinition"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDefinition.read(from:)))
            case "qualityReport":
                return .qualityreport(try reader["qualityReport"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionQualityReport.read(from:)))
            case "buildLog":
                return .buildlog(try reader["buildLog"].read(with: BedrockClientTypes.AutomatedReasoningPolicyBuildLog.read(from:)))
            case "generatedTestCases":
                return .generatedtestcases(try reader["generatedTestCases"].read(with: BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCases.read(from:)))
            case "policyScenarios":
                return .policyscenarios(try reader["policyScenarios"].read(with: BedrockClientTypes.AutomatedReasoningPolicyScenarios.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildStep {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyBuildStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyBuildStep()
        value.context = try reader["context"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyBuildStepContext.read(from:))
        value.priorElement = try reader["priorElement"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionElement.read(from:))
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyBuildStepMessage.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildStepContext {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyBuildStepContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "planning":
                return .planning(try reader["planning"].read(with: BedrockClientTypes.AutomatedReasoningPolicyPlanning.read(from:)))
            case "mutation":
                return .mutation(try reader["mutation"].read(with: BedrockClientTypes.AutomatedReasoningPolicyMutation.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildStepMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyBuildStepMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyBuildStepMessage()
        value.message = try reader["message"].readIfPresent() ?? ""
        value.messageType = try reader["messageType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowDocument {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowDocument?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["document"].write(value.document)
        try writer["documentContentType"].write(value.documentContentType)
        try writer["documentDescription"].write(value.documentDescription)
        try writer["documentName"].write(value.documentName)
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowRepairContent {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowRepairContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["annotations"].writeList(value.annotations, memberWritingClosure: BedrockClientTypes.AutomatedReasoningPolicyAnnotation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSource {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyDefinition"].write(value.policyDefinition, with: BedrockClientTypes.AutomatedReasoningPolicyDefinition.write(value:to:))
        try writer["workflowContent"].write(value.workflowContent, with: BedrockClientTypes.AutomatedReasoningPolicyWorkflowTypeContent.write(value:to:))
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowSummary()
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.buildWorkflowId = try reader["buildWorkflowId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.buildWorkflowType = try reader["buildWorkflowType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinition {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rules"].writeList(value.rules, memberWritingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["types"].writeList(value.types, memberWritingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["variables"].writeList(value.variables, memberWritingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDefinition()
        value.version = try reader["version"].readIfPresent() ?? "1"
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.variables = try reader["variables"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionElement {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDefinitionElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "policyDefinitionVariable":
                return .policydefinitionvariable(try reader["policyDefinitionVariable"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable.read(from:)))
            case "policyDefinitionType":
                return .policydefinitiontype(try reader["policyDefinitionType"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType.read(from:)))
            case "policyDefinitionRule":
                return .policydefinitionrule(try reader["policyDefinitionRule"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionQualityReport {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDefinitionQualityReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDefinitionQualityReport()
        value.typeCount = try reader["typeCount"].readIfPresent() ?? 0
        value.variableCount = try reader["variableCount"].readIfPresent() ?? 0
        value.ruleCount = try reader["ruleCount"].readIfPresent() ?? 0
        value.unusedTypes = try reader["unusedTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.unusedTypeValues = try reader["unusedTypeValues"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValuePair.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.unusedVariables = try reader["unusedVariables"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.conflictingRules = try reader["conflictingRules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.disjointRuleSets = try reader["disjointRuleSets"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyDisjointRuleSet.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alternateExpression"].write(value.alternateExpression)
        try writer["expression"].write(value.expression)
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.expression = try reader["expression"].readIfPresent() ?? ""
        value.alternateExpression = try reader["alternateExpression"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionType {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDefinitionType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDefinitionType()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValue()
        value.value = try reader["value"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValuePair {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValuePair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDefinitionTypeValuePair()
        value.typeName = try reader["typeName"].readIfPresent() ?? ""
        value.valueName = try reader["valueName"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ruleId"].write(value.ruleId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleAnnotation()
        value.ruleId = try reader["ruleId"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleMutation()
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeAnnotation()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeMutation()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeValue {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeValue()
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableAnnotation()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableMutation()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyDisjointRuleSet {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyDisjointRuleSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyDisjointRuleSet()
        value.variables = try reader["variables"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCase {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCase()
        value.queryContent = try reader["queryContent"].readIfPresent() ?? ""
        value.guardContent = try reader["guardContent"].readIfPresent() ?? ""
        value.expectedAggregatedFindingsResult = try reader["expectedAggregatedFindingsResult"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCases {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCases {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCases()
        value.generatedTestCases = try reader["generatedTestCases"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyGeneratedTestCase.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyIngestContentAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyIngestContentAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].write(value.content)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyIngestContentAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyIngestContentAnnotation()
        value.content = try reader["content"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "addType":
                return .addtype(try reader["addType"].read(with: BedrockClientTypes.AutomatedReasoningPolicyAddTypeMutation.read(from:)))
            case "updateType":
                return .updatetype(try reader["updateType"].read(with: BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeMutation.read(from:)))
            case "deleteType":
                return .deletetype(try reader["deleteType"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeMutation.read(from:)))
            case "addVariable":
                return .addvariable(try reader["addVariable"].read(with: BedrockClientTypes.AutomatedReasoningPolicyAddVariableMutation.read(from:)))
            case "updateVariable":
                return .updatevariable(try reader["updateVariable"].read(with: BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableMutation.read(from:)))
            case "deleteVariable":
                return .deletevariable(try reader["deleteVariable"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDeleteVariableMutation.read(from:)))
            case "addRule":
                return .addrule(try reader["addRule"].read(with: BedrockClientTypes.AutomatedReasoningPolicyAddRuleMutation.read(from:)))
            case "updateRule":
                return .updaterule(try reader["updateRule"].read(with: BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleMutation.read(from:)))
            case "deleteRule":
                return .deleterule(try reader["deleteRule"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDeleteRuleMutation.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyPlanning {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyPlanning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockClientTypes.AutomatedReasoningPolicyPlanning()
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyScenario {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyScenario {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyScenario()
        value.expression = try reader["expression"].readIfPresent() ?? ""
        value.alternateExpression = try reader["alternateExpression"].readIfPresent() ?? ""
        value.expectedResult = try reader["expectedResult"].readIfPresent() ?? .sdkUnknown("")
        value.ruleIds = try reader["ruleIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyScenarios {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyScenarios {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyScenarios()
        value.policyScenarios = try reader["policyScenarios"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyScenario.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicySummary()
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.version = try reader["version"].readIfPresent() ?? ""
        value.policyId = try reader["policyId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyTestCase {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyTestCase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyTestCase()
        value.testCaseId = try reader["testCaseId"].readIfPresent() ?? ""
        value.guardContent = try reader["guardContent"].readIfPresent() ?? ""
        value.queryContent = try reader["queryContent"].readIfPresent()
        value.expectedAggregatedFindingsResult = try reader["expectedAggregatedFindingsResult"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.confidenceThreshold = try reader["confidenceThreshold"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyTestResult {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyTestResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyTestResult()
        value.testCase = try reader["testCase"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyTestCase.read(from:))
        value.policyArn = try reader["policyArn"].readIfPresent() ?? ""
        value.testRunStatus = try reader["testRunStatus"].readIfPresent() ?? .sdkUnknown("")
        value.testFindings = try reader["testFindings"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningCheckFinding.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.testRunResult = try reader["testRunResult"].readIfPresent()
        value.aggregatedTestFindingsResult = try reader["aggregatedTestFindingsResult"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyTypeValueAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyTypeValueAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .addtypevalue(addtypevalue):
                try writer["addTypeValue"].write(addtypevalue, with: BedrockClientTypes.AutomatedReasoningPolicyAddTypeValue.write(value:to:))
            case let .deletetypevalue(deletetypevalue):
                try writer["deleteTypeValue"].write(deletetypevalue, with: BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeValue.write(value:to:))
            case let .updatetypevalue(updatetypevalue):
                try writer["updateTypeValue"].write(updatetypevalue, with: BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeValue.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyTypeValueAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "addTypeValue":
                return .addtypevalue(try reader["addTypeValue"].read(with: BedrockClientTypes.AutomatedReasoningPolicyAddTypeValue.read(from:)))
            case "updateTypeValue":
                return .updatetypevalue(try reader["updateTypeValue"].read(with: BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeValue.read(from:)))
            case "deleteTypeValue":
                return .deletetypevalue(try reader["deleteTypeValue"].read(with: BedrockClientTypes.AutomatedReasoningPolicyDeleteTypeValue.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["feedback"].write(value.feedback)
        try writer["ruleIds"].writeList(value.ruleIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyUpdateFromRuleFeedbackAnnotation()
        value.ruleIds = try reader["ruleIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.feedback = try reader["feedback"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["feedback"].write(value.feedback)
        try writer["ruleIds"].writeList(value.ruleIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scenarioExpression"].write(value.scenarioExpression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyUpdateFromScenarioFeedbackAnnotation()
        value.ruleIds = try reader["ruleIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scenarioExpression = try reader["scenarioExpression"].readIfPresent() ?? ""
        value.feedback = try reader["feedback"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expression"].write(value.expression)
        try writer["ruleId"].write(value.ruleId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleAnnotation()
        value.ruleId = try reader["ruleId"].readIfPresent() ?? ""
        value.expression = try reader["expression"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyUpdateRuleMutation()
        value.rule = try reader["rule"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionRule.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["newName"].write(value.newName)
        try writer["values"].writeList(value.values, memberWritingClosure: BedrockClientTypes.AutomatedReasoningPolicyTypeValueAnnotation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeAnnotation()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.newName = try reader["newName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: BedrockClientTypes.AutomatedReasoningPolicyTypeValueAnnotation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeMutation()
        value.type = try reader["type"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionType.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeValue {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["newValue"].write(value.newValue)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyUpdateTypeValue()
        value.value = try reader["value"].readIfPresent() ?? ""
        value.newValue = try reader["newValue"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableAnnotation {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableAnnotation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["newName"].write(value.newName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableAnnotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableAnnotation()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.newName = try reader["newName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableMutation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableMutation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.AutomatedReasoningPolicyUpdateVariableMutation()
        value.variable = try reader["variable"].readIfPresent(with: BedrockClientTypes.AutomatedReasoningPolicyDefinitionVariable.read(from:))
        return value
    }
}

extension BedrockClientTypes.AutomatedReasoningPolicyWorkflowTypeContent {

    static func write(value: BedrockClientTypes.AutomatedReasoningPolicyWorkflowTypeContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .documents(documents):
                try writer["documents"].writeList(documents, memberWritingClosure: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowDocument.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .policyrepairassets(policyrepairassets):
                try writer["policyRepairAssets"].write(policyrepairassets, with: BedrockClientTypes.AutomatedReasoningPolicyBuildWorkflowRepairContent.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobError {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.BatchDeleteEvaluationJobError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.BatchDeleteEvaluationJobError()
        value.jobIdentifier = try reader["jobIdentifier"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.BatchDeleteEvaluationJobItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.BatchDeleteEvaluationJobItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.BatchDeleteEvaluationJobItem()
        value.jobIdentifier = try reader["jobIdentifier"].readIfPresent() ?? ""
        value.jobStatus = try reader["jobStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.BedrockEvaluatorModel {

    static func write(value: BedrockClientTypes.BedrockEvaluatorModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelIdentifier"].write(value.modelIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.BedrockEvaluatorModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.BedrockEvaluatorModel()
        value.modelIdentifier = try reader["modelIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.ByteContentDoc {

    static func write(value: BedrockClientTypes.ByteContentDoc?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["data"].write(value.data)
        try writer["identifier"].write(value.identifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ByteContentDoc {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ByteContentDoc()
        value.identifier = try reader["identifier"].readIfPresent() ?? ""
        value.contentType = try reader["contentType"].readIfPresent() ?? ""
        value.data = try reader["data"].readIfPresent() ?? Foundation.Data(base64Encoded: "")
        return value
    }
}

extension BedrockClientTypes.CloudWatchConfig {

    static func write(value: BedrockClientTypes.CloudWatchConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["largeDataDeliveryS3Config"].write(value.largeDataDeliveryS3Config, with: BedrockClientTypes.S3Config.write(value:to:))
        try writer["logGroupName"].write(value.logGroupName)
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CloudWatchConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CloudWatchConfig()
        value.logGroupName = try reader["logGroupName"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.largeDataDeliveryS3Config = try reader["largeDataDeliveryS3Config"].readIfPresent(with: BedrockClientTypes.S3Config.read(from:))
        return value
    }
}

extension BedrockClientTypes.CustomizationConfig {

    static func write(value: BedrockClientTypes.CustomizationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .distillationconfig(distillationconfig):
                try writer["distillationConfig"].write(distillationconfig, with: BedrockClientTypes.DistillationConfig.write(value:to:))
            case let .rftconfig(rftconfig):
                try writer["rftConfig"].write(rftconfig, with: BedrockClientTypes.RFTConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomizationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "distillationConfig":
                return .distillationconfig(try reader["distillationConfig"].read(with: BedrockClientTypes.DistillationConfig.read(from:)))
            case "rftConfig":
                return .rftconfig(try reader["rftConfig"].read(with: BedrockClientTypes.RFTConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.CustomMetricBedrockEvaluatorModel {

    static func write(value: BedrockClientTypes.CustomMetricBedrockEvaluatorModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelIdentifier"].write(value.modelIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomMetricBedrockEvaluatorModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomMetricBedrockEvaluatorModel()
        value.modelIdentifier = try reader["modelIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.CustomMetricDefinition {

    static func write(value: BedrockClientTypes.CustomMetricDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instructions"].write(value.instructions)
        try writer["name"].write(value.name)
        try writer["ratingScale"].writeList(value.ratingScale, memberWritingClosure: BedrockClientTypes.RatingScaleItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomMetricDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomMetricDefinition()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.instructions = try reader["instructions"].readIfPresent() ?? ""
        value.ratingScale = try reader["ratingScale"].readListIfPresent(memberReadingClosure: BedrockClientTypes.RatingScaleItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.CustomMetricEvaluatorModelConfig {

    static func write(value: BedrockClientTypes.CustomMetricEvaluatorModelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bedrockEvaluatorModels"].writeList(value.bedrockEvaluatorModels, memberWritingClosure: BedrockClientTypes.CustomMetricBedrockEvaluatorModel.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomMetricEvaluatorModelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomMetricEvaluatorModelConfig()
        value.bedrockEvaluatorModels = try reader["bedrockEvaluatorModels"].readListIfPresent(memberReadingClosure: BedrockClientTypes.CustomMetricBedrockEvaluatorModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.CustomModelDeploymentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomModelDeploymentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomModelDeploymentSummary()
        value.customModelDeploymentArn = try reader["customModelDeploymentArn"].readIfPresent() ?? ""
        value.customModelDeploymentName = try reader["customModelDeploymentName"].readIfPresent() ?? ""
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.CustomModelDeploymentUpdateDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomModelDeploymentUpdateDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomModelDeploymentUpdateDetails()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.updateStatus = try reader["updateStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.CustomModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.baseModelName = try reader["baseModelName"].readIfPresent() ?? ""
        value.customizationType = try reader["customizationType"].readIfPresent()
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent()
        value.modelStatus = try reader["modelStatus"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.CustomModelUnits {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.CustomModelUnits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.CustomModelUnits()
        value.customModelUnitsPerModelCopy = try reader["customModelUnitsPerModelCopy"].readIfPresent()
        value.customModelUnitsVersion = try reader["customModelUnitsVersion"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.DataProcessingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.DataProcessingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.DataProcessingDetails()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockClientTypes.DimensionalPriceRate {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.DimensionalPriceRate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.DimensionalPriceRate()
        value.dimension = try reader["dimension"].readIfPresent()
        value.price = try reader["price"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.DistillationConfig {

    static func write(value: BedrockClientTypes.DistillationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["teacherModelConfig"].write(value.teacherModelConfig, with: BedrockClientTypes.TeacherModelConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.DistillationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.DistillationConfig()
        value.teacherModelConfig = try reader["teacherModelConfig"].readIfPresent(with: BedrockClientTypes.TeacherModelConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.EndpointConfig {

    static func write(value: BedrockClientTypes.EndpointConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .sagemaker(sagemaker):
                try writer["sageMaker"].write(sagemaker, with: BedrockClientTypes.SageMakerEndpoint.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EndpointConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "sageMaker":
                return .sagemaker(try reader["sageMaker"].read(with: BedrockClientTypes.SageMakerEndpoint.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.EvaluationBedrockModel {

    static func write(value: BedrockClientTypes.EvaluationBedrockModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inferenceParams"].write(value.inferenceParams)
        try writer["modelIdentifier"].write(value.modelIdentifier)
        try writer["performanceConfig"].write(value.performanceConfig, with: BedrockClientTypes.PerformanceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationBedrockModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationBedrockModel()
        value.modelIdentifier = try reader["modelIdentifier"].readIfPresent() ?? ""
        value.inferenceParams = try reader["inferenceParams"].readIfPresent() ?? "{}"
        value.performanceConfig = try reader["performanceConfig"].readIfPresent(with: BedrockClientTypes.PerformanceConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.EvaluationConfig {

    static func write(value: BedrockClientTypes.EvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .automated(automated):
                try writer["automated"].write(automated, with: BedrockClientTypes.AutomatedEvaluationConfig.write(value:to:))
            case let .human(human):
                try writer["human"].write(human, with: BedrockClientTypes.HumanEvaluationConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "automated":
                return .automated(try reader["automated"].read(with: BedrockClientTypes.AutomatedEvaluationConfig.read(from:)))
            case "human":
                return .human(try reader["human"].read(with: BedrockClientTypes.HumanEvaluationConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.EvaluationDataset {

    static func write(value: BedrockClientTypes.EvaluationDataset?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetLocation"].write(value.datasetLocation, with: BedrockClientTypes.EvaluationDatasetLocation.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDataset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationDataset()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.datasetLocation = try reader["datasetLocation"].readIfPresent(with: BedrockClientTypes.EvaluationDatasetLocation.read(from:))
        return value
    }
}

extension BedrockClientTypes.EvaluationDatasetLocation {

    static func write(value: BedrockClientTypes.EvaluationDatasetLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3uri(s3uri):
                try writer["s3Uri"].write(s3uri)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDatasetLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3Uri":
                return .s3uri(try reader["s3Uri"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.EvaluationDatasetMetricConfig {

    static func write(value: BedrockClientTypes.EvaluationDatasetMetricConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataset"].write(value.dataset, with: BedrockClientTypes.EvaluationDataset.write(value:to:))
        try writer["metricNames"].writeList(value.metricNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["taskType"].write(value.taskType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationDatasetMetricConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationDatasetMetricConfig()
        value.taskType = try reader["taskType"].readIfPresent() ?? .sdkUnknown("")
        value.dataset = try reader["dataset"].readIfPresent(with: BedrockClientTypes.EvaluationDataset.read(from:))
        value.metricNames = try reader["metricNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.EvaluationInferenceConfig {

    static func write(value: BedrockClientTypes.EvaluationInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .models(models):
                try writer["models"].writeList(models, memberWritingClosure: BedrockClientTypes.EvaluationModelConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .ragconfigs(ragconfigs):
                try writer["ragConfigs"].writeList(ragconfigs, memberWritingClosure: BedrockClientTypes.RAGConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationInferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "models":
                return .models(try reader["models"].readList(memberReadingClosure: BedrockClientTypes.EvaluationModelConfig.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "ragConfigs":
                return .ragconfigs(try reader["ragConfigs"].readList(memberReadingClosure: BedrockClientTypes.RAGConfig.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.EvaluationInferenceConfigSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationInferenceConfigSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationInferenceConfigSummary()
        value.modelConfigSummary = try reader["modelConfigSummary"].readIfPresent(with: BedrockClientTypes.EvaluationModelConfigSummary.read(from:))
        value.ragConfigSummary = try reader["ragConfigSummary"].readIfPresent(with: BedrockClientTypes.EvaluationRagConfigSummary.read(from:))
        return value
    }
}

extension BedrockClientTypes.EvaluationModelConfig {

    static func write(value: BedrockClientTypes.EvaluationModelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bedrockmodel(bedrockmodel):
                try writer["bedrockModel"].write(bedrockmodel, with: BedrockClientTypes.EvaluationBedrockModel.write(value:to:))
            case let .precomputedinferencesource(precomputedinferencesource):
                try writer["precomputedInferenceSource"].write(precomputedinferencesource, with: BedrockClientTypes.EvaluationPrecomputedInferenceSource.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationModelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bedrockModel":
                return .bedrockmodel(try reader["bedrockModel"].read(with: BedrockClientTypes.EvaluationBedrockModel.read(from:)))
            case "precomputedInferenceSource":
                return .precomputedinferencesource(try reader["precomputedInferenceSource"].read(with: BedrockClientTypes.EvaluationPrecomputedInferenceSource.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.EvaluationModelConfigSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationModelConfigSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationModelConfigSummary()
        value.bedrockModelIdentifiers = try reader["bedrockModelIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.precomputedInferenceSourceIdentifiers = try reader["precomputedInferenceSourceIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.EvaluationOutputDataConfig {

    static func write(value: BedrockClientTypes.EvaluationOutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationOutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationOutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.EvaluationPrecomputedInferenceSource {

    static func write(value: BedrockClientTypes.EvaluationPrecomputedInferenceSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inferenceSourceIdentifier"].write(value.inferenceSourceIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationPrecomputedInferenceSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationPrecomputedInferenceSource()
        value.inferenceSourceIdentifier = try reader["inferenceSourceIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.EvaluationPrecomputedRagSourceConfig {

    static func write(value: BedrockClientTypes.EvaluationPrecomputedRagSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .retrieveandgeneratesourceconfig(retrieveandgeneratesourceconfig):
                try writer["retrieveAndGenerateSourceConfig"].write(retrieveandgeneratesourceconfig, with: BedrockClientTypes.EvaluationPrecomputedRetrieveAndGenerateSourceConfig.write(value:to:))
            case let .retrievesourceconfig(retrievesourceconfig):
                try writer["retrieveSourceConfig"].write(retrievesourceconfig, with: BedrockClientTypes.EvaluationPrecomputedRetrieveSourceConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationPrecomputedRagSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "retrieveSourceConfig":
                return .retrievesourceconfig(try reader["retrieveSourceConfig"].read(with: BedrockClientTypes.EvaluationPrecomputedRetrieveSourceConfig.read(from:)))
            case "retrieveAndGenerateSourceConfig":
                return .retrieveandgeneratesourceconfig(try reader["retrieveAndGenerateSourceConfig"].read(with: BedrockClientTypes.EvaluationPrecomputedRetrieveAndGenerateSourceConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.EvaluationPrecomputedRetrieveAndGenerateSourceConfig {

    static func write(value: BedrockClientTypes.EvaluationPrecomputedRetrieveAndGenerateSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ragSourceIdentifier"].write(value.ragSourceIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationPrecomputedRetrieveAndGenerateSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationPrecomputedRetrieveAndGenerateSourceConfig()
        value.ragSourceIdentifier = try reader["ragSourceIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.EvaluationPrecomputedRetrieveSourceConfig {

    static func write(value: BedrockClientTypes.EvaluationPrecomputedRetrieveSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ragSourceIdentifier"].write(value.ragSourceIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationPrecomputedRetrieveSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationPrecomputedRetrieveSourceConfig()
        value.ragSourceIdentifier = try reader["ragSourceIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.EvaluationRagConfigSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationRagConfigSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationRagConfigSummary()
        value.bedrockKnowledgeBaseIdentifiers = try reader["bedrockKnowledgeBaseIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.precomputedRagSourceIdentifiers = try reader["precomputedRagSourceIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.EvaluationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.EvaluationSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobType = try reader["jobType"].readIfPresent() ?? .sdkUnknown("")
        value.evaluationTaskTypes = try reader["evaluationTaskTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.EvaluationTaskType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.modelIdentifiers = try reader["modelIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.ragIdentifiers = try reader["ragIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.evaluatorModelIdentifiers = try reader["evaluatorModelIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.customMetricsEvaluatorModelIdentifiers = try reader["customMetricsEvaluatorModelIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceConfigSummary = try reader["inferenceConfigSummary"].readIfPresent(with: BedrockClientTypes.EvaluationInferenceConfigSummary.read(from:))
        value.applicationType = try reader["applicationType"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.EvaluatorModelConfig {

    static func write(value: BedrockClientTypes.EvaluatorModelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bedrockevaluatormodels(bedrockevaluatormodels):
                try writer["bedrockEvaluatorModels"].writeList(bedrockevaluatormodels, memberWritingClosure: BedrockClientTypes.BedrockEvaluatorModel.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.EvaluatorModelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bedrockEvaluatorModels":
                return .bedrockevaluatormodels(try reader["bedrockEvaluatorModels"].readList(memberReadingClosure: BedrockClientTypes.BedrockEvaluatorModel.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.ExternalSource {

    static func write(value: BedrockClientTypes.ExternalSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["byteContent"].write(value.byteContent, with: BedrockClientTypes.ByteContentDoc.write(value:to:))
        try writer["s3Location"].write(value.s3Location, with: BedrockClientTypes.S3ObjectDoc.write(value:to:))
        try writer["sourceType"].write(value.sourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ExternalSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ExternalSource()
        value.sourceType = try reader["sourceType"].readIfPresent() ?? .sdkUnknown("")
        value.s3Location = try reader["s3Location"].readIfPresent(with: BedrockClientTypes.S3ObjectDoc.read(from:))
        value.byteContent = try reader["byteContent"].readIfPresent(with: BedrockClientTypes.ByteContentDoc.read(from:))
        return value
    }
}

extension BedrockClientTypes.ExternalSourcesGenerationConfiguration {

    static func write(value: BedrockClientTypes.ExternalSourcesGenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["kbInferenceConfig"].write(value.kbInferenceConfig, with: BedrockClientTypes.KbInferenceConfig.write(value:to:))
        try writer["promptTemplate"].write(value.promptTemplate, with: BedrockClientTypes.PromptTemplate.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ExternalSourcesGenerationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ExternalSourcesGenerationConfiguration()
        value.promptTemplate = try reader["promptTemplate"].readIfPresent(with: BedrockClientTypes.PromptTemplate.read(from:))
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockClientTypes.GuardrailConfiguration.read(from:))
        value.kbInferenceConfig = try reader["kbInferenceConfig"].readIfPresent(with: BedrockClientTypes.KbInferenceConfig.read(from:))
        value.additionalModelRequestFields = try reader["additionalModelRequestFields"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration {

    static func write(value: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generationConfiguration"].write(value.generationConfiguration, with: BedrockClientTypes.ExternalSourcesGenerationConfiguration.write(value:to:))
        try writer["modelArn"].write(value.modelArn)
        try writer["sources"].writeList(value.sources, memberWritingClosure: BedrockClientTypes.ExternalSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: BedrockClientTypes.ExternalSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.generationConfiguration = try reader["generationConfiguration"].readIfPresent(with: BedrockClientTypes.ExternalSourcesGenerationConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.FieldForReranking {

    static func write(value: BedrockClientTypes.FieldForReranking?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fieldName"].write(value.fieldName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FieldForReranking {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FieldForReranking()
        value.fieldName = try reader["fieldName"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.FilterAttribute {

    static func write(value: BedrockClientTypes.FilterAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FilterAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FilterAttribute()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? [:]
        return value
    }
}

extension BedrockClientTypes.FoundationModelDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelDetails()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseStreamingSupported = try reader["responseStreamingSupported"].readIfPresent()
        value.customizationsSupported = try reader["customizationsSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelCustomization>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceTypesSupported = try reader["inferenceTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.InferenceType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelLifecycle = try reader["modelLifecycle"].readIfPresent(with: BedrockClientTypes.FoundationModelLifecycle.read(from:))
        return value
    }
}

extension BedrockClientTypes.FoundationModelLifecycle {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelLifecycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelLifecycle()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.FoundationModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.FoundationModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.FoundationModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.responseStreamingSupported = try reader["responseStreamingSupported"].readIfPresent()
        value.customizationsSupported = try reader["customizationsSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.ModelCustomization>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inferenceTypesSupported = try reader["inferenceTypesSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.InferenceType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelLifecycle = try reader["modelLifecycle"].readIfPresent(with: BedrockClientTypes.FoundationModelLifecycle.read(from:))
        return value
    }
}

extension BedrockClientTypes.GenerationConfiguration {

    static func write(value: BedrockClientTypes.GenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["kbInferenceConfig"].write(value.kbInferenceConfig, with: BedrockClientTypes.KbInferenceConfig.write(value:to:))
        try writer["promptTemplate"].write(value.promptTemplate, with: BedrockClientTypes.PromptTemplate.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GenerationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GenerationConfiguration()
        value.promptTemplate = try reader["promptTemplate"].readIfPresent(with: BedrockClientTypes.PromptTemplate.read(from:))
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockClientTypes.GuardrailConfiguration.read(from:))
        value.kbInferenceConfig = try reader["kbInferenceConfig"].readIfPresent(with: BedrockClientTypes.KbInferenceConfig.read(from:))
        value.additionalModelRequestFields = try reader["additionalModelRequestFields"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GraderConfig {

    static func write(value: BedrockClientTypes.GraderConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .lambdagrader(lambdagrader):
                try writer["lambdaGrader"].write(lambdagrader, with: BedrockClientTypes.LambdaGraderConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GraderConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "lambdaGrader":
                return .lambdagrader(try reader["lambdaGrader"].read(with: BedrockClientTypes.LambdaGraderConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.GuardrailAutomatedReasoningPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailAutomatedReasoningPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailAutomatedReasoningPolicy()
        value.policies = try reader["policies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.confidenceThreshold = try reader["confidenceThreshold"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailAutomatedReasoningPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailAutomatedReasoningPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["confidenceThreshold"].write(value.confidenceThreshold)
        try writer["policies"].writeList(value.policies, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailConfiguration {

    static func write(value: BedrockClientTypes.GuardrailConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailId"].write(value.guardrailId)
        try writer["guardrailVersion"].write(value.guardrailVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailConfiguration()
        value.guardrailId = try reader["guardrailId"].readIfPresent() ?? ""
        value.guardrailVersion = try reader["guardrailVersion"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.GuardrailContentFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContentFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContentFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.inputStrength = try reader["inputStrength"].readIfPresent() ?? .sdkUnknown("")
        value.outputStrength = try reader["outputStrength"].readIfPresent() ?? .sdkUnknown("")
        value.inputModalities = try reader["inputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.GuardrailModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputModalities = try reader["outputModalities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockClientTypes.GuardrailModality>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inputAction = try reader["inputAction"].readIfPresent()
        value.outputAction = try reader["outputAction"].readIfPresent()
        value.inputEnabled = try reader["inputEnabled"].readIfPresent()
        value.outputEnabled = try reader["outputEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailContentFilterConfig {

    static func write(value: BedrockClientTypes.GuardrailContentFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputAction"].write(value.inputAction)
        try writer["inputEnabled"].write(value.inputEnabled)
        try writer["inputModalities"].writeList(value.inputModalities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockClientTypes.GuardrailModality>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inputStrength"].write(value.inputStrength)
        try writer["outputAction"].write(value.outputAction)
        try writer["outputEnabled"].write(value.outputEnabled)
        try writer["outputModalities"].writeList(value.outputModalities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockClientTypes.GuardrailModality>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputStrength"].write(value.outputStrength)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailContentFiltersTier {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContentFiltersTier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContentFiltersTier()
        value.tierName = try reader["tierName"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailContentFiltersTierConfig {

    static func write(value: BedrockClientTypes.GuardrailContentFiltersTierConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tierName"].write(value.tierName)
    }
}

extension BedrockClientTypes.GuardrailContentPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContentPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContentPolicy()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailContentFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tier = try reader["tier"].readIfPresent(with: BedrockClientTypes.GuardrailContentFiltersTier.read(from:))
        return value
    }
}

extension BedrockClientTypes.GuardrailContentPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailContentPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filtersConfig"].writeList(value.filtersConfig, memberWritingClosure: BedrockClientTypes.GuardrailContentFilterConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tierConfig"].write(value.tierConfig, with: BedrockClientTypes.GuardrailContentFiltersTierConfig.write(value:to:))
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContextualGroundingFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContextualGroundingFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.threshold = try reader["threshold"].readIfPresent() ?? 0.0
        value.action = try reader["action"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingFilterConfig {

    static func write(value: BedrockClientTypes.GuardrailContextualGroundingFilterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["enabled"].write(value.enabled)
        try writer["threshold"].write(value.threshold)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailContextualGroundingPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailContextualGroundingPolicy()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailContextualGroundingFilter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.GuardrailContextualGroundingPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailContextualGroundingPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filtersConfig"].writeList(value.filtersConfig, memberWritingClosure: BedrockClientTypes.GuardrailContextualGroundingFilterConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailCrossRegionConfig {

    static func write(value: BedrockClientTypes.GuardrailCrossRegionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailProfileIdentifier"].write(value.guardrailProfileIdentifier)
    }
}

extension BedrockClientTypes.GuardrailCrossRegionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailCrossRegionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailCrossRegionDetails()
        value.guardrailProfileId = try reader["guardrailProfileId"].readIfPresent()
        value.guardrailProfileArn = try reader["guardrailProfileArn"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailManagedWords {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailManagedWords {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailManagedWords()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.inputAction = try reader["inputAction"].readIfPresent()
        value.outputAction = try reader["outputAction"].readIfPresent()
        value.inputEnabled = try reader["inputEnabled"].readIfPresent()
        value.outputEnabled = try reader["outputEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailManagedWordsConfig {

    static func write(value: BedrockClientTypes.GuardrailManagedWordsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputAction"].write(value.inputAction)
        try writer["inputEnabled"].write(value.inputEnabled)
        try writer["outputAction"].write(value.outputAction)
        try writer["outputEnabled"].write(value.outputEnabled)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailPiiEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailPiiEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailPiiEntity()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.inputAction = try reader["inputAction"].readIfPresent()
        value.outputAction = try reader["outputAction"].readIfPresent()
        value.inputEnabled = try reader["inputEnabled"].readIfPresent()
        value.outputEnabled = try reader["outputEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailPiiEntityConfig {

    static func write(value: BedrockClientTypes.GuardrailPiiEntityConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["inputAction"].write(value.inputAction)
        try writer["inputEnabled"].write(value.inputEnabled)
        try writer["outputAction"].write(value.outputAction)
        try writer["outputEnabled"].write(value.outputEnabled)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailRegex {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailRegex {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailRegex()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.pattern = try reader["pattern"].readIfPresent() ?? ""
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.inputAction = try reader["inputAction"].readIfPresent()
        value.outputAction = try reader["outputAction"].readIfPresent()
        value.inputEnabled = try reader["inputEnabled"].readIfPresent()
        value.outputEnabled = try reader["outputEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailRegexConfig {

    static func write(value: BedrockClientTypes.GuardrailRegexConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["description"].write(value.description)
        try writer["inputAction"].write(value.inputAction)
        try writer["inputEnabled"].write(value.inputEnabled)
        try writer["name"].write(value.name)
        try writer["outputAction"].write(value.outputAction)
        try writer["outputEnabled"].write(value.outputEnabled)
        try writer["pattern"].write(value.pattern)
    }
}

extension BedrockClientTypes.GuardrailSensitiveInformationPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailSensitiveInformationPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailSensitiveInformationPolicy()
        value.piiEntities = try reader["piiEntities"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailPiiEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.regexes = try reader["regexes"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailRegex.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailSensitiveInformationPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["piiEntitiesConfig"].writeList(value.piiEntitiesConfig, memberWritingClosure: BedrockClientTypes.GuardrailPiiEntityConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["regexesConfig"].writeList(value.regexesConfig, memberWritingClosure: BedrockClientTypes.GuardrailRegexConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.version = try reader["version"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.crossRegionDetails = try reader["crossRegionDetails"].readIfPresent(with: BedrockClientTypes.GuardrailCrossRegionDetails.read(from:))
        return value
    }
}

extension BedrockClientTypes.GuardrailTopic {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailTopic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailTopic()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.definition = try reader["definition"].readIfPresent() ?? ""
        value.examples = try reader["examples"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        value.inputAction = try reader["inputAction"].readIfPresent()
        value.outputAction = try reader["outputAction"].readIfPresent()
        value.inputEnabled = try reader["inputEnabled"].readIfPresent()
        value.outputEnabled = try reader["outputEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailTopicConfig {

    static func write(value: BedrockClientTypes.GuardrailTopicConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["examples"].writeList(value.examples, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inputAction"].write(value.inputAction)
        try writer["inputEnabled"].write(value.inputEnabled)
        try writer["name"].write(value.name)
        try writer["outputAction"].write(value.outputAction)
        try writer["outputEnabled"].write(value.outputEnabled)
        try writer["type"].write(value.type)
    }
}

extension BedrockClientTypes.GuardrailTopicPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailTopicPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailTopicPolicy()
        value.topics = try reader["topics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailTopic.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tier = try reader["tier"].readIfPresent(with: BedrockClientTypes.GuardrailTopicsTier.read(from:))
        return value
    }
}

extension BedrockClientTypes.GuardrailTopicPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailTopicPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tierConfig"].write(value.tierConfig, with: BedrockClientTypes.GuardrailTopicsTierConfig.write(value:to:))
        try writer["topicsConfig"].writeList(value.topicsConfig, memberWritingClosure: BedrockClientTypes.GuardrailTopicConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.GuardrailTopicsTier {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailTopicsTier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailTopicsTier()
        value.tierName = try reader["tierName"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.GuardrailTopicsTierConfig {

    static func write(value: BedrockClientTypes.GuardrailTopicsTierConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tierName"].write(value.tierName)
    }
}

extension BedrockClientTypes.GuardrailWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailWord()
        value.text = try reader["text"].readIfPresent() ?? ""
        value.inputAction = try reader["inputAction"].readIfPresent()
        value.outputAction = try reader["outputAction"].readIfPresent()
        value.inputEnabled = try reader["inputEnabled"].readIfPresent()
        value.outputEnabled = try reader["outputEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.GuardrailWordConfig {

    static func write(value: BedrockClientTypes.GuardrailWordConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputAction"].write(value.inputAction)
        try writer["inputEnabled"].write(value.inputEnabled)
        try writer["outputAction"].write(value.outputAction)
        try writer["outputEnabled"].write(value.outputEnabled)
        try writer["text"].write(value.text)
    }
}

extension BedrockClientTypes.GuardrailWordPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.GuardrailWordPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.GuardrailWordPolicy()
        value.words = try reader["words"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailWord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.managedWordLists = try reader["managedWordLists"].readListIfPresent(memberReadingClosure: BedrockClientTypes.GuardrailManagedWords.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.GuardrailWordPolicyConfig {

    static func write(value: BedrockClientTypes.GuardrailWordPolicyConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["managedWordListsConfig"].writeList(value.managedWordListsConfig, memberWritingClosure: BedrockClientTypes.GuardrailManagedWordsConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["wordsConfig"].writeList(value.wordsConfig, memberWritingClosure: BedrockClientTypes.GuardrailWordConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockClientTypes.HumanEvaluationConfig {

    static func write(value: BedrockClientTypes.HumanEvaluationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customMetrics"].writeList(value.customMetrics, memberWritingClosure: BedrockClientTypes.HumanEvaluationCustomMetric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["datasetMetricConfigs"].writeList(value.datasetMetricConfigs, memberWritingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["humanWorkflowConfig"].write(value.humanWorkflowConfig, with: BedrockClientTypes.HumanWorkflowConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanEvaluationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanEvaluationConfig()
        value.humanWorkflowConfig = try reader["humanWorkflowConfig"].readIfPresent(with: BedrockClientTypes.HumanWorkflowConfig.read(from:))
        value.customMetrics = try reader["customMetrics"].readListIfPresent(memberReadingClosure: BedrockClientTypes.HumanEvaluationCustomMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.datasetMetricConfigs = try reader["datasetMetricConfigs"].readListIfPresent(memberReadingClosure: BedrockClientTypes.EvaluationDatasetMetricConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.HumanEvaluationCustomMetric {

    static func write(value: BedrockClientTypes.HumanEvaluationCustomMetric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["ratingMethod"].write(value.ratingMethod)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanEvaluationCustomMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanEvaluationCustomMetric()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.ratingMethod = try reader["ratingMethod"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.HumanWorkflowConfig {

    static func write(value: BedrockClientTypes.HumanWorkflowConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowDefinitionArn"].write(value.flowDefinitionArn)
        try writer["instructions"].write(value.instructions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.HumanWorkflowConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.HumanWorkflowConfig()
        value.flowDefinitionArn = try reader["flowDefinitionArn"].readIfPresent() ?? ""
        value.instructions = try reader["instructions"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ImplicitFilterConfiguration {

    static func write(value: BedrockClientTypes.ImplicitFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataAttributes"].writeList(value.metadataAttributes, memberWritingClosure: BedrockClientTypes.MetadataAttributeSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modelArn"].write(value.modelArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ImplicitFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ImplicitFilterConfiguration()
        value.metadataAttributes = try reader["metadataAttributes"].readListIfPresent(memberReadingClosure: BedrockClientTypes.MetadataAttributeSchema.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.ImportedModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ImportedModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ImportedModelSummary()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.modelName = try reader["modelName"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.instructSupported = try reader["instructSupported"].readIfPresent()
        value.modelArchitecture = try reader["modelArchitecture"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.InferenceProfileModel {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InferenceProfileModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.InferenceProfileModel()
        value.modelArn = try reader["modelArn"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.InferenceProfileModelSource {

    static func write(value: BedrockClientTypes.InferenceProfileModelSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .copyfrom(copyfrom):
                try writer["copyFrom"].write(copyfrom)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockClientTypes.InferenceProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InferenceProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.InferenceProfileSummary()
        value.inferenceProfileName = try reader["inferenceProfileName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.inferenceProfileArn = try reader["inferenceProfileArn"].readIfPresent() ?? ""
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.InferenceProfileModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.inferenceProfileId = try reader["inferenceProfileId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.InvocationLogsConfig {

    static func write(value: BedrockClientTypes.InvocationLogsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationLogSource"].write(value.invocationLogSource, with: BedrockClientTypes.InvocationLogSource.write(value:to:))
        try writer["requestMetadataFilters"].write(value.requestMetadataFilters, with: BedrockClientTypes.RequestMetadataFilters.write(value:to:))
        try writer["usePromptResponse"].write(value.usePromptResponse)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InvocationLogsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.InvocationLogsConfig()
        value.usePromptResponse = try reader["usePromptResponse"].readIfPresent() ?? false
        value.invocationLogSource = try reader["invocationLogSource"].readIfPresent(with: BedrockClientTypes.InvocationLogSource.read(from:))
        value.requestMetadataFilters = try reader["requestMetadataFilters"].readIfPresent(with: BedrockClientTypes.RequestMetadataFilters.read(from:))
        return value
    }
}

extension BedrockClientTypes.InvocationLogSource {

    static func write(value: BedrockClientTypes.InvocationLogSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3uri(s3uri):
                try writer["s3Uri"].write(s3uri)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.InvocationLogSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3Uri":
                return .s3uri(try reader["s3Uri"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.KbInferenceConfig {

    static func write(value: BedrockClientTypes.KbInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["textInferenceConfig"].write(value.textInferenceConfig, with: BedrockClientTypes.TextInferenceConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KbInferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.KbInferenceConfig()
        value.textInferenceConfig = try reader["textInferenceConfig"].readIfPresent(with: BedrockClientTypes.TextInferenceConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.KnowledgeBaseConfig {

    static func write(value: BedrockClientTypes.KnowledgeBaseConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .retrieveandgenerateconfig(retrieveandgenerateconfig):
                try writer["retrieveAndGenerateConfig"].write(retrieveandgenerateconfig, with: BedrockClientTypes.RetrieveAndGenerateConfiguration.write(value:to:))
            case let .retrieveconfig(retrieveconfig):
                try writer["retrieveConfig"].write(retrieveconfig, with: BedrockClientTypes.RetrieveConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KnowledgeBaseConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "retrieveConfig":
                return .retrieveconfig(try reader["retrieveConfig"].read(with: BedrockClientTypes.RetrieveConfig.read(from:)))
            case "retrieveAndGenerateConfig":
                return .retrieveandgenerateconfig(try reader["retrieveAndGenerateConfig"].read(with: BedrockClientTypes.RetrieveAndGenerateConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.KnowledgeBaseRetrievalConfiguration {

    static func write(value: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vectorSearchConfiguration"].write(value.vectorSearchConfiguration, with: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KnowledgeBaseRetrievalConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.KnowledgeBaseRetrievalConfiguration()
        value.vectorSearchConfiguration = try reader["vectorSearchConfiguration"].readIfPresent(with: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration {

    static func write(value: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generationConfiguration"].write(value.generationConfiguration, with: BedrockClientTypes.GenerationConfiguration.write(value:to:))
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["modelArn"].write(value.modelArn)
        try writer["orchestrationConfiguration"].write(value.orchestrationConfiguration, with: BedrockClientTypes.OrchestrationConfiguration.write(value:to:))
        try writer["retrievalConfiguration"].write(value.retrievalConfiguration, with: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.retrievalConfiguration = try reader["retrievalConfiguration"].readIfPresent(with: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration.read(from:))
        value.generationConfiguration = try reader["generationConfiguration"].readIfPresent(with: BedrockClientTypes.GenerationConfiguration.read(from:))
        value.orchestrationConfiguration = try reader["orchestrationConfiguration"].readIfPresent(with: BedrockClientTypes.OrchestrationConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration {

    static func write(value: BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BedrockClientTypes.RetrievalFilter.write(value:to:))
        try writer["implicitFilterConfiguration"].write(value.implicitFilterConfiguration, with: BedrockClientTypes.ImplicitFilterConfiguration.write(value:to:))
        try writer["numberOfResults"].write(value.numberOfResults)
        try writer["overrideSearchType"].write(value.overrideSearchType)
        try writer["rerankingConfiguration"].write(value.rerankingConfiguration, with: BedrockClientTypes.VectorSearchRerankingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.KnowledgeBaseVectorSearchConfiguration()
        value.numberOfResults = try reader["numberOfResults"].readIfPresent()
        value.overrideSearchType = try reader["overrideSearchType"].readIfPresent()
        value.filter = try reader["filter"].readIfPresent(with: BedrockClientTypes.RetrievalFilter.read(from:))
        value.implicitFilterConfiguration = try reader["implicitFilterConfiguration"].readIfPresent(with: BedrockClientTypes.ImplicitFilterConfiguration.read(from:))
        value.rerankingConfiguration = try reader["rerankingConfiguration"].readIfPresent(with: BedrockClientTypes.VectorSearchRerankingConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.LambdaGraderConfig {

    static func write(value: BedrockClientTypes.LambdaGraderConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambdaArn"].write(value.lambdaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.LambdaGraderConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.LambdaGraderConfig()
        value.lambdaArn = try reader["lambdaArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.LegalTerm {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.LegalTerm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.LegalTerm()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.LoggingConfig {

    static func write(value: BedrockClientTypes.LoggingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audioDataDeliveryEnabled"].write(value.audioDataDeliveryEnabled)
        try writer["cloudWatchConfig"].write(value.cloudWatchConfig, with: BedrockClientTypes.CloudWatchConfig.write(value:to:))
        try writer["embeddingDataDeliveryEnabled"].write(value.embeddingDataDeliveryEnabled)
        try writer["imageDataDeliveryEnabled"].write(value.imageDataDeliveryEnabled)
        try writer["s3Config"].write(value.s3Config, with: BedrockClientTypes.S3Config.write(value:to:))
        try writer["textDataDeliveryEnabled"].write(value.textDataDeliveryEnabled)
        try writer["videoDataDeliveryEnabled"].write(value.videoDataDeliveryEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.LoggingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.LoggingConfig()
        value.cloudWatchConfig = try reader["cloudWatchConfig"].readIfPresent(with: BedrockClientTypes.CloudWatchConfig.read(from:))
        value.s3Config = try reader["s3Config"].readIfPresent(with: BedrockClientTypes.S3Config.read(from:))
        value.textDataDeliveryEnabled = try reader["textDataDeliveryEnabled"].readIfPresent()
        value.imageDataDeliveryEnabled = try reader["imageDataDeliveryEnabled"].readIfPresent()
        value.embeddingDataDeliveryEnabled = try reader["embeddingDataDeliveryEnabled"].readIfPresent()
        value.videoDataDeliveryEnabled = try reader["videoDataDeliveryEnabled"].readIfPresent()
        value.audioDataDeliveryEnabled = try reader["audioDataDeliveryEnabled"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.MarketplaceModelEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.MarketplaceModelEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.MarketplaceModelEndpoint()
        value.endpointArn = try reader["endpointArn"].readIfPresent() ?? ""
        value.modelSourceIdentifier = try reader["modelSourceIdentifier"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endpointConfig = try reader["endpointConfig"].readIfPresent(with: BedrockClientTypes.EndpointConfig.read(from:))
        value.endpointStatus = try reader["endpointStatus"].readIfPresent() ?? ""
        value.endpointStatusMessage = try reader["endpointStatusMessage"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.MarketplaceModelEndpointSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.MarketplaceModelEndpointSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.MarketplaceModelEndpointSummary()
        value.endpointArn = try reader["endpointArn"].readIfPresent() ?? ""
        value.modelSourceIdentifier = try reader["modelSourceIdentifier"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.MetadataAttributeSchema {

    static func write(value: BedrockClientTypes.MetadataAttributeSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["key"].write(value.key)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.MetadataAttributeSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.MetadataAttributeSchema()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.MetadataConfigurationForReranking {

    static func write(value: BedrockClientTypes.MetadataConfigurationForReranking?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["selectionMode"].write(value.selectionMode)
        try writer["selectiveModeConfiguration"].write(value.selectiveModeConfiguration, with: BedrockClientTypes.RerankingMetadataSelectiveModeConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.MetadataConfigurationForReranking {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.MetadataConfigurationForReranking()
        value.selectionMode = try reader["selectionMode"].readIfPresent() ?? .sdkUnknown("")
        value.selectiveModeConfiguration = try reader["selectiveModeConfiguration"].readIfPresent(with: BedrockClientTypes.RerankingMetadataSelectiveModeConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.ModelCopyJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelCopyJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelCopyJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.targetModelArn = try reader["targetModelArn"].readIfPresent() ?? ""
        value.targetModelName = try reader["targetModelName"].readIfPresent()
        value.sourceAccountId = try reader["sourceAccountId"].readIfPresent() ?? ""
        value.sourceModelArn = try reader["sourceModelArn"].readIfPresent() ?? ""
        value.targetModelKmsKeyArn = try reader["targetModelKmsKeyArn"].readIfPresent()
        value.targetModelTags = try reader["targetModelTags"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.sourceModelName = try reader["sourceModelName"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelCustomizationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelCustomizationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelCustomizationJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.baseModelArn = try reader["baseModelArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusDetails = try reader["statusDetails"].readIfPresent(with: BedrockClientTypes.StatusDetails.read(from:))
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customModelArn = try reader["customModelArn"].readIfPresent()
        value.customModelName = try reader["customModelName"].readIfPresent()
        value.customizationType = try reader["customizationType"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelDataSource {

    static func write(value: BedrockClientTypes.ModelDataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3datasource(s3datasource):
                try writer["s3DataSource"].write(s3datasource, with: BedrockClientTypes.S3DataSource.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelDataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3DataSource":
                return .s3datasource(try reader["s3DataSource"].read(with: BedrockClientTypes.S3DataSource.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.ModelImportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelImportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelImportJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.importedModelArn = try reader["importedModelArn"].readIfPresent()
        value.importedModelName = try reader["importedModelName"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelInvocationJobInputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobInputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3inputdataconfig(s3inputdataconfig):
                try writer["s3InputDataConfig"].write(s3inputdataconfig, with: BedrockClientTypes.ModelInvocationJobS3InputDataConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobInputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3InputDataConfig":
                return .s3inputdataconfig(try reader["s3InputDataConfig"].read(with: BedrockClientTypes.ModelInvocationJobS3InputDataConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.ModelInvocationJobOutputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobOutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3outputdataconfig(s3outputdataconfig):
                try writer["s3OutputDataConfig"].write(s3outputdataconfig, with: BedrockClientTypes.ModelInvocationJobS3OutputDataConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobOutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3OutputDataConfig":
                return .s3outputdataconfig(try reader["s3OutputDataConfig"].read(with: BedrockClientTypes.ModelInvocationJobS3OutputDataConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.ModelInvocationJobS3InputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobS3InputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketOwner"].write(value.s3BucketOwner)
        try writer["s3InputFormat"].write(value.s3InputFormat)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobS3InputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelInvocationJobS3InputDataConfig()
        value.s3InputFormat = try reader["s3InputFormat"].readIfPresent()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        value.s3BucketOwner = try reader["s3BucketOwner"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelInvocationJobS3OutputDataConfig {

    static func write(value: BedrockClientTypes.ModelInvocationJobS3OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketOwner"].write(value.s3BucketOwner)
        try writer["s3EncryptionKeyId"].write(value.s3EncryptionKeyId)
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobS3OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelInvocationJobS3OutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        value.s3EncryptionKeyId = try reader["s3EncryptionKeyId"].readIfPresent()
        value.s3BucketOwner = try reader["s3BucketOwner"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ModelInvocationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ModelInvocationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ModelInvocationJobSummary()
        value.jobArn = try reader["jobArn"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.submitTime = try reader["submitTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.inputDataConfig = try reader["inputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobInputDataConfig.read(from:))
        value.outputDataConfig = try reader["outputDataConfig"].readIfPresent(with: BedrockClientTypes.ModelInvocationJobOutputDataConfig.read(from:))
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        value.timeoutDurationInHours = try reader["timeoutDurationInHours"].readIfPresent()
        value.jobExpirationTime = try reader["jobExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockClientTypes.Offer {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.Offer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.Offer()
        value.offerId = try reader["offerId"].readIfPresent()
        value.offerToken = try reader["offerToken"].readIfPresent() ?? ""
        value.termDetails = try reader["termDetails"].readIfPresent(with: BedrockClientTypes.TermDetails.read(from:))
        return value
    }
}

extension BedrockClientTypes.OrchestrationConfiguration {

    static func write(value: BedrockClientTypes.OrchestrationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["queryTransformationConfiguration"].write(value.queryTransformationConfiguration, with: BedrockClientTypes.QueryTransformationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.OrchestrationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.OrchestrationConfiguration()
        value.queryTransformationConfiguration = try reader["queryTransformationConfiguration"].readIfPresent(with: BedrockClientTypes.QueryTransformationConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.OutputDataConfig {

    static func write(value: BedrockClientTypes.OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.OutputDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.PerformanceConfiguration {

    static func write(value: BedrockClientTypes.PerformanceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["latency"].write(value.latency)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.PerformanceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.PerformanceConfiguration()
        value.latency = try reader["latency"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.PricingTerm {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.PricingTerm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.PricingTerm()
        value.rateCard = try reader["rateCard"].readListIfPresent(memberReadingClosure: BedrockClientTypes.DimensionalPriceRate.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.PromptRouterSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.PromptRouterSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.PromptRouterSummary()
        value.promptRouterName = try reader["promptRouterName"].readIfPresent() ?? ""
        value.routingCriteria = try reader["routingCriteria"].readIfPresent(with: BedrockClientTypes.RoutingCriteria.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.promptRouterArn = try reader["promptRouterArn"].readIfPresent() ?? ""
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: BedrockClientTypes.PromptRouterTargetModel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.fallbackModel = try reader["fallbackModel"].readIfPresent(with: BedrockClientTypes.PromptRouterTargetModel.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.PromptRouterTargetModel {

    static func write(value: BedrockClientTypes.PromptRouterTargetModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelArn"].write(value.modelArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.PromptRouterTargetModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.PromptRouterTargetModel()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.PromptTemplate {

    static func write(value: BedrockClientTypes.PromptTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["textPromptTemplate"].write(value.textPromptTemplate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.PromptTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.PromptTemplate()
        value.textPromptTemplate = try reader["textPromptTemplate"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ProvisionedModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ProvisionedModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ProvisionedModelSummary()
        value.provisionedModelName = try reader["provisionedModelName"].readIfPresent() ?? ""
        value.provisionedModelArn = try reader["provisionedModelArn"].readIfPresent() ?? ""
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.desiredModelArn = try reader["desiredModelArn"].readIfPresent() ?? ""
        value.foundationModelArn = try reader["foundationModelArn"].readIfPresent() ?? ""
        value.modelUnits = try reader["modelUnits"].readIfPresent() ?? 0
        value.desiredModelUnits = try reader["desiredModelUnits"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.commitmentDuration = try reader["commitmentDuration"].readIfPresent()
        value.commitmentExpirationTime = try reader["commitmentExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockClientTypes.QueryTransformationConfiguration {

    static func write(value: BedrockClientTypes.QueryTransformationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.QueryTransformationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.QueryTransformationConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockClientTypes.RAGConfig {

    static func write(value: BedrockClientTypes.RAGConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .knowledgebaseconfig(knowledgebaseconfig):
                try writer["knowledgeBaseConfig"].write(knowledgebaseconfig, with: BedrockClientTypes.KnowledgeBaseConfig.write(value:to:))
            case let .precomputedragsourceconfig(precomputedragsourceconfig):
                try writer["precomputedRagSourceConfig"].write(precomputedragsourceconfig, with: BedrockClientTypes.EvaluationPrecomputedRagSourceConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RAGConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "knowledgeBaseConfig":
                return .knowledgebaseconfig(try reader["knowledgeBaseConfig"].read(with: BedrockClientTypes.KnowledgeBaseConfig.read(from:)))
            case "precomputedRagSourceConfig":
                return .precomputedragsourceconfig(try reader["precomputedRagSourceConfig"].read(with: BedrockClientTypes.EvaluationPrecomputedRagSourceConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.RatingScaleItem {

    static func write(value: BedrockClientTypes.RatingScaleItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["value"].write(value.value, with: BedrockClientTypes.RatingScaleItemValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RatingScaleItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RatingScaleItem()
        value.definition = try reader["definition"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent(with: BedrockClientTypes.RatingScaleItemValue.read(from:))
        return value
    }
}

extension BedrockClientTypes.RatingScaleItemValue {

    static func write(value: BedrockClientTypes.RatingScaleItemValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .floatvalue(floatvalue):
                try writer["floatValue"].write(floatvalue)
            case let .stringvalue(stringvalue):
                try writer["stringValue"].write(stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RatingScaleItemValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "stringValue":
                return .stringvalue(try reader["stringValue"].read())
            case "floatValue":
                return .floatvalue(try reader["floatValue"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.RequestMetadataBaseFilters {

    static func write(value: BedrockClientTypes.RequestMetadataBaseFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["equals"].writeMap(value.equals, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["notEquals"].writeMap(value.notEquals, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RequestMetadataBaseFilters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RequestMetadataBaseFilters()
        value.equals = try reader["equals"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.notEquals = try reader["notEquals"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.RequestMetadataFilters {

    static func write(value: BedrockClientTypes.RequestMetadataFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .andall(andall):
                try writer["andAll"].writeList(andall, memberWritingClosure: BedrockClientTypes.RequestMetadataBaseFilters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .equals(equals):
                try writer["equals"].writeMap(equals, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            case let .notequals(notequals):
                try writer["notEquals"].writeMap(notequals, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            case let .orall(orall):
                try writer["orAll"].writeList(orall, memberWritingClosure: BedrockClientTypes.RequestMetadataBaseFilters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RequestMetadataFilters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "equals":
                return .equals(try reader["equals"].readMap(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
            case "notEquals":
                return .notequals(try reader["notEquals"].readMap(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
            case "andAll":
                return .andall(try reader["andAll"].readList(memberReadingClosure: BedrockClientTypes.RequestMetadataBaseFilters.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "orAll":
                return .orall(try reader["orAll"].readList(memberReadingClosure: BedrockClientTypes.RequestMetadataBaseFilters.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.RerankingMetadataSelectiveModeConfiguration {

    static func write(value: BedrockClientTypes.RerankingMetadataSelectiveModeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fieldstoexclude(fieldstoexclude):
                try writer["fieldsToExclude"].writeList(fieldstoexclude, memberWritingClosure: BedrockClientTypes.FieldForReranking.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .fieldstoinclude(fieldstoinclude):
                try writer["fieldsToInclude"].writeList(fieldstoinclude, memberWritingClosure: BedrockClientTypes.FieldForReranking.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RerankingMetadataSelectiveModeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "fieldsToInclude":
                return .fieldstoinclude(try reader["fieldsToInclude"].readList(memberReadingClosure: BedrockClientTypes.FieldForReranking.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "fieldsToExclude":
                return .fieldstoexclude(try reader["fieldsToExclude"].readList(memberReadingClosure: BedrockClientTypes.FieldForReranking.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.RetrievalFilter {

    static func write(value: BedrockClientTypes.RetrievalFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .andall(andall):
                try writer["andAll"].writeList(andall, memberWritingClosure: BedrockClientTypes.RetrievalFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .equals(equals):
                try writer["equals"].write(equals, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .greaterthan(greaterthan):
                try writer["greaterThan"].write(greaterthan, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .greaterthanorequals(greaterthanorequals):
                try writer["greaterThanOrEquals"].write(greaterthanorequals, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .`in`(`in`):
                try writer["in"].write(`in`, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .lessthan(lessthan):
                try writer["lessThan"].write(lessthan, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .lessthanorequals(lessthanorequals):
                try writer["lessThanOrEquals"].write(lessthanorequals, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .listcontains(listcontains):
                try writer["listContains"].write(listcontains, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .notequals(notequals):
                try writer["notEquals"].write(notequals, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .notin(notin):
                try writer["notIn"].write(notin, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .orall(orall):
                try writer["orAll"].writeList(orall, memberWritingClosure: BedrockClientTypes.RetrievalFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .startswith(startswith):
                try writer["startsWith"].write(startswith, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .stringcontains(stringcontains):
                try writer["stringContains"].write(stringcontains, with: BedrockClientTypes.FilterAttribute.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RetrievalFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "equals":
                return .equals(try reader["equals"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "notEquals":
                return .notequals(try reader["notEquals"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "greaterThan":
                return .greaterthan(try reader["greaterThan"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "greaterThanOrEquals":
                return .greaterthanorequals(try reader["greaterThanOrEquals"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "lessThan":
                return .lessthan(try reader["lessThan"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "lessThanOrEquals":
                return .lessthanorequals(try reader["lessThanOrEquals"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "in":
                return .`in`(try reader["in"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "notIn":
                return .notin(try reader["notIn"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "startsWith":
                return .startswith(try reader["startsWith"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "listContains":
                return .listcontains(try reader["listContains"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "stringContains":
                return .stringcontains(try reader["stringContains"].read(with: BedrockClientTypes.FilterAttribute.read(from:)))
            case "andAll":
                return .andall(try reader["andAll"].readList(memberReadingClosure: BedrockClientTypes.RetrievalFilter.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "orAll":
                return .orall(try reader["orAll"].readList(memberReadingClosure: BedrockClientTypes.RetrievalFilter.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockClientTypes.RetrieveAndGenerateConfiguration {

    static func write(value: BedrockClientTypes.RetrieveAndGenerateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["externalSourcesConfiguration"].write(value.externalSourcesConfiguration, with: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration.write(value:to:))
        try writer["knowledgeBaseConfiguration"].write(value.knowledgeBaseConfiguration, with: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RetrieveAndGenerateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RetrieveAndGenerateConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.knowledgeBaseConfiguration = try reader["knowledgeBaseConfiguration"].readIfPresent(with: BedrockClientTypes.KnowledgeBaseRetrieveAndGenerateConfiguration.read(from:))
        value.externalSourcesConfiguration = try reader["externalSourcesConfiguration"].readIfPresent(with: BedrockClientTypes.ExternalSourcesRetrieveAndGenerateConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.RetrieveConfig {

    static func write(value: BedrockClientTypes.RetrieveConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["knowledgeBaseRetrievalConfiguration"].write(value.knowledgeBaseRetrievalConfiguration, with: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RetrieveConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RetrieveConfig()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.knowledgeBaseRetrievalConfiguration = try reader["knowledgeBaseRetrievalConfiguration"].readIfPresent(with: BedrockClientTypes.KnowledgeBaseRetrievalConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.RFTConfig {

    static func write(value: BedrockClientTypes.RFTConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["graderConfig"].write(value.graderConfig, with: BedrockClientTypes.GraderConfig.write(value:to:))
        try writer["hyperParameters"].write(value.hyperParameters, with: BedrockClientTypes.RFTHyperParameters.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RFTConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RFTConfig()
        value.graderConfig = try reader["graderConfig"].readIfPresent(with: BedrockClientTypes.GraderConfig.read(from:))
        value.hyperParameters = try reader["hyperParameters"].readIfPresent(with: BedrockClientTypes.RFTHyperParameters.read(from:))
        return value
    }
}

extension BedrockClientTypes.RFTHyperParameters {

    static func write(value: BedrockClientTypes.RFTHyperParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchSize"].write(value.batchSize)
        try writer["epochCount"].write(value.epochCount)
        try writer["evalInterval"].write(value.evalInterval)
        try writer["inferenceMaxTokens"].write(value.inferenceMaxTokens)
        try writer["learningRate"].write(value.learningRate)
        try writer["maxPromptLength"].write(value.maxPromptLength)
        try writer["reasoningEffort"].write(value.reasoningEffort)
        try writer["trainingSamplePerPrompt"].write(value.trainingSamplePerPrompt)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RFTHyperParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RFTHyperParameters()
        value.epochCount = try reader["epochCount"].readIfPresent()
        value.batchSize = try reader["batchSize"].readIfPresent()
        value.learningRate = try reader["learningRate"].readIfPresent()
        value.maxPromptLength = try reader["maxPromptLength"].readIfPresent()
        value.trainingSamplePerPrompt = try reader["trainingSamplePerPrompt"].readIfPresent()
        value.inferenceMaxTokens = try reader["inferenceMaxTokens"].readIfPresent()
        value.reasoningEffort = try reader["reasoningEffort"].readIfPresent()
        value.evalInterval = try reader["evalInterval"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.RoutingCriteria {

    static func write(value: BedrockClientTypes.RoutingCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["responseQualityDifference"].write(value.responseQualityDifference)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.RoutingCriteria {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.RoutingCriteria()
        value.responseQualityDifference = try reader["responseQualityDifference"].readIfPresent() ?? 0.0
        return value
    }
}

extension BedrockClientTypes.S3Config {

    static func write(value: BedrockClientTypes.S3Config?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["keyPrefix"].write(value.keyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.S3Config {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.S3Config()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.keyPrefix = try reader["keyPrefix"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.S3DataSource {

    static func write(value: BedrockClientTypes.S3DataSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.S3DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.S3DataSource()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.S3ObjectDoc {

    static func write(value: BedrockClientTypes.S3ObjectDoc?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.S3ObjectDoc {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.S3ObjectDoc()
        value.uri = try reader["uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.SageMakerEndpoint {

    static func write(value: BedrockClientTypes.SageMakerEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionRole"].write(value.executionRole)
        try writer["initialInstanceCount"].write(value.initialInstanceCount)
        try writer["instanceType"].write(value.instanceType)
        try writer["kmsEncryptionKey"].write(value.kmsEncryptionKey)
        try writer["vpc"].write(value.vpc, with: BedrockClientTypes.VpcConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.SageMakerEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.SageMakerEndpoint()
        value.initialInstanceCount = try reader["initialInstanceCount"].readIfPresent() ?? 0
        value.instanceType = try reader["instanceType"].readIfPresent() ?? ""
        value.executionRole = try reader["executionRole"].readIfPresent() ?? ""
        value.kmsEncryptionKey = try reader["kmsEncryptionKey"].readIfPresent()
        value.vpc = try reader["vpc"].readIfPresent(with: BedrockClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.StatusDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.StatusDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.StatusDetails()
        value.validationDetails = try reader["validationDetails"].readIfPresent(with: BedrockClientTypes.ValidationDetails.read(from:))
        value.dataProcessingDetails = try reader["dataProcessingDetails"].readIfPresent(with: BedrockClientTypes.DataProcessingDetails.read(from:))
        value.trainingDetails = try reader["trainingDetails"].readIfPresent(with: BedrockClientTypes.TrainingDetails.read(from:))
        return value
    }
}

extension BedrockClientTypes.SupportTerm {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.SupportTerm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.SupportTerm()
        value.refundPolicyDescription = try reader["refundPolicyDescription"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.Tag {

    static func write(value: BedrockClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.TeacherModelConfig {

    static func write(value: BedrockClientTypes.TeacherModelConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResponseLengthForInference"].write(value.maxResponseLengthForInference)
        try writer["teacherModelIdentifier"].write(value.teacherModelIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TeacherModelConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TeacherModelConfig()
        value.teacherModelIdentifier = try reader["teacherModelIdentifier"].readIfPresent() ?? ""
        value.maxResponseLengthForInference = try reader["maxResponseLengthForInference"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.TermDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TermDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TermDetails()
        value.usageBasedPricingTerm = try reader["usageBasedPricingTerm"].readIfPresent(with: BedrockClientTypes.PricingTerm.read(from:))
        value.legalTerm = try reader["legalTerm"].readIfPresent(with: BedrockClientTypes.LegalTerm.read(from:))
        value.supportTerm = try reader["supportTerm"].readIfPresent(with: BedrockClientTypes.SupportTerm.read(from:))
        value.validityTerm = try reader["validityTerm"].readIfPresent(with: BedrockClientTypes.ValidityTerm.read(from:))
        return value
    }
}

extension BedrockClientTypes.TextInferenceConfig {

    static func write(value: BedrockClientTypes.TextInferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topP"].write(value.topp)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TextInferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TextInferenceConfig()
        value.temperature = try reader["temperature"].readIfPresent()
        value.topp = try reader["topP"].readIfPresent()
        value.maxTokens = try reader["maxTokens"].readIfPresent()
        value.stopSequences = try reader["stopSequences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.TrainingDataConfig {

    static func write(value: BedrockClientTypes.TrainingDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["invocationLogsConfig"].write(value.invocationLogsConfig, with: BedrockClientTypes.InvocationLogsConfig.write(value:to:))
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TrainingDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TrainingDataConfig()
        value.s3Uri = try reader["s3Uri"].readIfPresent()
        value.invocationLogsConfig = try reader["invocationLogsConfig"].readIfPresent(with: BedrockClientTypes.InvocationLogsConfig.read(from:))
        return value
    }
}

extension BedrockClientTypes.TrainingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TrainingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TrainingDetails()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockClientTypes.TrainingMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.TrainingMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.TrainingMetrics()
        value.trainingLoss = try reader["trainingLoss"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ValidationDataConfig {

    static func write(value: BedrockClientTypes.ValidationDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["validators"].writeList(value.validators, memberWritingClosure: BedrockClientTypes.Validator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidationDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidationDataConfig()
        value.validators = try reader["validators"].readListIfPresent(memberReadingClosure: BedrockClientTypes.Validator.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockClientTypes.ValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidationDetails()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockClientTypes.Validator {

    static func write(value: BedrockClientTypes.Validator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.Validator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.Validator()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockClientTypes.ValidatorMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidatorMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidatorMetric()
        value.validationLoss = try reader["validationLoss"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.ValidityTerm {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.ValidityTerm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.ValidityTerm()
        value.agreementDuration = try reader["agreementDuration"].readIfPresent()
        return value
    }
}

extension BedrockClientTypes.VectorSearchBedrockRerankingConfiguration {

    static func write(value: BedrockClientTypes.VectorSearchBedrockRerankingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataConfiguration"].write(value.metadataConfiguration, with: BedrockClientTypes.MetadataConfigurationForReranking.write(value:to:))
        try writer["modelConfiguration"].write(value.modelConfiguration, with: BedrockClientTypes.VectorSearchBedrockRerankingModelConfiguration.write(value:to:))
        try writer["numberOfRerankedResults"].write(value.numberOfRerankedResults)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.VectorSearchBedrockRerankingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.VectorSearchBedrockRerankingConfiguration()
        value.modelConfiguration = try reader["modelConfiguration"].readIfPresent(with: BedrockClientTypes.VectorSearchBedrockRerankingModelConfiguration.read(from:))
        value.numberOfRerankedResults = try reader["numberOfRerankedResults"].readIfPresent()
        value.metadataConfiguration = try reader["metadataConfiguration"].readIfPresent(with: BedrockClientTypes.MetadataConfigurationForReranking.read(from:))
        return value
    }
}

extension BedrockClientTypes.VectorSearchBedrockRerankingModelConfiguration {

    static func write(value: BedrockClientTypes.VectorSearchBedrockRerankingModelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].writeMap(value.additionalModelRequestFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeDocument(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["modelArn"].write(value.modelArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.VectorSearchBedrockRerankingModelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.VectorSearchBedrockRerankingModelConfiguration()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.additionalModelRequestFields = try reader["additionalModelRequestFields"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockClientTypes.VectorSearchRerankingConfiguration {

    static func write(value: BedrockClientTypes.VectorSearchRerankingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bedrockRerankingConfiguration"].write(value.bedrockRerankingConfiguration, with: BedrockClientTypes.VectorSearchBedrockRerankingConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.VectorSearchRerankingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.VectorSearchRerankingConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.bedrockRerankingConfiguration = try reader["bedrockRerankingConfiguration"].readIfPresent(with: BedrockClientTypes.VectorSearchBedrockRerankingConfiguration.read(from:))
        return value
    }
}

extension BedrockClientTypes.VpcConfig {

    static func write(value: BedrockClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockClientTypes.VpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockClientTypes.VpcConfig()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

public enum BedrockClientTypes {}
